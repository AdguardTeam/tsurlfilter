import * as rule from './rule';
import { Request } from '../request';
import { IAdvancedModifier } from '../modifiers/advanced-modifier';
import { HTTPMethod } from '../modifiers/method-modifier';
import { RequestType } from '../request-type';
/**
 * NetworkRuleOption is the enumeration of various rule options.
 * In order to save memory, we store some options as a flag.
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#modifiers
 */
export declare enum NetworkRuleOption {
    /** No value is set. Syntax sugar to simplify code. */
    NotSet = 0,
    /** $third-party modifier */
    ThirdParty = 1,
    /** $match-case modifier */
    MatchCase = 2,
    /** $important modifier */
    Important = 4,
    /** $elemhide modifier */
    Elemhide = 8,
    /** $generichide modifier */
    Generichide = 16,
    /** $specifichide modifier */
    Specifichide = 32,
    /** $genericblock modifier */
    Genericblock = 64,
    /** $jsinject modifier */
    Jsinject = 128,
    /** $urlblock modifier */
    Urlblock = 256,
    /** $content modifier */
    Content = 512,
    /** $extension modifier */
    Extension = 1024,
    /** $stealth modifier */
    Stealth = 2048,
    /** $popup modifier */
    Popup = 4096,
    /** $csp modifier */
    Csp = 8192,
    /** $replace modifier */
    Replace = 16384,
    /** $cookie modifier */
    Cookie = 32768,
    /** $redirect modifier */
    Redirect = 65536,
    /** $badfilter modifier */
    Badfilter = 131072,
    /** $removeparam modifier */
    RemoveParam = 262144,
    /** $removeheader modifier */
    RemoveHeader = 524288,
    /** $jsonprune modifier */
    JsonPrune = 1048576,
    /** $hls modifier */
    Hls = 2097152,
    /** $network modifier */
    Network = 4194304,
    /** dns modifiers */
    Client = 8388608,
    DnsRewrite = 16777216,
    DnsType = 33554432,
    Ctag = 67108864,
    Method = 134217728,
    To = 268435456,
    Permissions = 536870912,
    /** Allowlist-only modifiers */
    AllowlistOnly = 4088,
    /** Options supported by host-level network rules * */
    OptionHostLevelRules = 125960196,
    /**
     * Removeparam compatible modifiers
     *
     * $removeparam rules are compatible only with content type modifiers ($subdocument, $script, $stylesheet, etc)
     * except $document (using by default) and this list of modifiers:
     */
    RemoveParamCompatibleOptions = 393223,
    /**
     * Removeheader compatible modifiers
     *
     * $removeheader rules are compatible only with content type modifiers ($subdocument, $script, $stylesheet, etc)
     * except $document (using by default) and this list of modifiers:
     */
    RemoveHeaderCompatibleOptions = 655367
}
/**
 * Helper class that is used for passing {@link NetworkRule.parseRuleText}
 * result to the caller. Should not be used outside of this file.
 */
declare class BasicRuleParts {
    /**
     * Basic rule pattern (which can be easily converted into a regex).
     * See {@link SimpleRegex} for more details.
     */
    pattern: string | undefined;
    /**
     * String with all rule options (modifiers).
     */
    options: string | undefined;
    /**
     * Indicates if rule is "allowlist" (e.g. it should unblock requests, not block them).
     */
    allowlist: boolean | undefined;
}
/**
 * Basic network filtering rule.
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules
 */
export declare class NetworkRule implements rule.IRule {
    private readonly ruleText;
    private readonly filterListId;
    private readonly allowlist;
    private readonly pattern;
    private permittedDomains;
    private restrictedDomains;
    /**
     * Domains in denyallow modifier providing exceptions for permitted domains
     * https://github.com/AdguardTeam/CoreLibs/issues/1304
     */
    private denyAllowDomains;
    /**
     * Flag with all enabled rule options.
     */
    private enabledOptions;
    /**
     * Flag with all disabled rule options.
     */
    private disabledOptions;
    /**
     * Flag with all permitted request types.
     */
    private permittedRequestTypes;
    /**
     * Flag with all restricted request types.
     */
    private restrictedRequestTypes;
    /**
     * Rule Advanced modifier
     */
    private advancedModifier;
    /**
     * Rule App modifier
     */
    private appModifier;
    /**
     * Rule Method modifier
     */
    private methodModifier;
    /**
     * Rule To modifier
     */
    private toModifier;
    /**
     * Rule priority, which is needed when the engine has to choose between
     * several rules matching the query. This value is calculated based on
     * the rule modifiers enabled or disabled and rounded up
     * to the smallest integer greater than or equal to the calculated weight
     * in the {@link calculatePriorityWeight}.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-1
     */
    private priorityWeight;
    /**
     * Rules with base modifiers, from category 1, each of them adds 1
     * to the weight of the rule.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-1
     */
    private static readonly CATEGORY_1_OPTIONS_MASK;
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with permitted request types and methods.
     * The value 50 is chosen in order to cover (with a margin) all possible
     * combinations and variations of rules from categories with a lower
     * priority (each of them adds 1 to the rule priority).
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-2
     */
    private static readonly CategoryTwoWeight;
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with allowed domains.
     * The value 100 is chosen to cover all possible combinations and variations
     * of rules from categories with a lower priority, for example a rule with
     * one allowed query type will get priority 100 (50 + 50/1), but for allowed
     * domains with any number of domains we will get at least 101 (for 100
     * domains: 100 + 100/100; for 200 100 + 100/200; or even for 10000:
     * 100 + 100/10000) because the resulting weight is rounded up.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-3
     */
    private static readonly CategoryThreeWeight;
    /**
     * The priority weight used in {@link calculatePriorityWeight}
     * for $redirect rules.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-6
     */
    private static readonly CategoryFourWeight;
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with specific exceptions.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-4
     */
    private static readonly CategoryFiveWeight;
    /**
     * Rules with specific exclusions, from category 4, each of them adds
     * {@link SpecificExceptionsWeight} to the weight of the rule.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-4
     */
    private static readonly SPECIFIC_EXCLUSIONS_MASK;
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with allowlist mark '@@'.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-5
     */
    private static readonly CategorySixWeight;
    /**
     * The priority weight used in {@link calculatePriorityWeight}
     * for $important rules.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-7
     */
    private static readonly CategorySevenWeight;
    /**
     * Separates the rule pattern from the list of modifiers.
     *
     * ```
     * rule = ["@@"] pattern [ "$" modifiers ]
     * modifiers = [modifier0, modifier1[, ...[, modifierN]]]
     * ```
     */
    static readonly OPTIONS_DELIMITER = "$";
    /**
     * This character is used to escape special characters in modifiers values
     */
    private static ESCAPE_CHARACTER;
    private static RE_ESCAPED_OPTIONS_DELIMITER;
    /**
     * A marker that is used in rules of exception.
     * To turn off filtering for a request, start your rule with this marker.
     */
    static readonly MASK_ALLOWLIST = "@@";
    /**
     * Mark that negates options
     */
    static readonly NOT_MARK = "~";
    /**
     * Rule options
     */
    static readonly OPTIONS: {
        THIRD_PARTY: string;
        FIRST_PARTY: string;
        MATCH_CASE: string;
        IMPORTANT: string;
        DOMAIN: string;
        DENYALLOW: string;
        ELEMHIDE: string;
        GENERICHIDE: string;
        SPECIFICHIDE: string;
        GENERICBLOCK: string;
        JSINJECT: string;
        URLBLOCK: string;
        CONTENT: string;
        DOCUMENT: string;
        DOC: string;
        STEALTH: string;
        POPUP: string;
        EMPTY: string;
        MP4: string;
        SCRIPT: string;
        STYLESHEET: string;
        SUBDOCUMENT: string;
        OBJECT: string;
        IMAGE: string;
        XMLHTTPREQUEST: string;
        MEDIA: string;
        FONT: string;
        WEBSOCKET: string;
        OTHER: string;
        PING: string;
        BADFILTER: string;
        CSP: string;
        REPLACE: string;
        COOKIE: string;
        REDIRECT: string;
        REDIRECTRULE: string;
        REMOVEPARAM: string;
        REMOVEHEADER: string;
        JSONPRUNE: string;
        HLS: string;
        REFERRERPOLICY: string;
        APP: string;
        NETWORK: string;
        EXTENSION: string;
        NOOP: string;
        CLIENT: string;
        DNSREWRITE: string;
        DNSTYPE: string;
        CTAG: string;
        METHOD: string;
        TO: string;
        PERMISSIONS: string;
        ALL: string;
    };
    /**
     * Returns the original text of the rule from which it was parsed.
     *
     * @returns Original text of the rule.
     */
    getText(): string;
    /**
     * Returns the identifier of the filter from which the rule was received.
     *
     * @returns Identifier of the filter from which the rule was received.
     */
    getFilterListId(): number;
    /**
     * Each rule has its own priority, which is necessary when several rules
     * match the request and the filtering system needs to select one of them.
     * Priority is measured as a positive integer.
     * In the case of a conflict between two rules with the same priority value,
     * it is not specified which one of them will be chosen.
     *
     * @returns Rule priority.
     */
    getPriorityWeight(): number;
    /**
     * Returns rule pattern,
     * which currently is used only in the rule validator module
     */
    getPattern(): string;
    /**
     * Returns `true` if the rule is "allowlist", e.g. if it disables other
     * rules when the pattern matches the request.
     */
    isAllowlist(): boolean;
    /**
     * Checks if the rule is a document-level allowlist rule with $urlblock or
     * $genericblock or $content.
     * This means that the rule is supposed to disable or modify blocking
     * of the page subrequests.
     * For instance, `@@||example.org^$urlblock` unblocks all sub-requests.
     */
    isDocumentLevelAllowlistRule(): boolean;
    /**
     * Checks if the rule completely disables filtering.
     */
    isFilteringDisabled(): boolean;
    /**
     * The longest part of pattern without any special characters.
     * It is used to improve the matching performance.
     */
    getShortcut(): string;
    /**
     * Gets list of permitted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
     */
    getPermittedDomains(): string[] | null;
    /**
     * Gets list of denyAllow domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#denyallow-modifier
     */
    getDenyAllowDomains(): string[] | null;
    /**
     * Gets list of restricted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
     */
    getRestrictedDomains(): string[] | null;
    /**
     * Get list of permitted $to domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#to-modifier
     */
    getPermittedToDomains(): string[] | null;
    /**
     * Get list of restricted $to domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#to-modifier
     */
    getRestrictedToDomains(): string[] | null;
    /**
     * Gets list of permitted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
     */
    getPermittedApps(): string[] | null;
    /**
     * Gets list of restricted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
     */
    getRestrictedApps(): string[] | null;
    /**
     * Gets list of permitted methods.
     * See https://kb.adguard.com/general/how-to-create-your-own-ad-filters#method-modifier
     */
    getRestrictedMethods(): HTTPMethod[] | null;
    /**
     * Gets list of restricted methods.
     * See https://kb.adguard.com/general/how-to-create-your-own-ad-filters#method-modifier
     */
    getPermittedMethods(): HTTPMethod[] | null;
    /**
     * Flag with all permitted request types.
     * The value {@link RequestType.NotSet} here means "all request types are allowed".
     */
    getPermittedRequestTypes(): RequestType;
    /**
     * Flag with all restricted request types.
     * The value {@link RequestType.NotSet} here means "no type of request is restricted".
     */
    getRestrictedRequestTypes(): RequestType;
    /**
     * Advanced modifier
     */
    getAdvancedModifier(): IAdvancedModifier | null;
    /**
     * Advanced modifier value
     */
    getAdvancedModifierValue(): string | null;
    /**
     * isRegexRule returns true if rule's pattern is a regular expression.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#regexp-support
     */
    isRegexRule(): boolean;
    matchesPermittedDomains(hostname: string): boolean;
    /**
     * Checks if this filtering rule matches the specified request.
     * @param request - request to check.
     * @param useShortcut - the flag to use this rule shortcut
     *
     * In case we use Trie in lookup table, we don't need to use shortcut cause we already check if request's url
     * includes full rule shortcut.
     */
    match(request: Request, useShortcut?: boolean): boolean;
    /**
     * matchShortcut simply checks if shortcut is a substring of the URL.
     * @param request - request to check.
     */
    private matchShortcut;
    /**
     * matchDomain checks if the filtering rule is allowed on this domain.
     * @param domain - domain to check.
     */
    private matchDomain;
    /**
     * Check if request matches domain modifier by request referrer (general case) or by request target
     *
     * In some cases the $domain modifier can match not only the referrer domain, but also the target domain.
     * This happens when the following is true (1 AND ((2 AND 3) OR 4):
     *
     * 1) The request has document type
     * 2) The rule's pattern doesn't match any particular domain(s)
     * 3) The rule's pattern doesn't contain regular expressions
     * 4) The $domain modifier contains only excluded domains (e.g., $domain=~example.org|~example.com)
     *
     * When all these conditions are met, the domain modifier will match both the referrer domain and the target domain.
     * https://github.com/AdguardTeam/tsurlfilter/issues/45
     * @param request
     */
    matchDomainModifier(request: Request): boolean;
    /**
     * checks if the filtering rule is allowed on this domain.
     * @param domain
     */
    private matchDenyAllowDomains;
    /**
     * Checks if request target matches with specified domains
     *
     * @param domain request's domain
     * @return true if request domain matches with specified domains
     */
    private matchToModifier;
    /**
     * Return TRUE if this rule matches with the tags associated with a client
     *
     * @param clientTags
     */
    private matchClientTags;
    /**
     * returns TRUE if the rule matches with the specified client
     *
     * @param clientName
     * @param clientIP
     */
    private matchClient;
    /**
     * Return TRUE if this rule matches with the request dnstype
     *
     * @param dnstype
     */
    private matchDnsType;
    /**
     * Checks if rule has permitted domains
     */
    private hasPermittedDomains;
    /**
     * Checks if rule has restricted domains
     */
    private hasRestrictedDomains;
    /**
     * Checks if rule has permitted apps
     */
    private hasPermittedApps;
    /**
     * matchRequestType checks if the request's type matches the rule properties
     * @param requestType - request type to check.
     */
    private matchRequestType;
    /**
     * In case of $removeparam modifier,
     * we only allow it to target other content types if the rule has an explicit content-type modifier.
     */
    private matchRequestTypeExplicit;
    /**
     * Checks if request's method matches with the rule
     *
     * @param method request's method
     * @returns true, if rule must be applied to the request
     */
    private matchMethod;
    /**
     * Checks if pattern has spaces
     * Used in order to do not create network rules from host rules
     * @param pattern
     * @private
     */
    private static hasSpaces;
    /**
     * Creates an instance of the {@link NetworkRule}.
     * It parses this rule and extracts the rule pattern (see {@link SimpleRegex}),
     * and rule modifiers.
     *
     * @param ruleText - original rule text.
     * @param filterListId - ID of the filter list this rule belongs to.
     *
     * @throws error if it fails to parse the rule.
     */
    constructor(ruleText: string, filterListId: number);
    /**
     * Parses the options string and saves them.
     * More on the rule modifiers:
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers
     *
     * @param options - string with the rule modifiers
     *
     * @throws an error if there is an unsupported modifier
     */
    private loadOptions;
    /**
     * Returns true if rule contains (enabled or disabled) specified option.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option - rule option to check.
     */
    hasOption(option: NetworkRuleOption): boolean;
    /**
     * Returns true if the specified option is enabled.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option - rule option to check.
     */
    isOptionEnabled(option: NetworkRuleOption): boolean;
    /**
     * Returns true if one and only option is enabled
     *
     * @param option
     */
    isSingleOptionEnabled(option: NetworkRuleOption): boolean;
    /**
     * Returns true if the specified option is disabled.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option - rule option to check.
     */
    isOptionDisabled(option: NetworkRuleOption): boolean;
    /**
     * Checks if the rule has higher priority that the specified rule
     * allowlist + $important > $important > redirect > allowlist > basic rules
     */
    isHigherPriority(r: NetworkRule): boolean;
    /**
     * Returns true if the rule is considered "generic"
     * "generic" means that the rule is not restricted to a limited set of domains
     * Please note that it might be forbidden on some domains, though.
     *
     * @return {boolean}
     */
    isGeneric(): boolean;
    /**
     * Returns true if this rule negates the specified rule
     * Only makes sense when this rule has a `badfilter` modifier
     */
    negatesBadfilter(specifiedRule: NetworkRule): boolean;
    /**
     * Checks if this rule can be used for hosts-level blocking
     */
    isHostLevelNetworkRule(): boolean;
    /**
     * Enables or disables the specified option.
     *
     * @param option - option to enable or disable.
     * @param enabled - true to enable, false to disable.
     * @param skipRestrictions - skip options allowlist/blacklist restrictions
     *
     * @throws an error if the option we're trying to enable cannot be.
     * For instance, you cannot enable $elemhide for blacklist rules.
     */
    private setOptionEnabled;
    /**
     * Permits or forbids the specified request type.
     * "Permits" means that the rule will match **only** the types that are permitted.
     * "Restricts" means that the rule will match **all but restricted**.
     *
     * @param requestType - request type.
     * @param permitted - true if it's permitted (whic)
     */
    private setRequestType;
    /**
     * Sets and validates exceptionally allowed domains presented in $denyallow modifier
     *
     * @param optionValue
     */
    private setDenyAllowDomains;
    /**
     * Loads the specified modifier:
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers
     *
     * @param optionName - modifier name.
     * @param optionValue - modifier value.
     *
     * @throws an error if there is an unsupported modifier
     */
    private loadOption;
    /**
     * To calculate priority, we've categorized modifiers into different groups.
     * These groups are ranked based on their priority, from lowest to highest.
     * A modifier that significantly narrows the scope of a rule adds more
     * weight to its total priority. Conversely, if a rule applies to a broader
     * range of requests, its priority decreases.
     *
     * It's worth noting that there are cases where a single-parameter modifier
     * has a higher priority than multi-parameter ones. For instance, in
     * the case of `$domain=example.com|example.org`, a rule that includes two
     * domains has a slightly broader effective area than a rule with one
     * specified domain, therefore its priority is lower.
     *
     * The base priority weight of any rule is 1. If the calculated priority
     * is a floating-point number, it will be **rounded up** to the smallest
     * integer greater than or equal to the calculated weight.
     *
     * @see {@link NetworkRule.PermittedRequestTypeWeight}
     * @see {@link NetworkRule.PermittedDomainWeight}
     * @see {@link NetworkRule.SpecificExceptionsWeight}
     * @see {@link NetworkRule.AllowlistRuleWeight}
     * @see {@link NetworkRule.RedirectRuleWeight}
     * @see {@link NetworkRule.ImportantRuleWeight}
     *
     * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-counting}
     */
    private calculatePriorityWeight;
    /**
     * Validates rule options
     */
    private validateOptions;
    /**
     * $removeparam rules are not compatible with any other modifiers except $domain,
     * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
     * The rules with any other modifiers are considered invalid and will be discarded.
     */
    private validateRemoveParamRule;
    /**
     * $removeheader rules are not compatible with any other modifiers except $domain,
     * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
     * The rules with any other modifiers are considered invalid and will be discarded.
     */
    private validateRemoveHeaderRule;
    /**
     * $to rules are not compatible $denyallow - these rules considered invalid
     * and will be discarded.
     */
    private validateToRule;
    /**
     * $denyallow rules are not compatible $to - these rules considered invalid
     * and will be discarded.
     */
    private validateDenyallowRule;
    /**
     * parseRuleText splits the rule text into multiple parts.
     * @param ruleText - original rule text
     * @returns basic rule parts
     *
     * @throws error if the rule is empty (for instance, empty string or `@@`)
     */
    static parseRuleText(ruleText: string): BasicRuleParts;
}
export {};
