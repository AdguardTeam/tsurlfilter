import { s as splitByDelimiterWithEscapeCharacter, S as SimpleRegex, a as stringArraysEquals, b as stringArraysHaveIntersection, f as fastHash, i as indexOfAny, h as hasUnquotedSubstring } from './simple-regex-f1b757a6.js';
export { S as SimpleRegex, f as fastHash, h as hasUnquotedSubstring, i as indexOfAny, r as replaceAll, s as splitByDelimiterWithEscapeCharacter, c as startsAtIndexWith, a as stringArraysEquals, b as stringArraysHaveIntersection } from './simple-regex-f1b757a6.js';
import { getPublicSuffix, parse, getHostname } from 'tldts';
import scriptlets from '@adguard/scriptlets';
import { NETWORK_RULE_OPTIONS, NOT_MARK, OPTIONS_DELIMITER, ESCAPE_CHARACTER, MASK_ALLOWLIST } from './network-rule-options.js';
export { NETWORK_RULE_OPTIONS, OPTIONS_DELIMITER } from './network-rule-options.js';
import { RequestType } from './request-type.js';
export { RequestType } from './request-type.js';
import isCidr from 'is-cidr';
import isIp from 'is-ip';
import { contains } from 'cidr-tools';
import { findCosmeticRuleMarker, CosmeticRuleMarker, ADG_SCRIPTLET_MASK, isExtCssMarker } from './cosmetic-rule-marker.js';
export { CosmeticRuleMarker } from './cosmetic-rule-marker.js';

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

/**
 * Compatibility types are used to configure engine for better support of different libraries
 * For example:
 *  extension doesn't support $app modifier. So if we set in configuration CompatibilityTypes.Extension,
 *  engine would ignore rules with $app modifier
 */
var CompatibilityTypes;
(function (CompatibilityTypes) {
    CompatibilityTypes[CompatibilityTypes["Extension"] = 1] = "Extension";
    CompatibilityTypes[CompatibilityTypes["CoreLibs"] = 2] = "CoreLibs";
    CompatibilityTypes[CompatibilityTypes["Dns"] = 4] = "Dns";
})(CompatibilityTypes || (CompatibilityTypes = {}));
/**
 * Application configuration class
 */
var Configuration = /** @class */ (function () {
    function Configuration(inputConfig) {
        this.defaultConfig = {
            engine: null,
            version: null,
            verbose: false,
            compatibility: null,
        };
        /**
         * {'extension'|'corelibs'} engine application type
         */
        this.engine = null;
        /**
         * {string} version
         */
        this.version = null;
        /**
         * {boolean} verbose flag
         */
        this.verbose = false;
        /**
         * compatibility flag
         */
        this.compatibility = CompatibilityTypes.Extension;
        var config = __assign(__assign({}, this.defaultConfig), inputConfig);
        this.engine = config.engine;
        this.version = config.version;
        this.verbose = config.verbose;
        this.compatibility = config.compatibility;
    }
    return Configuration;
}());
// eslint-disable-next-line import/no-mutable-exports
var config = new Configuration();
/**
 * Checks config is compatible with input level
 * @param compatibilityLevel
 * @private
 */
function isCompatibleWith(compatibilityLevel) {
    if (config.compatibility === null) {
        return false;
    }
    return (config.compatibility & compatibilityLevel) === compatibilityLevel;
}
var setConfiguration = function (outerConfig) {
    config = new Configuration(outerConfig);
};

/**
 * This class stores found cosmetic css rules content in the appropriate collections
 * It is primarily used by the {@see CosmeticResult}
 */
var CosmeticStylesResult = /** @class */ (function () {
    /**
     * Constructor
     */
    function CosmeticStylesResult() {
        this.generic = [];
        this.specific = [];
        this.genericExtCss = [];
        this.specificExtCss = [];
    }
    /**
     * Appends rule to the appropriate collection
     * @param rule
     */
    CosmeticStylesResult.prototype.append = function (rule) {
        if (rule.isGeneric()) {
            if (rule.isExtendedCss()) {
                this.genericExtCss.push(rule);
            }
            else {
                this.generic.push(rule);
            }
        }
        else if (rule.isExtendedCss()) {
            this.specificExtCss.push(rule);
        }
        else {
            this.specific.push(rule);
        }
    };
    return CosmeticStylesResult;
}());

/**
 * This class stores found script rules content in the appropriate collections
 * It is primarily used by the {@see CosmeticResult}
 */
var CosmeticScriptsResult = /** @class */ (function () {
    /**
     * Constructor
     */
    function CosmeticScriptsResult() {
        this.generic = [];
        this.specific = [];
    }
    /**
     * Appends rule to appropriate collection
     * @param rule
     */
    CosmeticScriptsResult.prototype.append = function (rule) {
        if (rule.isGeneric()) {
            this.generic.push(rule);
        }
        else {
            this.specific.push(rule);
        }
    };
    /**
     * Returns rules collected
     */
    CosmeticScriptsResult.prototype.getRules = function () {
        return __spreadArray(__spreadArray([], this.generic, true), this.specific, true);
    };
    return CosmeticScriptsResult;
}());

/**
 * This class stores found cosmetic html rules content in the appropriate collections
 * It is primarily used by the {@see CosmeticResult}
 */
var CosmeticHtmlResult = /** @class */ (function () {
    /**
     * Constructor
     */
    function CosmeticHtmlResult() {
        this.generic = [];
        this.specific = [];
    }
    /**
     * Appends rule to the appropriate collection
     * @param rule
     */
    CosmeticHtmlResult.prototype.append = function (rule) {
        if (rule.isGeneric()) {
            this.generic.push(rule);
        }
        else {
            this.specific.push(rule);
        }
    };
    /**
     * Returns rules collected
     */
    CosmeticHtmlResult.prototype.getRules = function () {
        return __spreadArray(__spreadArray([], this.generic, true), this.specific, true);
    };
    return CosmeticHtmlResult;
}());

/**
 * Cosmetic result is the representation of rules
 * It is primarily used by the {@see CosmeticEngine}
 */
var CosmeticResult = /** @class */ (function () {
    /**
     * Constructor
     */
    function CosmeticResult() {
        this.elementHiding = new CosmeticStylesResult();
        this.CSS = new CosmeticStylesResult();
        this.JS = new CosmeticScriptsResult();
        this.Html = new CosmeticHtmlResult();
    }
    /**
     * Script rules
     */
    CosmeticResult.prototype.getScriptRules = function () {
        return this.JS.getRules();
    };
    return CosmeticResult;
}());

/**
 * CosmeticOption is the enumeration of various content script options.
 * Depending on the set of enabled flags the content script will contain different set of settings.
 */
var CosmeticOption;
(function (CosmeticOption) {
    /**
     * if generic elemhide and CSS rules are enabled
     * Could be disabled by a $generichide rule and $elemhide rule.
     */
    CosmeticOption[CosmeticOption["CosmeticOptionGenericCSS"] = 2] = "CosmeticOptionGenericCSS";
    /**
     * if specific elemhide and CSS rules are enabled
     * Could be disabled by a $specifichide rule and $elemhide rule.
     */
    CosmeticOption[CosmeticOption["CosmeticOptionSpecificCSS"] = 4] = "CosmeticOptionSpecificCSS";
    /**
     * if JS rules and scriptlets are enabled
     * Could be disabled by a $jsinject rule.
     */
    CosmeticOption[CosmeticOption["CosmeticOptionJS"] = 8] = "CosmeticOptionJS";
    /**
     * if Html filtering rules are enabled
     * Could be disabled by a $content rule.
     */
    CosmeticOption[CosmeticOption["CosmeticOptionHtml"] = 16] = "CosmeticOptionHtml";
    /**
     * TODO: Add support for these flags
     * They are useful when content script is injected into an iframe
     * In this case we can check what flags were applied to the top-level frame
     */
    CosmeticOption[CosmeticOption["CosmeticOptionSourceGenericCSS"] = 32] = "CosmeticOptionSourceGenericCSS";
    CosmeticOption[CosmeticOption["CosmeticOptionSourceCSS"] = 64] = "CosmeticOptionSourceCSS";
    CosmeticOption[CosmeticOption["CosmeticOptionSourceJS"] = 128] = "CosmeticOptionSourceJS";
    /**
     * everything is enabled
     */
    CosmeticOption[CosmeticOption["CosmeticOptionAll"] = 30] = "CosmeticOptionAll";
    /**
     * everything is disabled
     */
    CosmeticOption[CosmeticOption["CosmeticOptionNone"] = 0] = "CosmeticOptionNone";
})(CosmeticOption || (CosmeticOption = {}));

/**
 * This is a helper class that is used specifically to work
 * with domains restrictions.
 *
 * There are two options how you can add a domain restriction:
 * * `$domain` modifier: https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
 * * domains list for the cosmetic rules
 *
 * The only difference between them is that in one case we use `|` as a separator,
 * and in the other case - `,`.
 *
 * Examples:
 * * `||example.org^$domain=example.com|~sub.example.com` -- network rule
 * * `example.com,~sub.example.com##banner` -- cosmetic rule
 */
var DomainModifier = /** @class */ (function () {
    /**
     * Parses the `domains` string and initializes the object.
     *
     * @param domainsStr Domains string.
     * @param separator Separator — `,` or `|`.
     *
     * @throws An error if the domains string is empty or invalid
     */
    function DomainModifier(domainsStr, separator) {
        if (!domainsStr) {
            throw new SyntaxError('Modifier $domain cannot be empty');
        }
        var permittedDomains = [];
        var restrictedDomains = [];
        var parts = domainsStr.toLowerCase().split(separator);
        for (var i = 0; i < parts.length; i += 1) {
            var domain = parts[i].trim();
            var restricted = false;
            if (domain.startsWith('~')) {
                restricted = true;
                domain = domain.substring(1);
            }
            if (domain === '') {
                throw new SyntaxError("Empty domain specified in \"".concat(domainsStr, "\""));
            }
            if (restricted) {
                restrictedDomains.push(domain);
            }
            else {
                permittedDomains.push(domain);
            }
        }
        this.restrictedDomains = restrictedDomains.length > 0 ? restrictedDomains : null;
        this.permittedDomains = permittedDomains.length > 0 ? permittedDomains : null;
    }
    /**
     * isDomainOrSubdomainOfAny checks if `domain` is the same or a subdomain
     * of any of `domains`.
     *
     * @param domain - domain to check
     * @param domains - domains list to check against
     */
    DomainModifier.isDomainOrSubdomainOfAny = function (domain, domains) {
        for (var i = 0; i < domains.length; i += 1) {
            var d = domains[i];
            if (DomainModifier.isWildcardDomain(d)) {
                if (DomainModifier.matchAsWildcard(d, domain)) {
                    return true;
                }
            }
            if (domain === d || (domain.endsWith(d) && domain.endsWith(".".concat(d)))) {
                return true;
            }
        }
        return false;
    };
    /**
     * Checks if domain ends with wildcard
     *
     * @param domain
     */
    DomainModifier.isWildcardDomain = function (domain) {
        return domain.endsWith('.*');
    };
    /**
     * Checks if wildcard matches domain
     *
     * @param wildcard
     * @param domainNameToCheck
     */
    DomainModifier.matchAsWildcard = function (wildcard, domainNameToCheck) {
        var wildcardedDomainToCheck = DomainModifier.genTldWildcard(domainNameToCheck);
        if (wildcardedDomainToCheck) {
            return wildcardedDomainToCheck === wildcard
                || (wildcardedDomainToCheck.endsWith(wildcard) && wildcardedDomainToCheck.endsWith(".".concat(wildcard)));
        }
        return false;
    };
    /**
     * Generates from domain tld wildcard e.g. google.com -> google.* ; youtube.co.uk -> youtube.*
     *
     * @param {string} domainName
     * @returns {string} string is empty if tld for provided domain name doesn't exists
     */
    DomainModifier.genTldWildcard = function (domainName) {
        var tld = getPublicSuffix(domainName);
        if (tld) {
            // lastIndexOf() is needed not to match the domain, e.g. 'www.chrono24.ch'.
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/2312.
            return "".concat(domainName.slice(0, domainName.lastIndexOf(".".concat(tld))), ".*");
        }
        return '';
    };
    return DomainModifier;
}());
/**
 * Comma separator
 */
var COMMA_SEPARATOR = ',';
/**
 * Pipe separator
 */
var PIPE_SEPARATOR = '|';

var _a, _b;
/**
 * Array of special modifiers allow to check for modifier name more efficient
 * by avoiding Object.values(SpecialModifier) calls in custom type-guard while
 * allowing the usage of 'const enum' for SpecialModifier
 */
var SpecialModifiers = [
    "replace" /* SpecialModifier.Replace */,
    "removeparam" /* SpecialModifier.Removeparam */,
    "hls" /* SpecialModifier.Hls */,
];
var isSpecialModifierToken = function (token) { return token.type === "specialModifier" /* TokenType.SpecialModifier */; };
/**
 * TODO (s.atroschenko) git rid of necessity of adding modifier names for simple regexp values (removaparam, hls):
 * use unified 'simple-regexp' pattern instead
 */
var modifiersPatterns = (_a = {},
    _a["replace" /* SpecialModifier.Replace */] = ["regexp" /* Phase.Regexp */, "replacement" /* Phase.Replacement */, "flags" /* Phase.Flags */],
    _a["removeparam" /* SpecialModifier.Removeparam */] = ["regexp" /* Phase.Regexp */, "flags" /* Phase.Flags */],
    _a["hls" /* SpecialModifier.Hls */] = ["regexp" /* Phase.Regexp */, "flags" /* Phase.Flags */],
    _a);
/**
 * Extracts modifier's plain value
 */
var parsePlainValue = function (string, startIndex) {
    var modifierValue = '';
    var modifierEndIndex = -1;
    var chars = [];
    for (var i = startIndex; i < string.length; i += 1) {
        var c = string[i];
        var isLastChar = i === (string.length - 1);
        var isUnescapedChar = i > 0 && !(string[i - 1] === "\\" /* SpecialCharacter.OptionEscape */);
        if ((c === "," /* SpecialCharacter.OptionDelimiter */ && isUnescapedChar) || isLastChar) {
            if (isLastChar) {
                chars.push(c);
            }
            modifierValue = chars.join('');
            modifierEndIndex = i;
            break;
        }
        else {
            chars.push(c);
        }
    }
    return {
        modifierValue: modifierValue,
        modifierEndIndex: modifierEndIndex,
    };
};
/**
 * Extract modifier's regexp(-like) value
 *
 * @throws on invalid special modifier value
 */
var parseRegexpValue = function (string, startIndex, pattern) {
    var currentPhase;
    var nextPhase = (function () {
        var i = 0;
        return function () {
            if (i < pattern.length) {
                currentPhase = pattern[i];
                i += 1;
                return;
            }
            // Undefined phase indicates that there were more Regexp delimiters
            // than pattern implies and that makes modifier value invalid
            throw new Error('Invalid pattern for regexp modifier value.');
        };
    })();
    var modifierValue = '';
    var modifierEndIndex = -1;
    var chars = [];
    for (var i = startIndex; i < string.length; i += 1) {
        var c = string[i];
        var isLastChar = i === (string.length - 1);
        var isUnescapedChar = i > 0 && !(string[i - 1] === "\\" /* SpecialCharacter.OptionEscape */);
        if (c === "/" /* SpecialCharacter.RegexpDelimiter */ && isUnescapedChar) {
            // Step into the next pattern phase
            nextPhase();
        }
        if ((c === "," /* SpecialCharacter.OptionDelimiter */ && isUnescapedChar) || isLastChar) {
            // Skip unescaped commas that are part of regexp
            if (currentPhase === "regexp" /* Phase.Regexp */) {
                chars.push(c);
                continue;
            }
            if (isLastChar) {
                chars.push(c);
            }
            // Unescaped delimiter and/or last character indicates
            // the end of the modifier value, if current phase is the last one
            if (currentPhase === pattern[pattern.length - 1]) {
                modifierValue = chars.join('');
                modifierEndIndex = i;
                break;
            }
            else {
                throw new Error('Unexpected options delimiter or end of options string.');
            }
        }
        else {
            chars.push(c);
        }
    }
    return {
        modifierValue: modifierValue,
        modifierEndIndex: modifierEndIndex,
    };
};
var modifierValueParsers = (_b = {},
    _b["regexp" /* ModifierValueType.Regexp */] = parseRegexpValue,
    _b["plain" /* ModifierValueType.Plain */] = parsePlainValue,
    _b);
/**
 * Processes raw tokens by splitting token values by delimiter
 *
 * @param preprocessedTokens array of preprocessed tokens (of TokenType.SpecialModifier | TokenType.Raw type)
 * @param delimiter - delimiter
 * @param escapeCharacter - escape character
 * @param unescape if true, remove escape characters from string
 * @returns array of processed tokens
 */
var tokenize = function (preprocessedTokens, delimiter, escapeCharacter, unescape) {
    // Split raw tokens
    var nestedProcessedTokens = preprocessedTokens
        .map(function (token) {
        // Modifier tokens are already concrete tokens and are being passed down the pipeline here
        if (isSpecialModifierToken(token)) {
            return token;
        }
        var tokenValue = token.value;
        var tokens = [];
        var chars = [];
        var makeToken = function (type) {
            tokens.push({
                type: type,
                value: chars.join(''),
            });
            chars = [];
        };
        for (var i = 0; i < tokenValue.length; i += 1) {
            var c = tokenValue[i];
            if (c === delimiter) {
                var isEscaped = i > 0 && tokenValue[i - 1] === escapeCharacter;
                if (isEscaped) {
                    if (unescape) {
                        chars.splice(chars.length - 1, 1);
                    }
                    chars.push(c);
                }
                else {
                    // Don't make token with '' value
                    // when raw token starts with a delimiter
                    if (chars.length !== 0) {
                        makeToken("string" /* TokenType.String */);
                    }
                    chars.push(c);
                    makeToken("delim" /* TokenType.Delimiter */);
                }
            }
            else {
                chars.push(c);
                // Last character case
                if (i === (tokenValue.length - 1)) {
                    makeToken("string" /* TokenType.String */);
                }
            }
        }
        return tokens;
    });
    // Flatten the result
    var processedTokens = [];
    for (var i = 0; i < nestedProcessedTokens.length; i += 1) {
        var currentVal = nestedProcessedTokens[i];
        if (Array.isArray(currentVal)) {
            processedTokens.push.apply(processedTokens, currentVal);
        }
        else {
            processedTokens.push(currentVal);
        }
    }
    return processedTokens;
};
/**
 * Converts arrays of tokens into array of their values
 *
 * @param tokens array of arbitrary tokens
 * @returns array of tokens' values
 */
var makeWords = function (tokens) {
    var words = [];
    for (var i = 0; i < tokens.length; i += 1) {
        var token = tokens[i];
        if (token.type !== "delim" /* TokenType.Delimiter */) {
            words.push(token.value);
        }
    }
    return words;
};
/**
 * Parses special modifier value
 *
 * @param modifierName name of modifier to be parsed
 * @param string options string
 * @returns object with Modifier token value and next index to keep iterating from
 */
function parseSpecialModifier(modifierName, string) {
    var tokenValue = "".concat(modifierName).concat("=" /* SpecialCharacter.ModifierValueMarker */);
    var modifierValueStartIndex = string.indexOf(tokenValue) + tokenValue.length;
    // Define modifier value type
    var valueType = string[modifierValueStartIndex] === "/" /* SpecialCharacter.RegexpDelimiter */
        ? "regexp" /* ModifierValueType.Regexp */
        : "plain" /* ModifierValueType.Plain */;
    // Pick parser for specific type of modifier value
    var parser = modifierValueParsers[valueType];
    // Get pattern of current modifier
    var pattern = modifiersPatterns[modifierName];
    var _a = parser(string, modifierValueStartIndex, pattern), modifierValue = _a.modifierValue, modifierEndIndex = _a.modifierEndIndex;
    if (modifierEndIndex === -1) {
        throw new Error("Invalid $".concat(modifierName, " modifier value."));
    }
    tokenValue += modifierValue;
    var nextIndex = modifierEndIndex;
    return {
        tokenValue: tokenValue,
        nextIndex: nextIndex,
    };
}
/**
 * Converts options string into array of Raw and Modifier tokens
 *
 * @param string options string
 * @returns array of preprocessed tokens
 */
function splitBySpecialModifierTokens(string) {
    var tokens = [];
    var chars = [];
    var makeToken = function (tokenType, tokenValue) {
        tokens.push({
            type: tokenType,
            value: tokenValue,
        });
        chars = [];
    };
    for (var i = 0; i < string.length; i += 1) {
        var c = string[i];
        var isUnescapedChar = i > 0 && !(string[i - 1] === "\\" /* SpecialCharacter.OptionEscape */);
        if (c === "=" /* SpecialCharacter.ModifierValueMarker */ && isUnescapedChar) {
            // Parse current chars array to get modifier name
            // Assume that modifier name is everything after last ',' and before current '='
            var charsStr = chars.join('');
            var lastCommaIndex = charsStr.lastIndexOf("," /* SpecialCharacter.OptionDelimiter */, i);
            // Assertion is used to avoid type-guard for SpecialModifier, making it faster,
            // and reduce call stack size
            var modifierName = charsStr.substring(lastCommaIndex + 1);
            // Check if this is modifier that requires custom parsing logic
            if (!SpecialModifiers.includes(modifierName)) {
                chars.push(c);
                // Last character case
                if (i === (string.length - 1)) {
                    makeToken("raw" /* TokenType.Raw */, charsStr);
                }
                continue;
            }
            // Remove modifier name from char stack,
            // make token from whats left and empty chars
            makeToken("raw" /* TokenType.Raw */, charsStr.substring(0, charsStr.lastIndexOf(modifierName)));
            // Extract predefined token value and next iteration index
            // Token value includes both name, separator('=') and value of modifier
            var _a = parseSpecialModifier(modifierName, string), tokenValue = _a.tokenValue, nextIndex = _a.nextIndex;
            makeToken("specialModifier" /* TokenType.SpecialModifier */, tokenValue);
            i = nextIndex;
        }
        else {
            chars.push(c);
            // Last character case
            if (i === (string.length - 1)) {
                makeToken("raw" /* TokenType.Raw */, chars.join(''));
            }
        }
    }
    return tokens;
}
/**
 * Splits options string into array of modifier=value pairs
 *
 * @param string - string to split
 * @param unescape - if true, remove escape characters from string
 * @return array of string parts
 * @throws on invalid special modifier value
 */
function parseOptionsString(string, unescape) {
    if (unescape === void 0) { unescape = true; }
    if (!string) {
        return [];
    }
    if (string.startsWith("," /* SpecialCharacter.OptionDelimiter */)) {
        // eslint-disable-next-line no-param-reassign
        string = string.substring(1);
    }
    /**
     * Extract modifier tokens for modifiers that require custom parsing
     * https://github.com/AdguardTeam/tsurlfilter/issues/79
     */
    var preprocessedTokens = splitBySpecialModifierTokens(string);
    /**
     * Split raw tokens by delimiter
     */
    var tokens = tokenize(preprocessedTokens, "," /* SpecialCharacter.OptionDelimiter */, "\\" /* SpecialCharacter.OptionEscape */, unescape);
    /**
     * Join tokens into words
     */
    return makeWords(tokens);
}

/**
 * Replace modifier class
 */
var ReplaceModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     */
    function ReplaceModifier(value) {
        var parsed = ReplaceModifier.parseReplaceOption(value);
        this.replaceOption = parsed.optionText;
        this.replaceApply = parsed.apply;
    }
    /**
     *
     * @param option
     */
    ReplaceModifier.parseReplaceOption = function (option) {
        if (!option) {
            return {
                apply: function (x) { return x; },
                optionText: '',
            };
        }
        var parts = splitByDelimiterWithEscapeCharacter(option, '/', '\\', true);
        var modifiers = (parts[2] || '');
        if (modifiers.indexOf('g') < 0) {
            modifiers += 'g';
        }
        var pattern = new RegExp(parts[0], modifiers);
        // unescape replacement alias
        var replacement = parts[1].replace(/\\\$/g, '$');
        replacement = SimpleRegex.unescapeSpecials(replacement);
        var apply = function (input) { return input.replace(pattern, replacement); };
        return {
            apply: apply,
            optionText: option,
        };
    };
    /**
     * Replace content
     */
    ReplaceModifier.prototype.getValue = function () {
        return this.replaceOption;
    };
    /**
     * Replace apply function
     */
    ReplaceModifier.prototype.getApplyFunc = function () {
        return this.replaceApply;
    };
    return ReplaceModifier;
}());

/**
 * Csp modifier class
 */
var CspModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     * @param isAllowlist
     */
    function CspModifier(value, isAllowlist) {
        this.cspDirective = value;
        this.isAllowlist = isAllowlist;
        this.validateCspDirective();
    }
    /**
     * Csp directive
     */
    CspModifier.prototype.getValue = function () {
        return this.cspDirective;
    };
    /**
     * Validates CSP rule
     */
    CspModifier.prototype.validateCspDirective = function () {
        /**
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/685
         * CSP directive may be empty in case of allowlist rule,
         * it means to disable all $csp rules matching the allowlist rule
         */
        if (!this.isAllowlist && !this.cspDirective) {
            throw new Error('Invalid $CSP rule: CSP directive must not be empty');
        }
        if (this.cspDirective) {
            /**
             * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/685#issue-228287090
             * Forbids report-to and report-uri directives
             */
            var cspDirective = this.cspDirective.toLowerCase();
            if (cspDirective.indexOf('report-') >= 0) {
                throw new Error("Forbidden CSP directive: ".concat(cspDirective));
            }
        }
    };
    return CspModifier;
}());

/**
 * Cookie modifier class
 *
 * Learn more about it here:
 * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/961
 */
var CookieModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     */
    function CookieModifier(value) {
        // Save the source text of the option modifier
        this.optionValue = value || '';
        this.regex = null;
        this.cookieName = null;
        this.sameSite = null;
        this.maxAge = null;
        // Parse cookie name/regex
        var parts = this.optionValue.split(/;/);
        if (parts.length < 1) {
            throw new Error("Cannot parse ".concat(this.optionValue));
        }
        var cookieName = parts[0];
        if (cookieName.startsWith('/') && cookieName.endsWith('/')) {
            var pattern = cookieName.substring(1, cookieName.length - 1);
            // Save regex to be used further for matching cookies
            this.regex = new RegExp(pattern);
        }
        else {
            // Match by cookie name
            this.cookieName = cookieName;
        }
        // Parse other cookie options
        if (parts.length > 1) {
            for (var i = 1; i < parts.length; i += 1) {
                var nameValue = parts[i].split('=');
                var optionName = nameValue[0];
                var optionValue = nameValue[1];
                if (optionName === CookieModifier.MAX_AGE) {
                    this.maxAge = parseInt(optionValue, 10);
                }
                else if (optionName === CookieModifier.SAME_SITE) {
                    this.sameSite = optionValue;
                }
                else {
                    throw new Error("Unknown $cookie option: ".concat(optionName));
                }
            }
        }
    }
    /**
     * Modifier value
     */
    CookieModifier.prototype.getValue = function () {
        return this.optionValue;
    };
    /**
     * First cookie name
     */
    CookieModifier.prototype.getCookieName = function () {
        return this.cookieName;
    };
    /**
     * Max age cookie value
     */
    CookieModifier.prototype.getMaxAge = function () {
        return this.maxAge;
    };
    /**
     * Same site cookie value
     */
    CookieModifier.prototype.getSameSite = function () {
        return this.sameSite;
    };
    /**
     * Checks if cookie with the specified name matches this option
     *
     * @param {string} name Cookie name
     * @return {boolean} true if it does
     */
    CookieModifier.prototype.matches = function (name) {
        if (!name) {
            return false;
        }
        if (this.regex) {
            return this.regex.test(name);
        }
        if (this.cookieName) {
            return this.cookieName === name;
        }
        // Empty regex and cookieName means that we must match all cookies
        return true;
    };
    /**
     * Checks if cookie rule has an empty $cookie option
     *
     * @return {boolean} True if $cookie option is empty
     */
    CookieModifier.prototype.isEmpty = function () {
        return !this.regex && !this.cookieName;
    };
    /**
     * Cookie name maxAge
     */
    CookieModifier.MAX_AGE = 'maxAge';
    /**
     * Cookie name sameSite
     */
    CookieModifier.SAME_SITE = 'sameSite';
    return CookieModifier;
}());

/**
 * Redirect modifier class
 */
var RedirectModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     * @param ruleText
     * @param isAllowlist
     * @param isRedirectingOnlyBlocked is redirect-rule modifier
     */
    function RedirectModifier(value, ruleText, isAllowlist, isRedirectingOnlyBlocked) {
        if (isRedirectingOnlyBlocked === void 0) { isRedirectingOnlyBlocked = false; }
        /**
         * Is redirecting only blocked requests
         * See $redirect-rule options
         */
        this.isRedirectingOnlyBlocked = false;
        RedirectModifier.validate(ruleText, value, isAllowlist);
        this.redirectTitle = value;
        this.isRedirectingOnlyBlocked = isRedirectingOnlyBlocked;
    }
    /**
     * Redirect title
     */
    RedirectModifier.prototype.getValue = function () {
        return this.redirectTitle;
    };
    /**
     * Validates redirect rule
     *
     * @param ruleText
     * @param redirectTitle
     * @param isAllowlist
     */
    RedirectModifier.validate = function (ruleText, redirectTitle, isAllowlist) {
        if (isAllowlist && !redirectTitle) {
            return;
        }
        if (!redirectTitle) {
            throw new SyntaxError('Invalid $redirect rule, redirect value must not be empty');
        }
        var redirects = scriptlets.redirects;
        var ruleTextToValidate = ruleText.replace(NETWORK_RULE_OPTIONS.REDIRECTRULE, NETWORK_RULE_OPTIONS.REDIRECT);
        if (!redirects.isAdgRedirectRule(ruleTextToValidate) || !redirects.isValidAdgRedirectRule(ruleTextToValidate)) {
            throw new SyntaxError('$redirect modifier is invalid');
        }
    };
    return RedirectModifier;
}());

/**
 * Splits url into parts
 *
 * @param url
 */
function splitUrl(url) {
    var strippedUrl = url;
    var hash = '';
    var hashIndex = url.indexOf('#');
    if (hashIndex >= 0) {
        hash = url.slice(hashIndex);
        strippedUrl = url.slice(0, hashIndex);
    }
    var query = '';
    var queryIndex = url.indexOf('?');
    if (queryIndex >= 0) {
        query = strippedUrl.slice(queryIndex + 1);
        strippedUrl = strippedUrl.slice(0, queryIndex);
    }
    return {
        path: strippedUrl,
        query: query,
        hash: hash,
    };
}
/**
 * Normalizes url query parameters
 *
 * @param query
 */
function normalizeQuery(query) {
    // Cleanup empty params (p0=0&=2&=3)
    var result = query
        .split('&')
        .filter(function (x) { return x && !x.startsWith('='); })
        .join('&');
    // If we've collapsed the URL to the point where there's an '&' against the '?'
    // then we need to get rid of that.
    while (result.charAt(0) === '&') {
        result = result.substr(1);
    }
    return result;
}
/**
 * Removes query params from url by regexp
 *
 * @param url
 * @param regExp
 * @param invert remove every parameter in url except the ones matched regexp
 */
function cleanUrlParamByRegExp(url, regExp, invert) {
    if (invert === void 0) { invert = false; }
    var searchIndex = url.indexOf('?');
    // If no params, nothing to modify
    if (searchIndex === -1) {
        return url;
    }
    var split = splitUrl(url);
    var modifiedQuery;
    if (invert) {
        modifiedQuery = split.query
            .split('&')
            .filter(function (x) { return x; })
            .filter(function (x) { return x && x.match(regExp); })
            .join('&');
    }
    else {
        modifiedQuery = split.query
            .split('&')
            .filter(function (x) {
            var test = x.includes('=') ? x : "".concat(x, "=");
            return !test.match(regExp);
        })
            .join('&');
    }
    // Do not normalize if regexp is not applied
    if (modifiedQuery === split.query) {
        return url;
    }
    modifiedQuery = normalizeQuery(modifiedQuery);
    var result = split.path;
    if (modifiedQuery) {
        result += "?".concat(modifiedQuery);
    }
    return result + split.hash;
}
var DOMAIN_REGEX = /^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9](?:\.[a-zA-Z]{2,})+$/;
/**
 * Check if the string could be a domain name
 *
 * @param text
 */
var isDomainName = function (text) {
    if (text.indexOf('.') < 0 || text.endsWith('.')) {
        return false;
    }
    return DOMAIN_REGEX.test(text);
};
/**
 * Extract relative part from hierarchical structured URL
 * @param url
 */
var getRelativeUrl = function (url) {
    var i = url.indexOf('/', url.indexOf('://') + 3);
    return i !== -1 ? url.substr(i) : null;
};

/**
 * Query parameters filtering modifier class
 * Works with '$removeparam' modifier
 */
var RemoveParamModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     */
    function RemoveParamModifier(value) {
        /**
         * Is modifier valid for MV3 or not
         */
        this.mv3Valid = true;
        this.value = value;
        var rawValue = value;
        // TODO: Seems like negation not using in valueRegExp
        if (value.startsWith('~')) {
            rawValue = value.substring(1);
            this.mv3Valid = false;
        }
        if (rawValue.startsWith('/')) {
            this.valueRegExp = SimpleRegex.patternFromString(rawValue);
            this.mv3Valid = false;
        }
        else {
            if (rawValue.includes('|')) {
                throw new Error('Unsupported option in $removeparam: multiple values are not allowed');
            }
            this.valueRegExp = new RegExp("((^|&)(".concat(SimpleRegex.escapeRegexSpecials(rawValue), ")=[^&#]*)"), 'g');
        }
    }
    /**
     * Modifier value
     */
    RemoveParamModifier.prototype.getValue = function () {
        return this.value;
    };
    /**
     * Is modifier valid for MV3 or not
     */
    RemoveParamModifier.prototype.getMV3Validity = function () {
        return this.mv3Valid;
    };
    /**
     * Removes query parameters from url
     *
     * @param url
     */
    RemoveParamModifier.prototype.removeParameters = function (url) {
        var sepIndex = url.indexOf('?');
        if (sepIndex < 0) {
            return url;
        }
        if (!this.value) {
            return url.substring(0, sepIndex);
        }
        if (sepIndex === url.length - 1) {
            return url;
        }
        if (this.value.startsWith('~')) {
            return cleanUrlParamByRegExp(url, this.valueRegExp, true);
        }
        return cleanUrlParamByRegExp(url, this.valueRegExp);
    };
    return RemoveParamModifier;
}());

/**
 * Headers filtering modifier class.
 * Rules with $removeheader modifier are intended to remove headers from HTTP requests and responses.
 */
var RemoveHeaderModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     * @param isAllowlist
     */
    function RemoveHeaderModifier(value, isAllowlist) {
        this.value = value.toLowerCase();
        if (!isAllowlist && !this.value) {
            throw new SyntaxError('Invalid $removeheader rule, removeheader value must not be empty');
        }
        this.isRequestModifier = this.value.startsWith(RemoveHeaderModifier.REQUEST_PREFIX);
        var headerName = this.isRequestModifier
            ? this.value.substring(RemoveHeaderModifier.REQUEST_PREFIX.length)
            : this.value;
        // Values with ":" are not supported in MV3 declarative rules, e.g. "$removeheader=dnt:1"
        this.valid = RemoveHeaderModifier.isAllowedHeader(headerName) && !headerName.includes(':');
        this.applicableHeaderName = this.valid ? headerName : null;
    }
    /**
     * Modifier value
     */
    RemoveHeaderModifier.prototype.getValue = function () {
        return this.value;
    };
    Object.defineProperty(RemoveHeaderModifier.prototype, "isValid", {
        /**
         * Modifier validity
         */
        get: function () {
            return this.valid;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns effective header name to be removed
     *
     * @param isRequestHeaders
     */
    RemoveHeaderModifier.prototype.getApplicableHeaderName = function (isRequestHeaders) {
        if (!this.applicableHeaderName) {
            return null;
        }
        if (isRequestHeaders !== this.isRequestModifier) {
            return null;
        }
        return this.applicableHeaderName;
    };
    /**
     * Some headers are forbidden to remove
     *
     * @param headerName
     */
    RemoveHeaderModifier.isAllowedHeader = function (headerName) {
        return !this.FORBIDDEN_HEADERS.includes(headerName);
    };
    /**
     * List of forbidden headers
     */
    RemoveHeaderModifier.FORBIDDEN_HEADERS = [
        'access-control-allow-origin',
        'access-control-allow-credentials',
        'access-control-allow-headers',
        'access-control-allow-methods',
        'access-control-expose-headers',
        'access-control-max-age',
        'access-control-request-headers',
        'access-control-request-method',
        'origin',
        'timing-allow-origin',
        'allow',
        'cross-origin-embedder-policy',
        'cross-origin-opener-policy',
        'cross-origin-resource-policy',
        'content-security-policy',
        'content-security-policy-report-only',
        'expect-ct',
        'feature-policy',
        'origin-isolation',
        'strict-transport-security',
        'upgrade-insecure-requests',
        'x-content-type-options',
        'x-download-options',
        'x-frame-options',
        'x-permitted-cross-domain-policies',
        'x-powered-by',
        'x-xss-protection',
        'public-key-pins',
        'public-key-pins-report-only',
        'sec-websocket-key',
        'sec-websocket-extensions',
        'sec-websocket-accept',
        'sec-websocket-protocol',
        'sec-websocket-version',
        'p3p',
        'sec-fetch-mode',
        'sec-fetch-dest',
        'sec-fetch-site',
        'sec-fetch-user',
        'referrer-policy',
        'content-type',
        'content-length',
        'accept',
        'accept-encoding',
        'host',
        'connection',
        'transfer-encoding',
        'upgrade',
    ];
    /**
     * Request prefix
     */
    RemoveHeaderModifier.REQUEST_PREFIX = 'request:';
    return RemoveHeaderModifier;
}());

var ErrorStatusCodes;
(function (ErrorStatusCodes) {
    ErrorStatusCodes[ErrorStatusCodes["ComplexRegex"] = 1001] = "ComplexRegex";
    ErrorStatusCodes[ErrorStatusCodes["RuleLimit"] = 1002] = "RuleLimit";
    ErrorStatusCodes[ErrorStatusCodes["RegexpRuleLimit"] = 1003] = "RegexpRuleLimit";
    ErrorStatusCodes[ErrorStatusCodes["RemoveparamRegexpIsNotSupported"] = 1004] = "RemoveparamRegexpIsNotSupported";
    ErrorStatusCodes[ErrorStatusCodes["RemoveparamInversionIsNotSupported"] = 1005] = "RemoveparamInversionIsNotSupported";
})(ErrorStatusCodes || (ErrorStatusCodes = {}));
var SEPARATOR = '|';

/**
 * This is a helper class that is used specifically to work with app restrictions.
 *
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
 *
 * Examples:
 * ||baddomain.com^$app=org.example.app
 * ||baddomain.com^$app=org.example.app1|org.example.app2
 */
var AppModifier = /** @class */ (function () {
    /**
     * Parses the `apps` string
     *
     * @param apps - apps string
     *
     * @throws an error if the app string is empty or invalid
     */
    function AppModifier(apps) {
        if (!apps) {
            throw new SyntaxError('$app modifier cannot be empty');
        }
        var permittedApps = [];
        var restrictedApps = [];
        var parts = apps.split(SEPARATOR);
        for (var i = 0; i < parts.length; i += 1) {
            var app = parts[i];
            var restricted = false;
            if (app.startsWith('~')) {
                restricted = true;
                app = app.substring(1).trim();
            }
            if (app === '') {
                throw new SyntaxError("Empty app specified in \"".concat(apps, "\""));
            }
            if (restricted) {
                restrictedApps.push(app);
            }
            else {
                permittedApps.push(app);
            }
        }
        this.restrictedApps = restrictedApps.length > 0 ? restrictedApps : null;
        this.permittedApps = permittedApps.length > 0 ? permittedApps : null;
    }
    return AppModifier;
}());

var HTTPMethod;
(function (HTTPMethod) {
    HTTPMethod["GET"] = "GET";
    HTTPMethod["POST"] = "POST";
    HTTPMethod["PUT"] = "PUT";
    HTTPMethod["DELETE"] = "DELETE";
    HTTPMethod["PATCH"] = "PATCH";
    HTTPMethod["HEAD"] = "HEAD";
    HTTPMethod["OPTIONS"] = "OPTIONS";
    HTTPMethod["CONNECT"] = "CONNECT";
    HTTPMethod["TRACE"] = "TRACE";
})(HTTPMethod || (HTTPMethod = {}));
/**
 * Method modifier class.
 * Rules with $method modifier will be applied only to requests with specified methods.
 *
 * Learn more about it here:
 * https://adguard.com/kb/general/ad-filtering/create-own-filters/#method-modifier
 */
var MethodModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     */
    function MethodModifier(methodsStr) {
        if (methodsStr === '') {
            throw new SyntaxError('$method modifier value cannot be empty');
        }
        var permittedMethods = [];
        var restrictedMethods = [];
        var parts = methodsStr.toUpperCase().split(MethodModifier.PIPE_SEPARATOR);
        for (var i = 0; i < parts.length; i += 1) {
            var method = parts[i].trim();
            var restricted = false;
            if (method.startsWith('~')) {
                restricted = true;
                method = method.substring(1);
            }
            if (!MethodModifier.isHTTPMethod(method)) {
                throw new SyntaxError("Invalid $method modifier value: ".concat(method));
            }
            if (restricted) {
                restrictedMethods.push(method);
            }
            else {
                permittedMethods.push(method);
            }
        }
        if (restrictedMethods.length > 0 && permittedMethods.length > 0) {
            throw new SyntaxError("Negated values cannot be mixed with non-negated values: ".concat(methodsStr));
        }
        this.restrictedValues = restrictedMethods.length > 0 ? restrictedMethods : null;
        this.permittedValues = permittedMethods.length > 0 ? permittedMethods : null;
    }
    /**
     * Request methods separator
     */
    MethodModifier.PIPE_SEPARATOR = '|';
    MethodModifier.isHTTPMethod = function (value) { return value in HTTPMethod; };
    return MethodModifier;
}());

/**
 * To modifier class.
 * Rules with $to modifier are limited to requests made to the specified domains and their subdomains.
 *
 * Learn more about it here:
 * https://adguard.com/kb/general/ad-filtering/create-own-filters/#to-modifier
 */
var ToModifier = /** @class */ (function () {
    /**
     * Constructor
     */
    function ToModifier(domainsStr) {
        if (!domainsStr) {
            throw new SyntaxError('$to modifier value cannot be empty');
        }
        var permittedDomains = [];
        var restrictedDomains = [];
        var parts = domainsStr.toLowerCase().split(ToModifier.PIPE_SEPARATOR);
        for (var i = 0; i < parts.length; i += 1) {
            var domain = parts[i].trim();
            var restricted = false;
            if (domain.startsWith('~')) {
                restricted = true;
                domain = domain.substring(1);
            }
            if (domain === '') {
                throw new SyntaxError("Empty domain specified in \"".concat(domainsStr, "\""));
            }
            if (restricted) {
                restrictedDomains.push(domain);
            }
            else {
                permittedDomains.push(domain);
            }
        }
        this.restrictedValues = restrictedDomains.length > 0 ? restrictedDomains : null;
        this.permittedValues = permittedDomains.length > 0 ? permittedDomains : null;
    }
    /**
     * Domains separator
     */
    ToModifier.PIPE_SEPARATOR = '|';
    return ToModifier;
}());

/**
 * Checks if error has message.
 *
 * @param error Error object.
 * @returns If param is error.
 */
function isErrorWithMessage(error) {
    return (typeof error === 'object'
        && error !== null
        && 'message' in error
        && typeof error.message === 'string');
}
/**
 * Converts error to the error with message.
 *
 * @param maybeError Possible error.
 * @returns Error with message.
 */
function toErrorWithMessage(maybeError) {
    if (isErrorWithMessage(maybeError)) {
        return maybeError;
    }
    try {
        return new Error(JSON.stringify(maybeError));
    }
    catch (_a) {
        // fallback in case there's an error stringifying the maybeError
        // like with circular references for example.
        return new Error(String(maybeError));
    }
}
/**
 * Converts error object to error with message. This method might be helpful to handle thrown errors.
 *
 * @param error Error object.
 *
 * @returns Message of the error.
 */
function getErrorMessage(error) {
    return toErrorWithMessage(error).message;
}

/**
 * This is the base class representing double values modifiers
 */
var BaseValuesModifier = /** @class */ (function () {
    /**
     * Parses the values string
     *
     * @param values - values string
     *
     * @throws an error if the string is empty or invalid
     */
    function BaseValuesModifier(values) {
        if (!values) {
            throw new SyntaxError('Modifier cannot be empty');
        }
        this.value = values;
        var permittedValues = [];
        var restrictedValues = [];
        var parts = values.split(SEPARATOR);
        for (var i = 0; i < parts.length; i += 1) {
            var app = parts[i];
            var restricted = false;
            if (app.startsWith('~')) {
                restricted = true;
                app = app.substring(1).trim();
            }
            if (app === '') {
                throw new SyntaxError("Empty values specified in \"".concat(values, "\""));
            }
            if (restricted) {
                restrictedValues.push(app);
            }
            else {
                permittedValues.push(app);
            }
        }
        this.restricted = restrictedValues.length > 0 ? restrictedValues : null;
        this.permitted = permittedValues.length > 0 ? permittedValues : null;
    }
    BaseValuesModifier.prototype.getPermitted = function () {
        return this.permitted;
    };
    BaseValuesModifier.prototype.getRestricted = function () {
        return this.restricted;
    };
    BaseValuesModifier.prototype.getValue = function () {
        return this.value;
    };
    BaseValuesModifier.prototype.match = function (value) {
        if (!this.restricted && !this.permitted) {
            return true;
        }
        if (this.restricted && this.restricted.includes(value)) {
            return false;
        }
        if (this.permitted) {
            return this.permitted.includes(value);
        }
        return true;
    };
    return BaseValuesModifier;
}());

/**
 * Netmasks class
 */
var NetmasksCollection = /** @class */ (function () {
    function NetmasksCollection() {
        this.ipv4Masks = [];
        this.ipv6Masks = [];
    }
    /**
     * Returns true if any of the containing masks contains provided value
     *
     * @param value
     */
    NetmasksCollection.prototype.contains = function (value) {
        if (isIp.v4(value)) {
            return this.ipv4Masks.some(function (x) { return contains(x, value); });
        }
        return this.ipv6Masks.some(function (x) { return contains(x, value); });
    };
    return NetmasksCollection;
}());
/**
 * The client modifier allows specifying clients this rule will be working for.
 * It accepts client names (not ClientIDs), IP addresses, or CIDR ranges.
 */
var ClientModifier = /** @class */ (function (_super) {
    __extends(ClientModifier, _super);
    /**
     * Constructor
     *
     * @param value
     */
    function ClientModifier(value) {
        var _this = _super.call(this, value) || this;
        var permitted = _this.getPermitted();
        if (permitted) {
            _this.permitted = ClientModifier.stripValues(permitted);
            _this.permittedNetmasks = ClientModifier.parseNetmasks(_this.permitted);
        }
        var restricted = _this.getRestricted();
        if (restricted) {
            _this.restricted = ClientModifier.stripValues(restricted);
            _this.restrictedNetmasks = ClientModifier.parseNetmasks(_this.restricted);
        }
        return _this;
    }
    /**
     * Unquotes and unescapes string
     *
     * @param values
     */
    ClientModifier.stripValues = function (values) {
        return values.map(function (v) {
            if ((v.startsWith('"') && v.endsWith('"'))
                || (v.startsWith('\'') && v.endsWith('\''))) {
                // eslint-disable-next-line no-param-reassign
                v = v.substr(1, v.length - 2);
            }
            return v.replace(/\\/ig, '');
        });
    };
    /**
     * Checks if this modifier matches provided params
     *
     * @param clientName
     * @param clientIP
     */
    ClientModifier.prototype.matchAny = function (clientName, clientIP) {
        if (this.restricted) {
            if (clientName && this.restricted.includes(clientName)) {
                return false;
            }
            if (clientIP && this.restricted.includes(clientIP)) {
                return false;
            }
            return true;
        }
        if (this.restrictedNetmasks) {
            if (clientIP && this.restrictedNetmasks.contains(clientIP)) {
                return false;
            }
            return true;
        }
        if (this.permitted) {
            if (clientName && this.permitted.includes(clientName)) {
                return true;
            }
            if (clientIP && this.permitted.includes(clientIP)) {
                return true;
            }
        }
        if (this.permittedNetmasks) {
            if (clientIP && this.permittedNetmasks.contains(clientIP)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Parses netmasks from client's strings
     *
     * @param values
     */
    ClientModifier.parseNetmasks = function (values) {
        var result = new NetmasksCollection();
        values.forEach(function (x) {
            var cidrVersion = isCidr(x);
            if (cidrVersion === 4) {
                result.ipv4Masks.push(x);
            }
            else if (cidrVersion === 6) {
                result.ipv6Masks.push(x);
            }
        });
        return result;
    };
    return ClientModifier;
}(BaseValuesModifier));

/**
 * The dnsrewrite response modifier allows replacing the content of the response
 * to the DNS request for the matching hosts.
 *
 * TODO: This modifier is not yet implemented
 * https://github.com/AdguardTeam/AdGuardHome/wiki/Hosts-Blocklists#dnsrewrite
 */
var DnsRewriteModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     */
    function DnsRewriteModifier(value) {
        this.value = value;
    }
    /**
     * Modifier value
     */
    DnsRewriteModifier.prototype.getValue = function () {
        return this.value;
    };
    return DnsRewriteModifier;
}());

/**
 * The dnstype modifier allows specifying DNS request type on which this rule will be triggered.
 */
var DnsTypeModifier = /** @class */ (function (_super) {
    __extends(DnsTypeModifier, _super);
    /**
     * Constructor
     *
     * @param value
     */
    function DnsTypeModifier(value) {
        var _this = _super.call(this, value) || this;
        if (_this.permitted) {
            _this.restricted = null;
        }
        return _this;
    }
    return DnsTypeModifier;
}(BaseValuesModifier));

/**
 * The ctag modifier allows to block domains only for specific types of DNS client tags.
 */
var CtagModifier = /** @class */ (function (_super) {
    __extends(CtagModifier, _super);
    /**
     * Constructor
     *
     * @param value
     */
    function CtagModifier(value) {
        var _this = _super.call(this, value) || this;
        _this.validate();
        return _this;
    }
    /**
     * Validates tag values
     */
    CtagModifier.prototype.validate = function () {
        if (!this.getValue()) {
            throw new Error('Invalid rule: Ctag modifier must not be empty');
        }
        var tags = this.permitted ? this.permitted : this.restricted;
        if (tags && tags.some(function (x) { return !CtagModifier.ALLOWED_TAGS.includes(x); })) {
            throw new Error('Invalid rule: Invalid ctag modifier');
        }
    };
    /**
     * The list of allowed tags
     */
    CtagModifier.ALLOWED_TAGS = [
        // By device type:
        'device_audio',
        'device_camera',
        'device_gameconsole',
        'device_laptop',
        'device_nas',
        'device_pc',
        'device_phone',
        'device_printer',
        'device_securityalarm',
        'device_tablet',
        'device_tv',
        'device_other',
        // By operating system:
        'os_android',
        'os_ios',
        'os_linux',
        'os_macos',
        'os_windows',
        'os_other',
        // By user group:
        'user_admin',
        'user_regular',
        'user_child',
    ];
    return CtagModifier;
}(BaseValuesModifier));

/**
 * Rule pattern class
 *
 * This class parses rule pattern text to simple fields.
 */
var Pattern = /** @class */ (function () {
    /**
     * Constructor
     * @param pattern
     * @param matchcase
     */
    function Pattern(pattern, matchcase) {
        if (matchcase === void 0) { matchcase = false; }
        this.pattern = pattern;
        this.shortcut = SimpleRegex.extractShortcut(this.pattern);
        this.matchcase = matchcase;
    }
    /**
     * Checks if this rule pattern matches the specified request.
     *
     * @param request - request to check
     * @param shortcutMatched if true, it means that the request already matches
     * this pattern's shortcut and we don't need to match it again.
     * @returns true if pattern matches
     */
    Pattern.prototype.matchPattern = function (request, shortcutMatched) {
        this.prepare();
        if (this.patternShortcut) {
            return shortcutMatched || this.matchShortcut(request.urlLowercase);
        }
        if (this.hostname) {
            // If we have a `||example.org^` rule, it's easier to match
            // against the request's hostname only without matching
            // a regular expression.
            return request.hostname === this.hostname
                || ( // First light check without new string memory allocation
                request.hostname.endsWith(this.hostname)
                    // Strict check
                    && request.hostname.endsWith(".".concat(this.hostname)));
        }
        // If the regular expression is invalid, just return false right away.
        if (this.regexInvalid || !this.regex) {
            return false;
        }
        // This is needed for DNS filtering only, not used in browser blocking.
        if (this.shouldMatchHostname(request)) {
            return this.regex.test(request.hostname);
        }
        return this.regex.test(request.url);
    };
    /**
     * Checks if this rule pattern matches the specified relative path string.
     * This method is used in cosmetic rules to implement the $path modifier matching logic.
     *
     * @param path - path to check
     * @returns true if pattern matches
     */
    Pattern.prototype.matchPathPattern = function (path) {
        this.prepare();
        if (this.hostname) {
            return false;
        }
        var pathIsEmptyString = this.pattern === '';
        // No-value $path should match root URL
        if (pathIsEmptyString && path === '/') {
            return true;
        }
        if (!pathIsEmptyString && this.patternShortcut) {
            return this.matchShortcut(path);
        }
        // If the regular expression is invalid, just return false right away.
        if (this.regexInvalid || !this.regex) {
            return false;
        }
        return this.regex.test(path);
    };
    /**
     * matchShortcut simply checks if shortcut is a substring of the URL.
     * @param request - request to check.
     */
    Pattern.prototype.matchShortcut = function (str) {
        return str.indexOf(this.shortcut) >= 0;
    };
    /**
     * Prepares this pattern
     */
    Pattern.prototype.prepare = function () {
        if (this.prepared) {
            return;
        }
        this.prepared = true;
        // If shortcut and pattern are the same, we don't need to actually compile
        // a regex and can simply use matchShortcut instead,
        // except for the $match-case modifier
        if (this.pattern === this.shortcut && !this.matchcase) {
            this.patternShortcut = true;
            return;
        }
        // Rules like `/example/*` are rather often in the real-life filters,
        // we might want to process them.
        if (this.pattern.startsWith(this.shortcut)
            && this.pattern.length === this.shortcut.length + 1
            && this.pattern.endsWith('*')) {
            this.patternShortcut = true;
            return;
        }
        if (this.pattern.startsWith(SimpleRegex.MASK_START_URL)
            && this.pattern.endsWith(SimpleRegex.MASK_SEPARATOR)
            && this.pattern.indexOf('*') < 0
            && this.pattern.indexOf('/') < 0) {
            this.hostname = this.pattern.slice(2, this.pattern.length - 1);
            return;
        }
        this.compileRegex();
    };
    /**
     * Compiles this pattern regex
     */
    Pattern.prototype.compileRegex = function () {
        var regexText = SimpleRegex.patternToRegexp(this.pattern);
        try {
            var flags = 'i';
            if (this.matchcase) {
                flags = '';
            }
            this.regex = new RegExp(regexText, flags);
        }
        catch (e) {
            this.regexInvalid = true;
        }
    };
    /**
     * Checks if we should match hostnames and not the URL
     * this is important for the cases when we use urlfilter for DNS-level blocking
     * Note, that even though we may work on a DNS-level, we should still sometimes match full URL instead
     *
     * @param request
     */
    Pattern.prototype.shouldMatchHostname = function (request) {
        if (!request.isHostnameRequest) {
            return false;
        }
        return !this.isPatternDomainSpecific();
    };
    /**
     * In case pattern starts with the following it targets some specific domain
     */
    Pattern.prototype.isPatternDomainSpecific = function () {
        if (this.patternDomainSpecific === undefined) {
            this.patternDomainSpecific = this.pattern.startsWith(SimpleRegex.MASK_START_URL)
                || this.pattern.startsWith('http://')
                || this.pattern.startsWith('https:/')
                || this.pattern.startsWith('://');
        }
        return this.patternDomainSpecific;
    };
    return Pattern;
}());

/**
 * Counts the number of bits in the number and returns it
 *
 * @param a number to count bits
 *
 * @returns The number of bits in the number.
 */
function getBitCount(a) {
    var count = 0;
    var n = a;
    while (n > 0) {
        count += n & 1;
        n >>= 1;
    }
    return count;
}
/**
 * Count the number of bits enabled in a number based on a bit mask
 *
 * @param base Base number to check
 * @param mask Mask to check
 *
 * @returns The number of bits enabled in the base number based on the mask
 *
 * @example
 * countEnabledBits(0b100, 0b110); // 1
 * countEnabledBits(0b111, 0b000); // 0
 */
function countEnabledBits(base, mask) {
    // Get the common bits between the base and the mask
    var common = base & mask;
    // Count the number of bits enabled in the common bits
    return getBitCount(common);
}

/**
 * NetworkRuleOption is the enumeration of various rule options.
 * In order to save memory, we store some options as a flag.
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#modifiers
 */
var NetworkRuleOption;
(function (NetworkRuleOption) {
    /** No value is set. Syntax sugar to simplify code. */
    NetworkRuleOption[NetworkRuleOption["NotSet"] = 0] = "NotSet";
    /** $third-party modifier */
    NetworkRuleOption[NetworkRuleOption["ThirdParty"] = 1] = "ThirdParty";
    /** $match-case modifier */
    NetworkRuleOption[NetworkRuleOption["MatchCase"] = 2] = "MatchCase";
    /** $important modifier */
    NetworkRuleOption[NetworkRuleOption["Important"] = 4] = "Important";
    // Allowlist rules modifiers
    // Each of them can disable part of the functionality
    /** $elemhide modifier */
    NetworkRuleOption[NetworkRuleOption["Elemhide"] = 8] = "Elemhide";
    /** $generichide modifier */
    NetworkRuleOption[NetworkRuleOption["Generichide"] = 16] = "Generichide";
    /** $specifichide modifier */
    NetworkRuleOption[NetworkRuleOption["Specifichide"] = 32] = "Specifichide";
    /** $genericblock modifier */
    NetworkRuleOption[NetworkRuleOption["Genericblock"] = 64] = "Genericblock";
    /** $jsinject modifier */
    NetworkRuleOption[NetworkRuleOption["Jsinject"] = 128] = "Jsinject";
    /** $urlblock modifier */
    NetworkRuleOption[NetworkRuleOption["Urlblock"] = 256] = "Urlblock";
    /** $content modifier */
    NetworkRuleOption[NetworkRuleOption["Content"] = 512] = "Content";
    /** $extension modifier */
    NetworkRuleOption[NetworkRuleOption["Extension"] = 1024] = "Extension";
    /** $stealth modifier */
    NetworkRuleOption[NetworkRuleOption["Stealth"] = 2048] = "Stealth";
    // Other modifiers
    /** $popup modifier */
    NetworkRuleOption[NetworkRuleOption["Popup"] = 4096] = "Popup";
    /** $csp modifier */
    NetworkRuleOption[NetworkRuleOption["Csp"] = 8192] = "Csp";
    /** $replace modifier */
    NetworkRuleOption[NetworkRuleOption["Replace"] = 16384] = "Replace";
    /** $cookie modifier */
    NetworkRuleOption[NetworkRuleOption["Cookie"] = 32768] = "Cookie";
    /** $redirect modifier */
    NetworkRuleOption[NetworkRuleOption["Redirect"] = 65536] = "Redirect";
    /** $badfilter modifier */
    NetworkRuleOption[NetworkRuleOption["Badfilter"] = 131072] = "Badfilter";
    /** $removeparam modifier */
    NetworkRuleOption[NetworkRuleOption["RemoveParam"] = 262144] = "RemoveParam";
    /** $removeheader modifier */
    NetworkRuleOption[NetworkRuleOption["RemoveHeader"] = 524288] = "RemoveHeader";
    /** $jsonprune modifier */
    NetworkRuleOption[NetworkRuleOption["JsonPrune"] = 1048576] = "JsonPrune";
    /** $hls modifier */
    NetworkRuleOption[NetworkRuleOption["Hls"] = 2097152] = "Hls";
    // Compatibility dependent
    /** $network modifier */
    NetworkRuleOption[NetworkRuleOption["Network"] = 4194304] = "Network";
    /** dns modifiers */
    NetworkRuleOption[NetworkRuleOption["Client"] = 8388608] = "Client";
    NetworkRuleOption[NetworkRuleOption["DnsRewrite"] = 16777216] = "DnsRewrite";
    NetworkRuleOption[NetworkRuleOption["DnsType"] = 33554432] = "DnsType";
    NetworkRuleOption[NetworkRuleOption["Ctag"] = 67108864] = "Ctag";
    /* $method modifier */
    NetworkRuleOption[NetworkRuleOption["Method"] = 134217728] = "Method";
    /* $to modifier */
    NetworkRuleOption[NetworkRuleOption["To"] = 268435456] = "To";
    /* $permissions modifier */
    NetworkRuleOption[NetworkRuleOption["Permissions"] = 536870912] = "Permissions";
    // Groups (for validation)
    /** Allowlist-only modifiers */
    NetworkRuleOption[NetworkRuleOption["AllowlistOnly"] = 4088] = "AllowlistOnly";
    /** Options supported by host-level network rules * */
    NetworkRuleOption[NetworkRuleOption["OptionHostLevelRules"] = 125960196] = "OptionHostLevelRules";
    /**
     * Removeparam compatible modifiers
     *
     * $removeparam rules are compatible only with content type modifiers ($subdocument, $script, $stylesheet, etc)
     * except $document (using by default) and this list of modifiers:
     */
    NetworkRuleOption[NetworkRuleOption["RemoveParamCompatibleOptions"] = 393223] = "RemoveParamCompatibleOptions";
    /**
     * Removeheader compatible modifiers
     *
     * $removeheader rules are compatible only with content type modifiers ($subdocument, $script, $stylesheet, etc)
     * except $document (using by default) and this list of modifiers:
     */
    NetworkRuleOption[NetworkRuleOption["RemoveHeaderCompatibleOptions"] = 655367] = "RemoveHeaderCompatibleOptions";
})(NetworkRuleOption || (NetworkRuleOption = {}));
/**
 * Helper class that is used for passing {@link NetworkRule.parseRuleText}
 * result to the caller. Should not be used outside of this file.
 */
var BasicRuleParts = /** @class */ (function () {
    function BasicRuleParts() {
    }
    return BasicRuleParts;
}());
/**
 * Basic network filtering rule.
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules
 */
var NetworkRule = /** @class */ (function () {
    /**
     * Creates an instance of the {@link NetworkRule}.
     * It parses this rule and extracts the rule pattern (see {@link SimpleRegex}),
     * and rule modifiers.
     *
     * @param ruleText - original rule text.
     * @param filterListId - ID of the filter list this rule belongs to.
     *
     * @throws error if it fails to parse the rule.
     */
    function NetworkRule(ruleText, filterListId) {
        this.permittedDomains = null;
        this.restrictedDomains = null;
        /**
         * Domains in denyallow modifier providing exceptions for permitted domains
         * https://github.com/AdguardTeam/CoreLibs/issues/1304
         */
        this.denyAllowDomains = null;
        /**
         * Flag with all enabled rule options.
         */
        this.enabledOptions = NetworkRuleOption.NotSet;
        /**
         * Flag with all disabled rule options.
         */
        this.disabledOptions = NetworkRuleOption.NotSet;
        /**
         * Flag with all permitted request types.
         */
        this.permittedRequestTypes = RequestType.NotSet;
        /**
         * Flag with all restricted request types.
         */
        this.restrictedRequestTypes = RequestType.NotSet;
        /**
         * Rule Advanced modifier
         */
        this.advancedModifier = null;
        /**
         * Rule App modifier
         */
        this.appModifier = null;
        /**
         * Rule Method modifier
         */
        this.methodModifier = null;
        /**
         * Rule To modifier
         */
        this.toModifier = null;
        /**
         * Rule priority, which is needed when the engine has to choose between
         * several rules matching the query. This value is calculated based on
         * the rule modifiers enabled or disabled and rounded up
         * to the smallest integer greater than or equal to the calculated weight
         * in the {@link calculatePriorityWeight}.
         *
         * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-1
         */
        this.priorityWeight = 1;
        this.ruleText = ruleText;
        this.filterListId = filterListId;
        var ruleParts = NetworkRule.parseRuleText(ruleText);
        this.allowlist = !!ruleParts.allowlist;
        var pattern = ruleParts.pattern;
        if (pattern && NetworkRule.hasSpaces(pattern)) {
            throw new SyntaxError('Rule has spaces, seems to be an host rule');
        }
        if (ruleParts.options) {
            this.loadOptions(ruleParts.options);
        }
        if (pattern === SimpleRegex.MASK_START_URL
            || pattern === SimpleRegex.MASK_ANY_CHARACTER
            || pattern === ''
            || pattern.length < SimpleRegex.MIN_GENERIC_RULE_LENGTH) {
            // Except cookie, removeparam rules and dns compatible rules, they have their own atmosphere
            var hasCookieModifier = this.advancedModifier instanceof CookieModifier;
            var hasRemoveParamModifier = this.advancedModifier instanceof RemoveParamModifier;
            // https://github.com/AdguardTeam/tsurlfilter/issues/56
            var isDnsCompatible = isCompatibleWith(CompatibilityTypes.Dns);
            if (!hasCookieModifier && !hasRemoveParamModifier && !isDnsCompatible) {
                if (!(this.hasPermittedDomains() || this.hasPermittedApps())) {
                    // Rule matches too much and does not have any domain restriction
                    // We should not allow this kind of rules
                    // eslint-disable-next-line max-len
                    throw new SyntaxError('The rule is too wide, add domain restriction or make the pattern more specific');
                }
            }
        }
        this.calculatePriorityWeight();
        this.pattern = new Pattern(pattern, this.isOptionEnabled(NetworkRuleOption.MatchCase));
    }
    /**
     * Returns the original text of the rule from which it was parsed.
     *
     * @returns Original text of the rule.
     */
    NetworkRule.prototype.getText = function () {
        return this.ruleText;
    };
    /**
     * Returns the identifier of the filter from which the rule was received.
     *
     * @returns Identifier of the filter from which the rule was received.
     */
    NetworkRule.prototype.getFilterListId = function () {
        return this.filterListId;
    };
    /**
     * Each rule has its own priority, which is necessary when several rules
     * match the request and the filtering system needs to select one of them.
     * Priority is measured as a positive integer.
     * In the case of a conflict between two rules with the same priority value,
     * it is not specified which one of them will be chosen.
     *
     * @returns Rule priority.
     */
    NetworkRule.prototype.getPriorityWeight = function () {
        return this.priorityWeight;
    };
    /**
     * Returns rule pattern,
     * which currently is used only in the rule validator module
     */
    NetworkRule.prototype.getPattern = function () {
        return this.pattern.pattern;
    };
    /**
     * Returns `true` if the rule is "allowlist", e.g. if it disables other
     * rules when the pattern matches the request.
     */
    NetworkRule.prototype.isAllowlist = function () {
        return this.allowlist;
    };
    /**
     * Checks if the rule is a document-level allowlist rule with $urlblock or
     * $genericblock or $content.
     * This means that the rule is supposed to disable or modify blocking
     * of the page subrequests.
     * For instance, `@@||example.org^$urlblock` unblocks all sub-requests.
     */
    NetworkRule.prototype.isDocumentLevelAllowlistRule = function () {
        if (!this.isAllowlist()) {
            return false;
        }
        return this.isOptionEnabled(NetworkRuleOption.Urlblock)
            || this.isOptionEnabled(NetworkRuleOption.Genericblock)
            || this.isOptionEnabled(NetworkRuleOption.Content);
    };
    /**
     * Checks if the rule completely disables filtering.
     */
    NetworkRule.prototype.isFilteringDisabled = function () {
        if (!this.isAllowlist()) {
            return false;
        }
        return this.isOptionEnabled(NetworkRuleOption.Elemhide)
            && this.isOptionEnabled(NetworkRuleOption.Content)
            && this.isOptionEnabled(NetworkRuleOption.Urlblock)
            && this.isOptionEnabled(NetworkRuleOption.Jsinject);
    };
    /**
     * The longest part of pattern without any special characters.
     * It is used to improve the matching performance.
     */
    NetworkRule.prototype.getShortcut = function () {
        return this.pattern.shortcut;
    };
    /**
     * Gets list of permitted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
     */
    NetworkRule.prototype.getPermittedDomains = function () {
        return this.permittedDomains;
    };
    /**
     * Gets list of denyAllow domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#denyallow-modifier
     */
    NetworkRule.prototype.getDenyAllowDomains = function () {
        return this.denyAllowDomains;
    };
    /**
     * Gets list of restricted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
     */
    NetworkRule.prototype.getRestrictedDomains = function () {
        return this.restrictedDomains;
    };
    /**
     * Get list of permitted $to domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#to-modifier
     */
    NetworkRule.prototype.getPermittedToDomains = function () {
        if (this.toModifier) {
            return this.toModifier.permittedValues;
        }
        return null;
    };
    /**
     * Get list of restricted $to domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#to-modifier
     */
    NetworkRule.prototype.getRestrictedToDomains = function () {
        if (this.toModifier) {
            return this.toModifier.restrictedValues;
        }
        return null;
    };
    /**
     * Gets list of permitted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
     */
    NetworkRule.prototype.getPermittedApps = function () {
        if (this.appModifier) {
            return this.appModifier.permittedApps;
        }
        return null;
    };
    /**
     * Gets list of restricted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
     */
    NetworkRule.prototype.getRestrictedApps = function () {
        if (this.appModifier) {
            return this.appModifier.restrictedApps;
        }
        return null;
    };
    /**
     * Gets list of permitted methods.
     * See https://kb.adguard.com/general/how-to-create-your-own-ad-filters#method-modifier
     */
    NetworkRule.prototype.getRestrictedMethods = function () {
        if (this.methodModifier) {
            return this.methodModifier.restrictedValues;
        }
        return null;
    };
    /**
     * Gets list of restricted methods.
     * See https://kb.adguard.com/general/how-to-create-your-own-ad-filters#method-modifier
     */
    NetworkRule.prototype.getPermittedMethods = function () {
        if (this.methodModifier) {
            return this.methodModifier.permittedValues;
        }
        return null;
    };
    /**
     * Flag with all permitted request types.
     * The value {@link RequestType.NotSet} here means "all request types are allowed".
     */
    NetworkRule.prototype.getPermittedRequestTypes = function () {
        return this.permittedRequestTypes;
    };
    /**
     * Flag with all restricted request types.
     * The value {@link RequestType.NotSet} here means "no type of request is restricted".
     */
    NetworkRule.prototype.getRestrictedRequestTypes = function () {
        return this.restrictedRequestTypes;
    };
    /**
     * Advanced modifier
     */
    NetworkRule.prototype.getAdvancedModifier = function () {
        return this.advancedModifier;
    };
    /**
     * Advanced modifier value
     */
    NetworkRule.prototype.getAdvancedModifierValue = function () {
        return this.advancedModifier && this.advancedModifier.getValue();
    };
    /**
     * isRegexRule returns true if rule's pattern is a regular expression.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#regexp-support
     */
    NetworkRule.prototype.isRegexRule = function () {
        return (this.getPattern().startsWith(SimpleRegex.MASK_REGEX_RULE)
            && this.getPattern().endsWith(SimpleRegex.MASK_REGEX_RULE));
    };
    NetworkRule.prototype.matchesPermittedDomains = function (hostname) {
        if (this.hasPermittedDomains()
            && DomainModifier.isDomainOrSubdomainOfAny(hostname, this.permittedDomains)) {
            return true;
        }
        return false;
    };
    /**
     * Checks if this filtering rule matches the specified request.
     * @param request - request to check.
     * @param useShortcut - the flag to use this rule shortcut
     *
     * In case we use Trie in lookup table, we don't need to use shortcut cause we already check if request's url
     * includes full rule shortcut.
     */
    NetworkRule.prototype.match = function (request, useShortcut) {
        if (useShortcut === void 0) { useShortcut = true; }
        // Regex rules should not be tested by shortcut
        if (useShortcut && !this.matchShortcut(request)) {
            return false;
        }
        if (this.isOptionEnabled(NetworkRuleOption.Method) && !this.matchMethod(request.method)) {
            return false;
        }
        if (this.isOptionEnabled(NetworkRuleOption.ThirdParty) && !request.thirdParty) {
            return false;
        }
        if (this.isOptionDisabled(NetworkRuleOption.ThirdParty) && request.thirdParty) {
            return false;
        }
        if (!this.matchRequestType(request.requestType)) {
            return false;
        }
        if (!this.matchDomainModifier(request)) {
            return false;
        }
        if (this.isOptionEnabled(NetworkRuleOption.RemoveParam)) {
            if (!this.matchRequestTypeExplicit(request.requestType)) {
                return false;
            }
        }
        if (!this.matchDenyAllowDomains(request.hostname)) {
            return false;
        }
        if (this.isOptionEnabled(NetworkRuleOption.To) && !this.matchToModifier(request.hostname)) {
            return false;
        }
        if (!this.matchDnsType(request.dnsType)) {
            return false;
        }
        if (!this.matchClientTags(request.clientTags)) {
            return false;
        }
        if (!this.matchClient(request.clientName, request.clientIP)) {
            return false;
        }
        return this.pattern.matchPattern(request, true);
    };
    /**
     * matchShortcut simply checks if shortcut is a substring of the URL.
     * @param request - request to check.
     */
    NetworkRule.prototype.matchShortcut = function (request) {
        return request.urlLowercase.indexOf(this.getShortcut()) >= 0;
    };
    /**
     * matchDomain checks if the filtering rule is allowed on this domain.
     * @param domain - domain to check.
     */
    NetworkRule.prototype.matchDomain = function (domain) {
        if (this.hasRestrictedDomains()) {
            if (DomainModifier.isDomainOrSubdomainOfAny(domain, this.restrictedDomains)) {
                // Domain or host is restricted
                // i.e. $domain=~example.org
                return false;
            }
        }
        if (this.hasPermittedDomains()) {
            if (!DomainModifier.isDomainOrSubdomainOfAny(domain, this.permittedDomains)) {
                // Domain is not among permitted
                // i.e. $domain=example.org and we're checking example.com
                return false;
            }
        }
        return true;
    };
    /**
     * Check if request matches domain modifier by request referrer (general case) or by request target
     *
     * In some cases the $domain modifier can match not only the referrer domain, but also the target domain.
     * This happens when the following is true (1 AND ((2 AND 3) OR 4):
     *
     * 1) The request has document type
     * 2) The rule's pattern doesn't match any particular domain(s)
     * 3) The rule's pattern doesn't contain regular expressions
     * 4) The $domain modifier contains only excluded domains (e.g., $domain=~example.org|~example.com)
     *
     * When all these conditions are met, the domain modifier will match both the referrer domain and the target domain.
     * https://github.com/AdguardTeam/tsurlfilter/issues/45
     * @param request
     */
    NetworkRule.prototype.matchDomainModifier = function (request) {
        if (!this.permittedDomains && !this.restrictedDomains) {
            return true;
        }
        var isDocumentType = request.requestType === RequestType.Document
            || request.requestType === RequestType.SubDocument;
        var hasOnlyExcludedDomains = (!this.permittedDomains || this.permittedDomains.length === 0)
            && this.restrictedDomains
            && this.restrictedDomains.length > 0;
        var patternIsRegex = this.isRegexRule();
        var patternIsDomainSpecific = this.pattern.isPatternDomainSpecific();
        var matchesTargetByPatternCondition = !patternIsRegex && !patternIsDomainSpecific;
        if (isDocumentType && (hasOnlyExcludedDomains || matchesTargetByPatternCondition)) {
            // check if matches source hostname if exists or if matches target hostname
            return (request.sourceHostname && this.matchDomain(request.sourceHostname))
                || this.matchDomain(request.hostname);
        }
        return this.matchDomain(request.sourceHostname || '');
    };
    /**
     * checks if the filtering rule is allowed on this domain.
     * @param domain
     */
    NetworkRule.prototype.matchDenyAllowDomains = function (domain) {
        if (!this.denyAllowDomains) {
            return true;
        }
        if (this.denyAllowDomains.length > 0) {
            if (DomainModifier.isDomainOrSubdomainOfAny(domain, this.denyAllowDomains)) {
                return false;
            }
        }
        return true;
    };
    /**
     * Checks if request target matches with specified domains
     *
     * @param domain request's domain
     * @return true if request domain matches with specified domains
     */
    NetworkRule.prototype.matchToModifier = function (domain) {
        if (!this.toModifier) {
            return true;
        }
        /**
         * Request's domain must be either explicitly
         * permitted and not be included in list of restricted domains
         * for the rule to apply
         */
        var permittedDomains = this.getPermittedToDomains();
        var restrictedDomains = this.getRestrictedToDomains();
        var isPermittedDomain = !!permittedDomains
            && DomainModifier.isDomainOrSubdomainOfAny(domain, permittedDomains);
        var isRestrictedDomain = !!restrictedDomains
            && DomainModifier.isDomainOrSubdomainOfAny(domain, restrictedDomains);
        return isPermittedDomain && !isRestrictedDomain;
    };
    /**
     * Return TRUE if this rule matches with the tags associated with a client
     *
     * @param clientTags
     */
    NetworkRule.prototype.matchClientTags = function (clientTags) {
        var advancedModifier = this.getAdvancedModifier();
        if (!advancedModifier || !(advancedModifier instanceof CtagModifier)) {
            return true;
        }
        if (!clientTags) {
            return false;
        }
        var cTagsModifier = advancedModifier;
        return clientTags.every(function (x) { return cTagsModifier.match(x); });
    };
    /**
     * returns TRUE if the rule matches with the specified client
     *
     * @param clientName
     * @param clientIP
     */
    NetworkRule.prototype.matchClient = function (clientName, clientIP) {
        var advancedModifier = this.getAdvancedModifier();
        if (!advancedModifier || !(advancedModifier instanceof ClientModifier)) {
            return true;
        }
        if (!clientName && !clientIP) {
            return false;
        }
        var modifier = advancedModifier;
        return modifier.matchAny(clientName, clientIP);
    };
    /**
     * Return TRUE if this rule matches with the request dnstype
     *
     * @param dnstype
     */
    NetworkRule.prototype.matchDnsType = function (dnstype) {
        var advancedModifier = this.getAdvancedModifier();
        if (!advancedModifier || !(advancedModifier instanceof DnsTypeModifier)) {
            return true;
        }
        if (!dnstype) {
            return false;
        }
        var modifier = advancedModifier;
        return modifier.match(dnstype);
    };
    /**
     * Checks if rule has permitted domains
     */
    NetworkRule.prototype.hasPermittedDomains = function () {
        return this.permittedDomains != null && this.permittedDomains.length > 0;
    };
    /**
     * Checks if rule has restricted domains
     */
    NetworkRule.prototype.hasRestrictedDomains = function () {
        return this.restrictedDomains != null && this.restrictedDomains.length > 0;
    };
    /**
     * Checks if rule has permitted apps
     */
    NetworkRule.prototype.hasPermittedApps = function () {
        if (!this.appModifier) {
            return false;
        }
        return this.appModifier.permittedApps !== null && this.appModifier.permittedApps.length > 0;
    };
    /**
     * matchRequestType checks if the request's type matches the rule properties
     * @param requestType - request type to check.
     */
    NetworkRule.prototype.matchRequestType = function (requestType) {
        if (this.permittedRequestTypes !== RequestType.NotSet) {
            if ((this.permittedRequestTypes & requestType) !== requestType) {
                return false;
            }
        }
        if (this.restrictedRequestTypes !== RequestType.NotSet) {
            if ((this.restrictedRequestTypes & requestType) === requestType) {
                return false;
            }
        }
        return true;
    };
    /**
     * In case of $removeparam modifier,
     * we only allow it to target other content types if the rule has an explicit content-type modifier.
     */
    NetworkRule.prototype.matchRequestTypeExplicit = function (requestType) {
        if (this.permittedRequestTypes === RequestType.NotSet
            && this.restrictedRequestTypes === RequestType.NotSet
            && requestType !== RequestType.Document
            && requestType !== RequestType.SubDocument) {
            return false;
        }
        return this.matchRequestType(requestType);
    };
    /**
     * Checks if request's method matches with the rule
     *
     * @param method request's method
     * @returns true, if rule must be applied to the request
     */
    NetworkRule.prototype.matchMethod = function (method) {
        if (!method || !MethodModifier.isHTTPMethod(method)) {
            return false;
        }
        /**
         * Request's method must be either explicitly
         * permitted or not be included in list of restricted methods
         * for the rule to apply
         */
        var permittedMethods = this.getPermittedMethods();
        if (permittedMethods === null || permittedMethods === void 0 ? void 0 : permittedMethods.includes(method)) {
            return true;
        }
        var restrictedMethods = this.getRestrictedMethods();
        return !!restrictedMethods && !restrictedMethods.includes(method);
    };
    /**
     * Checks if pattern has spaces
     * Used in order to do not create network rules from host rules
     * @param pattern
     * @private
     */
    NetworkRule.hasSpaces = function (pattern) {
        return pattern.indexOf(' ') > -1;
    };
    /**
     * Parses the options string and saves them.
     * More on the rule modifiers:
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers
     *
     * @param options - string with the rule modifiers
     *
     * @throws an error if there is an unsupported modifier
     */
    NetworkRule.prototype.loadOptions = function (options) {
        var optionParts;
        try {
            optionParts = parseOptionsString(options);
        }
        catch (e) {
            var errorMessage = getErrorMessage(e);
            throw new Error("Cannot parse ".concat(options, ": ").concat(errorMessage));
        }
        for (var i = 0; i < optionParts.length; i += 1) {
            var option = optionParts[i];
            var valueIndex = option.indexOf('=');
            var optionName = option;
            var optionValue = '';
            if (valueIndex > 0) {
                optionName = option.substring(0, valueIndex);
                optionValue = option.substring(valueIndex + 1);
            }
            this.loadOption(optionName, optionValue);
        }
        this.validateOptions();
    };
    /**
     * Returns true if rule contains (enabled or disabled) specified option.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option - rule option to check.
     */
    NetworkRule.prototype.hasOption = function (option) {
        return this.isOptionEnabled(option) || this.isOptionDisabled(option);
    };
    /**
     * Returns true if the specified option is enabled.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option - rule option to check.
     */
    NetworkRule.prototype.isOptionEnabled = function (option) {
        return (this.enabledOptions & option) === option;
    };
    /**
     * Returns true if one and only option is enabled
     *
     * @param option
     */
    NetworkRule.prototype.isSingleOptionEnabled = function (option) {
        return this.enabledOptions === option;
    };
    /**
     * Returns true if the specified option is disabled.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option - rule option to check.
     */
    NetworkRule.prototype.isOptionDisabled = function (option) {
        return (this.disabledOptions & option) === option;
    };
    /**
     * Checks if the rule has higher priority that the specified rule
     * allowlist + $important > $important > redirect > allowlist > basic rules
     */
    NetworkRule.prototype.isHigherPriority = function (r) {
        return this.priorityWeight > r.priorityWeight;
    };
    /**
     * Returns true if the rule is considered "generic"
     * "generic" means that the rule is not restricted to a limited set of domains
     * Please note that it might be forbidden on some domains, though.
     *
     * @return {boolean}
     */
    NetworkRule.prototype.isGeneric = function () {
        return !this.hasPermittedDomains();
    };
    /**
     * Returns true if this rule negates the specified rule
     * Only makes sense when this rule has a `badfilter` modifier
     */
    NetworkRule.prototype.negatesBadfilter = function (specifiedRule) {
        if (!this.isOptionEnabled(NetworkRuleOption.Badfilter)) {
            return false;
        }
        if (this.allowlist !== specifiedRule.allowlist) {
            return false;
        }
        if (this.pattern.pattern !== specifiedRule.pattern.pattern) {
            return false;
        }
        if (this.permittedRequestTypes !== specifiedRule.permittedRequestTypes) {
            return false;
        }
        if (this.restrictedRequestTypes !== specifiedRule.restrictedRequestTypes) {
            return false;
        }
        if ((this.enabledOptions ^ NetworkRuleOption.Badfilter) !== specifiedRule.enabledOptions) {
            return false;
        }
        if (this.disabledOptions !== specifiedRule.disabledOptions) {
            return false;
        }
        if (!stringArraysEquals(this.restrictedDomains, specifiedRule.restrictedDomains)) {
            return false;
        }
        if (!stringArraysHaveIntersection(this.permittedDomains, specifiedRule.permittedDomains)) {
            return false;
        }
        return true;
    };
    /**
     * Checks if this rule can be used for hosts-level blocking
     */
    NetworkRule.prototype.isHostLevelNetworkRule = function () {
        if (this.hasPermittedDomains() || this.hasRestrictedDomains()) {
            return false;
        }
        if (this.permittedRequestTypes !== 0 && this.restrictedRequestTypes !== 0) {
            return false;
        }
        if (this.disabledOptions !== NetworkRuleOption.NotSet) {
            return false;
        }
        if (this.enabledOptions !== NetworkRuleOption.NotSet) {
            return ((this.enabledOptions
                & NetworkRuleOption.OptionHostLevelRules)
                | (this.enabledOptions
                    ^ NetworkRuleOption.OptionHostLevelRules)) === NetworkRuleOption.OptionHostLevelRules;
        }
        return true;
    };
    /**
     * Enables or disables the specified option.
     *
     * @param option - option to enable or disable.
     * @param enabled - true to enable, false to disable.
     * @param skipRestrictions - skip options allowlist/blacklist restrictions
     *
     * @throws an error if the option we're trying to enable cannot be.
     * For instance, you cannot enable $elemhide for blacklist rules.
     */
    NetworkRule.prototype.setOptionEnabled = function (option, enabled, skipRestrictions) {
        if (skipRestrictions === void 0) { skipRestrictions = false; }
        if (!skipRestrictions) {
            if (!this.allowlist && (option & NetworkRuleOption.AllowlistOnly) === option) {
                throw new SyntaxError("Modifier ".concat(NetworkRuleOption[option], " cannot be used in blacklist rule"));
            }
        }
        if (enabled) {
            this.enabledOptions |= option;
        }
        else {
            this.disabledOptions |= option;
        }
    };
    /**
     * Permits or forbids the specified request type.
     * "Permits" means that the rule will match **only** the types that are permitted.
     * "Restricts" means that the rule will match **all but restricted**.
     *
     * @param requestType - request type.
     * @param permitted - true if it's permitted (whic)
     */
    NetworkRule.prototype.setRequestType = function (requestType, permitted) {
        if (permitted) {
            this.permittedRequestTypes |= requestType;
        }
        else {
            this.restrictedRequestTypes |= requestType;
        }
    };
    /**
     * Sets and validates exceptionally allowed domains presented in $denyallow modifier
     *
     * @param optionValue
     */
    NetworkRule.prototype.setDenyAllowDomains = function (optionValue) {
        var domainModifier = new DomainModifier(optionValue, PIPE_SEPARATOR);
        if (domainModifier.restrictedDomains && domainModifier.restrictedDomains.length > 0) {
            throw new SyntaxError('Invalid modifier: $denyallow domains cannot be negated');
        }
        if (domainModifier.permittedDomains
            && domainModifier.permittedDomains.some(function (x) { return x.includes(SimpleRegex.MASK_ANY_CHARACTER); })) {
            throw new SyntaxError('Invalid modifier: $denyallow domains wildcards are not supported');
        }
        this.denyAllowDomains = domainModifier.permittedDomains;
    };
    /**
     * Loads the specified modifier:
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers
     *
     * @param optionName - modifier name.
     * @param optionValue - modifier value.
     *
     * @throws an error if there is an unsupported modifier
     */
    NetworkRule.prototype.loadOption = function (optionName, optionValue) {
        var _this = this;
        var OPTIONS = NetworkRule.OPTIONS;
        if (optionName.startsWith(OPTIONS.NOOP)) {
            /**
             * A noop modifier does nothing and can be used to increase some rules readability.
             * It consists of the sequence of underscore characters (_) of any length
             * and can appear in a rule as many times as it's needed.
             */
            if (!optionName.split(OPTIONS.NOOP).some(function (s) { return !!s; })) {
                return;
            }
        }
        switch (optionName) {
            // General options
            // $third-party, $~first-party
            case OPTIONS.THIRD_PARTY:
            case NOT_MARK + OPTIONS.FIRST_PARTY:
                this.setOptionEnabled(NetworkRuleOption.ThirdParty, true);
                break;
            // $first-party, $~third-party
            case NOT_MARK + OPTIONS.THIRD_PARTY:
            case OPTIONS.FIRST_PARTY:
                this.setOptionEnabled(NetworkRuleOption.ThirdParty, false);
                break;
            // $match-case
            case OPTIONS.MATCH_CASE:
                this.setOptionEnabled(NetworkRuleOption.MatchCase, true);
                break;
            // $~match-case
            case NOT_MARK + OPTIONS.MATCH_CASE:
                this.setOptionEnabled(NetworkRuleOption.MatchCase, false);
                break;
            // $important
            case OPTIONS.IMPORTANT:
                this.setOptionEnabled(NetworkRuleOption.Important, true);
                break;
            // $domain
            case OPTIONS.DOMAIN:
                // eslint-disable-next-line no-case-declarations
                var domainModifier = new DomainModifier(optionValue, PIPE_SEPARATOR);
                this.permittedDomains = domainModifier.permittedDomains;
                this.restrictedDomains = domainModifier.restrictedDomains;
                break;
            // $denyallow
            case OPTIONS.DENYALLOW:
                this.setDenyAllowDomains(optionValue);
                break;
            // $method modifier
            case OPTIONS.METHOD: {
                this.setOptionEnabled(NetworkRuleOption.Method, true);
                this.methodModifier = new MethodModifier(optionValue);
                break;
            }
            // $to modifier
            case OPTIONS.TO: {
                this.setOptionEnabled(NetworkRuleOption.To, true);
                this.toModifier = new ToModifier(optionValue);
                break;
            }
            // Document-level allowlist rules
            // $elemhide
            case OPTIONS.ELEMHIDE:
                this.setOptionEnabled(NetworkRuleOption.Elemhide, true);
                this.setRequestType(RequestType.Document, true);
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $generichide
            case OPTIONS.GENERICHIDE:
                this.setOptionEnabled(NetworkRuleOption.Generichide, true);
                this.setRequestType(RequestType.Document, true);
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $specifichide
            case OPTIONS.SPECIFICHIDE:
                this.setOptionEnabled(NetworkRuleOption.Specifichide, true);
                this.setRequestType(RequestType.Document, true);
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $genericblock
            case OPTIONS.GENERICBLOCK:
                this.setOptionEnabled(NetworkRuleOption.Genericblock, true);
                this.setRequestType(RequestType.Document, true);
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $jsinject
            case OPTIONS.JSINJECT:
                this.setOptionEnabled(NetworkRuleOption.Jsinject, true);
                this.setRequestType(RequestType.Document, true);
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $urlblock
            case OPTIONS.URLBLOCK:
                this.setOptionEnabled(NetworkRuleOption.Urlblock, true);
                this.setRequestType(RequestType.Document, true);
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $content
            case OPTIONS.CONTENT:
                this.setOptionEnabled(NetworkRuleOption.Content, true);
                this.setRequestType(RequestType.Document, true);
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $document, $doc
            case OPTIONS.DOCUMENT:
            case OPTIONS.DOC:
                this.setRequestType(RequestType.Document, true);
                // In the case of allowlist rules $document implicitly includes
                // all these modifiers: `$content`, `$elemhide`, `$jsinject`,
                // `$urlblock`.
                if (this.isAllowlist()) {
                    this.setOptionEnabled(NetworkRuleOption.Elemhide, true, true);
                    this.setOptionEnabled(NetworkRuleOption.Jsinject, true, true);
                    this.setOptionEnabled(NetworkRuleOption.Urlblock, true, true);
                    this.setOptionEnabled(NetworkRuleOption.Content, true, true);
                }
                break;
            // $~document, $~doc
            case NOT_MARK + OPTIONS.DOCUMENT:
            case NOT_MARK + OPTIONS.DOC:
                this.setRequestType(RequestType.Document, false);
                break;
            // $stealh
            case OPTIONS.STEALTH:
                this.setOptionEnabled(NetworkRuleOption.Stealth, true);
                break;
            // $popup
            case OPTIONS.POPUP:
                this.setRequestType(RequestType.Document, true);
                this.setOptionEnabled(NetworkRuleOption.Popup, true);
                break;
            // Content type options
            // $script
            case OPTIONS.SCRIPT:
                this.setRequestType(RequestType.Script, true);
                break;
            // $~script
            case NOT_MARK + OPTIONS.SCRIPT:
                this.setRequestType(RequestType.Script, false);
                break;
            // $stylesheet
            case OPTIONS.STYLESHEET:
                this.setRequestType(RequestType.Stylesheet, true);
                break;
            // $~stylesheet
            case NOT_MARK + OPTIONS.STYLESHEET:
                this.setRequestType(RequestType.Stylesheet, false);
                break;
            // $subdocument
            case OPTIONS.SUBDOCUMENT:
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $~subdocument
            case NOT_MARK + OPTIONS.SUBDOCUMENT:
                this.setRequestType(RequestType.SubDocument, false);
                break;
            // $object
            case OPTIONS.OBJECT:
                this.setRequestType(RequestType.Object, true);
                break;
            // $~object
            case NOT_MARK + OPTIONS.OBJECT:
                this.setRequestType(RequestType.Object, false);
                break;
            // $image
            case OPTIONS.IMAGE:
                this.setRequestType(RequestType.Image, true);
                break;
            // $~image
            case NOT_MARK + OPTIONS.IMAGE:
                this.setRequestType(RequestType.Image, false);
                break;
            // $xmlhttprequest
            case OPTIONS.XMLHTTPREQUEST:
                this.setRequestType(RequestType.XmlHttpRequest, true);
                break;
            // $~xmlhttprequest
            case NOT_MARK + OPTIONS.XMLHTTPREQUEST:
                this.setRequestType(RequestType.XmlHttpRequest, false);
                break;
            // $media
            case OPTIONS.MEDIA:
                this.setRequestType(RequestType.Media, true);
                break;
            // $~media
            case NOT_MARK + OPTIONS.MEDIA:
                this.setRequestType(RequestType.Media, false);
                break;
            // $font
            case OPTIONS.FONT:
                this.setRequestType(RequestType.Font, true);
                break;
            // $~font
            case NOT_MARK + OPTIONS.FONT:
                this.setRequestType(RequestType.Font, false);
                break;
            // $websocket
            case OPTIONS.WEBSOCKET:
                this.setRequestType(RequestType.WebSocket, true);
                break;
            // $~websocket
            case NOT_MARK + OPTIONS.WEBSOCKET:
                this.setRequestType(RequestType.WebSocket, false);
                break;
            // $other
            case OPTIONS.OTHER:
                this.setRequestType(RequestType.Other, true);
                break;
            // $~other
            case NOT_MARK + OPTIONS.OTHER:
                this.setRequestType(RequestType.Other, false);
                break;
            // $ping
            case OPTIONS.PING:
                this.setRequestType(RequestType.Ping, true);
                break;
            // $~ping
            case NOT_MARK + OPTIONS.PING:
                this.setRequestType(RequestType.Ping, false);
                break;
            // Special modifiers
            // $badfilter
            case OPTIONS.BADFILTER:
                this.setOptionEnabled(NetworkRuleOption.Badfilter, true);
                break;
            // $csp
            case OPTIONS.CSP:
                this.setOptionEnabled(NetworkRuleOption.Csp, true);
                this.advancedModifier = new CspModifier(optionValue, this.isAllowlist());
                break;
            // $replace
            case OPTIONS.REPLACE:
                this.setOptionEnabled(NetworkRuleOption.Replace, true);
                this.advancedModifier = new ReplaceModifier(optionValue);
                break;
            // $cookie
            case OPTIONS.COOKIE:
                this.setOptionEnabled(NetworkRuleOption.Cookie, true);
                this.advancedModifier = new CookieModifier(optionValue);
                break;
            // $redirect
            case OPTIONS.REDIRECT:
                this.setOptionEnabled(NetworkRuleOption.Redirect, true);
                this.advancedModifier = new RedirectModifier(optionValue, this.ruleText, this.isAllowlist());
                break;
            // $redirect-rule
            case OPTIONS.REDIRECTRULE:
                this.setOptionEnabled(NetworkRuleOption.Redirect, true);
                this.advancedModifier = new RedirectModifier(optionValue, this.ruleText, this.isAllowlist(), true);
                break;
            // $removeparam
            case OPTIONS.REMOVEPARAM:
                this.setOptionEnabled(NetworkRuleOption.RemoveParam, true);
                this.advancedModifier = new RemoveParamModifier(optionValue);
                break;
            // $removeheader
            case OPTIONS.REMOVEHEADER:
                this.setOptionEnabled(NetworkRuleOption.RemoveHeader, true);
                this.advancedModifier = new RemoveHeaderModifier(optionValue, this.isAllowlist());
                break;
            // $permissions
            case OPTIONS.PERMISSIONS:
                // simple validation of permissions rules for compiler.
                // should be fully supported in tsurlfilter v2.3 and the browser extension v4.4. AG-17467
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension does not support $permissions modifier yet');
                }
                this.setOptionEnabled(NetworkRuleOption.Permissions, true);
                break;
            // $jsonprune
            // simple validation of jsonprune rules for compiler
            // https://github.com/AdguardTeam/FiltersCompiler/issues/168
            case OPTIONS.JSONPRUNE:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension does not support $jsonprune modifier yet');
                }
                this.setOptionEnabled(NetworkRuleOption.JsonPrune, true);
                // TODO: should be properly implemented later
                // https://github.com/AdguardTeam/tsurlfilter/issues/71
                break;
            // $hls
            // simple validation of hls rules for compiler
            // https://github.com/AdguardTeam/FiltersCompiler/issues/169
            case OPTIONS.HLS:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension does not support $hls modifier yet');
                }
                this.setOptionEnabled(NetworkRuleOption.Hls, true);
                // TODO: should be properly implemented later
                // https://github.com/AdguardTeam/tsurlfilter/issues/72
                break;
            // $referrerpolicy
            // simple validation of referrerpolicy rules for compiler
            // https://github.com/AdguardTeam/FiltersCompiler/issues/191
            case OPTIONS.REFERRERPOLICY:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension does not support $referrerpolicy modifier');
                }
                // do nothing as $referrerpolicy is supported by CoreLibs-based apps only.
                // it is needed for proper rule conversion performed by FiltersCompiler
                // so rules with $referrerpolicy modifier is not marked as invalid
                break;
            // Dns modifiers
            // $client
            case OPTIONS.CLIENT:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $client modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Client, true);
                this.advancedModifier = new ClientModifier(optionValue);
                break;
            // $dnsrewrite
            case OPTIONS.DNSREWRITE:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $dnsrewrite modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.DnsRewrite, true);
                this.advancedModifier = new DnsRewriteModifier(optionValue);
                break;
            // $dnstype
            case OPTIONS.DNSTYPE:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $dnstype modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.DnsType, true);
                this.advancedModifier = new DnsTypeModifier(optionValue);
                break;
            // $ctag
            case OPTIONS.CTAG:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $ctag modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Ctag, true);
                this.advancedModifier = new CtagModifier(optionValue);
                break;
            // $app
            case OPTIONS.APP:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $app modifier');
                }
                this.appModifier = new AppModifier(optionValue);
                break;
            // $network
            case OPTIONS.NETWORK:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $network modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Network, true);
                break;
            // $extension
            case OPTIONS.EXTENSION:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $extension modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Extension, true);
                break;
            // $~extension
            case NOT_MARK + OPTIONS.EXTENSION:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $extension modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Extension, false);
                break;
            // $all
            case OPTIONS.ALL:
                if (this.isAllowlist()) {
                    throw new SyntaxError('Rule with $all modifier can not be allowlist rule');
                }
                // Set all request types
                Object.values(RequestType).forEach(function (type) {
                    _this.setRequestType(type, true);
                });
                this.setOptionEnabled(NetworkRuleOption.Popup, true);
                break;
            // $empty and $mp4
            // Deprecated in favor of $redirect
            case OPTIONS.EMPTY:
            case OPTIONS.MP4:
                // Do nothing.
                break;
            default: {
                // clear empty values
                var modifierView = [optionName, optionValue]
                    .filter(function (i) { return i; })
                    .join('=');
                throw new SyntaxError("Unknown modifier: ".concat(modifierView));
            }
        }
    };
    /**
     * To calculate priority, we've categorized modifiers into different groups.
     * These groups are ranked based on their priority, from lowest to highest.
     * A modifier that significantly narrows the scope of a rule adds more
     * weight to its total priority. Conversely, if a rule applies to a broader
     * range of requests, its priority decreases.
     *
     * It's worth noting that there are cases where a single-parameter modifier
     * has a higher priority than multi-parameter ones. For instance, in
     * the case of `$domain=example.com|example.org`, a rule that includes two
     * domains has a slightly broader effective area than a rule with one
     * specified domain, therefore its priority is lower.
     *
     * The base priority weight of any rule is 1. If the calculated priority
     * is a floating-point number, it will be **rounded up** to the smallest
     * integer greater than or equal to the calculated weight.
     *
     * @see {@link NetworkRule.PermittedRequestTypeWeight}
     * @see {@link NetworkRule.PermittedDomainWeight}
     * @see {@link NetworkRule.SpecificExceptionsWeight}
     * @see {@link NetworkRule.AllowlistRuleWeight}
     * @see {@link NetworkRule.RedirectRuleWeight}
     * @see {@link NetworkRule.ImportantRuleWeight}
     *
     * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-counting}
     */
    NetworkRule.prototype.calculatePriorityWeight = function () {
        var _a, _b;
        // Base modifiers, category 1.
        this.priorityWeight += countEnabledBits(this.enabledOptions, NetworkRule.CATEGORY_1_OPTIONS_MASK);
        this.priorityWeight += countEnabledBits(this.disabledOptions, NetworkRule.CATEGORY_1_OPTIONS_MASK);
        /**
         * When dealing with a negated domain, app, method, or content-type,
         * we add a point for the existence of the modifier itself, regardless
         * of the quantity of negated domains or content-types. This is because
         * the rule's scope is already infinitely broad. Put simply,
         * by prohibiting multiple domains, content-types, methods or apps,
         * the scope of the rule becomes only minimally smaller.
         */
        if (this.denyAllowDomains && this.denyAllowDomains.length > 0) {
            this.priorityWeight += 1;
        }
        if (this.restrictedDomains && this.restrictedDomains.length > 0) {
            this.priorityWeight += 1;
        }
        if (((_a = this.methodModifier) === null || _a === void 0 ? void 0 : _a.restrictedValues) && this.methodModifier.restrictedValues.length > 0) {
            this.priorityWeight += 1;
        }
        if (this.restrictedRequestTypes !== RequestType.NotSet) {
            this.priorityWeight += 1;
        }
        // $to modifier is basically a replacement for a regular expression
        // See https://github.com/AdguardTeam/KnowledgeBase/pull/196#discussion_r1221401215
        if (this.toModifier) {
            this.priorityWeight += 1;
        }
        /**
         * Category 2: permitted request types and methods.
         * Specified content-types add `50 + 50 / number_of_content_types`,
         * for example: `||example.com^$image,script` will add
         * `50 + 50 / 2 = 50 + 25 = 75` to the total weight of the rule.
         * The `$popup` also belongs to this category, because it implicitly
         * adds the modifier `$document`.
         * Similarly, specific exceptions add `$document,subdocument`.
         */
        if (this.permittedRequestTypes !== RequestType.NotSet) {
            var numberOfPermittedRequestTypes = getBitCount(this.permittedRequestTypes);
            // More permitted request types mean less priority weight.
            var relativeWeight = NetworkRule.CategoryTwoWeight / numberOfPermittedRequestTypes;
            this.priorityWeight += NetworkRule.CategoryTwoWeight + relativeWeight;
        }
        if (((_b = this.methodModifier) === null || _b === void 0 ? void 0 : _b.permittedValues) && this.methodModifier.permittedValues.length > 0) {
            // More permitted request methods mean less priority weight.
            var relativeWeight = NetworkRule.CategoryTwoWeight / this.methodModifier.permittedValues.length;
            this.priorityWeight += NetworkRule.CategoryTwoWeight + relativeWeight;
        }
        /**
         * Category 3: permitted domains.
         * Specified domains through `$domain` and specified applications
         * through `$app` add `100 + 100 / number_domains (or number_applications)`,
         * for example:
         * `||example.com^$domain=example.com|example.org|example.net`
         * will add `100 + 100 / 3 = 134.3 = 134` or
         * `||example.com^$app=org.example.app1|org.example.app2`
         * will add `100 + 100 / 2 = 151`.
         */
        if (this.permittedDomains && this.permittedDomains.length > 0) {
            // More permitted domains mean less priority weight.
            var relativeWeight = NetworkRule.CategoryThreeWeight / this.permittedDomains.length;
            this.priorityWeight += NetworkRule.CategoryThreeWeight + relativeWeight;
        }
        // Category 4: redirect rules.
        if (this.isOptionEnabled(NetworkRuleOption.Redirect)) {
            this.priorityWeight += NetworkRule.CategoryFourWeight;
        }
        // Category 5: specific exceptions.
        this.priorityWeight += NetworkRule.CategoryFiveWeight * countEnabledBits(this.enabledOptions, NetworkRule.SPECIFIC_EXCLUSIONS_MASK);
        // Category 6: allowlist rules.
        if (this.isAllowlist()) {
            this.priorityWeight += NetworkRule.CategorySixWeight;
        }
        // Category 7: important rules.
        if (this.isOptionEnabled(NetworkRuleOption.Important)) {
            this.priorityWeight += NetworkRule.CategorySevenWeight;
        }
        // Round up to avoid overlap between different categories of rules.
        this.priorityWeight = Math.ceil(this.priorityWeight);
    };
    /**
     * Validates rule options
     */
    NetworkRule.prototype.validateOptions = function () {
        if (this.advancedModifier instanceof RemoveParamModifier) {
            this.validateRemoveParamRule();
        }
        else if (this.advancedModifier instanceof RemoveHeaderModifier) {
            this.validateRemoveHeaderRule();
        }
        else if (this.toModifier !== null) {
            this.validateToRule();
        }
        else if (this.denyAllowDomains !== null) {
            this.validateDenyallowRule();
        }
    };
    /**
     * $removeparam rules are not compatible with any other modifiers except $domain,
     * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
     * The rules with any other modifiers are considered invalid and will be discarded.
     */
    NetworkRule.prototype.validateRemoveParamRule = function () {
        if ((this.enabledOptions | NetworkRuleOption.RemoveParamCompatibleOptions)
            !== NetworkRuleOption.RemoveParamCompatibleOptions) {
            throw new SyntaxError('$removeparam rules are not compatible with some other modifiers');
        }
    };
    /**
     * $removeheader rules are not compatible with any other modifiers except $domain,
     * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
     * The rules with any other modifiers are considered invalid and will be discarded.
     */
    NetworkRule.prototype.validateRemoveHeaderRule = function () {
        if ((this.enabledOptions | NetworkRuleOption.RemoveHeaderCompatibleOptions)
            !== NetworkRuleOption.RemoveHeaderCompatibleOptions) {
            throw new SyntaxError('$removeheader rules are not compatible with some other modifiers');
        }
    };
    /**
     * $to rules are not compatible $denyallow - these rules considered invalid
     * and will be discarded.
     */
    NetworkRule.prototype.validateToRule = function () {
        if (this.denyAllowDomains) {
            throw new SyntaxError('modifier $to is not compatible with $denyallow modifier');
        }
    };
    /**
     * $denyallow rules are not compatible $to - these rules considered invalid
     * and will be discarded.
     */
    NetworkRule.prototype.validateDenyallowRule = function () {
        if (this.toModifier) {
            throw new SyntaxError('modifier $to is not compatible with $denyallow modifier');
        }
    };
    /**
     * parseRuleText splits the rule text into multiple parts.
     * @param ruleText - original rule text
     * @returns basic rule parts
     *
     * @throws error if the rule is empty (for instance, empty string or `@@`)
     */
    NetworkRule.parseRuleText = function (ruleText) {
        var ruleParts = new BasicRuleParts();
        ruleParts.allowlist = false;
        var startIndex = 0;
        if (ruleText.startsWith(NetworkRule.MASK_ALLOWLIST)) {
            ruleParts.allowlist = true;
            startIndex = NetworkRule.MASK_ALLOWLIST.length;
        }
        if (ruleText.length <= startIndex) {
            throw new SyntaxError('Rule is too short');
        }
        // Setting pattern to rule text (for the case of empty options)
        ruleParts.pattern = ruleText.substring(startIndex);
        // Avoid parsing options inside of a regex rule
        if (ruleParts.pattern.startsWith(SimpleRegex.MASK_REGEX_RULE)
            && ruleParts.pattern.endsWith(SimpleRegex.MASK_REGEX_RULE)
            && !ruleParts.pattern.includes("".concat(NetworkRule.OPTIONS.REPLACE, "="))) {
            return ruleParts;
        }
        var removeParamIndex = ruleText.lastIndexOf("".concat(NetworkRule.OPTIONS.REMOVEPARAM, "="));
        var endIndex = removeParamIndex >= 0 ? removeParamIndex : ruleText.length - 2;
        var foundEscaped = false;
        for (var i = endIndex; i >= startIndex; i -= 1) {
            var c = ruleText.charAt(i);
            if (c === NetworkRule.OPTIONS_DELIMITER) {
                if (i > startIndex && ruleText.charAt(i - 1) === NetworkRule.ESCAPE_CHARACTER) {
                    foundEscaped = true;
                }
                else {
                    ruleParts.pattern = ruleText.substring(startIndex, i);
                    ruleParts.options = ruleText.substring(i + 1);
                    if (foundEscaped) {
                        // Find and replace escaped options delimiter
                        ruleParts.options = ruleParts.options.replace(NetworkRule.RE_ESCAPED_OPTIONS_DELIMITER, NetworkRule.OPTIONS_DELIMITER);
                        // Reset the regexp state
                        NetworkRule.RE_ESCAPED_OPTIONS_DELIMITER.lastIndex = 0;
                    }
                    // Options delimiter was found, exiting loop
                    break;
                }
            }
        }
        return ruleParts;
    };
    /**
     * Rules with base modifiers, from category 1, each of them adds 1
     * to the weight of the rule.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-1
     */
    NetworkRule.CATEGORY_1_OPTIONS_MASK = NetworkRuleOption.ThirdParty
        | NetworkRuleOption.MatchCase
        | NetworkRuleOption.DnsRewrite;
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with permitted request types and methods.
     * The value 50 is chosen in order to cover (with a margin) all possible
     * combinations and variations of rules from categories with a lower
     * priority (each of them adds 1 to the rule priority).
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-2
     */
    NetworkRule.CategoryTwoWeight = 50;
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with allowed domains.
     * The value 100 is chosen to cover all possible combinations and variations
     * of rules from categories with a lower priority, for example a rule with
     * one allowed query type will get priority 100 (50 + 50/1), but for allowed
     * domains with any number of domains we will get at least 101 (for 100
     * domains: 100 + 100/100; for 200 100 + 100/200; or even for 10000:
     * 100 + 100/10000) because the resulting weight is rounded up.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-3
     */
    NetworkRule.CategoryThreeWeight = 100;
    /**
     * The priority weight used in {@link calculatePriorityWeight}
     * for $redirect rules.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-6
     */
    NetworkRule.CategoryFourWeight = Math.pow(10, 3);
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with specific exceptions.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-4
     */
    NetworkRule.CategoryFiveWeight = Math.pow(10, 4);
    /**
     * Rules with specific exclusions, from category 4, each of them adds
     * {@link SpecificExceptionsWeight} to the weight of the rule.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-4
     */
    NetworkRule.SPECIFIC_EXCLUSIONS_MASK = NetworkRuleOption.Elemhide
        | NetworkRuleOption.Generichide
        | NetworkRuleOption.Specifichide
        | NetworkRuleOption.Content
        | NetworkRuleOption.Urlblock
        | NetworkRuleOption.Genericblock
        | NetworkRuleOption.Jsinject
        | NetworkRuleOption.Extension;
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with allowlist mark '@@'.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-5
     */
    NetworkRule.CategorySixWeight = Math.pow(10, 5);
    /**
     * The priority weight used in {@link calculatePriorityWeight}
     * for $important rules.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-7
     */
    NetworkRule.CategorySevenWeight = Math.pow(10, 6);
    /**
     * Separates the rule pattern from the list of modifiers.
     *
     * ```
     * rule = ["@@"] pattern [ "$" modifiers ]
     * modifiers = [modifier0, modifier1[, ...[, modifierN]]]
     * ```
     */
    NetworkRule.OPTIONS_DELIMITER = OPTIONS_DELIMITER;
    /**
     * This character is used to escape special characters in modifiers values
     */
    NetworkRule.ESCAPE_CHARACTER = ESCAPE_CHARACTER;
    // eslint-disable-next-line max-len
    NetworkRule.RE_ESCAPED_OPTIONS_DELIMITER = new RegExp("".concat(NetworkRule.ESCAPE_CHARACTER).concat(NetworkRule.OPTIONS_DELIMITER), 'g');
    /**
     * A marker that is used in rules of exception.
     * To turn off filtering for a request, start your rule with this marker.
     */
    NetworkRule.MASK_ALLOWLIST = MASK_ALLOWLIST;
    /**
     * Mark that negates options
     */
    NetworkRule.NOT_MARK = NOT_MARK;
    /**
     * Rule options
     */
    NetworkRule.OPTIONS = NETWORK_RULE_OPTIONS;
    return NetworkRule;
}());

/**
 * Implements a host rule.
 *
 * HostRule is a structure for simple host-level rules (i.e. /etc/hosts syntax).
 * http://man7.org/linux/man-pages/man5/hosts.5.html
 * It also supports "just domain" syntax. In this case, the IP will be set to 0.0.0.0.
 *
 * Rules syntax looks like this:
 * ```
 * IP_address canonical_hostname [aliases...]
 * ```
 *
 * Examples:
 * * `192.168.1.13 bar.mydomain.org bar` -- ipv4
 * * `ff02::1 ip6-allnodes` -- ipv6
 * * `::1 localhost ip6-localhost ip6-loopback` -- ipv6 aliases
 * * `example.org` -- "just domain" syntax
 */
var HostRule = /** @class */ (function () {
    /**
     * Constructor
     *
     * Parses the rule and creates a new HostRule instance
     *
     * @param ruleText - original rule text.
     * @param filterListId - ID of the filter list this rule belongs to.
     *
     * @throws error if it fails to parse the rule.
     */
    function HostRule(ruleText, filterListId) {
        this.hostnames = [];
        this.ip = '';
        this.invalid = false;
        this.ruleText = ruleText;
        this.filterListId = filterListId;
        var commentIndex = ruleText.indexOf('#');
        var stripped = commentIndex >= 0 ? ruleText.substring(0, commentIndex) : ruleText;
        var parts = stripped.trim().split(' ');
        if (parts.length >= 2) {
            if (!isIp(parts[0])) {
                this.invalid = true;
                return;
            }
            // eslint-disable-next-line prefer-destructuring
            this.ip = parts[0];
            this.hostnames = parts.slice(1).filter(function (x) { return !!x; });
        }
        else if (parts.length === 1 && isDomainName(parts[0])) {
            this.hostnames = [parts[0]];
            this.ip = '0.0.0.0';
        }
        else {
            this.invalid = true;
        }
    }
    /**
     * Match returns true if this rule can be used on the specified hostname.
     *
     * @param hostname - hostname to check
     */
    HostRule.prototype.match = function (hostname) {
        return this.hostnames.includes(hostname);
    };
    /**
     * Returns list id
     */
    HostRule.prototype.getFilterListId = function () {
        return this.filterListId;
    };
    /**
     * Return rule text
     */
    HostRule.prototype.getText = function () {
        return this.ruleText;
    };
    /**
     * Returns ip address
     */
    HostRule.prototype.getIp = function () {
        return this.ip;
    };
    /**
     * Returns hostnames
     */
    HostRule.prototype.getHostnames = function () {
        return this.hostnames;
    };
    /**
     * Is invalid rule
     */
    HostRule.prototype.isInvalid = function () {
        return this.invalid;
    };
    return HostRule;
}());

/**
 * MatchingResult contains all the rules matching a web request, and provides methods
 * that define how a web request should be processed
 */
var MatchingResult = /** @class */ (function () {
    /**
     * Creates an instance of the MatchingResult struct and fills it with the rules.
     *
     * @param rules A list of network rules that match the request.
     * @param sourceRule A rule that matches the document that is a source
     * of the request, i.e. document-level exclusions.
     */
    function MatchingResult(rules, sourceRule) {
        var _a;
        this.basicRule = null;
        this.documentRule = null;
        this.cspRules = null;
        this.cookieRules = null;
        this.replaceRules = null;
        this.removeParamRules = null;
        this.removeHeaderRules = null;
        this.redirectRules = null;
        this.stealthRule = null;
        // eslint-disable-next-line no-param-reassign
        rules = MatchingResult.removeBadfilterRules(rules);
        if (sourceRule) {
            this.documentRule = sourceRule;
        }
        // Second - check if blocking rules (generic or all of them) are allowed
        // generic blocking rules are allowed by default
        var genericAllowed = true;
        // basic blocking rules are allowed by default
        var basicAllowed = true;
        if (this.documentRule) {
            var documentRule = this.documentRule;
            if (documentRule.isOptionEnabled(NetworkRuleOption.Urlblock)) {
                basicAllowed = false;
            }
            else if (documentRule.isOptionEnabled(NetworkRuleOption.Genericblock)) {
                genericAllowed = false;
            }
        }
        // Iterate through the list of rules and fill the MatchingResult
        for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {
            var rule = rules_1[_i];
            if (rule.isOptionEnabled(NetworkRuleOption.Cookie)) {
                if (!this.cookieRules) {
                    this.cookieRules = [];
                }
                this.cookieRules.push(rule);
                continue;
            }
            if (rule.isOptionEnabled(NetworkRuleOption.Replace)) {
                if (!this.replaceRules) {
                    this.replaceRules = [];
                }
                this.replaceRules.push(rule);
                continue;
            }
            if (rule.isOptionEnabled(NetworkRuleOption.RemoveParam)) {
                if (!this.removeParamRules) {
                    this.removeParamRules = [];
                }
                this.removeParamRules.push(rule);
                continue;
            }
            if (rule.isOptionEnabled(NetworkRuleOption.RemoveHeader)) {
                if (!this.removeHeaderRules) {
                    this.removeHeaderRules = [];
                }
                this.removeHeaderRules.push(rule);
                continue;
            }
            if (rule.isOptionEnabled(NetworkRuleOption.Redirect)) {
                if (!this.redirectRules) {
                    this.redirectRules = [];
                }
                this.redirectRules.push(rule);
                continue;
            }
            if (rule.isOptionEnabled(NetworkRuleOption.Csp)) {
                if (!this.cspRules) {
                    this.cspRules = [];
                }
                this.cspRules.push(rule);
                continue;
            }
            if (rule.isOptionEnabled(NetworkRuleOption.Stealth)) {
                this.stealthRule = rule;
                continue;
            }
            // Check blocking rules against $genericblock / $urlblock
            if (!rule.isAllowlist() && ((_a = this.documentRule) === null || _a === void 0 ? void 0 : _a.isHigherPriority(rule))) {
                if (!basicAllowed) {
                    continue;
                }
                if (!genericAllowed && rule.isGeneric()) {
                    continue;
                }
            }
            if (!this.basicRule || rule.isHigherPriority(this.basicRule)) {
                this.basicRule = rule;
            }
        }
    }
    /**
     * GetBasicResult returns a rule that should be applied to the web request.
     * Possible outcomes are:
     * returns nil -- allow the request.
     * returns an allowlist rule -- allow the request.
     * returns a blocking rule -- block the request.
     * returns a redirect rule -- redirect the request.
     *
     * @return {NetworkRule | null} basic result rule
     */
    MatchingResult.prototype.getBasicResult = function () {
        var basic = this.basicRule;
        if (!basic) {
            // Only document-level frame rule would be returned as a basic result,
            // cause only those rules could block or modify page subrequests.
            // Other frame rules (generichide, elemhide etc) will be used in getCosmeticOption function.
            if (this.documentRule && this.documentRule.isDocumentLevelAllowlistRule()) {
                basic = this.documentRule;
            }
        }
        // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#replace-modifier
        // https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-extra
        // $replace rules have a higher priority than other basic rules (including exception rules).
        // So if a request corresponds to two different rules one of which has the $replace modifier,
        // this rule will be applied.
        if (this.replaceRules) {
            var isReplaceOrContent = (basic === null || basic === void 0 ? void 0 : basic.isOptionEnabled(NetworkRuleOption.Replace))
                || (basic === null || basic === void 0 ? void 0 : basic.isOptionEnabled(NetworkRuleOption.Content));
            // If basic rule is an exception with $replace or $content modifier,
            // then basic rule will disable $replace rules.
            if ((basic === null || basic === void 0 ? void 0 : basic.isAllowlist()) && isReplaceOrContent) {
                return basic;
            }
            // Otherwise null is returned to allow the request, because we need
            // to get response first to then apply the $replace rules to
            // the response.
            return null;
        }
        // Redirect rules have a high priority
        // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#redirect-modifier
        // https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-6
        var redirectRule = this.getRedirectRule();
        if (redirectRule && (!basic || !basic.isHigherPriority(redirectRule))) {
            return redirectRule;
        }
        return basic;
    };
    /**
     * Returns a bit-flag with the list of cosmetic options
     *
     * @return {CosmeticOption} mask
     */
    MatchingResult.prototype.getCosmeticOption = function () {
        var _a = this, basicRule = _a.basicRule, documentRule = _a.documentRule;
        var rule = basicRule;
        // We choose a non-empty rule and the one of the two with the higher
        // priority in order to accurately calculate cosmetic options.
        if ((!rule && documentRule) || (rule && (documentRule === null || documentRule === void 0 ? void 0 : documentRule.isHigherPriority(rule)))) {
            rule = documentRule;
        }
        if (!rule || !rule.isAllowlist()) {
            return CosmeticOption.CosmeticOptionAll;
        }
        var option = CosmeticOption.CosmeticOptionAll;
        if (rule.isOptionEnabled(NetworkRuleOption.Elemhide)) {
            option ^= CosmeticOption.CosmeticOptionGenericCSS;
            option ^= CosmeticOption.CosmeticOptionSpecificCSS;
        }
        if (rule.isOptionEnabled(NetworkRuleOption.Generichide)) {
            option ^= CosmeticOption.CosmeticOptionGenericCSS;
        }
        if (rule.isOptionEnabled(NetworkRuleOption.Specifichide)) {
            option ^= CosmeticOption.CosmeticOptionSpecificCSS;
        }
        if (rule.isOptionEnabled(NetworkRuleOption.Jsinject)) {
            option ^= CosmeticOption.CosmeticOptionJS;
        }
        if (rule.isOptionEnabled(NetworkRuleOption.Content)) {
            option ^= CosmeticOption.CosmeticOptionHtml;
        }
        return option;
    };
    /**
     * Return an array of replace rules
     */
    MatchingResult.prototype.getReplaceRules = function () {
        if (!this.replaceRules) {
            return [];
        }
        // TODO: Look up for allowlist $content rule
        return MatchingResult.filterAdvancedModifierRules(this.replaceRules, function (rule) { return (function (x) { return x.getAdvancedModifierValue() === rule.getAdvancedModifierValue(); }); });
    };
    /**
     * Filters array of rules according to allowlist rules contained.
     * Empty advanced modifier allowlists everything.
     *
     * @param rules
     * @param allowlistPredicate allowlist criteria
     * This function result will be called for testing if rule `x` allowlists rule `r`
     */
    MatchingResult.filterAdvancedModifierRules = function (rules, allowlistPredicate) {
        var _this = this;
        var blockingRules = [];
        var allowlistRules = [];
        for (var _i = 0, rules_2 = rules; _i < rules_2.length; _i++) {
            var rule = rules_2[_i];
            if (rule.isAllowlist()) {
                allowlistRules.push(rule);
            }
            else {
                blockingRules.push(rule);
            }
        }
        if (blockingRules.length === 0) {
            return [];
        }
        if (allowlistRules.length === 0) {
            return blockingRules;
        }
        if (allowlistRules.length > 0) {
            var allowlistRuleWithEmptyOption_1 = allowlistRules
                .find(function (allowlistRule) { return allowlistRule.getAdvancedModifierValue() === ''; });
            var result_1 = [];
            blockingRules.forEach(function (blockRule) {
                if (allowlistRuleWithEmptyOption_1
                    && !blockRule.isHigherPriority(allowlistRuleWithEmptyOption_1)) {
                    result_1.push(allowlistRuleWithEmptyOption_1);
                    return;
                }
                var allowlistingRule = allowlistRules.find(function (a) {
                    return !blockRule.isHigherPriority(a) && allowlistPredicate.call(_this, blockRule)(a);
                });
                if (allowlistingRule) {
                    result_1.push(allowlistingRule);
                }
                else {
                    result_1.push(blockRule);
                }
            });
            return result_1.filter(function (item, pos) { return result_1.indexOf(item) === pos; });
        }
        return blockingRules;
    };
    /**
     * Returns an array of csp rules
     */
    MatchingResult.prototype.getCspRules = function () {
        if (!this.cspRules) {
            return [];
        }
        var blockingRules = [];
        var allowlistedRulesByDirective = new Map();
        for (var _i = 0, _a = this.cspRules; _i < _a.length; _i++) {
            var rule = _a[_i];
            if (rule.isAllowlist()) {
                if (!rule.getAdvancedModifierValue()) { // Global allowlist rule
                    return [rule];
                }
                MatchingResult.putWithPriority(rule, undefined, allowlistedRulesByDirective);
            }
            else {
                blockingRules.push(rule);
            }
        }
        var rulesByDirective = new Map();
        // Collect allowlist and blocking CSP rules in one array
        blockingRules.forEach(function (rule) {
            if (rule.getAdvancedModifierValue()) {
                var allowlistRule = allowlistedRulesByDirective.get(rule.getAdvancedModifierValue());
                MatchingResult.putWithPriority(rule, allowlistRule, rulesByDirective);
            }
        });
        return Array.from(rulesByDirective.values());
    };
    /**
     * Returns a redirect rule or null if redirect rules are empty.
     * $redirect-rule is only returned if there's a blocking rule also matching
     * this request.
     */
    MatchingResult.prototype.getRedirectRule = function () {
        if (!this.redirectRules) {
            return null;
        }
        // Apply allowlist $redirect rules.
        var result = MatchingResult.filterAdvancedModifierRules(this.redirectRules, function (rule) { return (function (x) { return x.getAdvancedModifierValue() === rule.getAdvancedModifierValue(); }); });
        // Filters only not allowlist rules.
        result = result.filter(function (r) { return !r.isAllowlist(); });
        // Splits $redirect and $redirect-rule into separate arrays.
        var conditionalRedirectRules = [];
        var allWeatherRedirectRules = [];
        result.forEach(function (rule) {
            var redirectModifier = rule.getAdvancedModifier();
            if (redirectModifier.isRedirectingOnlyBlocked) {
                conditionalRedirectRules.push(rule);
            }
            else {
                allWeatherRedirectRules.push(rule);
            }
        });
        if (allWeatherRedirectRules.length > 0) {
            return allWeatherRedirectRules
                .sort(function (a, b) { return (b.isHigherPriority(a) ? 1 : -1); })[0];
        }
        if (conditionalRedirectRules.length > 0 && this.basicRule && !this.basicRule.isAllowlist()) {
            return conditionalRedirectRules
                .sort(function (a, b) { return (b.isHigherPriority(a) ? 1 : -1); })[0];
        }
        return null;
    };
    /**
     * Returns an array of cookie rules
     */
    MatchingResult.prototype.getCookieRules = function () {
        if (!this.cookieRules) {
            return [];
        }
        var basic = this.getBasicResult();
        if ((basic === null || basic === void 0 ? void 0 : basic.isAllowlist()) && basic.isOptionEnabled(NetworkRuleOption.Urlblock)) {
            return [];
        }
        var allowlistPredicate = function (rule) { return (function (allowlistRule) {
            var allowlistRuleCookieModifier = allowlistRule.getAdvancedModifier();
            var ruleCookieModifier = rule.getAdvancedModifier();
            if (allowlistRule.getAdvancedModifierValue() === rule.getAdvancedModifierValue()) {
                return true;
            }
            // Matches by cookie name
            if (allowlistRuleCookieModifier.matches(ruleCookieModifier.getCookieName())) {
                return true;
            }
            return false;
        }); };
        var filtered = MatchingResult.filterAdvancedModifierRules(this.cookieRules, allowlistPredicate);
        return filtered.concat(__spreadArray([], this.cookieRules.filter(function (r) { return r.isAllowlist(); }), true));
    };
    /**
     * Returns an array of removeparam rules
     */
    MatchingResult.prototype.getRemoveParamRules = function () {
        if (!this.removeParamRules) {
            return [];
        }
        return MatchingResult.filterAdvancedModifierRules(this.removeParamRules, 
        // eslint-disable-next-line arrow-body-style
        function (rule) { return (function (x) {
            return x.isHigherPriority(rule) && x.getAdvancedModifierValue() === rule.getAdvancedModifierValue();
        }); });
    };
    /**
     * Returns an array of removeheader rules
     */
    MatchingResult.prototype.getRemoveHeaderRules = function () {
        if (!this.removeHeaderRules) {
            return [];
        }
        if (this.basicRule
            && this.basicRule.isAllowlist()
            && this.basicRule.isOptionEnabled(NetworkRuleOption.Urlblock)) {
            return [];
        }
        return MatchingResult.filterAdvancedModifierRules(this.removeHeaderRules, function (rule) { return (function (x) { return x.getAdvancedModifierValue() === rule.getAdvancedModifierValue(); }); });
    };
    /**
     * Decides which rule should be put into the given map.
     * Compares priorities of the two given rules with the equal CSP directive and the rule that may already in the map.
     *
     * @param rule CSP rule (not null)
     * @param allowlistRule CSP allowlist rule (may be null)
     * @param map Rules mapped by csp directive
     */
    // eslint-disable-next-line max-len
    MatchingResult.putWithPriority = function (rule, allowlistRule, map) {
        var cspDirective = rule.getAdvancedModifierValue();
        var currentRule = cspDirective ? map.get(cspDirective) : null;
        var newRule = rule;
        if (currentRule && !rule.isHigherPriority(currentRule)) {
            newRule = currentRule;
        }
        if (allowlistRule && allowlistRule.isHigherPriority(newRule)) {
            newRule = allowlistRule;
        }
        map.set(cspDirective, newRule);
    };
    /**
     * Looks if there are any matching $badfilter rules and removes
     * matching bad filters from the array (see the $badfilter description for more info)
     *
     * @param rules to filter
     * @return filtered rules
     */
    MatchingResult.removeBadfilterRules = function (rules) {
        var badfilterRules = [];
        for (var _i = 0, rules_3 = rules; _i < rules_3.length; _i++) {
            var rule = rules_3[_i];
            if (rule.isOptionEnabled(NetworkRuleOption.Badfilter)) {
                badfilterRules.push(rule);
            }
        }
        if (badfilterRules.length > 0) {
            return rules.filter(function (rule) {
                if (rule.isOptionEnabled(NetworkRuleOption.Badfilter)) {
                    return false;
                }
                var isRuleNegated = badfilterRules.some(function (badfilter) { return badfilter.negatesBadfilter(rule); });
                return !isRuleNegated;
            });
        }
        return rules;
    };
    return MatchingResult;
}());

/**
 * Scanner types enum
 */
var ScannerType;
(function (ScannerType) {
    /**
     * Scanning for network rules
     */
    ScannerType[ScannerType["NetworkRules"] = 0] = "NetworkRules";
    /**
     * Scanning for cosmetic rules
     */
    ScannerType[ScannerType["CosmeticRules"] = 2] = "CosmeticRules";
    /**
     * Scanning for host rules
     */
    ScannerType[ScannerType["HostRules"] = 4] = "HostRules";
    /**
     * All
     */
    ScannerType[ScannerType["All"] = 6] = "All";
})(ScannerType || (ScannerType = {}));

/**
 * Prefix tree implementation
 */
var TrieNode = /** @class */ (function () {
    /**
     * Creates an instance of a TrieNode with the specified char code.
     *
     * @param code
     */
    function TrieNode(code) {
        this.code = code;
    }
    /**
     * Attaches data to this TrieNode.
     *
     * @param data
     */
    TrieNode.prototype.attach = function (data) {
        if (!this.data) {
            this.data = [];
        }
        this.data.push(data);
    };
    /**
     * Adds the specified string to the Trie and attaches data to it.
     *
     * @param str string to add.
     * @param data data to attach to the leaf node.
     */
    TrieNode.prototype.add = function (str, data) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var root = this;
        for (var i = 0; i < str.length; i += 1) {
            var c = str.charCodeAt(i);
            var next = root.getChild(c);
            if (!next) {
                next = root.addChild(c);
            }
            root = next;
        }
        root.attach(data);
    };
    /**
     * Traverses this TrieNode and it's children using the specified search string.
     * This method collects all the data that's attached on the way and returns as
     * a result.
     *
     * @param str string to check.
     * @param start index in str where to start traversing from.
     */
    TrieNode.prototype.traverse = function (str, start) {
        var result = [];
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var current = this;
        for (var i = start; i < str.length; i += 1) {
            var c = str.charCodeAt(i);
            var next = current.getChild(c);
            if (!next) {
                break;
            }
            if (next.data) {
                result.push.apply(result, next.data);
            }
            current = next;
        }
        return result;
    };
    /**
     * Traverses this TrieNode and it's children using the specified search string and all substrings.
     *
     * @param str string to check
     * @param len max length to check
     */
    TrieNode.prototype.traverseAll = function (str, len) {
        var data = [];
        for (var i = 0; i <= len; i += 1) {
            var result = this.traverse(str, i);
            if (result) {
                data.push.apply(data, result);
            }
        }
        return data;
    };
    /**
     * Returns a child node with the specified character code or
     * undefined if not found.
     *
     * @param code character code
     * @returns child node or undefined.
     */
    TrieNode.prototype.getChild = function (code) {
        var children = this.children;
        if (!children) {
            return undefined;
        }
        if (children instanceof TrieNode) {
            if (children.code === code) {
                return children;
            }
            return undefined;
        }
        return children.get(code);
    };
    /**
     * Adds a new child node with the specified character code.
     *
     * @param code character code.
     * @returns the newly created TrieNode.
     */
    TrieNode.prototype.addChild = function (code) {
        var node = new TrieNode(code);
        if (!this.children) {
            this.children = node;
        }
        else if (this.children instanceof TrieNode) {
            var oldNode = this.children;
            this.children = new Map();
            this.children.set(oldNode.code, oldNode);
            this.children.set(code, node);
        }
        else {
            this.children.set(code, node);
        }
        return node;
    };
    return TrieNode;
}());

/**
 * Look up table with underlying prefix tree
 */
var TrieLookupTable = /** @class */ (function () {
    /**
     * Creates a new instance of the TrieLookupTable.
     *
     * @param storage rules storage. We store "rule indexes" in the lookup table which
     * can be used to retrieve the full rules from the storage.
     */
    function TrieLookupTable(storage) {
        /**
         * Count of rules added to this lookup table.
         */
        this.rulesCount = 0;
        this.ruleStorage = storage;
        this.trie = new TrieNode(0);
    }
    /**
     * Finds all matching rules from the shortcuts lookup table
     *
     * @param request to check
     * @return array of matching rules
     */
    TrieLookupTable.prototype.matchAll = function (request) {
        var rulesIndexes = this.traverse(request);
        return this.matchRules(request, rulesIndexes);
    };
    /**
     * Tries to add the rule to the lookup table.
     * returns true if it was added
     *
     * @param rule to add
     * @param storageIdx index
     * @return {boolean} true if the rule been added
     */
    TrieLookupTable.prototype.addRule = function (rule, storageIdx) {
        var shortcut = rule.getShortcut();
        if (!shortcut || TrieLookupTable.isAnyURLShortcut(shortcut)
            || shortcut.length < SimpleRegex.MIN_SHORTCUT_LENGTH) {
            return false;
        }
        this.trie.add(shortcut, storageIdx);
        this.rulesCount += 1;
        return true;
    };
    /**
     * @return total rules count
     */
    TrieLookupTable.prototype.getRulesCount = function () {
        return this.rulesCount;
    };
    /**
     * For specified request finds matching rules from rules indexes array
     *
     * @param request
     * @param rulesIndexes
     */
    TrieLookupTable.prototype.matchRules = function (request, rulesIndexes) {
        if (!rulesIndexes) {
            return [];
        }
        var result = [];
        for (var j = 0; j < rulesIndexes.length; j += 1) {
            var idx = rulesIndexes[j];
            var rule = this.ruleStorage.retrieveNetworkRule(idx);
            if (rule && rule.match(request, false)) {
                result.push(rule);
            }
        }
        return result;
    };
    /**
     * Traverses trie
     *
     * @param request
     */
    TrieLookupTable.prototype.traverse = function (request) {
        return this.trie.traverseAll(request.urlLowercase, request.urlLowercase.length);
    };
    /**
     * Checks if the rule potentially matches too many URLs.
     * We'd better use another type of lookup table for this kind of rules.
     *
     * @param shortcut to check
     * @return check result
     */
    TrieLookupTable.isAnyURLShortcut = function (shortcut) {
        // The numbers are basically ("PROTO://".length + 1)
        if (shortcut.length < 6 && shortcut.indexOf('ws:') === 0) {
            return true;
        }
        if (shortcut.length < 7 && shortcut.indexOf('|ws') === 0) {
            return true;
        }
        if (shortcut.length < 9 && shortcut.indexOf('http') === 0) {
            return true;
        }
        return !!(shortcut.length < 10 && shortcut.indexOf('|http') === 0);
    };
    return TrieLookupTable;
}());

/**
 * Domain lookup table. Key is the domain name hash.
 */
var DomainsLookupTable = /** @class */ (function () {
    /**
     * Creates a new instance
     *
     * @param storage rules storage. We store "rule indexes" in the lookup table which
     * can be used to retrieve the full rules from the storage.
     */
    function DomainsLookupTable(storage) {
        /**
         * Count of rules added to this lookup table.
         */
        this.rulesCount = 0;
        /**
         * Domain lookup table. Key is the domain name hash.
         */
        this.domainsLookupTable = new Map();
        this.ruleStorage = storage;
    }
    /**
     * addRule implements the ILookupTable interface for DomainsLookupTable.
     * @param rule
     * @param storageIdx
     */
    DomainsLookupTable.prototype.addRule = function (rule, storageIdx) {
        var _this = this;
        var permittedDomains = rule.getPermittedDomains();
        if (!permittedDomains || permittedDomains.length === 0) {
            return false;
        }
        var hasWildcardDomain = permittedDomains.some(function (d) { return DomainModifier.isWildcardDomain(d); });
        if (hasWildcardDomain) {
            return false;
        }
        permittedDomains.forEach(function (domain) {
            var hash = fastHash(domain);
            // Add the rule to the lookup table
            var rulesIndexes = _this.domainsLookupTable.get(hash);
            if (!rulesIndexes) {
                rulesIndexes = [];
            }
            rulesIndexes.push(storageIdx);
            _this.domainsLookupTable.set(hash, rulesIndexes);
        });
        this.rulesCount += 1;
        return true;
    };
    /**
     * Implements the ILookupTable interface method.
     */
    DomainsLookupTable.prototype.getRulesCount = function () {
        return this.rulesCount;
    };
    /**
     * Implements the ILookupTable interface method.
     * @param request
     */
    DomainsLookupTable.prototype.matchAll = function (request) {
        var result = [];
        if (!request.sourceHostname) {
            return result;
        }
        var domains = request.subdomains;
        if (request.hostname !== request.sourceHostname) {
            domains.push.apply(domains, request.sourceSubdomains);
        }
        for (var i = 0; i < domains.length; i += 1) {
            var hash = fastHash(domains[i]);
            var rulesIndexes = this.domainsLookupTable.get(hash);
            if (rulesIndexes) {
                for (var j = 0; j < rulesIndexes.length; j += 1) {
                    var rule = this.ruleStorage.retrieveNetworkRule(rulesIndexes[j]);
                    if (rule && rule.match(request)) {
                        result.push(rule);
                    }
                }
            }
        }
        return result;
    };
    return DomainsLookupTable;
}());

/**
 * Hostname lookup table.
 * For specific kind of rules like '||hostname^' and '||hostname/path' more simple algorithm with hashes is faster.
 */
var HostnameLookupTable = /** @class */ (function () {
    /**
     * Creates a new instance
     *
     * @param storage rules storage. We store "rule indexes" in the lookup table which
     * can be used to retrieve the full rules from the storage.
     */
    function HostnameLookupTable(storage) {
        /**
         * Count of rules added to this lookup table.
         */
        this.rulesCount = 0;
        /**
         * Domain lookup table. Key is the domain name hash.
         */
        this.hostnameLookupTable = new Map();
        this.ruleStorage = storage;
    }
    /**
     * addRule implements the ILookupTable interface for DomainsLookupTable.
     * @param rule
     * @param storageIdx
     */
    HostnameLookupTable.prototype.addRule = function (rule, storageIdx) {
        var pattern = rule.getPattern();
        var hostname = '';
        // Pattern: '||example.org^'
        if (pattern.startsWith(SimpleRegex.MASK_START_URL) && pattern.endsWith(SimpleRegex.MASK_SEPARATOR)) {
            hostname = pattern.slice(SimpleRegex.MASK_START_URL.length, pattern.length - SimpleRegex.MASK_SEPARATOR.length);
        }
        // Pattern: '||example.org/path'
        if (pattern.startsWith(SimpleRegex.MASK_START_URL) && pattern.indexOf(SimpleRegex.MASK_BACKSLASH) !== -1) {
            var end = pattern.indexOf(SimpleRegex.MASK_BACKSLASH);
            hostname = pattern.slice(SimpleRegex.MASK_START_URL.length, end);
        }
        if (!HostnameLookupTable.isValidHostname(hostname)) {
            return false;
        }
        var hash = fastHash(hostname);
        var rulesIndexes = this.hostnameLookupTable.get(hash);
        if (!rulesIndexes) {
            rulesIndexes = new Array();
            this.hostnameLookupTable.set(hash, rulesIndexes);
        }
        rulesIndexes.push(storageIdx);
        this.rulesCount += 1;
        return true;
    };
    /**
     * Implements the ILookupTable interface method.
     */
    HostnameLookupTable.prototype.getRulesCount = function () {
        return this.rulesCount;
    };
    /**
     * Implements the ILookupTable interface method.
     * @param request
     */
    HostnameLookupTable.prototype.matchAll = function (request) {
        var result = [];
        var domains = request.subdomains;
        for (var i = 0; i < domains.length; i += 1) {
            var hash = fastHash(domains[i]);
            var rulesIndexes = this.hostnameLookupTable.get(hash);
            if (rulesIndexes) {
                for (var j = 0; j < rulesIndexes.length; j += 1) {
                    var rule = this.ruleStorage.retrieveNetworkRule(rulesIndexes[j]);
                    if (rule && rule.match(request)) {
                        result.push(rule);
                    }
                }
            }
        }
        return result;
    };
    /**
     * Checks if this hostname string is valid
     *
     * @param hostname
     */
    HostnameLookupTable.isValidHostname = function (hostname) {
        if (!hostname) {
            return false;
        }
        if (hostname.indexOf(SimpleRegex.MASK_ANY_CHARACTER) !== -1) {
            return false;
        }
        if (hostname.indexOf('.') < 0 || hostname.endsWith('.')) {
            return false;
        }
        return true;
    };
    return HostnameLookupTable;
}());

/**
 * Sequence scan lookup table of rules for which we could not find a shortcut
 * and could not place it to the shortcuts lookup table.
 * In common case of rule there is always a way to just check a rule.match().
 */
var SeqScanLookupTable = /** @class */ (function () {
    function SeqScanLookupTable() {
        /**
         * Count of rules added to this lookup table.
         */
        this.rulesCount = 0;
        /**
         * Rules for which we could not find a shortcut and could not place it to the shortcuts lookup table.
         */
        this.rules = [];
    }
    /**
     * addRule implements the ILookupTable interface for SeqScanLookupTable.
     * @param rule
     */
    SeqScanLookupTable.prototype.addRule = function (rule) {
        if (!this.rules.includes(rule)) {
            this.rules.push(rule);
            this.rulesCount += 1;
            return true;
        }
        return false;
    };
    /**
     * Implements the ILookupTable interface method.
     */
    SeqScanLookupTable.prototype.getRulesCount = function () {
        return this.rulesCount;
    };
    /**
     * Implements the ILookupTable interface method.
     * @param request
     */
    SeqScanLookupTable.prototype.matchAll = function (request) {
        var result = [];
        for (var i = 0; i < this.rules.length; i += 1) {
            var r = this.rules[i];
            if (r.match(request)) {
                result.push(r);
            }
        }
        return result;
    };
    return SeqScanLookupTable;
}());

/**
 * NetworkEngine is the engine that supports quick search over network rules
 */
var NetworkEngine = /** @class */ (function () {
    /**
     * Builds an instance of the network engine
     *
     * @param storage an object for a rules storage.
     * @param skipStorageScan create an instance without storage scanning.
     */
    function NetworkEngine(storage, skipStorageScan) {
        if (skipStorageScan === void 0) { skipStorageScan = false; }
        this.ruleStorage = storage;
        this.rulesCount = 0;
        this.domainsLookupTable = new DomainsLookupTable(storage);
        this.hostnameLookupTable = new HostnameLookupTable(storage);
        this.shortcutsLookupTable = new TrieLookupTable(storage);
        this.seqScanLookupTable = new SeqScanLookupTable();
        if (skipStorageScan) {
            return;
        }
        var scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.NetworkRules);
        while (scanner.scan()) {
            var indexedRule = scanner.getRule();
            if (indexedRule
                && indexedRule.rule instanceof NetworkRule) {
                this.addRule(indexedRule.rule, indexedRule.index);
            }
        }
    }
    /**
     * Match searches over all filtering rules loaded to the engine
     * It returns rule if a match was found alongside the matching rule
     *
     * @param request to check
     * @return rule matching request or null
     */
    NetworkEngine.prototype.match = function (request) {
        var networkRules = this.matchAll(request);
        if (networkRules.length === 0) {
            return null;
        }
        var result = new MatchingResult(networkRules, null);
        return result.getBasicResult();
    };
    /**
     * Finds all rules matching the specified request regardless of the rule types
     * It will find both allowlist and blacklist rules
     *
     * @param request to check
     * @return array of matching rules
     */
    NetworkEngine.prototype.matchAll = function (request) {
        // First check by shortcuts
        var result = this.hostnameLookupTable.matchAll(request);
        result.push.apply(result, (this.shortcutsLookupTable.matchAll(request)));
        result.push.apply(result, (this.domainsLookupTable.matchAll(request)));
        result.push.apply(result, (this.seqScanLookupTable.matchAll(request)));
        return result;
    };
    /**
     * Adds rule to the network engine
     *
     * @param rule
     * @param storageIdx
     */
    NetworkEngine.prototype.addRule = function (rule, storageIdx) {
        if (!this.hostnameLookupTable.addRule(rule, storageIdx)) {
            if (!this.shortcutsLookupTable.addRule(rule, storageIdx)) {
                if (!this.domainsLookupTable.addRule(rule, storageIdx)) {
                    this.seqScanLookupTable.addRule(rule, storageIdx);
                }
            }
        }
        this.rulesCount += 1;
    };
    return NetworkEngine;
}());

/**
 * Request represents a web request with all it's necessary properties
 */
var Request = /** @class */ (function () {
    /**
     * Creates an instance of a Request
     *
     * @param url - request URL
     * @param sourceUrl - source URL
     * @param requestType - request type
     * @param method - request method
     *
     * @throws
     */
    function Request(url, sourceUrl, requestType, method) {
        /**
         * the request is for a given Hostname, and not for a URL, and we don't really know what protocol it is.
         * This can be true for DNS requests, or for HTTP CONNECT, or SNI matching.
         */
        this.isHostnameRequest = false;
        if (typeof url !== 'string') {
            throw new TypeError("Invalid request url: ".concat(url));
        }
        this.url = url;
        this.requestType = requestType;
        this.method = method;
        this.urlLowercase = Request.compactUrl(url).toLowerCase();
        this.sourceUrl = Request.compactUrl(sourceUrl);
        var tldResult = parse(url);
        this.hostname = tldResult.hostname;
        this.domain = tldResult.domain;
        this.subdomains = Request.getSubdomains(tldResult);
        var sourceTldResult;
        if (sourceUrl) {
            sourceTldResult = parse(sourceUrl);
            this.sourceHostname = sourceTldResult.hostname;
            this.sourceDomain = sourceTldResult.domain;
            this.sourceSubdomains = Request.getSubdomains(sourceTldResult);
        }
        else {
            this.sourceHostname = null;
            this.sourceDomain = null;
            this.sourceSubdomains = [];
        }
        if (this.sourceDomain) {
            this.thirdParty = this.domain !== this.sourceDomain;
        }
        else if (sourceTldResult && sourceTldResult.isIp) {
            this.thirdParty = this.hostname !== this.sourceHostname;
        }
        else {
            this.thirdParty = null;
        }
    }
    /**
     * We cut the url in performance purposes
     * @param url
     */
    Request.compactUrl = function (url) {
        var compacted = url;
        if (compacted && compacted.length > Request.MAX_URL_MATCH_LENGTH) {
            compacted = compacted.substring(0, Request.MAX_URL_MATCH_LENGTH);
        }
        return compacted;
    };
    /**
    * Splits subdomains and returns all subdomains (including the hostname itself)
    *
    * @param tldResult
    * @returns array of subdomains
    */
    Request.getSubdomains = function (tldResult) {
        var domain = tldResult.domain, hostname = tldResult.hostname, subdomain = tldResult.subdomain, publicSuffix = tldResult.publicSuffix;
        var subdomainsResult = [];
        if (!domain) {
            if (hostname) {
                subdomainsResult.push(hostname);
                return subdomainsResult;
            }
            return [];
        }
        if (publicSuffix) {
            subdomainsResult.push(publicSuffix);
            // Extract subdomains from complex suffixes
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/2037
            // https://github.com/AdguardTeam/tsurlfilter/issues/57
            for (var i = 0; i < publicSuffix.length; i += 1) {
                if (publicSuffix[i] === '.') {
                    subdomainsResult.push(publicSuffix.slice(i + 1));
                }
            }
        }
        subdomainsResult.push(domain);
        if (!subdomain) {
            return subdomainsResult;
        }
        var parts = subdomain.split('.');
        var incrementDomain = domain;
        for (var i = parts.length - 1; i >= 0; i -= 1) {
            incrementDomain = "".concat(parts[i], ".").concat(incrementDomain);
            subdomainsResult.push(incrementDomain);
        }
        return subdomainsResult;
    };
    /**
     * Max url length for matching
     * Some urls are really long and slow down matching, so we cut them to this length.
     */
    Request.MAX_URL_MATCH_LENGTH = 2000;
    return Request;
}());

/**
 * DnsResult contains a network rule and host rules matching request
 */
var DnsResult = /** @class */ (function () {
    function DnsResult() {
        /**
         * BasicRule - a network rule matching the request.
         */
        this.basicRule = null;
        /**
         * Host rules
         */
        this.hostRules = [];
    }
    return DnsResult;
}());

/**
 * DNSEngine combines host rules and network rules and is supposed to quickly find
 * matching rules for hostnames.
 * First, it looks over network rules and returns first rule found.
 * Then, if nothing found, it looks up the host rules.
 */
var DnsEngine = /** @class */ (function () {
    /**
     * Builds an instance of dns engine
     *
     * @param storage
     */
    function DnsEngine(storage) {
        this.ruleStorage = storage;
        this.rulesCount = 0;
        this.lookupTable = new Map();
        this.networkEngine = new NetworkEngine(storage, true);
        var scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.HostRules);
        while (scanner.scan()) {
            var indexedRule = scanner.getRule();
            if (indexedRule) {
                if (indexedRule.rule instanceof HostRule) {
                    this.addRule(indexedRule.rule, indexedRule.index);
                }
                else if (indexedRule.rule instanceof NetworkRule
                    && indexedRule.rule.isHostLevelNetworkRule()) {
                    this.networkEngine.addRule(indexedRule.rule, indexedRule.index);
                }
            }
        }
    }
    /**
     * Match searches over all filtering and host rules loaded to the engine
     *
     * @param hostname to check
     * @return dns result object
     */
    DnsEngine.prototype.match = function (hostname) {
        var result = new DnsResult();
        if (!hostname) {
            return result;
        }
        var url = "http://".concat(hostname, "/");
        var request = new Request(url, url, RequestType.Document);
        request.isHostnameRequest = true;
        var networkRule = this.networkEngine.match(request);
        if (networkRule) {
            // Network rules always have higher priority
            result.basicRule = networkRule;
            return result;
        }
        var hash = fastHash(hostname);
        var rulesIndexes = this.lookupTable.get(hash);
        if (rulesIndexes) {
            for (var j = 0; j < rulesIndexes.length; j += 1) {
                var rule = this.ruleStorage.retrieveHostRule(rulesIndexes[j]);
                if (rule && rule.match(hostname)) {
                    result.hostRules.push(rule);
                }
            }
        }
        return result;
    };
    /**
     * Adds rule to engine
     *
     * @param rule
     * @param storageIdx
     */
    DnsEngine.prototype.addRule = function (rule, storageIdx) {
        var _this = this;
        rule.getHostnames().forEach(function (hostname) {
            var hash = fastHash(hostname);
            // Add the rule to the lookup table
            var rulesIndexes = _this.lookupTable.get(hash);
            if (!rulesIndexes) {
                rulesIndexes = [];
            }
            rulesIndexes.push(storageIdx);
            _this.lookupTable.set(hash, rulesIndexes);
        });
        this.rulesCount += 1;
    };
    return DnsEngine;
}());

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var lru = {exports: {}};

(function (module, exports) {
	!function(g,c){c(exports);}(commonjsGlobal,function(g){const c=Symbol("newer"),e=Symbol("older");class n{constructor(a,b){typeof a!=="number"&&(b=a,a=0),this.size=0,this.limit=a,this.oldest=this.newest=void 0,this._keymap=new Map(),b&&(this.assign(b),a<1&&(this.limit=this.size));}_markEntryAsUsed(a){if(a===this.newest)return;a[c]&&(a===this.oldest&&(this.oldest=a[c]),a[c][e]=a[e]),a[e]&&(a[e][c]=a[c]),a[c]=void 0,a[e]=this.newest,this.newest&&(this.newest[c]=a),this.newest=a;}assign(a){let b,d=this.limit||Number.MAX_VALUE;this._keymap.clear();let m=a[Symbol.iterator]();for(let h=m.next();!h.done;h=m.next()){let f=new l(h.value[0],h.value[1]);this._keymap.set(f.key,f),b?(b[c]=f,f[e]=b):this.oldest=f,b=f;if(d--==0)throw new Error("overflow")}this.newest=b,this.size=this._keymap.size;}get(a){var b=this._keymap.get(a);return b?(this._markEntryAsUsed(b),b.value):void 0}set(a,b){var d=this._keymap.get(a);return d?(d.value=b,this._markEntryAsUsed(d),this):(this._keymap.set(a,d=new l(a,b)),this.newest?(this.newest[c]=d,d[e]=this.newest):this.oldest=d,this.newest=d,++this.size,this.size>this.limit&&this.shift(),this)}shift(){var a=this.oldest;if(a)return this.oldest[c]?(this.oldest=this.oldest[c],this.oldest[e]=void 0):(this.oldest=void 0,this.newest=void 0),a[c]=a[e]=void 0,this._keymap.delete(a.key),--this.size,[a.key,a.value]}find(a){let b=this._keymap.get(a);return b?b.value:void 0}has(a){return this._keymap.has(a)}delete(a){var b=this._keymap.get(a);return b?(this._keymap.delete(b.key),b[c]&&b[e]?(b[e][c]=b[c],b[c][e]=b[e]):b[c]?(b[c][e]=void 0,this.oldest=b[c]):b[e]?(b[e][c]=void 0,this.newest=b[e]):this.oldest=this.newest=void 0,this.size--,b.value):void 0}clear(){this.oldest=this.newest=void 0,this.size=0,this._keymap.clear();}keys(){return new j(this.oldest)}values(){return new k(this.oldest)}entries(){return this}[Symbol.iterator](){return new i(this.oldest)}forEach(a,b){typeof b!=="object"&&(b=this);let d=this.oldest;for(;d;)a.call(b,d.value,d.key,this),d=d[c];}toJSON(){for(var a=new Array(this.size),b=0,d=this.oldest;d;)a[b++]={key:d.key,value:d.value},d=d[c];return a}toString(){for(var a="",b=this.oldest;b;)a+=String(b.key)+":"+b.value,b=b[c],b&&(a+=" < ");return a}}g.LRUMap=n;function l(a,b){this.key=a,this.value=b,this[c]=void 0,this[e]=void 0;}function i(a){this.entry=a;}i.prototype[Symbol.iterator]=function(){return this},i.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:[a.key,a.value]}):{done:!0,value:void 0}};function j(a){this.entry=a;}j.prototype[Symbol.iterator]=function(){return this},j.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.key}):{done:!0,value:void 0}};function k(a){this.entry=a;}k.prototype[Symbol.iterator]=function(){return this},k.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.value}):{done:!0,value:void 0}};});
	
} (lru, lru.exports));

/**
 * CosmeticLookupTable lets quickly lookup cosmetic rules for the specified hostname.
 * It is primarily used by the {@see CosmeticEngine}.
 */
var CosmeticLookupTable = /** @class */ (function () {
    /**
     * Creates a new instance
     *
     * @param storage rules storage. We store "rule indexes" in the lookup table which
     * can be used to retrieve the full rules from the storage.
     */
    function CosmeticLookupTable(storage) {
        this.byHostname = new Map();
        this.wildcardRules = [];
        this.genericRules = [];
        this.allowlist = new Map();
        this.ruleStorage = storage;
    }
    /**
     * Adds rule to the appropriate collection
     * @param rule
     * @param storageIdx
     */
    CosmeticLookupTable.prototype.addRule = function (rule, storageIdx) {
        if (rule.isAllowlist()) {
            var key = rule.getContent();
            var existingRules = this.allowlist.get(key) || [];
            existingRules.push(storageIdx);
            this.allowlist.set(key, existingRules);
            return;
        }
        if (rule.isGeneric()) {
            this.genericRules.push(rule);
            return;
        }
        var domains = rule.getPermittedDomains();
        if (domains) {
            var hasWildcardDomain = domains.some(function (d) { return DomainModifier.isWildcardDomain(d); });
            if (hasWildcardDomain) {
                this.wildcardRules.push(rule);
                return;
            }
            for (var _i = 0, domains_1 = domains; _i < domains_1.length; _i++) {
                var domain = domains_1[_i];
                var tldResult = parse(domain);
                // tldResult.domain equals to eTLD domain,
                // e.g. sub.example.uk.org would result in example.uk.org
                var parsedDomain = tldResult.domain || domain;
                var key = fastHash(parsedDomain);
                var rules = this.byHostname.get(key) || [];
                rules.push(storageIdx);
                this.byHostname.set(key, rules);
            }
        }
    };
    /**
     * Finds rules by hostname
     * @param request
     * @param subdomains
     */
    CosmeticLookupTable.prototype.findByHostname = function (request) {
        var result = [];
        var subdomains = request.subdomains;
        var _loop_1 = function (i) {
            var subdomain = subdomains[i];
            var rulesIndexes = this_1.byHostname.get(fastHash(subdomain));
            if (rulesIndexes) {
                // Filtering out duplicates
                rulesIndexes = rulesIndexes.filter(function (v, index) { return rulesIndexes.indexOf(v) === index; });
                for (var j = 0; j < rulesIndexes.length; j += 1) {
                    var rule = this_1.ruleStorage.retrieveRule(rulesIndexes[j]);
                    if (rule && rule.match(request)) {
                        result.push(rule);
                    }
                }
            }
        };
        var this_1 = this;
        // Iterate over all sub-domains
        for (var i = 0; i < subdomains.length; i += 1) {
            _loop_1(i);
        }
        result.push.apply(result, this.wildcardRules.filter(function (r) { return r.match(request); }));
        return result.filter(function (rule) { return !rule.isAllowlist(); });
    };
    /**
     * Checks if the rule is disabled on the specified hostname.
     * @param request
     * @param rule
     */
    CosmeticLookupTable.prototype.isAllowlisted = function (request, rule) {
        var rulesIndexes = this.allowlist.get(rule.getContent());
        if (!rulesIndexes) {
            return false;
        }
        for (var j = 0; j < rulesIndexes.length; j += 1) {
            var r = this.ruleStorage.retrieveRule(rulesIndexes[j]);
            if (r && r.match(request)) {
                return true;
            }
        }
        return false;
    };
    return CosmeticLookupTable;
}());

var CosmeticRuleModifiers;
(function (CosmeticRuleModifiers) {
    CosmeticRuleModifiers["Path"] = "path";
    CosmeticRuleModifiers["Domain"] = "domain";
})(CosmeticRuleModifiers || (CosmeticRuleModifiers = {}));
var CosmeticRuleModifiersSyntax = {
    OpenBracket: '[',
    CloseBracket: ']',
    SpecialSymbol: '$',
    Delimiter: ',',
    Assigner: '=',
    EscapeCharacter: '\\',
};

var cosmeticRuleModifiersList = Object.values(CosmeticRuleModifiers);
/**
 * Helper class for parsing text of cosmetic rules
 * used by CosmeticRule and [Filter compiler](https://github.com/AdguardTeam/FiltersCompiler)
 *
 *
 * The cosmetic rule contains of the following parts:
 *
 * `pattern##content`
 *
 * `pattern` contains the list of the rule modifiers and domains.
 *
 * `##` is a marker (might be a different marker depending on the rule type).
 * You can find the list of markers in the CosmeticRuleMarker enumeration.
 *
 * `content` might be a CSS selector, a scriptlet or something else, depending on the rule type.
 */
var CosmeticRuleParser = /** @class */ (function () {
    function CosmeticRuleParser() {
    }
    /**
     * Parse the rule's pattern, cosmetic marker and the content parts from the rule text.
     * If the content is empty, throws a SyntaxError.
     *
     * @param ruleText
     * @returns Object with pattern, marker and content text parts
     */
    CosmeticRuleParser.parseRuleTextByMarker = function (ruleText) {
        var _a = findCosmeticRuleMarker(ruleText), markerIndex = _a[0], marker = _a[1];
        if (marker === null) {
            throw new SyntaxError('Not a cosmetic rule');
        }
        var content = ruleText.substring(markerIndex + marker.length).trim();
        if (!content) {
            throw new SyntaxError('Rule content is empty');
        }
        var pattern;
        if (markerIndex > 0) {
            pattern = ruleText.substring(0, markerIndex);
        }
        return {
            pattern: pattern,
            marker: marker,
            content: content,
        };
    };
    /**
     * Extracts the rule modifiers and domains from the rule pattern.
     * @param rulePattern
     * @returns Object with modifiers and domains text parts
     */
    CosmeticRuleParser.parseRulePatternText = function (rulePattern) {
        var OpenBracket = CosmeticRuleModifiersSyntax.OpenBracket, CloseBracket = CosmeticRuleModifiersSyntax.CloseBracket, SpecialSymbol = CosmeticRuleModifiersSyntax.SpecialSymbol, EscapeCharacter = CosmeticRuleModifiersSyntax.EscapeCharacter;
        if (!rulePattern.startsWith("".concat(OpenBracket + SpecialSymbol))) {
            return { domainsText: rulePattern };
        }
        var closeBracketIndex;
        // The first two characters cannot be closing brackets
        for (var i = 2; i < rulePattern.length; i += 1) {
            if (rulePattern[i] === CloseBracket && rulePattern[i - 1] !== EscapeCharacter) {
                closeBracketIndex = i;
                break;
            }
        }
        if (!closeBracketIndex) {
            throw new SyntaxError('Can\'t parse modifiers list');
        }
        // Handle this case: `[$]`
        if (closeBracketIndex === 2) {
            throw new SyntaxError('Modifiers list can\'t be empty');
        }
        var modifiersText = rulePattern.slice(2, closeBracketIndex);
        var domainsText;
        if (closeBracketIndex < rulePattern.length - 1) {
            domainsText = rulePattern.slice(closeBracketIndex + 1);
        }
        return {
            modifiersText: modifiersText,
            domainsText: domainsText,
        };
    };
    /**
     * Parses the list of modifiers. Parsing is done in the same way as it's done in the NetworkRule, i.e.
     * we have a comma-separated list of modifier-value pairs.
     * If we encounter an invalid modifier, this method throws a SyntaxError.
     *
     * @param modifiersText - list of modifiers splited by comma
     * @returns - modifiers collection object
     */
    CosmeticRuleParser.parseRuleModifiers = function (modifiersText) {
        if (!modifiersText) {
            return null;
        }
        var Assigner = CosmeticRuleModifiersSyntax.Assigner;
        var modifiersTextArray = parseOptionsString(modifiersText, false);
        var modifiers = Object.create(null);
        for (var i = 0; i < modifiersTextArray.length; i += 1) {
            var modifierText = modifiersTextArray[i];
            var assignerIndex = modifierText.indexOf(Assigner);
            if (modifierText === 'path') {
                // Empty path modifier without assigner and value will match only main page
                modifiers[modifierText] = '';
                continue;
            }
            if (assignerIndex === -1) {
                throw new SyntaxError('Modifier must have assigned value');
            }
            var modifierKey = modifierText.substring(0, assignerIndex);
            if (cosmeticRuleModifiersList.includes(modifierKey)) {
                var modifierValue = modifierText.substring(assignerIndex + 1);
                modifiers[modifierKey] = modifierValue;
            }
            else {
                throw new SyntaxError("'".concat(modifierKey, "' is not valid modifier"));
            }
        }
        return modifiers;
    };
    /**
     * Parses the rule pattern and extracts the permitted/restricted domains and the unescaped path modifier value,
     * If domains are declared through $domain modifier and pattern domain list, this method throws a SyntaxError.
     * @param rulePattern - rule pattern text
     *
     * @returns Object with permitted/restricted domains list and the path modifier string value
     */
    CosmeticRuleParser.parseRulePattern = function (rulePattern) {
        var _a = CosmeticRuleParser.parseRulePatternText(rulePattern), domainsText = _a.domainsText, modifiersText = _a.modifiersText;
        var domains = domainsText;
        var path;
        var modifiers = CosmeticRuleParser.parseRuleModifiers(modifiersText);
        if (modifiers) {
            if (modifiers.path || modifiers.path === '') {
                path = modifiers.path;
                if (SimpleRegex.isRegexPattern(path)) {
                    path = SimpleRegex.unescapeRegexSpecials(path, SimpleRegex.reModifierPatternEscapedSpecialCharacters);
                }
            }
            if (modifiers.domain) {
                if (domains) {
                    throw new SyntaxError('The $domain modifier is not allowed in a domain-specific rule');
                }
                else {
                    domains = modifiers.domain;
                }
            }
        }
        var permittedDomains;
        var restrictedDomains;
        // Skip wildcard domain
        if (domains && domains !== SimpleRegex.MASK_ANY_CHARACTER) {
            var separator = (modifiers === null || modifiers === void 0 ? void 0 : modifiers.domain) ? PIPE_SEPARATOR : COMMA_SEPARATOR;
            var domainModifier = new DomainModifier(domains, separator);
            if (domainModifier.permittedDomains) {
                permittedDomains = domainModifier.permittedDomains;
            }
            if (domainModifier.restrictedDomains) {
                restrictedDomains = domainModifier.restrictedDomains;
            }
        }
        return {
            path: path,
            permittedDomains: permittedDomains,
            restrictedDomains: restrictedDomains,
        };
    };
    return CosmeticRuleParser;
}());

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Scriptlets helper class
 */
// eslint-disable-next-line max-classes-per-file
var ScriptletParser = /** @class */ (function () {
    function ScriptletParser() {
    }
    /**
     * Iterate over iterable argument and evaluate current state with transitions
     *
     * @param {Array|Collection|string} iterable
     * @param {Object} transitions transition functions
     * @param {string} initState first transition name
     * @param {any} args arguments which should be passed to transition functions
     * @returns {string} transition
     */
    ScriptletParser.iterateWithTransitions = function (iterable, transitions, initState, args) {
        var state = initState;
        for (var i = 0; i < iterable.length; i += 1) {
            state = transitions[state](iterable, i, args);
        }
        return state;
    };
    /**
     * Parse and validate scriptlet rule
     * @param {*} ruleContent
     * @returns {{name: string, args: Array<string>}}
     */
    ScriptletParser.parseRule = function (ruleContent) {
        var _a;
        var transitions = (_a = {},
            _a[ScriptletParser.TRANSITION.OPENED] = ScriptletParser.opened,
            _a[ScriptletParser.TRANSITION.PARAM] = ScriptletParser.param,
            _a[ScriptletParser.TRANSITION.CLOSED] = function () { },
            _a);
        var sep = { symb: null };
        var saver = new ScriptletParser.WordSaver();
        var state = ScriptletParser.iterateWithTransitions(ruleContent, transitions, ScriptletParser.TRANSITION.OPENED, { sep: sep, saver: saver });
        if (state !== 'closed') {
            throw new Error("Invalid scriptlet ".concat(ruleContent));
        }
        var args = saver.getAll();
        return {
            name: args[0],
            args: args.slice(1),
        };
    };
    /**
     * Helper class to accumulate an array of strings char by char
     */
    ScriptletParser.WordSaver = /** @class */ (function () {
        function class_1() {
            /**
             * String cursor
             */
            this.str = '';
            /**
             * Strings array
             */
            this.collectedStrings = [];
        }
        /**
         * Saves symbol to cursor
         *
         * @param s
         */
        class_1.prototype.saveSymbol = function (s) {
            this.str += s;
        };
        /**
         * Saves cursor to strings
         */
        class_1.prototype.saveStr = function () {
            this.collectedStrings.push(this.str);
            this.str = '';
        };
        /**
         * Returns collected strings
         */
        class_1.prototype.getAll = function () {
            return __spreadArray([], this.collectedStrings, true);
        };
        return class_1;
    }());
    /**
     * Transition names
     */
    ScriptletParser.TRANSITION = {
        OPENED: 'opened',
        PARAM: 'param',
        CLOSED: 'closed',
    };
    /**
     * Transition function: the current index position in start, end or between params
     * @param {string} rule
     * @param {number} index
     * @param {Object} Object
     * @property {Object} Object.sep contains prop symb with current separator char
     * @returns {string} transition
     */
    ScriptletParser.opened = function (rule, index, _a) {
        var sep = _a.sep;
        var char = rule[index];
        switch (char) {
            case ' ':
            case '(':
            case ',':
                return ScriptletParser.TRANSITION.OPENED;
            case '\'':
            case '"':
                // eslint-disable-next-line no-param-reassign
                sep.symb = char;
                return ScriptletParser.TRANSITION.PARAM;
            case ')':
                return index === rule.length - 1
                    ? ScriptletParser.TRANSITION.CLOSED
                    : ScriptletParser.TRANSITION.OPENED;
        }
        return undefined;
    };
    /**
     * Transition function: the current index position inside param
     *
     * @param {string} rule
     * @param {number} index
     * @param {Object} Object
     * @property {Object} Object.sep contains prop `symb` with current separator char
     * @property {Object} Object.saver helper which allow to save strings by car by char
     * @returns {string} transition
     */
    ScriptletParser.param = function (rule, index, _a) {
        var saver = _a.saver, sep = _a.sep;
        var char = rule[index];
        switch (char) {
            case '\'':
            case '"':
                if (char === sep.symb && rule[index - 1] !== '\\') {
                    // eslint-disable-next-line no-param-reassign
                    sep.symb = null;
                    saver.saveStr();
                    return ScriptletParser.TRANSITION.OPENED;
                }
                saver.saveSymbol(char);
                return ScriptletParser.TRANSITION.PARAM;
            default:
                saver.saveSymbol(char);
                return ScriptletParser.TRANSITION.PARAM;
        }
    };
    return ScriptletParser;
}());

/**
 * CosmeticRuleType is an enumeration of the possible
 * cosmetic rule types.
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-rules
 */
var CosmeticRuleType;
(function (CosmeticRuleType) {
    /**
     * Cosmetic rules that just hide page elements.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#element-hiding-rules
     */
    CosmeticRuleType[CosmeticRuleType["ElementHiding"] = 0] = "ElementHiding";
    /**
     * Cosmetic rules that allow adding custom CSS styles.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules
     */
    CosmeticRuleType[CosmeticRuleType["Css"] = 1] = "Css";
    /**
     * Cosmetic rules that allow executing custom JS scripts.
     * Some restrictions are applied to this type of rules by default.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#javascript-rules
     */
    CosmeticRuleType[CosmeticRuleType["Js"] = 2] = "Js";
    /**
     * Special type of rules that allows filtering HTML code of web pages.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules
     */
    CosmeticRuleType[CosmeticRuleType["Html"] = 3] = "Html";
})(CosmeticRuleType || (CosmeticRuleType = {}));
/**
 * Pseudo class indicators. They are used to detect if rule is extended or not even if rule does not
 * have extended css marker
 */
var EXT_CSS_PSEUDO_INDICATORS = [
    /**
     * Pseudo-classes :is(), and :not() may use native implementation
     * so they are not listed here
     * https://github.com/AdguardTeam/ExtendedCss#extended-css-is
     * https://github.com/AdguardTeam/ExtendedCss#extended-css-not
     */
    /**
     * :has() should also be conditionally considered as extended and should not be in this list
     * https://github.com/AdguardTeam/ExtendedCss#extended-css-has
     * but there is a bug with content blocker in safari
     * https://bugs.webkit.org/show_bug.cgi?id=248868
     *
     * TODO: remove ':has(' later
     */
    ':has(',
    ':contains(',
    ':matches-css(',
    ':matches-attr(',
    ':matches-property(',
    ':xpath(',
    ':upward(',
    ':nth-ancestor(',
    ':remove(',
    // aliases for :has()
    ':-abp-has(',
    // aliases for :contains()
    ':has-text(',
    ':-abp-contains(',
    // old syntax
    '[-ext-has=',
    '[-ext-contains=',
    '[-ext-has-text=',
    '[-ext-matches-css=',
    '[-ext-matches-css-before=',
    '[-ext-matches-css-after=',
    // obsolete since ExtendedCss v2.0.2 but still compatible
    // https://github.com/AdguardTeam/ExtendedCss/releases/tag/v2.0.2
    ':matches-css-before(',
    ':matches-css-after(',
];
/**
 * Implements a basic cosmetic rule.
 *
 * Cosmetic rules syntax are almost similar and looks like this:
 * ```
 * rule = [domains] "marker" content
 * domains = [domain0, domain1[, ...[, domainN]]]
 * ```
 *
 * The rule type is defined by the `marker` value, you can find the list of them
 * in the {@see CosmeticRuleMarker} enumeration.
 *
 * What matters, though, is what's in the `content` part of it.
 *
 * Examples:
 * * `example.org##.banner` -- element hiding rule
 * * `example.org#$#.banner { display: block; }` -- CSS rule
 * * `example.org#%#window.x=1;` -- JS rule
 * * `example.org#%#//scriptlet('scriptlet-name')` -- Scriptlet rule
 * * `example.org$$div[id="test"]` -- HTML filtering rule
 */
var CosmeticRule = /** @class */ (function () {
    /**
     * Creates an instance of the {@link CosmeticRule}.
     * It parses the rule and extracts the permitted/restricted domains,
     * and also the cosmetic rule's content.
     *
     * Depending on the rule type, the content might be transformed in
     * one of the helper classes, or kept as string when it's appropriate.
     *
     * @param ruleText - original rule text.
     * @param filterListId - ID of the filter list this rule belongs to.
     *
     * @throws error if it fails to parse the rule.
     */
    function CosmeticRule(ruleText, filterListId) {
        this.allowlist = false;
        this.extendedCss = false;
        this.permittedDomains = undefined;
        this.restrictedDomains = undefined;
        /**
         * Js script to execute
         */
        this.script = undefined;
        /**
         * Object with script code ready to execute and debug, domain values
         * @private
         */
        this.scriptData = null;
        /**
         * Object with scriptlet function and params
         * @private
         */
        this.scriptletData = null;
        /**
         * If the rule contains scriptlet content
         */
        this.isScriptlet = false;
        this.ruleText = ruleText;
        this.filterListId = filterListId;
        var _a = CosmeticRuleParser.parseRuleTextByMarker(ruleText), pattern = _a.pattern, marker = _a.marker, content = _a.content;
        this.content = content;
        this.type = CosmeticRule.parseType(marker);
        this.extendedCss = isExtCssMarker(marker);
        if (!this.extendedCss
            && (this.type === CosmeticRuleType.ElementHiding
                || this.type === CosmeticRuleType.Css)) {
            // additional check if rule is extended css rule by pseudo class indicators
            for (var i = 0; i < EXT_CSS_PSEUDO_INDICATORS.length; i += 1) {
                if (this.content.indexOf(EXT_CSS_PSEUDO_INDICATORS[i]) !== -1) {
                    this.extendedCss = true;
                    break;
                }
            }
        }
        CosmeticRule.validate(ruleText, this.type, content, this.extendedCss);
        if (pattern) {
            // This means that the marker is preceded by the list of domains and modifiers
            // Now it's a good time to parse them.
            var _b = CosmeticRuleParser.parseRulePattern(pattern), path = _b.path, permittedDomains = _b.permittedDomains, restrictedDomains = _b.restrictedDomains;
            if (path || path === '') {
                this.pathModifier = new Pattern(path);
            }
            if (permittedDomains) {
                this.permittedDomains = permittedDomains;
            }
            if (restrictedDomains) {
                this.restrictedDomains = restrictedDomains;
            }
        }
        this.allowlist = CosmeticRule.parseAllowlist(marker);
        this.isScriptlet = this.content.startsWith(ADG_SCRIPTLET_MASK);
    }
    /**
     * Parses first pseudo class from the specified CSS selector
     *
     * @param selector
     * @returns pseudo class name if found or null
     */
    CosmeticRule.parsePseudoClass = function (selector) {
        var beginIndex = 0;
        var nameStartIndex = -1;
        var squareBracketIndex = 0;
        while (squareBracketIndex >= 0) {
            nameStartIndex = selector.indexOf(':', beginIndex);
            if (nameStartIndex < 0) {
                return null;
            }
            if (nameStartIndex > 0 && selector.charAt(nameStartIndex - 1) === '\\') {
                // Escaped colon character
                return null;
            }
            squareBracketIndex = selector.indexOf('[', beginIndex);
            while (squareBracketIndex >= 0) {
                if (nameStartIndex > squareBracketIndex) {
                    var squareEndBracketIndex = selector.indexOf(']', squareBracketIndex + 1);
                    beginIndex = squareEndBracketIndex + 1;
                    if (nameStartIndex < squareEndBracketIndex) {
                        // Means that colon character is somewhere inside attribute selector
                        // Something like a[src^="http://domain.com"]
                        break;
                    }
                    if (squareEndBracketIndex > 0) {
                        squareBracketIndex = selector.indexOf('[', beginIndex);
                    }
                    else {
                        // bad rule, example: a[src="http:
                        return null;
                    }
                }
                else {
                    squareBracketIndex = -1;
                    break;
                }
            }
        }
        var nameEndIndex = indexOfAny(selector, [' ', ',', '\t', '>', '(', '[', '.', '#', ':', '+', '~', '"', '\''], nameStartIndex + 1);
        if (nameEndIndex < 0) {
            nameEndIndex = selector.length;
        }
        var name = selector.substring(nameStartIndex, nameEndIndex);
        if (name.length <= 1) {
            // Either empty name or a pseudo element (like ::content)
            return null;
        }
        return name;
    };
    CosmeticRule.prototype.getText = function () {
        return this.ruleText;
    };
    CosmeticRule.prototype.getFilterListId = function () {
        return this.filterListId;
    };
    /**
     * Cosmetic rule type (always present)
     */
    CosmeticRule.prototype.getType = function () {
        return this.type;
    };
    /**
     * Allowlist means that this rule is meant to disable other rules.
     * For instance, https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#elemhide-exceptions
     */
    CosmeticRule.prototype.isAllowlist = function () {
        return this.allowlist;
    };
    /**
     * Gets the rule content. The meaning of this field depends on the rule type.
     * For instance, for an element hiding rule, this is just a CSS selector.
     * While, for a CSS rule, this is a CSS selector + style.
     */
    CosmeticRule.prototype.getContent = function () {
        return this.content;
    };
    /**
     * Returns script ready to execute or null
     * Rebuilds scriptlet script if debug or domain params change
     * @param options script options
     * @returns script code or null
     */
    CosmeticRule.prototype.getScript = function (options) {
        var _a, _b;
        if (options === void 0) { options = {}; }
        var _c = options.debug, debug = _c === void 0 ? false : _c, frameUrl = options.frameUrl;
        var scriptData = this.scriptData;
        if (scriptData && !this.isScriptlet) {
            return scriptData.code;
        }
        if (scriptData && scriptData.debug === debug) {
            if (frameUrl) {
                if (frameUrl === scriptData.frameUrl) {
                    return scriptData.code;
                }
            }
            else {
                return scriptData.code;
            }
        }
        this.initScript(options);
        return (_b = (_a = this.scriptData) === null || _a === void 0 ? void 0 : _a.code) !== null && _b !== void 0 ? _b : null;
    };
    /**
     * Gets list of permitted domains.
     */
    CosmeticRule.prototype.getPermittedDomains = function () {
        return this.permittedDomains;
    };
    /**
     * Returns true if the rule is considered "generic"
     * "generic" means that the rule is not restricted to a limited set of domains
     * Please note that it might be forbidden on some domains, though.
     *
     * @return {boolean}
     */
    CosmeticRule.prototype.isGeneric = function () {
        return !this.permittedDomains || this.permittedDomains.length === 0;
    };
    /**
     * Gets list of restricted domains.
     */
    CosmeticRule.prototype.getRestrictedDomains = function () {
        return this.restrictedDomains;
    };
    CosmeticRule.prototype.isExtendedCss = function () {
        return this.extendedCss;
    };
    /**
     * Match returns true if this rule can be used on the specified request.
     *
     * @param request - request to check
     */
    CosmeticRule.prototype.match = function (request) {
        if (!this.permittedDomains && !this.restrictedDomains && !this.pathModifier) {
            return true;
        }
        if (this.matchesRestrictedDomains(request.hostname)) {
            /**
             * Domain or host is restricted
             * i.e. ~example.org##rule
             */
            return false;
        }
        if (this.hasPermittedDomains()) {
            if (!DomainModifier.isDomainOrSubdomainOfAny(request.hostname, this.permittedDomains)) {
                /**
                 * Domain is not among permitted
                 * i.e. example.org##rule and we're checking example.org
                 */
                return false;
            }
        }
        if (this.pathModifier) {
            var path = getRelativeUrl(request.urlLowercase);
            if (path) {
                return this.pathModifier.matchPathPattern(path);
            }
            return false;
        }
        return true;
    };
    CosmeticRule.parseType = function (marker) {
        switch (marker) {
            case CosmeticRuleMarker.ElementHiding:
            case CosmeticRuleMarker.ElementHidingExtCSS:
                return CosmeticRuleType.ElementHiding;
            case CosmeticRuleMarker.ElementHidingException:
            case CosmeticRuleMarker.ElementHidingExtCSSException:
                return CosmeticRuleType.ElementHiding;
            case CosmeticRuleMarker.Css:
            case CosmeticRuleMarker.CssExtCSS:
                return CosmeticRuleType.Css;
            case CosmeticRuleMarker.CssException:
            case CosmeticRuleMarker.CssExtCSSException:
                return CosmeticRuleType.Css;
            case CosmeticRuleMarker.Js:
                return CosmeticRuleType.Js;
            case CosmeticRuleMarker.JsException:
                return CosmeticRuleType.Js;
            case CosmeticRuleMarker.Html:
                return CosmeticRuleType.Html;
            case CosmeticRuleMarker.HtmlException:
                return CosmeticRuleType.Html;
            default:
                throw new SyntaxError('Unsupported rule type');
        }
    };
    /**
     * Determines if rule is allowlist rule
     * @param marker
     * @private
     */
    CosmeticRule.parseAllowlist = function (marker) {
        switch (marker) {
            case CosmeticRuleMarker.ElementHidingException:
            case CosmeticRuleMarker.ElementHidingExtCSSException:
            case CosmeticRuleMarker.CssException:
            case CosmeticRuleMarker.CssExtCSSException:
            case CosmeticRuleMarker.JsException:
            case CosmeticRuleMarker.HtmlException:
                return true;
            default:
                return false;
        }
    };
    /**
     * Validate pseudo-classes
     *
     * @param ruleText
     * @param ruleContent
     * @throws SyntaxError
     */
    CosmeticRule.validatePseudoClasses = function (ruleText, ruleContent) {
        var pseudoClass = CosmeticRule.parsePseudoClass(ruleContent);
        if (pseudoClass !== null) {
            if (CosmeticRule.SUPPORTED_PSEUDO_CLASSES.indexOf(pseudoClass) < 0) {
                throw new SyntaxError("Unknown pseudo-class '".concat(pseudoClass, "' in selector: '").concat(ruleContent, "'"));
            }
        }
    };
    /**
     * Simple validation for elemhide rules
     *
     * @param ruleText
     * @param ruleContent
     * @throws SyntaxError
     */
    CosmeticRule.validateElemhideRule = function (ruleText, ruleContent) {
        if (ruleText.startsWith(SimpleRegex.MASK_START_URL)) {
            throw new SyntaxError('Element hiding rule shouldn\'t start with "||"');
        }
        if (CosmeticRule.ELEMHIDE_VALIDATION_REGEX.test(ruleContent)) {
            throw new SyntaxError('Invalid elemhide rule, style presented');
        }
    };
    CosmeticRule.validateJsRules = function (ruleText, ruleContent) {
        if (ruleContent.startsWith(ADG_SCRIPTLET_MASK)) {
            if (!scriptlets.isValidScriptletRule(ruleText)) {
                throw new SyntaxError('Invalid scriptlet');
            }
        }
    };
    /**
     * Validates css injection rules
     *
     * @param ruleText
     * @param ruleContent
     * @throws SyntaxError
     */
    CosmeticRule.validateCssRules = function (ruleText, ruleContent) {
        // Simple validation for css injection rules
        if (!/{.+}/.test(ruleContent)) {
            throw new SyntaxError('Invalid CSS modifying rule, no style presented');
        }
        // discard css inject rules containing "url"
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1196
        if (/{.*url\(.*\)/gi.test(ruleContent)) {
            throw new SyntaxError('CSS modifying rule with \'url\' was omitted');
        }
        // discard css inject rules containing other unsafe selectors
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1920
        if (/{.*image-set\(.*\)/gi.test(ruleContent)
            || /{.*image\(.*\)/gi.test(ruleContent)
            || /{.*cross-fade\(.*\)/gi.test(ruleContent)) {
            throw new SyntaxError('CSS modifying rule with unsafe style was omitted');
        }
        // Prohibit "\" character in style of CSS injection rules
        // Check slash character only after the index of last opening curly brackets
        if (ruleContent.indexOf('\\', ruleContent.lastIndexOf('{')) > -1) {
            throw new SyntaxError('CSS injection rule with \'\\\' was omitted');
        }
    };
    /**
     * Checks if the rule has permitted domains
     */
    CosmeticRule.prototype.hasPermittedDomains = function () {
        return this.permittedDomains != null && this.permittedDomains.length > 0;
    };
    /**
     * Checks if the rule has restricted domains
     */
    CosmeticRule.prototype.hasRestrictedDomains = function () {
        return this.restrictedDomains != null && this.restrictedDomains.length > 0;
    };
    /**
     * Checks if the hostname matches permitted domains
     * @param hostname
     */
    CosmeticRule.prototype.matchesPermittedDomains = function (hostname) {
        return this.hasPermittedDomains() && DomainModifier.isDomainOrSubdomainOfAny(hostname, this.permittedDomains);
    };
    /**
     * Checks if the hostname matches the restricted domains.
     * @param hostname
     */
    CosmeticRule.prototype.matchesRestrictedDomains = function (hostname) {
        return this.hasRestrictedDomains()
            && DomainModifier.isDomainOrSubdomainOfAny(hostname, this.restrictedDomains);
    };
    /**
     * Validates cosmetic rule text
     * @param ruleText
     * @param type
     * @param content
     * @param isExtCss
     * @private
     */
    CosmeticRule.validate = function (ruleText, type, content, isExtCss) {
        if (type !== CosmeticRuleType.Css
            && type !== CosmeticRuleType.Js
            && type !== CosmeticRuleType.Html) {
            CosmeticRule.validatePseudoClasses(ruleText, content);
            if (hasUnquotedSubstring(content, '{')) {
                throw new SyntaxError('Invalid cosmetic rule, wrong brackets');
            }
        }
        if (type === CosmeticRuleType.ElementHiding) {
            CosmeticRule.validateElemhideRule(ruleText, content);
        }
        if (type === CosmeticRuleType.Css) {
            CosmeticRule.validateCssRules(ruleText, content);
        }
        if (type === CosmeticRuleType.Js) {
            CosmeticRule.validateJsRules(ruleText, content);
        }
        if ((!isExtCss && hasUnquotedSubstring(content, '/*'))
            || hasUnquotedSubstring(content, ' /*')
            || hasUnquotedSubstring(content, ' //')) {
            throw new SyntaxError('Cosmetic rule should not contain comments');
        }
    };
    /**
     * Returns the scriptlet's data consisting of the scriptlet function and its arguments.
     * This method is supposed to be used in the manifest V3 extension.
     */
    CosmeticRule.prototype.getScriptletData = function () {
        if (this.scriptletData) {
            return this.scriptletData;
        }
        this.initScript();
        return this.scriptletData;
    };
    /**
     * Updates this.scriptData and if scriptlet this.scriptletData with js ready to execute
     *
     * @param options
     */
    CosmeticRule.prototype.initScript = function (options) {
        var _a;
        if (options === void 0) { options = {}; }
        var _b = options.debug, debug = _b === void 0 ? false : _b, frameUrl = options.frameUrl;
        var ruleContent = this.getContent();
        if (!this.isScriptlet) {
            this.scriptData = {
                code: ruleContent,
            };
            return;
        }
        var scriptletContent = ruleContent.substring(ADG_SCRIPTLET_MASK.length);
        var scriptletParams = ScriptletParser.parseRule(scriptletContent);
        var params = {
            args: scriptletParams.args,
            engine: config.engine || '',
            name: scriptletParams.name,
            ruleText: this.getText(),
            verbose: debug,
            domainName: frameUrl,
            version: config.version || '',
        };
        this.scriptData = {
            code: (_a = scriptlets.invoke(params)) !== null && _a !== void 0 ? _a : null,
            debug: debug,
            frameUrl: frameUrl,
        };
        this.scriptletData = {
            func: scriptlets.getScriptletFunction(params.name),
            params: params,
        };
    };
    /**
     * The problem with pseudo-classes is that any unknown pseudo-class makes browser ignore the whole CSS rule,
     * which contains a lot more selectors. So, if CSS selector contains a pseudo-class, we should try to validate it.
     * <p>
     * One more problem with pseudo-classes is that they are actively used in uBlock, hence it may mess AG styles.
     */
    CosmeticRule.SUPPORTED_PSEUDO_CLASSES = [':active',
        ':checked', ':contains', ':disabled', ':empty', ':enabled', ':first-child', ':first-of-type',
        ':focus', ':has', ':has-text', ':hover', ':if', ':if-not', ':in-range', ':invalid', ':lang',
        ':last-child', ':last-of-type', ':link', ':matches-css', ':matches-css-before', ':matches-css-after',
        ':not', ':nth-child', ':nth-last-child', ':nth-last-of-type', ':nth-of-type',
        ':only-child', ':only-of-type', ':optional', ':out-of-range', ':read-only',
        ':read-write', ':required', ':root', ':target', ':valid', ':visited',
        ':-abp-has', ':-abp-contains', ':xpath', ':nth-ancestor', ':upward', ':remove',
        ':matches-attr', ':matches-property', ':is', ':where'];
    CosmeticRule.ELEMHIDE_VALIDATION_REGEX = / {.+}/;
    return CosmeticRule;
}());

/**
 * CosmeticEngine combines all the cosmetic rules and allows to quickly
 * find all rules matching this or that hostname
 * It is primarily used by the {@see Engine}
 */
var CosmeticEngine = /** @class */ (function () {
    /**
     * Builds instance of cosmetic engine
     *
     * @param ruleStorage
     * @param skipStorageScan create an instance without storage scanning
     */
    function CosmeticEngine(ruleStorage, skipStorageScan) {
        if (skipStorageScan === void 0) { skipStorageScan = false; }
        this.ruleStorage = ruleStorage;
        this.rulesCount = 0;
        this.elementHidingLookupTable = new CosmeticLookupTable(ruleStorage);
        this.cssLookupTable = new CosmeticLookupTable(ruleStorage);
        this.jsLookupTable = new CosmeticLookupTable(ruleStorage);
        this.htmlLookupTable = new CosmeticLookupTable(ruleStorage);
        if (skipStorageScan) {
            return;
        }
        var scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.CosmeticRules);
        while (scanner.scan()) {
            var indexedRule = scanner.getRule();
            if (indexedRule
                && indexedRule.rule instanceof CosmeticRule) {
                this.addRule(indexedRule.rule, indexedRule.index);
            }
        }
    }
    /**
     * Adds rules into appropriate tables
     * @param rule
     * @param storageIdx
     */
    CosmeticEngine.prototype.addRule = function (rule, storageIdx) {
        switch (rule.getType()) {
            case CosmeticRuleType.ElementHiding: {
                this.elementHidingLookupTable.addRule(rule, storageIdx);
                break;
            }
            case CosmeticRuleType.Css: {
                this.cssLookupTable.addRule(rule, storageIdx);
                break;
            }
            case CosmeticRuleType.Js: {
                this.jsLookupTable.addRule(rule, storageIdx);
                break;
            }
            case CosmeticRuleType.Html: {
                this.htmlLookupTable.addRule(rule, storageIdx);
                break;
            }
        }
        this.rulesCount += 1;
    };
    /**
     * Checks if bitwise mask matches option
     * @param option
     * @param targetOption
     */
    CosmeticEngine.matchOption = function (option, targetOption) {
        return (option & targetOption) === targetOption;
    };
    /**
     * Prepares cosmetic result by request
     *
     * @param request - request to match
     * @param option mask of enabled cosmetic types
     * @return CosmeticResult
     */
    CosmeticEngine.prototype.match = function (request, option) {
        var includeGeneric = CosmeticEngine.matchOption(option, CosmeticOption.CosmeticOptionGenericCSS);
        var includeSpecific = CosmeticEngine.matchOption(option, CosmeticOption.CosmeticOptionSpecificCSS);
        var includeJs = CosmeticEngine.matchOption(option, CosmeticOption.CosmeticOptionJS);
        var includeHtml = CosmeticEngine.matchOption(option, CosmeticOption.CosmeticOptionHtml);
        var cosmeticResult = new CosmeticResult();
        if (includeGeneric) {
            CosmeticEngine.appendGenericRules(cosmeticResult.elementHiding, this.elementHidingLookupTable, request);
            CosmeticEngine.appendGenericRules(cosmeticResult.CSS, this.cssLookupTable, request);
        }
        if (includeSpecific) {
            CosmeticEngine.appendSpecificRules(cosmeticResult.elementHiding, this.elementHidingLookupTable, request);
            CosmeticEngine.appendSpecificRules(cosmeticResult.CSS, this.cssLookupTable, request);
        }
        if (includeJs) {
            CosmeticEngine.appendGenericRules(cosmeticResult.JS, this.jsLookupTable, request);
            CosmeticEngine.appendSpecificRules(cosmeticResult.JS, this.jsLookupTable, request);
        }
        if (includeHtml) {
            if (includeGeneric) {
                CosmeticEngine.appendGenericRules(cosmeticResult.Html, this.htmlLookupTable, request);
            }
            CosmeticEngine.appendSpecificRules(cosmeticResult.Html, this.htmlLookupTable, request);
        }
        return cosmeticResult;
    };
    /**
     * Selects generic rules and appends rules content to cosmetic result
     * @param cosmeticResult
     * @param lookupTable
     * @param request
     */
    CosmeticEngine.appendGenericRules = function (cosmeticResult, lookupTable, request) {
        for (var _i = 0, _a = lookupTable.genericRules; _i < _a.length; _i++) {
            var genericRule = _a[_i];
            if (!lookupTable.isAllowlisted(request, genericRule)
                && genericRule.match(request)) {
                cosmeticResult.append(genericRule, request);
            }
        }
    };
    /**
     * Selects specific rules and appends rules content to cosmetic result
     * @param cosmeticResult
     * @param lookupTable
     * @param request
     */
    CosmeticEngine.appendSpecificRules = function (cosmeticResult, lookupTable, request) {
        var hostnameRules = lookupTable.findByHostname(request);
        if (hostnameRules.length > 0) {
            for (var _i = 0, hostnameRules_1 = hostnameRules; _i < hostnameRules_1.length; _i++) {
                var rule = hostnameRules_1[_i];
                if (!lookupTable.isAllowlisted(request, rule)) {
                    cosmeticResult.append(rule, request);
                }
            }
        }
    };
    return CosmeticEngine;
}());

/**
 * Engine represents the filtering engine with all the loaded rules
 */
var Engine = /** @class */ (function () {
    /**
     * Creates an instance of an Engine
     * Parses the filtering rules and creates a filtering engine of them
     *
     * @param ruleStorage storage
     * @param skipStorageScan create an instance without storage scanning
     * @throws
     */
    function Engine(ruleStorage, skipStorageScan) {
        if (skipStorageScan === void 0) { skipStorageScan = false; }
        this.ruleStorage = ruleStorage;
        this.networkEngine = new NetworkEngine(ruleStorage, skipStorageScan);
        this.cosmeticEngine = new CosmeticEngine(ruleStorage, skipStorageScan);
        this.resultCache = new lru.exports.LRUMap(Engine.REQUEST_CACHE_SIZE);
    }
    /**
     * Loads rules to engine
     */
    Engine.prototype.loadRules = function () {
        var scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.NetworkRules | ScannerType.CosmeticRules);
        while (scanner.scan()) {
            this.addRule(scanner.getRule());
        }
    };
    /**
     * Async loads rules to engine
     *
     * @param chunkSize size of rules chunk to load at a time
     */
    Engine.prototype.loadRulesAsync = function (chunkSize) {
        return __awaiter(this, void 0, void 0, function () {
            var scanner, counter;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.NetworkRules | ScannerType.CosmeticRules);
                        counter = 0;
                        _a.label = 1;
                    case 1:
                        if (!scanner.scan()) return [3 /*break*/, 4];
                        counter += 1;
                        if (!(counter >= chunkSize)) return [3 /*break*/, 3];
                        counter = 0;
                        /**
                         * In some cases UI thread becomes blocked while adding rules to engine,
                         * that't why we create filter rules using chunks of the specified length
                         * Rules creation is rather slow operation so we should
                         * use setTimeout calls to give UI thread some time.
                         */
                        return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, 1); })];
                    case 2:
                        /**
                         * In some cases UI thread becomes blocked while adding rules to engine,
                         * that't why we create filter rules using chunks of the specified length
                         * Rules creation is rather slow operation so we should
                         * use setTimeout calls to give UI thread some time.
                         */
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        this.addRule(scanner.getRule());
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Matches the specified request against the filtering engine and returns the matching result.
     *
     * @param request - request to check
     * @param frameRule - source document rule or null
     * @return matching result
     */
    Engine.prototype.matchRequest = function (request, frameRule) {
        if (frameRule === void 0) { frameRule = null; }
        var cacheKey = "".concat(request.url, "#").concat(request.sourceHostname, "#").concat(request.requestType);
        if (request.method) {
            cacheKey += "#".concat(request.method);
        }
        /**
         * Add frame url text to the key to avoid caching,
         * because allowlist rules are not stored in the engine
         * AG-12694
         */
        if (frameRule) {
            cacheKey += "#".concat(frameRule.getText());
        }
        var res = this.resultCache.get(cacheKey);
        if (res) {
            return res;
        }
        var networkRules = this.networkEngine.matchAll(request);
        var result = new MatchingResult(networkRules, frameRule);
        this.resultCache.set(cacheKey, result);
        return result;
    };
    /**
     * Matches current frame and returns document-level allowlist rule if found.
     *
     * @param frameUrl
     */
    Engine.prototype.matchFrame = function (frameUrl) {
        var sourceRequest = new Request(frameUrl, '', RequestType.Document);
        var sourceRules = this.networkEngine.matchAll(sourceRequest);
        sourceRules = MatchingResult.removeBadfilterRules(sourceRules);
        var result = null;
        sourceRules.forEach(function (r) {
            if (r.isDocumentLevelAllowlistRule()) {
                if (!result || r.isHigherPriority(result)) {
                    result = r;
                }
            }
        });
        return result;
    };
    /**
     * Gets cosmetic result for the specified hostname and cosmetic options
     *
     * @param request host to check
     * @param option mask of enabled cosmetic types
     * @return cosmetic result
     */
    Engine.prototype.getCosmeticResult = function (request, option) {
        return this.cosmeticEngine.match(request, option);
    };
    /**
     * Gets rules count
     */
    Engine.prototype.getRulesCount = function () {
        return this.networkEngine.rulesCount + this.cosmeticEngine.rulesCount;
    };
    /**
     * Adds rules to engines
     *
     * @param indexedRule
     */
    Engine.prototype.addRule = function (indexedRule) {
        if (indexedRule) {
            if (indexedRule.rule instanceof NetworkRule) {
                this.networkEngine.addRule(indexedRule.rule, indexedRule.index);
            }
            else if (indexedRule.rule instanceof CosmeticRule) {
                this.cosmeticEngine.addRule(indexedRule.rule, indexedRule.index);
            }
        }
    };
    /**
     * Request's cache size
     * Used as both source rules and others limit.
     * The value is based on benchmark runs.
     */
    Engine.REQUEST_CACHE_SIZE = 500;
    return Engine;
}());

/**
 * Rule with index
 */
var IndexedRule = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param rule
     * @param index
     */
    function IndexedRule(rule, index) {
        this.rule = rule;
        this.index = index;
    }
    return IndexedRule;
}());
/**
 * Rule with storage index
 */
var IndexedStorageRule = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param rule
     * @param index
     */
    function IndexedStorageRule(rule, index) {
        this.rule = rule;
        this.index = index;
    }
    return IndexedStorageRule;
}());

/**
 * Export logger implementation
 */
var logger = console;
/**
 * Set logger implementation
 *
 * @param loggerImpl
 */
function setLogger(loggerImpl) {
    logger = loggerImpl;
}

/**
 * Rule builder class
 */
var RuleFactory = /** @class */ (function () {
    function RuleFactory() {
    }
    /**
     * Creates rule of suitable class from text string
     * It returns null if the line is empty or if it is a comment
     *
     * TODO: Pack `ignore*` parameters and `silent` into one object with flags.
     *
     * @param text rule string
     * @param filterListId list id
     * @param ignoreNetwork do not create network rules
     * @param ignoreCosmetic do not create cosmetic rules
     * @param ignoreHost do not create host rules
     * @param silent Log the error for `true`, otherwise throw an exception on
     * a rule creation
     *
     * @throws Error when `silent` flag is passed as false on rule creation error.
     *
     * @return IRule object or null
     */
    RuleFactory.createRule = function (text, filterListId, ignoreNetwork, ignoreCosmetic, ignoreHost, silent) {
        if (ignoreNetwork === void 0) { ignoreNetwork = false; }
        if (ignoreCosmetic === void 0) { ignoreCosmetic = false; }
        if (ignoreHost === void 0) { ignoreHost = true; }
        if (silent === void 0) { silent = true; }
        if (!text || RuleFactory.isComment(text)) {
            return null;
        }
        if (RuleFactory.isShort(text)) {
            logger.info("The rule is too short: ".concat(text));
        }
        var line = text.trim();
        try {
            if (RuleFactory.isCosmetic(line)) {
                if (ignoreCosmetic) {
                    return null;
                }
                return new CosmeticRule(line, filterListId);
            }
            if (!ignoreHost) {
                var hostRule = RuleFactory.createHostRule(line, filterListId);
                if (hostRule) {
                    return hostRule;
                }
            }
            if (!ignoreNetwork) {
                return new NetworkRule(line, filterListId);
            }
        }
        catch (e) {
            var msg = "\"".concat(getErrorMessage(e), "\" in the rule: \"").concat(line, "\"");
            if (silent) {
                logger.info("Error: ".concat(msg));
            }
            else {
                throw new Error(msg);
            }
        }
        return null;
    };
    /**
     * Creates host rule from text
     *
     * @param ruleText
     * @param filterListId
     */
    RuleFactory.createHostRule = function (ruleText, filterListId) {
        var rule = new HostRule(ruleText, filterListId);
        return rule.isInvalid() ? null : rule;
    };
    /**
     * Checks if rule is short
     */
    RuleFactory.isShort = function (rule) {
        if (!rule) {
            return true;
        }
        return !!(rule && rule.length <= 3);
    };
    /**
     * Checks if the rule is cosmetic or not.
     * @param ruleText - rule text to check.
     */
    RuleFactory.isCosmetic = function (ruleText) {
        var marker = findCosmeticRuleMarker(ruleText);
        return marker[0] !== -1;
    };
    /**
     * If text is comment
     *
     * @param text
     */
    RuleFactory.isComment = function (text) {
        if (text.charAt(0) === '!') {
            return true;
        }
        if (text.charAt(0) === '#') {
            if (text.length === 1) {
                return true;
            }
            // Now we should check that this is not a cosmetic rule
            return !RuleFactory.isCosmetic(text);
        }
        return false;
    };
    return RuleFactory;
}());

/**
 * Rule scanner implements an interface for reading filtering rules.
 */
var RuleScanner = /** @class */ (function () {
    /**
     * NewRuleScanner returns a new RuleScanner to read from r.
     *
     * @param reader source of the filtering rules
     * @param listId filter list ID
     * @param configuration config object
     */
    function RuleScanner(reader, listId, configuration) {
        /**
         *  Current rule
         */
        this.currentRule = null;
        /**
         * Index of the beginning of the current rule
         */
        this.currentRuleIndex = 0;
        /**
         * Current position in the reader
         */
        this.currentPos = 0;
        this.reader = reader;
        this.listId = listId;
        this.ignoreCosmetic = !!configuration.ignoreCosmetic
            || ((configuration.scannerType & ScannerType.CosmeticRules) !== ScannerType.CosmeticRules);
        this.ignoreNetwork = (configuration.scannerType & ScannerType.NetworkRules) !== ScannerType.NetworkRules;
        this.ignoreHost = (configuration.scannerType & ScannerType.HostRules) !== ScannerType.HostRules;
        this.ignoreJS = !!configuration.ignoreJS;
        this.ignoreUnsafe = !!configuration.ignoreUnsafe;
    }
    /**
     * Scan advances the RuleScanner to the next rule, which will then be available
     * through the Rule method.
     *
     * @return false when the scan stops, either by
     * reaching the end of the input or an error.
    */
    RuleScanner.prototype.scan = function () {
        while (true) {
            var lineIndex = this.currentPos;
            var line = this.readNextLine();
            if (line === null) {
                return false;
            }
            if (line) {
                var rule = RuleFactory.createRule(line, this.listId, this.ignoreNetwork, this.ignoreCosmetic, this.ignoreHost);
                if (rule && !this.isIgnored(rule)) {
                    this.currentRule = rule;
                    this.currentRuleIndex = lineIndex;
                    return true;
                }
            }
        }
    };
    /**
     * @return the most recent rule generated by a call to Scan, and the index of this rule's text.
     */
    RuleScanner.prototype.getRule = function () {
        if (this.currentRule) {
            return new IndexedRule(this.currentRule, this.currentRuleIndex);
        }
        return null;
    };
    /**
     * Reads the next line and returns it
     *
     * @return next line string or null
     */
    RuleScanner.prototype.readNextLine = function () {
        var line = this.reader.readLine();
        if (line != null) {
            this.currentPos += line.length + 1;
            return line.trim();
        }
        return null;
    };
    /**
     * Checks if the rule should be ignored by this scanner
     *
     * @param rule to check
     * @return is rule ignored
     */
    RuleScanner.prototype.isIgnored = function (rule) {
        if (!this.ignoreCosmetic && !this.ignoreJS && !this.ignoreUnsafe) {
            return false;
        }
        if (rule instanceof CosmeticRule) {
            if (this.ignoreCosmetic) {
                return true;
            }
            // Ignore JS type rules
            // TODO: in the future we may allow CSS rules and Scriptlets (except for "trusted" scriptlets)
            return (this.ignoreJS && rule.getType() === CosmeticRuleType.Js);
        }
        if (this.ignoreUnsafe) {
            if (rule instanceof NetworkRule) {
                if (rule.getAdvancedModifier() && (rule.getAdvancedModifier() instanceof RemoveHeaderModifier)) {
                    return true;
                }
            }
        }
        return false;
    };
    return RuleScanner;
}());

/**
 * Reads string line by line
 */
var StringLineReader = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param text
     */
    function StringLineReader(text) {
        /**
         * Current position
         */
        this.currentIndex = 0;
        this.text = text;
    }
    /**
     * Reads next line
     *
     * @return text or null on end
     */
    StringLineReader.prototype.readLine = function () {
        if (this.currentIndex === -1) {
            return null;
        }
        var startIndex = this.currentIndex;
        this.currentIndex = this.text.indexOf('\n', startIndex);
        if (this.currentIndex === -1) {
            return this.text.substring(startIndex);
        }
        this.currentIndex += 1;
        // - 1 in order to exclude EOL
        return this.text.substring(startIndex, this.currentIndex - 1);
    };
    return StringLineReader;
}());

/**
 * List identifier max value.
 * We use "number" type for storage indexes, so we have some limits for list identifiers,
 * We line number for rule index, so if we save 11 ranks for rules, then we have 6 ranks left for list ids.
 * Check RuleStorageScanner class for more info.
 */
var LIST_ID_MAX_VALUE = Math.pow(10, 6);
/**
 * StringRuleList represents a string-based rule list
 */
var StringRuleList = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param listId
     * @param ruleText
     * @param ignoreCosmetic (Optional) default false
     * @param ignoreJS (Optional) default false
     * @param ignoreUnsafe (Optional) default false
     */
    function StringRuleList(listId, ruleText, ignoreCosmetic, ignoreJS, ignoreUnsafe) {
        if (listId >= LIST_ID_MAX_VALUE) {
            throw new Error("Invalid list identifier, it must be less than ".concat(LIST_ID_MAX_VALUE));
        }
        this.id = listId;
        this.rulesText = ruleText;
        this.ignoreCosmetic = !!ignoreCosmetic;
        this.ignoreJS = !!ignoreJS;
        this.ignoreUnsafe = !!ignoreUnsafe;
    }
    /**
     * Close does nothing as here's nothing to close in the StringRuleList
     */
    // eslint-disable-next-line class-methods-use-this
    StringRuleList.prototype.close = function () {
        // Empty
    };
    /**
     * @return the rule list identifier
     */
    StringRuleList.prototype.getId = function () {
        return this.id;
    };
    /**
     * Creates a new rules scanner that reads the list contents
     * @return scanner object
     */
    StringRuleList.prototype.newScanner = function (scannerType) {
        var reader = new StringLineReader(this.rulesText);
        return new RuleScanner(reader, this.id, {
            scannerType: scannerType,
            ignoreCosmetic: this.ignoreCosmetic,
            ignoreJS: this.ignoreJS,
            ignoreUnsafe: this.ignoreUnsafe,
        });
    };
    /**
     * Finds rule text by its index.
     * If there's no rule by that index or rule is invalid, it will return null
     *
     * @param ruleIdx
     * @return rule text or null
     */
    StringRuleList.prototype.retrieveRuleText = function (ruleIdx) {
        if (ruleIdx < 0 || ruleIdx >= this.rulesText.length) {
            return null;
        }
        var endOfLine = this.rulesText.indexOf('\n', ruleIdx);
        if (endOfLine === -1) {
            endOfLine = this.rulesText.length;
        }
        var line = this.rulesText.substring(ruleIdx, endOfLine).trim();
        if (!line) {
            return null;
        }
        return line;
    };
    return StringRuleList;
}());

/**
 * RuleStorageScanner scans multiple RuleScanner instances
 * The rule index is built from the rule index in the list + the list ID
 * In the index number we consider decimal part as listId and integer part as ruleId
*/
var RuleStorageScanner = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param scanners
     */
    function RuleStorageScanner(scanners) {
        /**
         * Current scanner
         */
        this.currentScanner = null;
        /**
         * Index of the current scanner
         */
        this.currentScannerIdx = -1;
        this.scanners = scanners;
    }
    /**
     * Scan advances the RuleStorageScanner to the next rule, which will then be available
     * through the Rule method. It returns false when the scan stops, either by
     * reaching the end of the input or an error.
     *
     * @return true if there is some result
    */
    RuleStorageScanner.prototype.scan = function () {
        if (this.scanners.length === 0) {
            return false;
        }
        if (!this.currentScanner) {
            this.currentScannerIdx = 0;
            this.currentScanner = this.scanners[this.currentScannerIdx];
        }
        while (true) {
            if (this.currentScanner.scan()) {
                return true;
            }
            // Take the next scanner or just return false if there's nothing more
            if (this.currentScannerIdx === (this.scanners.length - 1)) {
                return false;
            }
            this.currentScannerIdx += 1;
            this.currentScanner = this.scanners[this.currentScannerIdx];
        }
    };
    /**
     * Rule returns the most recent rule generated by a call to Scan, and the index of this rule.
     * See ruleListIdxToStorageIdx for more information on what this index is.
    */
    RuleStorageScanner.prototype.getRule = function () {
        if (!this.currentScanner) {
            return null;
        }
        var rule = this.currentScanner.getRule();
        if (!rule) {
            return null;
        }
        var index = RuleStorageScanner.ruleListIdxToStorageIdx(rule.rule.getFilterListId(), rule.index);
        return new IndexedStorageRule(rule.rule, index);
    };
    /**
     * ruleListIdxToStorageIdx converts pair of listID and rule list index
     * to "storage index" number
     *
     * @param listId
     * @param ruleIdx
     */
    RuleStorageScanner.ruleListIdxToStorageIdx = function (listId, ruleIdx) {
        return listId / LIST_ID_MAX_VALUE + ruleIdx;
    };
    /**
     * Converts the "storage index" to two integers:
     * listID -- rule list identifier
     * ruleIdx -- index of the rule in the list
     *
     * @param storageIdx
     * @return [listId, ruleIdx]
     */
    RuleStorageScanner.storageIdxToRuleListIdx = function (storageIdx) {
        var listId = Math.round((storageIdx % 1) * LIST_ID_MAX_VALUE);
        var ruleIdx = Math.trunc(storageIdx);
        return [listId, ruleIdx];
    };
    return RuleStorageScanner;
}());

/**
 * Rule list's cache
 */
var ListCache = /** @class */ (function () {
    /**
     * Constructor
     */
    function ListCache() {
        this.cache = new Map();
    }
    /**
     * @param key
     * @return rule for specified key
     */
    ListCache.prototype.get = function (key) {
        return this.cache.get(key);
    };
    /**
     * Sets rule for specified key
     *
     * @param key
     * @param rule
     */
    ListCache.prototype.set = function (key, rule) {
        this.cache.set(key, rule);
    };
    return ListCache;
}());

/**
 * RuleStorage is an abstraction that combines several rule lists
 * It can be scanned using RuleStorageScanner, and also it allows
 * retrieving rules by its index

 * The idea is to keep rules in a serialized format (even original format in the case of FileRuleList)
 * and create them in a lazy manner only when we really need them. When the filtering engine is
 * being initialized, we need to scan the rule lists once in order to fill up the lookup tables.
 * We use rule indexes as a unique rule identifier instead of the rule itself.
 * The rule is created (see RetrieveRule) only when there's a chance that it's needed.

 * Rule index is an int64 value that actually consists of two int32 values:
 * One is the rule list identifier, and the second is the index of the rule inside of that list.
*/
var RuleStorage = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param lists rule lists array
     *
     * @throws on duplicate lists
     */
    function RuleStorage(lists) {
        var _this = this;
        this.lists = lists;
        this.listsMap = new Map();
        this.cache = new Map();
        this.lists.forEach(function (list) {
            var filterListId = list.getId();
            if (_this.listsMap.get(filterListId)) {
                throw new Error("Duplicate list ID: ".concat(filterListId));
            }
            _this.listsMap.set(filterListId, list);
        });
    }
    /**
     * Creates a new instance of RuleStorageScanner.
     * It can be used to read and parse all the storage contents.
     *
     * @return scanner instance
     */
    RuleStorage.prototype.createRuleStorageScanner = function (scannerType) {
        var scanners = this.lists.map(function (list) { return list.newScanner(scannerType); });
        return new RuleStorageScanner(scanners);
    };
    /**
     * Looks for the filtering rule in this storage
     *
     * @param storageIdx the lookup index that you can get from the rule storage scanner
     * @param ignoreHost rules could be retrieved as host rules
     */
    RuleStorage.prototype.retrieveRule = function (storageIdx, ignoreHost) {
        if (ignoreHost === void 0) { ignoreHost = true; }
        var _a = RuleStorageScanner.storageIdxToRuleListIdx(storageIdx), listId = _a[0], ruleIdx = _a[1];
        var rule = this.getFromCache(listId, ruleIdx);
        if (rule) {
            return rule;
        }
        var list = this.listsMap.get(listId);
        if (!list) {
            // List doesn't exist
            return null;
        }
        var ruleText = list.retrieveRuleText(ruleIdx);
        if (!ruleText) {
            return null;
        }
        var result = RuleFactory.createRule(ruleText, listId, false, false, ignoreHost);
        if (result) {
            this.saveToCache(listId, ruleIdx, result);
        }
        return result;
    };
    /**
     * RetrieveNetworkRule is a helper method that retrieves a network rule from the storage
     *
     * @param storageIdx
     * @return the rule or nil in any other case (not found or error)
     */
    RuleStorage.prototype.retrieveNetworkRule = function (storageIdx) {
        var rule = this.retrieveRule(storageIdx);
        if (!rule) {
            return null;
        }
        if (rule instanceof NetworkRule) {
            return rule;
        }
        return null;
    };
    /**
     * RetrieveHostRule is a helper method that retrieves a host rule from the storage
     *
     * @param storageIdx
     * @return the rule or nil in any other case (not found or error)
     */
    RuleStorage.prototype.retrieveHostRule = function (storageIdx) {
        var rule = this.retrieveRule(storageIdx, false);
        if (!rule) {
            return null;
        }
        if (rule instanceof HostRule) {
            return rule;
        }
        return null;
    };
    /**
     * Saves rule to cache
     *
     * @param listId
     * @param ruleIdx
     * @param rule
     */
    RuleStorage.prototype.saveToCache = function (listId, ruleIdx, rule) {
        var listCache = this.cache.get(listId);
        if (!listCache) {
            listCache = new ListCache();
            this.cache.set(listId, listCache);
        }
        listCache.set(ruleIdx, rule);
    };
    /**
     * Retrieves rule form cache
     *
     * @param listId
     * @param ruleIdx
     */
    RuleStorage.prototype.getFromCache = function (listId, ruleIdx) {
        var listCache = this.cache.get(listId);
        if (!listCache) {
            return undefined;
        }
        return listCache.get(ruleIdx);
    };
    return RuleStorage;
}());

/**
 * Rule converter class
 */
var RuleConverter = /** @class */ (function () {
    function RuleConverter() {
    }
    /**
     * Converts rules text
     *
     * @param rulesText
     */
    RuleConverter.convertRules = function (rulesText) {
        var result = [];
        var lines = rulesText.split(/\r?\n/);
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
            var line = lines_1[_i];
            try {
                result.push.apply(result, RuleConverter.convertRule(line));
            }
            catch (e) {
                logger.warn(e.message);
            }
        }
        return result.join('\n');
    };
    /**
     * TODO for more efficient conversion build AST. And then use the modified AST for creating a
     *  rule object.
     * Convert external scriptlet rule to AdGuard scriptlet syntax
     *
     * @param rawRule
     */
    RuleConverter.convertRule = function (rawRule) {
        var rule = rawRule.trim();
        if (rule.startsWith(SimpleRegex.MASK_COMMENT) || rule === '') {
            return [rule];
        }
        var comment = RuleConverter.convertUboComments(rule);
        if (comment) {
            return [comment];
        }
        var converted = rule;
        if (RuleFactory.isCosmetic(rule)) {
            converted = RuleConverter.convertCssInjection(converted);
            converted = RuleConverter.convertPseudoElements(converted);
            converted = RuleConverter.convertRemoveRule(converted);
            converted = RuleConverter.convertScriptHasTextToScriptTagContent(converted);
            converted = RuleConverter.convertUboMatchesPathRule(converted);
            // special case for ubo response header rule, it looks like cosmetic rule, but is converted to network rule
            var removeHeaderRule = RuleConverter.convertUboResponseHeaderRule(converted);
            if (removeHeaderRule) {
                return [removeHeaderRule];
            }
        }
        else {
            var domainAndOptions = RuleConverter.splitIntoDomainAndOptions(converted);
            var domain = domainAndOptions[0];
            var optionsParts = domainAndOptions[1];
            if (optionsParts) {
                optionsParts = RuleConverter.replaceOptions(optionsParts);
                var ruleWithConvertedOptions = RuleConverter.convertOptions(domain, optionsParts);
                if (ruleWithConvertedOptions) {
                    return ruleWithConvertedOptions;
                }
                converted = "".concat(domain, "$").concat(optionsParts.join(','));
            }
        }
        var scriptletRules = scriptlets.convertScriptletToAdg(converted);
        // TODO Check if isValidScriptletRule call is needed here, looks like convertScriptletToAdg
        //  should already return a valid scriptlet.
        if (scriptletRules && scriptletRules.every(function (x) { return RuleConverter.isValidScriptletRule(x); })) {
            return scriptletRules;
        }
        var adgRedirectRule = RuleConverter.convertUboAndAbpRedirectsToAdg(converted);
        if (adgRedirectRule) {
            return [adgRedirectRule];
        }
        if (converted.includes(RuleConverter.UBO_HTML_RULE_MASK)) {
            throw new SyntaxError("Invalid UBO script rule: ".concat(converted));
        }
        return [converted];
    };
    /**
     * Validates AdGuard syntax scriptlet rule.
     *
     * @param ruleText AdGuard scriptlet rule.
     */
    RuleConverter.isValidScriptletRule = function (ruleText) {
        try {
            // checks whether the ADG scriptlet rule name is valid
            return scriptlets.isValidScriptletRule(ruleText);
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Converts UBO Script rule
     *
     * @param {string} ruleText rule text
     * @returns {string} converted rule
     */
    RuleConverter.convertScriptHasTextToScriptTagContent = function (ruleText) {
        if (ruleText.startsWith(SimpleRegex.MASK_COMMENT)
            || !RuleConverter.SCRIPT_HAS_TEXT_REGEX.test(ruleText)
            || RuleConverter.CSS_COMBINATORS_REGEX.test(ruleText)) {
            return ruleText;
        }
        var convertedRuleText = ruleText;
        var attributeStrings = [];
        // Cut all attributes substrings from rule text into array
        // https://github.com/AdguardTeam/tsurlfilter/issues/55
        if (RuleConverter.ATTRIBUTE_REGEX.test(ruleText)) {
            var globalAttributeRegExp = new RegExp(RuleConverter.ATTRIBUTE_REGEX, 'gi');
            attributeStrings = ruleText.match(globalAttributeRegExp);
            attributeStrings === null || attributeStrings === void 0 ? void 0 : attributeStrings.forEach(function (attrStr) {
                convertedRuleText = convertedRuleText.replace(attrStr, '');
            });
        }
        // Convert base of the rule ##^script:has-text(text) to $$script[tag-content='text']
        convertedRuleText = "".concat(convertedRuleText
            .replace(RuleConverter.SCRIPT_HAS_TEXT_REGEX_SHORT, RuleConverter.SCRIPT_HAS_TEXT_REPLACEMENT)
            .slice(0, -1), "\"][max-length=\"262144\"]");
        // Escape double quotes inside tag-content, like it is required by AdGuard syntax
        // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#tag-content
        convertedRuleText = convertedRuleText.replace(RuleConverter.TAG_CONTENT_VALUE_REGEX, function (match, group) {
            return "[tag-content=\"".concat(group.replace(/"/g, '""'), "\"]");
        });
        // Return attributes if there were any
        attributeStrings === null || attributeStrings === void 0 ? void 0 : attributeStrings.forEach(function (attrStr) {
            convertedRuleText += attrStr;
        });
        return convertedRuleText;
    };
    /**
     * Converts UBO and ABP redirect rules to AdGuard redirect rules
     * @param rule
     * @return {string} convertedRule
     */
    RuleConverter.convertUboAndAbpRedirectsToAdg = function (rule) {
        var redirects = scriptlets.redirects;
        if (redirects.isUboRedirectCompatibleWithAdg(rule) || redirects.isAbpRedirectCompatibleWithAdg(rule)) {
            return redirects.convertRedirectToAdg(rule);
        }
        return null;
    };
    /**
     * Converts the rule options according to the conversion map and handles special cases.
     * @param domainPart - The domain part of the rule.
     * @param optionsParts - The options part of the rule as an array of strings.
     * @private
     */
    RuleConverter.convertOptions = function (domainPart, optionsParts) {
        var NAME_VALUE_SPLITTER = '=';
        var areOptionsConverted = false;
        var updatedOptionsParts = optionsParts.map(function (optionsPart) {
            var convertedOptionsPart = RuleConverter.OPTIONS_CONVERSION_MAP.get(optionsPart);
            // If option is $mp4, then it should go with $media option together
            if (optionsPart === 'mp4') {
                // Check if media is not already among options
                if (!optionsParts.some(function (option) { return option === 'media'; })) {
                    convertedOptionsPart = "".concat(convertedOptionsPart, ",media");
                }
            }
            if (convertedOptionsPart) {
                areOptionsConverted = true;
                return convertedOptionsPart;
            }
            return optionsPart;
        });
        // If options have more than one csp modifiers, we merge them into one;
        var cspParts = updatedOptionsParts.filter(function (optionsPart) { return optionsPart.startsWith('csp'); });
        if (cspParts.length > 1) {
            var allButCsp = updatedOptionsParts.filter(function (optionsPart) { return !optionsPart.startsWith('csp'); });
            var cspValues = cspParts.map(function (cspPart) { return cspPart.split(NAME_VALUE_SPLITTER)[1]; });
            var updatedCspOption = "csp".concat(NAME_VALUE_SPLITTER).concat(cspValues.join('; '));
            updatedOptionsParts = allButCsp.concat(updatedCspOption);
        }
        if (areOptionsConverted) {
            var updatedOptions = updatedOptionsParts.join(',');
            return ["".concat(domainPart, "$").concat(updatedOptions)];
        }
        return null;
    };
    /**
     * Converts ubo syntax comments (rules starting with #)
     * Note: It's not possible to detect 100% cause rules starting with ## are valid elemhide rules
     *
     * @param rule
     * @return {string}
     */
    RuleConverter.convertUboComments = function (rule) {
        if (rule.startsWith('# ') || rule.startsWith('####')) {
            return "! ".concat(rule);
        }
        return null;
    };
    /**
     * Executes rule css conversion
     *
     * @param rule
     * @param parts
     * @param ruleMark
     */
    RuleConverter.executeConversion = function (rule, parts, ruleMark) {
        var result = rule;
        var domain = parts[0];
        if (domain) {
            var rulePart = parts[1];
            if (rulePart.match(RuleConverter.CSS_RULE_REPLACE_PATTERN)) {
                var groups = RuleConverter.CSS_RULE_REPLACE_PATTERN.exec(rulePart);
                if (groups != null) {
                    if (groups.length === 3) {
                        result = domain + ruleMark;
                        result += "".concat(groups[1], " { ").concat(groups[2], " }");
                    }
                }
            }
        }
        return result;
    };
    /**
     * Adds colon to the pseudo elements written with one colon (:before, :after);
     * e.g.
     *  "hotline.ua##.reset-scroll:before" -> "hotline.ua##.reset-scroll::before"
     * @param rule
     * @private
     */
    RuleConverter.convertPseudoElements = function (rule) {
        var BEFORE = 'before';
        var AFTER = 'after';
        var SINGLE_COLON = ':';
        // does not have parts to convert
        if (!(rule.includes(SINGLE_COLON + BEFORE) || rule.includes(SINGLE_COLON + AFTER))) {
            return rule;
        }
        // not an css rule
        if (!(rule.includes(RuleConverter.MASK_ELEMENT_HIDING)
            || rule.includes(RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION)
            || rule.includes(RuleConverter.MASK_CSS)
            || rule.includes(RuleConverter.MASK_CSS_EXCEPTION))) {
            return rule;
        }
        var modifiedRule = '';
        for (var i = 0; i < rule.length; i += 1) {
            if (rule[i] !== SINGLE_COLON) {
                modifiedRule += rule[i];
                continue;
            }
            if ((rule.indexOf(BEFORE, i) === i + 1
                || rule.indexOf(AFTER, i) === i + 1)
                && rule[i - 1] !== SINGLE_COLON) {
                modifiedRule += SINGLE_COLON;
                modifiedRule += rule[i];
                continue;
            }
            modifiedRule += rule[i];
        }
        return modifiedRule;
    };
    /**
     * Converts CSS injection
     * example.com##h1:style(background-color: blue !important)
     * into
     * example.com#$#h1 { background-color: blue !important }
     * <p>
     * OR (for exceptions):
     * example.com#@#h1:style(background-color: blue !important)
     * into
     * example.com#@$#h1 { background-color: blue !important }
     *
     * @param {string} rule
     * @return {string} convertedRule
     */
    RuleConverter.convertCssInjection = function (rule) {
        if (rule.includes(':style')) {
            var parts = void 0;
            var resultMask = void 0;
            var resultRule = rule;
            var isExtendedCss = false;
            for (var i = 0; i < EXT_CSS_PSEUDO_INDICATORS.length; i += 1) {
                isExtendedCss = rule.indexOf(EXT_CSS_PSEUDO_INDICATORS[i]) !== -1;
                if (isExtendedCss) {
                    break;
                }
            }
            if (rule.includes(RuleConverter.MASK_CSS_EXTENDED_CSS_RULE)) {
                parts = rule.split(RuleConverter.MASK_CSS_EXTENDED_CSS_RULE, 2);
                resultMask = RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE;
            }
            else if (rule.includes(RuleConverter.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE)) {
                parts = rule.split(RuleConverter.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE, 2);
                resultMask = RuleConverter.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE;
                // firstly we check for exception rule in order not to confuse with id selectors
                // e.g. yourconroenews.com#@##siteNav:style(transform: none !important;)
            }
            else if (rule.includes(RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION)) {
                parts = rule.split(RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION, 2);
                if (isExtendedCss) {
                    resultMask = RuleConverter.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE;
                }
                else {
                    resultMask = RuleConverter.MASK_CSS_EXCEPTION;
                }
            }
            else if (rule.includes(RuleConverter.MASK_ELEMENT_HIDING)) {
                parts = rule.split(RuleConverter.MASK_ELEMENT_HIDING, 2);
                if (isExtendedCss) {
                    resultMask = RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE;
                }
                else {
                    resultMask = RuleConverter.MASK_CSS;
                }
            }
            if (parts && resultMask) {
                resultRule = RuleConverter.executeConversion(rule, parts, resultMask);
            }
            return resultRule;
        }
        return rule;
    };
    /**
     * Converts ':remove()' rule to AdGuard extended css rule
     * example.com###banner:remove() -> example.com#$?##banner { remove: true; }
     * @param {string} rule
     * @return {string} rule or converted rule
     */
    RuleConverter.convertRemoveRule = function (rule) {
        // if rule is already extended css, do not convert it
        if (rule.includes(RuleConverter.MASK_CSS_EXTENDED_CSS_RULE)) {
            return rule;
        }
        if (rule.includes(RuleConverter.MASK_ELEMENT_HIDING) && rule.endsWith(RuleConverter.REMOVE_RULE_PATTERN)) {
            return rule
                .replace(RuleConverter.MASK_ELEMENT_HIDING, RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE)
                .replace(RuleConverter.REMOVE_RULE_PATTERN, RuleConverter.REMOVE_RULE_REPLACER);
        }
        return rule;
    };
    /**
     * Converts '^responseheader()' rule to AdGuard's $removeheader modifier
     * "ya.ru##^responseheader(header-name)" -> "||ya.ru^$removeheader=header-name"
     *
     * @param {string} ruleText
     * @return {string} ruleText or converted rule
     */
    RuleConverter.convertUboResponseHeaderRule = function (ruleText) {
        if (ruleText.startsWith(SimpleRegex.MASK_COMMENT) || !ruleText.includes(RuleConverter.UBO_RESPONSE_HEADER)) {
            return null;
        }
        if (RuleConverter.UBO_RESPONSE_HEADER_REGEX.test(ruleText)) {
            return "||".concat(ruleText.replace(RuleConverter.UBO_RESPONSE_HEADER_REGEX, RuleConverter.UBO_RESPONSE_HEADER_REPLACEMENT)
                .slice(0, -1));
        }
        if (RuleConverter.UBO_RESPONSE_HEADER_EXCEPTION_REGEX.test(ruleText)) {
            return "@@||".concat(ruleText.replace(RuleConverter.UBO_RESPONSE_HEADER_EXCEPTION_REGEX, RuleConverter.UBO_RESPONSE_HEADER_REPLACEMENT).slice(0, -1));
        }
        return ruleText;
    };
    /**
     * Converts cosmetic 'matches-path()' rule to AdGuard's $path modifier
     * "ya.ru##:matches-path(/page) p" -> "[$path=/page]ya.ru##p"
     *
     * @param {string} ruleText
     * @return {string} ruleText or converted rule
     */
    RuleConverter.convertUboMatchesPathRule = function (ruleText) {
        if (ruleText.startsWith(SimpleRegex.MASK_COMMENT)) {
            return ruleText;
        }
        var _b = findCosmeticRuleMarker(ruleText), markerIndex = _b[0], marker = _b[1];
        if (!marker) {
            return ruleText;
        }
        var expressionStartIndex = markerIndex + marker.length;
        var matchesPathStartIndex = ruleText.indexOf(RuleConverter.UBO_MATCHES_PATH, expressionStartIndex);
        if (matchesPathStartIndex === -1) {
            return ruleText;
        }
        var reversedMatchesPathStartIndex = ruleText.indexOf(RuleConverter.UBO_REVERSED_MATCHES_PATH, expressionStartIndex);
        var isReversed = reversedMatchesPathStartIndex !== -1;
        var pathStartIndex = isReversed
            ? reversedMatchesPathStartIndex + RuleConverter.UBO_REVERSED_MATCHES_PATH.length
            : matchesPathStartIndex + RuleConverter.UBO_MATCHES_PATH.length;
        var matchPathOperatorCloseBracketIndex;
        var openBracketCounter = 1;
        var closeBracketCounter = 0;
        for (var i = pathStartIndex; i < ruleText.length; i += 1) {
            if (ruleText[i - 1] !== '\\') {
                if (ruleText[i] === '(') {
                    openBracketCounter += 1;
                }
                else if (ruleText[i] === ')') {
                    closeBracketCounter += 1;
                    if (openBracketCounter === closeBracketCounter) {
                        matchPathOperatorCloseBracketIndex = i;
                        break;
                    }
                }
            }
        }
        if (!matchPathOperatorCloseBracketIndex) {
            return ruleText;
        }
        var domains = ruleText.slice(0, markerIndex);
        var expressionMiddle = ruleText.slice(expressionStartIndex, isReversed ? reversedMatchesPathStartIndex : matchesPathStartIndex);
        var expressionTail = ruleText
            .slice(matchPathOperatorCloseBracketIndex + (isReversed ? 2 : 1))
            .trim();
        var path = ruleText.slice(pathStartIndex, matchPathOperatorCloseBracketIndex);
        var isRegex = SimpleRegex.isRegexPattern(path);
        if (isReversed) {
            path = "/^((?!".concat(isRegex ? path.slice(1, path.length - 1) : SimpleRegex.patternToRegexp(path), ").)*$/");
        }
        if (isRegex) {
            path = SimpleRegex.escapeRegexSpecials(path, SimpleRegex.reModifierPatternSpecialCharacters);
        }
        return "[$path=".concat(path, "]").concat(domains).concat(marker).concat(expressionMiddle).concat(expressionTail);
    };
    /**
     * Substitutes option aliases in the provided options array with their corresponding aliases.
     *
     * @param optionsParts - An array of options to replace aliases in.
     * @returns - An array of options with aliases replaced.
     */
    RuleConverter.replaceOptions = function (optionsParts) {
        var resultOptions = optionsParts.map(function (option) {
            var _b = option.split('=', 2), optionNameRaw = _b[0], optionValue = _b[1];
            var isNegated = optionNameRaw.startsWith('~');
            var optionName = isNegated ? optionNameRaw.slice(1) : optionNameRaw;
            var convertedOptionName = RuleConverter.OPTIONS_ALIASES[optionName];
            if (!convertedOptionName) {
                return option;
            }
            var negationPrefix = isNegated ? '~' : '';
            return optionValue
                ? "".concat(negationPrefix).concat(convertedOptionName, "=").concat(optionValue)
                : "".concat(negationPrefix).concat(convertedOptionName);
        });
        return resultOptions;
    };
    var _a;
    _a = RuleConverter;
    RuleConverter.CSS_RULE_REPLACE_PATTERN = /(.*):style\((.*)\)/g;
    // eslint-disable-next-line max-len
    RuleConverter.SCRIPT_HAS_TEXT_REGEX = /##\^(script(\[[{a-z0-9-_.:}]*(="[{a-z0-9-_.:}]*")*\])*:(has-text|contains))\((?!\/.+\/\))/i;
    RuleConverter.SCRIPT_HAS_TEXT_REGEX_SHORT = /(##\^script:(has-text|contains))\((?!\/.+\/\))/i;
    RuleConverter.TAG_CONTENT_VALUE_REGEX = /\[tag-content="(.*?)"]/g;
    RuleConverter.ATTRIBUTE_REGEX = /(\[[{a-z0-9-_.:}]*(="[{a-z0-9-_.:}]*")*\])/i;
    RuleConverter.CSS_COMBINATORS_REGEX = />|\+|~/;
    RuleConverter.SCRIPT_HAS_TEXT_REPLACEMENT = '$$$$script[tag-content="';
    RuleConverter.UBO_RESPONSE_HEADER = '#^responseheader(';
    RuleConverter.UBO_RESPONSE_HEADER_REGEX = /##\^responseheader\((?!\/.+\/\))/i;
    RuleConverter.UBO_RESPONSE_HEADER_EXCEPTION_REGEX = /#@#\^responseheader\((?!\/.+\/\))/i;
    RuleConverter.UBO_RESPONSE_HEADER_REPLACEMENT = '^$removeheader=';
    RuleConverter.UBO_MATCHES_PATH = ':matches-path(';
    RuleConverter.UBO_REVERSED_MATCHES_PATH = ':not(:matches-path(';
    /**
     * Rule masks
     */
    RuleConverter.MASK_ELEMENT_HIDING = '##';
    RuleConverter.UBO_HTML_RULE_MASK = '##^';
    RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION = '#@#';
    RuleConverter.MASK_CSS = '#$#';
    RuleConverter.MASK_CSS_EXCEPTION = '#@$#';
    RuleConverter.MASK_CSS_EXTENDED_CSS_RULE = '#?#';
    RuleConverter.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE = '#@?#';
    RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE = '#$?#';
    RuleConverter.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE = '#@$?#';
    RuleConverter.REMOVE_RULE_PATTERN = ':remove()';
    RuleConverter.REMOVE_RULE_REPLACER = ' { remove: true; }';
    /**
     * Special characters
     */
    RuleConverter.REGEXP_DELIMITER = '/';
    RuleConverter.ESCAPING_SLASH = '\\';
    /**
     * Splits the given rule text into domain and options parts using the options delimiter ($).
     * Returns the domain part and an array of options, or null if no options are present.
     *
     * @param ruleText - The rule text to be split.
     * @returns [domain, options] or [domain, null] if no options are present.
     */
    RuleConverter.splitIntoDomainAndOptions = function (ruleText) {
        var optionsDelimiterIdx = -1;
        var inRegExp = false;
        for (var i = ruleText.length - 1; i >= 0; i -= 1) {
            if (!inRegExp && ruleText[i] === OPTIONS_DELIMITER) {
                optionsDelimiterIdx = i;
                break;
            }
            if (ruleText[i] === _a.REGEXP_DELIMITER
                && (i === 0 || ruleText[i - 1] !== _a.ESCAPING_SLASH)) {
                inRegExp = !inRegExp;
            }
        }
        if (optionsDelimiterIdx === -1) {
            return [ruleText, null];
        }
        var domainPart = ruleText.slice(0, optionsDelimiterIdx);
        var optionsPart = ruleText.slice(optionsDelimiterIdx + 1);
        // do not remove escape characters from regexp modifiers values
        var optionsParts = parseOptionsString(optionsPart, false);
        return [domainPart, optionsParts];
    };
    /**
     * These option shortcuts will be converted to a more wordy AdGuard options.
     * @private
     */
    RuleConverter.OPTIONS_CONVERSION_MAP = new Map([
        // See https://adguard.com/kb/general/ad-filtering/create-own-filters/#empty-modifier
        ['empty', 'redirect=nooptext'],
        // See https://adguard.com/kb/general/ad-filtering/create-own-filters/#mp4-modifier
        ['mp4', 'redirect=noopmp4-1s'],
        ['inline-script', "csp=script-src 'self' 'unsafe-eval' http: https: data: blob: mediastream: filesystem:"],
        ['inline-font', "csp=font-src 'self' 'unsafe-eval' http: https: data: blob: mediastream: filesystem:"],
    ]);
    /**
     * Options aliases, used to convert non-AdGuard options to AdGuard options
     */
    RuleConverter.OPTIONS_ALIASES = {
        'first-party': '~third-party',
        xhr: 'xmlhttprequest',
        css: 'stylesheet',
        frame: 'subdocument',
        queryprune: 'removeparam',
        doc: 'document',
        '1p': '~third-party',
        '3p': 'third-party',
        ghide: 'generichide',
        ehide: 'elemhide',
        shide: 'specifichide',
    };
    return RuleConverter;
}());

/**
 * Module, which can be used to validate filter rules in other libraries
 */
var RuleValidator = /** @class */ (function () {
    function RuleValidator() {
    }
    /**
     * Creates validation result
     * @param valid
     * @param error
     * @private
     */
    RuleValidator.createValidationResult = function (valid, error) {
        if (error) {
            return { valid: valid, error: error };
        }
        return { valid: valid, error: null };
    };
    RuleValidator.validateRegexp = function (pattern, ruleText) {
        if (pattern.startsWith(SimpleRegex.MASK_REGEX_RULE)
            && pattern.endsWith(SimpleRegex.MASK_REGEX_RULE)) {
            try {
                new RegExp(pattern.slice(1, -1));
            }
            catch (e) {
                throw new SyntaxError("Rule has invalid regex pattern: \"".concat(ruleText, "\""));
            }
        }
    };
    /**
     * Validates raw rule string
     * @param rawRule
     */
    RuleValidator.validate = function (rawRule) {
        var ruleText = rawRule.trim();
        if (!ruleText || RuleFactory.isComment(ruleText)) {
            return RuleValidator.createValidationResult(true);
        }
        if (RuleFactory.isShort(ruleText)) {
            return RuleValidator.createValidationResult(false, "Rule is too short: ".concat(ruleText));
        }
        try {
            // Validate cosmetic rules
            if (RuleFactory.isCosmetic(ruleText)) {
                new CosmeticRule(ruleText, 0);
                return RuleValidator.createValidationResult(true);
            }
            // Validate network rules
            var rule = new NetworkRule(ruleText, 0);
            RuleValidator.validateRegexp(rule.getPattern(), rule.getText());
        }
        catch (e) {
            var errorMessage = "Error: \"".concat(e.message, "\" in the rule: \"").concat(ruleText, "\"");
            return RuleValidator.createValidationResult(false, errorMessage);
        }
        return RuleValidator.createValidationResult(true);
        // TODO validate host rules
    };
    return RuleValidator;
}());

/**
 * Module with miscellaneous syntax utils exposed in API
 */
var RuleSyntaxUtils = /** @class */ (function () {
    function RuleSyntaxUtils() {
    }
    /**
     * Checks if rule can be matched by domain
     * @param ruleText
     * @param domain
     */
    RuleSyntaxUtils.isRuleForDomain = function (ruleText, domain) {
        var rule = RuleFactory.createRule(ruleText, this.DUMMY_FILTER_ID);
        if (!rule) {
            return false;
        }
        return rule.matchesPermittedDomains(domain);
    };
    /**
     * Checks if rule can be matched by url
     * @param ruleText
     * @param url
     */
    RuleSyntaxUtils.isRuleForUrl = function (ruleText, url) {
        var domain = getHostname(url);
        if (!domain) {
            return false;
        }
        return this.isRuleForDomain(ruleText, domain);
    };
    RuleSyntaxUtils.DUMMY_FILTER_ID = 0;
    return RuleSyntaxUtils;
}());

export { CompatibilityTypes, CookieModifier, CosmeticOption, CosmeticResult, CosmeticRule, CosmeticRuleParser, CosmeticRuleType, DnsEngine, DnsResult, EXT_CSS_PSEUDO_INDICATORS, Engine, HTTPMethod, HostRule, IndexedRule, IndexedStorageRule, LIST_ID_MAX_VALUE, MatchingResult, NetworkRule, NetworkRuleOption, RemoveHeaderModifier, RemoveParamModifier, ReplaceModifier, Request, RuleConverter, RuleFactory, RuleStorage, RuleSyntaxUtils, RuleValidator, StringRuleList, cleanUrlParamByRegExp, config, getRelativeUrl, isCompatibleWith, isDomainName, logger, setConfiguration, setLogger };
