import { IRuleList } from './rule-list';
import { RuleStorageScanner } from './scanner/rule-storage-scanner';
import { IRule } from '../rules/rule';
import { NetworkRule } from '../rules/network-rule';
import { HostRule } from '../rules/host-rule';
import { ScannerType } from './scanner/scanner-type';
/**
 * RuleStorage is an abstraction that combines several rule lists
 * It can be scanned using RuleStorageScanner, and also it allows
 * retrieving rules by its index

 * The idea is to keep rules in a serialized format (even original format in the case of FileRuleList)
 * and create them in a lazy manner only when we really need them. When the filtering engine is
 * being initialized, we need to scan the rule lists once in order to fill up the lookup tables.
 * We use rule indexes as a unique rule identifier instead of the rule itself.
 * The rule is created (see RetrieveRule) only when there's a chance that it's needed.

 * Rule index is an int64 value that actually consists of two int32 values:
 * One is the rule list identifier, and the second is the index of the rule inside of that list.
*/
export declare class RuleStorage {
    /**
     * Lists is an array of rules lists which can be accessed using this RuleStorage
     */
    private readonly lists;
    /**
     * Map with rule lists. map key is the list ID.
     */
    private readonly listsMap;
    /**
     * Cache with the rules which were retrieved.
     * We use double layer map in order to achieve better performance. The reason is a fact that a map with number
     * keys is much faster than a map with string keys. So we have a structure like Map<number, Map<number, IRule>>.
     */
    private readonly cache;
    /**
     * Constructor
     *
     * @param lists rule lists array
     *
     * @throws on duplicate lists
     */
    constructor(lists: IRuleList[]);
    /**
     * Creates a new instance of RuleStorageScanner.
     * It can be used to read and parse all the storage contents.
     *
     * @return scanner instance
     */
    createRuleStorageScanner(scannerType: ScannerType): RuleStorageScanner;
    /**
     * Looks for the filtering rule in this storage
     *
     * @param storageIdx the lookup index that you can get from the rule storage scanner
     * @param ignoreHost rules could be retrieved as host rules
     */
    retrieveRule(storageIdx: number, ignoreHost?: boolean): IRule | null;
    /**
     * RetrieveNetworkRule is a helper method that retrieves a network rule from the storage
     *
     * @param storageIdx
     * @return the rule or nil in any other case (not found or error)
     */
    retrieveNetworkRule(storageIdx: number): NetworkRule | null;
    /**
     * RetrieveHostRule is a helper method that retrieves a host rule from the storage
     *
     * @param storageIdx
     * @return the rule or nil in any other case (not found or error)
     */
    retrieveHostRule(storageIdx: number): HostRule | null;
    /**
     * Saves rule to cache
     *
     * @param listId
     * @param ruleIdx
     * @param rule
     */
    private saveToCache;
    /**
     * Retrieves rule form cache
     *
     * @param listId
     * @param ruleIdx
     */
    private getFromCache;
}
