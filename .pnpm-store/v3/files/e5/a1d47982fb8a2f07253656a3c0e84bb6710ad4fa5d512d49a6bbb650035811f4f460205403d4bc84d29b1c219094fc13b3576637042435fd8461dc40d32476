import { IndexedNetworkRuleWithHash } from './network-indexed-rule-with-hash';
import { IFilter } from './filter';
/**
 * IFilterScanner describes a method that should return indexed network rules
 * with theirs hashes.
 */
interface IFilterScanner {
    getIndexedRules(): ScannedRulesWithErrors;
}
/**
 * Contains scanned indexed rules with theirs hashes and list of errors.
 */
declare type ScannedRulesWithErrors = {
    rules: IndexedNetworkRuleWithHash[];
    errors: Error[];
};
/**
 * FilterScanner returns indexed, only network rules from IFilter's content.
 */
export declare class FilterScanner implements IFilterScanner {
    private readonly filterContent;
    private readonly filterId;
    /**
     * Constructor of FilterScanner.
     *
     * @param filterContent Filter rules.
     * @param filterId Filter id.
     */
    constructor(filterContent: string[], filterId: number);
    /**
     * Creates new filter scanner.
     *
     * @param filter From which filter the rules should be scanned.
     *
     * @returns New FilterScanner.
     */
    static createNew(filter: IFilter): Promise<FilterScanner>;
    /**
     * Gets the entire contents of the filter, extracts only the network rules
     * (ignore cosmetic and host rules) and tries to convert each line into an
     * indexed rule with hash.
     *
     * @param filterFn If this function is specified, it will be applied to each
     * rule after it has been parsed and transformed. This function is needed
     * for example to apply $badfilter: to exclude negated rules from the array
     * of rules that will be returned.
     *
     * @returns List of indexed rules with hash. If filterFn was specified then
     * out values will be filtered with this function.
     */
    getIndexedRules(filterFn?: (r: IndexedNetworkRuleWithHash) => boolean): ScannedRulesWithErrors;
}
export {};
