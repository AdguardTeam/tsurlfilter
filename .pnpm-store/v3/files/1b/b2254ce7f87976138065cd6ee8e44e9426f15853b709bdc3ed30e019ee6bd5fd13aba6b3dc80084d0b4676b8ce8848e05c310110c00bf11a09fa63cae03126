import type { IFilter } from './filter';
import type { IndexedNetworkRuleWithHash } from './network-indexed-rule-with-hash';
/**
 * This is an intermediate type required for conversion from filter to ruleset.
 *
 * Contains scanned indexed rules with theirs hashes: regular rules separately,
 * rules with `$badfilter` separately.
 */
export declare type ScannedFilter = {
    id: number;
    rules: IndexedNetworkRuleWithHash[];
    badFilterRules: IndexedNetworkRuleWithHash[];
};
/**
 * The result of scanning a list of filters includes the scanned filters and
 * any errors that may occur during the scan.
 */
declare type ScannedFiltersWithErrors = {
    errors: Error[];
    filters: ScannedFilter[];
};
/**
 * Scanner for network rules from list of filters.
 */
export declare class NetworkRulesScanner {
    /**
     * Asynchronous scans the list of filters for network rules.
     *
     * @param filterList List of {@link IFilter}.
     * @param filterFn If this function is specified, it will be applied to each
     * rule after it has been parsed and transformed. This function is needed
     * for example to apply $badfilter: to exclude negated rules from the array
     * of rules that will be returned.
     *
     * @returns List of filters includes the scanned filters and any errors that
     * may occur during the scan.
     */
    static scanRules(filterList: IFilter[], filterFn?: (r: IndexedNetworkRuleWithHash) => boolean): Promise<ScannedFiltersWithErrors>;
}
export {};
