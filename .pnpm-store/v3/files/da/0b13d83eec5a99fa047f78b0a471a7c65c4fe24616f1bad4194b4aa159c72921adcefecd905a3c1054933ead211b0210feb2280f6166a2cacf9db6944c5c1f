import { Request } from '../request';
import { MatchingResult } from './matching-result';
import { NetworkRule } from '../rules/network-rule';
import { RuleStorage } from '../filterlist/rule-storage';
import { CosmeticResult } from './cosmetic-engine/cosmetic-result';
import { CosmeticOption } from './cosmetic-option';
/**
 * Engine represents the filtering engine with all the loaded rules
 */
export declare class Engine {
    /**
     * Request's cache size
     * Used as both source rules and others limit.
     * The value is based on benchmark runs.
     */
    private static REQUEST_CACHE_SIZE;
    /**
     * Basic filtering rules engine
     */
    private readonly networkEngine;
    /**
     * Cosmetic rules engine
     */
    private readonly cosmeticEngine;
    /**
     * Rules storage
     */
    private readonly ruleStorage;
    /**
     * Request results cache
     */
    private readonly resultCache;
    /**
     * Creates an instance of an Engine
     * Parses the filtering rules and creates a filtering engine of them
     *
     * @param ruleStorage storage
     * @param skipStorageScan create an instance without storage scanning
     * @throws
     */
    constructor(ruleStorage: RuleStorage, skipStorageScan?: boolean);
    /**
     * Loads rules to engine
     */
    loadRules(): void;
    /**
     * Async loads rules to engine
     *
     * @param chunkSize size of rules chunk to load at a time
     */
    loadRulesAsync(chunkSize: number): Promise<void>;
    /**
     * Matches the specified request against the filtering engine and returns the matching result.
     *
     * @param request - request to check
     * @param frameRule - source document rule or null
     * @return matching result
     */
    matchRequest(request: Request, frameRule?: NetworkRule | null): MatchingResult;
    /**
     * Matches current frame and returns document-level allowlist rule if found.
     *
     * @param frameUrl
     */
    matchFrame(frameUrl: string): NetworkRule | null;
    /**
     * Gets cosmetic result for the specified hostname and cosmetic options
     *
     * @param request host to check
     * @param option mask of enabled cosmetic types
     * @return cosmetic result
     */
    getCosmeticResult(request: Request, option: CosmeticOption): CosmeticResult;
    /**
     * Gets rules count
     */
    getRulesCount(): number;
    /**
     * Adds rules to engines
     *
     * @param indexedRule
     */
    private addRule;
}
