import { z } from 'zod';
import { getPublicSuffix } from 'tldts';
import scriptlets, { redirects } from '@adguard/scriptlets';
import isCidr from 'is-cidr';
import isIp from 'is-ip';
import { contains } from 'cidr-tools';
import punycode from 'punycode/';

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

/**
 * Checks if error has message.
 *
 * @param error Error object.
 * @returns If param is error.
 */
function isErrorWithMessage(error) {
    return (typeof error === 'object'
        && error !== null
        && 'message' in error
        && typeof error.message === 'string');
}
/**
 * Converts error to the error with message.
 *
 * @param maybeError Possible error.
 * @returns Error with message.
 */
function toErrorWithMessage(maybeError) {
    if (isErrorWithMessage(maybeError)) {
        return maybeError;
    }
    try {
        return new Error(JSON.stringify(maybeError));
    }
    catch (_a) {
        // fallback in case there's an error stringifying the maybeError
        // like with circular references for example.
        return new Error(String(maybeError));
    }
}
/**
 * Converts error object to error with message. This method might be helpful to handle thrown errors.
 *
 * @param error Error object.
 *
 * @returns Message of the error.
 */
function getErrorMessage(error) {
    return toErrorWithMessage(error).message;
}

/**
 * Splits the string by the delimiter, ignoring escaped delimiters
 * and without tokenizing.
 * Works for plain strings that don't include string representation of
 * complex entities, e.g $replace modifier values.
 *
 * @param string - string to split
 * @param delimiter - delimiter
 * @param escapeCharacter - escape character
 * @param preserveEmptyTokens - if true, preserve empty parts
 * @param shouldUnescape - if true, unescape characters
 * @return array of string parts
 */
function splitByDelimiterWithEscapeCharacter(string, delimiter, escapeCharacter, preserveEmptyTokens, shouldUnescape) {
    if (shouldUnescape === void 0) { shouldUnescape = true; }
    if (!string) {
        return [];
    }
    if (string.startsWith(delimiter)) {
        // eslint-disable-next-line no-param-reassign
        string = string.substring(1);
    }
    var words = [];
    if (!string.includes(escapeCharacter)) {
        words = string.split(delimiter);
        if (!preserveEmptyTokens) {
            words = words.filter(function (word) { return !!word; });
        }
        return words;
    }
    var chars = [];
    var makeWord = function () {
        var word = chars.join('');
        words.push(word);
        chars = [];
    };
    for (var i = 0; i < string.length; i += 1) {
        var char = string.charAt(i);
        var isLastChar = i === (string.length - 1);
        if (char === delimiter) {
            var isEscapedChar = i > 0 && string[i - 1] === escapeCharacter;
            if (isEscapedChar) {
                if (shouldUnescape) {
                    chars.splice(chars.length - 1, 1);
                }
                chars.push(char);
            }
            else {
                makeWord();
            }
            if (isLastChar) {
                makeWord();
            }
        }
        else if (isLastChar) {
            chars.push(char);
            makeWord();
        }
        else {
            chars.push(char);
        }
    }
    if (!preserveEmptyTokens) {
        words = words.filter(function (word) { return !!word; });
    }
    return words;
}
/**
 * Checks if the specified string starts with a substr at the specified index.
 *
 * @param str - String to check
 * @param startIndex - Index to start checking from
 * @param substr - Substring to check
 * @return boolean true if it does start
 */
function startsAtIndexWith(str, startIndex, substr) {
    if (str.length - startIndex < substr.length) {
        return false;
    }
    for (var i = 0; i < substr.length; i += 1) {
        if (str.charAt(startIndex + i) !== substr.charAt(i)) {
            return false;
        }
    }
    return true;
}
/**
 * Checks if str has unquoted substr
 *
 * @param str
 * @param substr
 */
function hasUnquotedSubstring(str, substr) {
    var quotes = ['"', "'", '/'];
    if (!str.includes(substr)) {
        return false;
    }
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    if (indexOfAny(str, quotes) === -1) {
        return true;
    }
    var stack = [];
    for (var i = 0; i < str.length; i += 1) {
        var cursor = str[i];
        if (stack.length === 0) {
            if (startsAtIndexWith(str, i, substr)) {
                return true;
            }
        }
        if (quotes.indexOf(cursor) >= 0
            && (i === 0 || str[i - 1] !== '\\')) {
            var last = stack.pop();
            if (!last) {
                stack.push(cursor);
            }
            else if (last !== cursor) {
                stack.push(last);
                stack.push(cursor);
            }
        }
    }
    return false;
}
/**
 * djb2 hash algorithm
 *
 * NOTE: This version uses some bit operands to exclude overflow MAX_SAFE_INTEGER
 * (and moreover, exclude overflow 2^32).
 *
 * @see {@link https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765}
 *
 * @param str string to get hash
 * @return {number} hash
 */
function fastHash(str) {
    if (str.length === 0) {
        return 0;
    }
    var hash = 5381;
    for (var i = 0; i < str.length; i += 1) {
        hash = hash * 33 ^ str.charCodeAt(i);
    }
    return hash >>> 0;
}
/**
 * Look for any symbol from "chars" array starting at "start" index or from the start of the string
 *
 * @param str   String to search
 * @param chars Chars to search for
 * @param start Start index (optional, inclusive)
 * @return int Index of the element found or -1 if not
 */
function indexOfAny(str, chars, start) {
    if (start === void 0) { start = 0; }
    if (str.length <= start) {
        return -1;
    }
    for (var i = start; i < str.length; i += 1) {
        var c = str.charAt(i);
        if (chars.indexOf(c) > -1) {
            return i;
        }
    }
    return -1;
}
/**
 * Replaces all occurences of find with replace in str
 *
 * @param str
 * @param find
 * @param replace
 */
function replaceAll(str, find, replace) {
    if (!str) {
        return str;
    }
    return str.split(find).join(replace);
}
/**
 * Checks if arrays are equal
 *
 * @param left array
 * @param right array
 * @return {boolean} true on equality
 */
function stringArraysEquals(left, right) {
    if (!left || !right) {
        return !left && !right;
    }
    if (left.length !== right.length) {
        return false;
    }
    for (var i = 0; i < left.length; i += 1) {
        if (left[i] !== right[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Checks if arrays have an intersection
 *
 * @param left array
 * @param right array
 * @return {boolean} true on equality
 */
function stringArraysHaveIntersection(left, right) {
    if (!left || !right) {
        return true;
    }
    for (var i = 0; i < left.length; i += 1) {
        if (right.includes(left[i])) {
            return true;
        }
    }
    return false;
}

/* eslint-disable prefer-regex-literals */
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp
// should be escaped . * + ? ^ $ { } ( ) | [ ] / \
// except of * | ^
var specialCharacters = ['.', '+', '?', '$', '{', '}', '(', ')', '[', ']', '/', '\\'];
var reSpecialCharacters = new RegExp("[".concat(specialCharacters.join('\\'), "]"), 'g');
var reSpecialCharactersFull = /[.*+?^${}()|[\]\\]/g;
var reEscapedSpecialCharactersFull = /\\[.*+?^${}()|[\]\\]/g;
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#using_special_characters_in_strings
var escapeSequence = {
    n: '\n',
    r: '\r',
    t: '\t',
    b: '\b',
    f: '\f',
    v: '\v',
};
/**
 * Class with static helper methods for working with basic filtering rules patterns.
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules
 */
var SimpleRegex = /** @class */ (function () {
    function SimpleRegex() {
    }
    /**
     * Extracts the shortcut from the rule's pattern.
     * Shortcut is the longest substring of the pattern that does not contain
     * any special characters.
     *
     * Please note, that the shortcut is always lower-case!
     *
     * @param pattern - network rule's pattern.
     * @returns the shortcut or the empty string if we could not extract any.
     */
    SimpleRegex.extractShortcut = function (pattern) {
        if (pattern.startsWith(this.MASK_REGEX_RULE) && pattern.endsWith(this.MASK_REGEX_RULE)) {
            return this.extractRegexpShortcut(pattern);
        }
        return this.extractBasicShortcut(pattern);
    };
    /**
     * Searches for the longest substring of the pattern that
     * does not contain any special characters: *,^,|.
     *
     * @param pattern - network rule's pattern.
     * @returns the shortcut or the empty string
     */
    SimpleRegex.extractBasicShortcut = function (pattern) {
        var longest = '';
        var parts = pattern.split(this.rePatternSpecialCharacters);
        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
            var part = parts_1[_i];
            if (part.length > longest.length) {
                longest = part;
            }
        }
        return (longest || '').toLowerCase();
    };
    /**
     * Searches for a shortcut inside of a regexp pattern.
     * Shortcut in this case is a longest string with no REGEX special characters.
     * Also, we discard complicated regexps right away.
     *
     * @param pattern - network rule's pattern (regexp).
     * @returns the shortcut or the empty string
     */
    SimpleRegex.extractRegexpShortcut = function (pattern) {
        var reText = pattern.substring(this.MASK_REGEX_RULE.length, pattern.length - this.MASK_REGEX_RULE.length);
        if (reText.length === 0) {
            // The rule is too short, doing nothing
            return '';
        }
        if (reText.indexOf('?') >= 0) {
            // Do not mess with complex expressions which use lookahead
            // And with those using ? special character
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/978
            return '';
        }
        var specialCharacter = '$$$';
        // Prepend specialCharacter for the following replace calls to work properly
        reText = specialCharacter + reText;
        // Strip all types of brackets
        reText = reText.replace(/[^\\]\(.*[^\\]\)/, specialCharacter);
        reText = reText.replace(/[^\\]\[.*[^\\]\]/, specialCharacter);
        reText = reText.replace(/[^\\]\{.*[^\\]\}/, specialCharacter);
        // Strip some special characters
        reText = reText.replace(/[^\\]\\[a-zA-Z]/, specialCharacter);
        // Replace \. with .
        reText = reText.replace(/\\\./g, '.');
        // Split by special characters
        // `.` is one of the special characters so our `specialCharacter`
        // will be removed from the resulting array
        var parts = reText.split(/[\\^$*+?()|[\]{}]/);
        var longest = '';
        for (var i = 0; i < parts.length; i += 1) {
            var part = parts[i];
            if (part.length > longest.length) {
                longest = part;
            }
        }
        return longest.toLowerCase();
    };
    /**
     * patternToRegexp is a helper method for creating regular expressions from the simple
     * wildcard-based syntax which is used in basic filters:
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules
     *
     * @param pattern - basic rule pattern
     * @returns regular expression
     */
    SimpleRegex.patternToRegexp = function (pattern) {
        if (pattern === this.MASK_START_URL
            || pattern === this.MASK_PIPE
            || pattern === this.MASK_ANY_CHARACTER
            || pattern === '') {
            return this.REGEX_ANY_CHARACTER;
        }
        if (pattern.startsWith(this.MASK_REGEX_RULE) && pattern.endsWith(this.MASK_REGEX_RULE)) {
            // This is a regex rule, just remove the regex markers
            return pattern.substring(this.MASK_REGEX_RULE.length, pattern.length - this.MASK_REGEX_RULE.length);
        }
        // Escape special characters except of * | ^
        var regex = pattern.replace(reSpecialCharacters, '\\$&');
        // Now escape "|" characters but avoid escaping them in the special places
        if (regex.startsWith(this.MASK_START_URL)) {
            regex = regex.substring(0, this.MASK_START_URL.length)
                + replaceAll(regex.substring(this.MASK_START_URL.length, regex.length - this.MASK_PIPE.length), this.MASK_PIPE, "\\".concat(this.MASK_PIPE))
                + regex.substring(regex.length - this.MASK_PIPE.length);
        }
        else {
            regex = regex.substring(0, this.MASK_PIPE.length)
                + replaceAll(regex.substring(this.MASK_PIPE.length, regex.length - this.MASK_PIPE.length), this.MASK_PIPE, "\\".concat(this.MASK_PIPE))
                + regex.substring(regex.length - this.MASK_PIPE.length);
        }
        // Replace special URL masks
        regex = replaceAll(regex, this.MASK_ANY_CHARACTER, this.REGEX_ANY_CHARACTER);
        regex = replaceAll(regex, this.MASK_SEPARATOR, this.REGEX_SEPARATOR);
        // Replace start URL and pipes
        if (regex.startsWith(this.MASK_START_URL)) {
            regex = this.REGEX_START_URL + regex.substring(this.MASK_START_URL.length);
        }
        else if (regex.startsWith(this.MASK_PIPE)) {
            regex = this.REGEX_START_STRING + regex.substring(this.MASK_PIPE.length);
        }
        if (regex.endsWith(this.MASK_PIPE)) {
            regex = regex.substring(0, regex.length - this.MASK_PIPE.length) + this.REGEX_END_STRING;
        }
        return regex;
    };
    /**
     * Creates RegExp object from string in '/reg_exp/gi' format
     *
     * @param str
     */
    SimpleRegex.patternFromString = function (str) {
        var parts = splitByDelimiterWithEscapeCharacter(str, '/', '\\', true);
        var modifiers = (parts[1] || '');
        if (modifiers.indexOf('g') < 0) {
            modifiers += 'g';
        }
        return new RegExp(parts[0], modifiers);
    };
    /**
     * Escapes characters with special meaning inside a regular expression.
     *
     * @param str
     * @param searchPattern - Pattern for detecting special characters. Optional.
     */
    SimpleRegex.escapeRegexSpecials = function (str, searchPattern) {
        if (searchPattern === void 0) { searchPattern = reSpecialCharactersFull; }
        return str.replace(searchPattern, '\\$&');
    };
    /**
     * Unescapes characters with special meaning inside a regular expression.
     *
     * @param str
     * @param searchPattern - Pattern for detecting special characters. Optional.
     */
    SimpleRegex.unescapeRegexSpecials = function (str, searchPattern) {
        if (searchPattern === void 0) { searchPattern = reEscapedSpecialCharactersFull; }
        return str.replace(searchPattern, function (match) { return match.substring(1); });
    };
    /**
     * Check if pattern is Regex
     */
    SimpleRegex.isRegexPattern = function (str) {
        return str.startsWith('/') && str.endsWith('/');
    };
    /**
     * Unescapes special characters in a string
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#using_special_characters_in_strings
     */
    SimpleRegex.unescapeSpecials = function (str) {
        var keys = Object.keys(escapeSequence).join('|');
        var regex = new RegExp("\\\\(".concat(keys, ")"), 'g');
        return str.replace(regex, function (match, group) {
            return escapeSequence[group];
        });
    };
    /**
     * Matching the beginning of an address. With this character you don't
     * have to specify a particular protocol and subdomain in address mask.
     * It means, || stands for http://*., https://*., ws://*., wss://*. at once.
     */
    SimpleRegex.MASK_START_URL = '||';
    /**
     * REGEX_START_URL corresponds to MASK_START_URL
     */
    SimpleRegex.REGEX_START_URL = '^(http|https|ws|wss)://([a-z0-9-_.]+\\.)?';
    /**
     * A pointer to the beginning or the end of address. The value depends on the
     * character placement in the mask. For example, a rule swf| corresponds
     * to http://example.com/annoyingflash.swf , but not to http://example.com/swf/index.html.
     * |http://example.org corresponds to http://example.org,
     * but not to http://domain.com?url=http://example.org.
     */
    SimpleRegex.MASK_PIPE = '|';
    /**
     * REGEX_END_STRING corresponds to MASK_PIPE if it is in the end of a pattern.
     */
    SimpleRegex.REGEX_END_STRING = '$';
    /**
     * REGEX_START_STRING corresponds to MASK_PIPE if it is in the beginning of a pattern.
     */
    SimpleRegex.REGEX_START_STRING = '^';
    /**
     * Separator character mark. Separator character is any character,
     * but a letter, a digit, or one of the following: _ - .
     */
    SimpleRegex.MASK_SEPARATOR = '^';
    /**
     * REGEX_SEPARATOR corresponds to MASK_SEPARATOR
     */
    SimpleRegex.REGEX_SEPARATOR = '([^ a-zA-Z0-9.%_-]|$)';
    /**
     * This is a wildcard character. It is used to represent "any set of characters".
     * This can also be an empty string or a string of any length.
     */
    SimpleRegex.MASK_ANY_CHARACTER = '*';
    /**
     * Path separator
     */
    SimpleRegex.MASK_BACKSLASH = '/';
    /**
     * REGEX_ANY_CHARACTER corresponds to MASK_ANY_CHARACTER.
     */
    SimpleRegex.REGEX_ANY_CHARACTER = '.*';
    /**
     * Enclose regex in two backslashes to mark a regex rule:
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#regular-expressions-support
     */
    SimpleRegex.MASK_REGEX_RULE = '/';
    /**
     *  Regex for matching special characters in modifier regex pattern
     */
    SimpleRegex.reModifierPatternSpecialCharacters = /[[\],\\]/g;
    /**
      *  Regex for matching escaped special characters in modifier regex pattern
      */
    SimpleRegex.reModifierPatternEscapedSpecialCharacters = /\\[[\],\\]/g;
    /**
     * If string starts with exclamation mark "!" we consider it as comment
     */
    SimpleRegex.MASK_COMMENT = '!';
    /**
     * Min length of rule shortcut
     * This value has been picked as a result of performance experiments
     */
    SimpleRegex.MIN_SHORTCUT_LENGTH = 3;
    /**
     * Min length of generic rule shortcut
     */
    SimpleRegex.MIN_GENERIC_RULE_LENGTH = 4;
    /** Regex with basic matching pattern special characters */
    SimpleRegex.rePatternSpecialCharacters = new RegExp('[*^|]');
    return SimpleRegex;
}());

/**
 * This is a helper class that is used specifically to work
 * with domains restrictions.
 *
 * There are two options how you can add a domain restriction:
 * * `$domain` modifier: https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
 * * domains list for the cosmetic rules
 *
 * The only difference between them is that in one case we use `|` as a separator,
 * and in the other case - `,`.
 *
 * Examples:
 * * `||example.org^$domain=example.com|~sub.example.com` -- network rule
 * * `example.com,~sub.example.com##banner` -- cosmetic rule
 */
var DomainModifier = /** @class */ (function () {
    /**
     * Parses the `domains` string and initializes the object.
     *
     * @param domainsStr Domains string.
     * @param separator Separator — `,` or `|`.
     *
     * @throws An error if the domains string is empty or invalid
     */
    function DomainModifier(domainsStr, separator) {
        if (!domainsStr) {
            throw new SyntaxError('Modifier $domain cannot be empty');
        }
        var permittedDomains = [];
        var restrictedDomains = [];
        var parts = domainsStr.toLowerCase().split(separator);
        for (var i = 0; i < parts.length; i += 1) {
            var domain = parts[i].trim();
            var restricted = false;
            if (domain.startsWith('~')) {
                restricted = true;
                domain = domain.substring(1);
            }
            if (domain === '') {
                throw new SyntaxError("Empty domain specified in \"".concat(domainsStr, "\""));
            }
            if (restricted) {
                restrictedDomains.push(domain);
            }
            else {
                permittedDomains.push(domain);
            }
        }
        this.restrictedDomains = restrictedDomains.length > 0 ? restrictedDomains : null;
        this.permittedDomains = permittedDomains.length > 0 ? permittedDomains : null;
    }
    /**
     * isDomainOrSubdomainOfAny checks if `domain` is the same or a subdomain
     * of any of `domains`.
     *
     * @param domain - domain to check
     * @param domains - domains list to check against
     */
    DomainModifier.isDomainOrSubdomainOfAny = function (domain, domains) {
        for (var i = 0; i < domains.length; i += 1) {
            var d = domains[i];
            if (DomainModifier.isWildcardDomain(d)) {
                if (DomainModifier.matchAsWildcard(d, domain)) {
                    return true;
                }
            }
            if (domain === d || (domain.endsWith(d) && domain.endsWith(".".concat(d)))) {
                return true;
            }
        }
        return false;
    };
    /**
     * Checks if domain ends with wildcard
     *
     * @param domain
     */
    DomainModifier.isWildcardDomain = function (domain) {
        return domain.endsWith('.*');
    };
    /**
     * Checks if wildcard matches domain
     *
     * @param wildcard
     * @param domainNameToCheck
     */
    DomainModifier.matchAsWildcard = function (wildcard, domainNameToCheck) {
        var wildcardedDomainToCheck = DomainModifier.genTldWildcard(domainNameToCheck);
        if (wildcardedDomainToCheck) {
            return wildcardedDomainToCheck === wildcard
                || (wildcardedDomainToCheck.endsWith(wildcard) && wildcardedDomainToCheck.endsWith(".".concat(wildcard)));
        }
        return false;
    };
    /**
     * Generates from domain tld wildcard e.g. google.com -> google.* ; youtube.co.uk -> youtube.*
     *
     * @param {string} domainName
     * @returns {string} string is empty if tld for provided domain name doesn't exists
     */
    DomainModifier.genTldWildcard = function (domainName) {
        var tld = getPublicSuffix(domainName);
        if (tld) {
            // lastIndexOf() is needed not to match the domain, e.g. 'www.chrono24.ch'.
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/2312.
            return "".concat(domainName.slice(0, domainName.lastIndexOf(".".concat(tld))), ".*");
        }
        return '';
    };
    return DomainModifier;
}());
/**
 * Comma separator
 */
var COMMA_SEPARATOR = ',';
/**
 * Pipe separator
 */
var PIPE_SEPARATOR = '|';

var _a$2, _b$1;
/**
 * Array of special modifiers allow to check for modifier name more efficient
 * by avoiding Object.values(SpecialModifier) calls in custom type-guard while
 * allowing the usage of 'const enum' for SpecialModifier
 */
var SpecialModifiers = [
    "replace" /* SpecialModifier.Replace */,
    "removeparam" /* SpecialModifier.Removeparam */,
    "hls" /* SpecialModifier.Hls */,
];
var isSpecialModifierToken = function (token) { return token.type === "specialModifier" /* TokenType.SpecialModifier */; };
/**
 * TODO (s.atroschenko) git rid of necessity of adding modifier names for simple regexp values (removaparam, hls):
 * use unified 'simple-regexp' pattern instead
 */
var modifiersPatterns = (_a$2 = {},
    _a$2["replace" /* SpecialModifier.Replace */] = ["regexp" /* Phase.Regexp */, "replacement" /* Phase.Replacement */, "flags" /* Phase.Flags */],
    _a$2["removeparam" /* SpecialModifier.Removeparam */] = ["regexp" /* Phase.Regexp */, "flags" /* Phase.Flags */],
    _a$2["hls" /* SpecialModifier.Hls */] = ["regexp" /* Phase.Regexp */, "flags" /* Phase.Flags */],
    _a$2);
/**
 * Extracts modifier's plain value
 */
var parsePlainValue = function (string, startIndex) {
    var modifierValue = '';
    var modifierEndIndex = -1;
    var chars = [];
    for (var i = startIndex; i < string.length; i += 1) {
        var c = string[i];
        var isLastChar = i === (string.length - 1);
        var isUnescapedChar = i > 0 && !(string[i - 1] === "\\" /* SpecialCharacter.OptionEscape */);
        if ((c === "," /* SpecialCharacter.OptionDelimiter */ && isUnescapedChar) || isLastChar) {
            if (isLastChar) {
                chars.push(c);
            }
            modifierValue = chars.join('');
            modifierEndIndex = i;
            break;
        }
        else {
            chars.push(c);
        }
    }
    return {
        modifierValue: modifierValue,
        modifierEndIndex: modifierEndIndex,
    };
};
/**
 * Extract modifier's regexp(-like) value
 *
 * @throws on invalid special modifier value
 */
var parseRegexpValue = function (string, startIndex, pattern) {
    var currentPhase;
    var nextPhase = (function () {
        var i = 0;
        return function () {
            if (i < pattern.length) {
                currentPhase = pattern[i];
                i += 1;
                return;
            }
            // Undefined phase indicates that there were more Regexp delimiters
            // than pattern implies and that makes modifier value invalid
            throw new Error('Invalid pattern for regexp modifier value.');
        };
    })();
    var modifierValue = '';
    var modifierEndIndex = -1;
    var chars = [];
    for (var i = startIndex; i < string.length; i += 1) {
        var c = string[i];
        var isLastChar = i === (string.length - 1);
        var isUnescapedChar = i > 0 && !(string[i - 1] === "\\" /* SpecialCharacter.OptionEscape */);
        if (c === "/" /* SpecialCharacter.RegexpDelimiter */ && isUnescapedChar) {
            // Step into the next pattern phase
            nextPhase();
        }
        if ((c === "," /* SpecialCharacter.OptionDelimiter */ && isUnescapedChar) || isLastChar) {
            // Skip unescaped commas that are part of regexp
            if (currentPhase === "regexp" /* Phase.Regexp */) {
                chars.push(c);
                continue;
            }
            if (isLastChar) {
                chars.push(c);
            }
            // Unescaped delimiter and/or last character indicates
            // the end of the modifier value, if current phase is the last one
            if (currentPhase === pattern[pattern.length - 1]) {
                modifierValue = chars.join('');
                modifierEndIndex = i;
                break;
            }
            else {
                throw new Error('Unexpected options delimiter or end of options string.');
            }
        }
        else {
            chars.push(c);
        }
    }
    return {
        modifierValue: modifierValue,
        modifierEndIndex: modifierEndIndex,
    };
};
var modifierValueParsers = (_b$1 = {},
    _b$1["regexp" /* ModifierValueType.Regexp */] = parseRegexpValue,
    _b$1["plain" /* ModifierValueType.Plain */] = parsePlainValue,
    _b$1);
/**
 * Processes raw tokens by splitting token values by delimiter
 *
 * @param preprocessedTokens array of preprocessed tokens (of TokenType.SpecialModifier | TokenType.Raw type)
 * @param delimiter - delimiter
 * @param escapeCharacter - escape character
 * @param unescape if true, remove escape characters from string
 * @returns array of processed tokens
 */
var tokenize = function (preprocessedTokens, delimiter, escapeCharacter, unescape) {
    // Split raw tokens
    var nestedProcessedTokens = preprocessedTokens
        .map(function (token) {
        // Modifier tokens are already concrete tokens and are being passed down the pipeline here
        if (isSpecialModifierToken(token)) {
            return token;
        }
        var tokenValue = token.value;
        var tokens = [];
        var chars = [];
        var makeToken = function (type) {
            tokens.push({
                type: type,
                value: chars.join(''),
            });
            chars = [];
        };
        for (var i = 0; i < tokenValue.length; i += 1) {
            var c = tokenValue[i];
            if (c === delimiter) {
                var isEscaped = i > 0 && tokenValue[i - 1] === escapeCharacter;
                if (isEscaped) {
                    if (unescape) {
                        chars.splice(chars.length - 1, 1);
                    }
                    chars.push(c);
                }
                else {
                    // Don't make token with '' value
                    // when raw token starts with a delimiter
                    if (chars.length !== 0) {
                        makeToken("string" /* TokenType.String */);
                    }
                    chars.push(c);
                    makeToken("delim" /* TokenType.Delimiter */);
                }
            }
            else {
                chars.push(c);
                // Last character case
                if (i === (tokenValue.length - 1)) {
                    makeToken("string" /* TokenType.String */);
                }
            }
        }
        return tokens;
    });
    // Flatten the result
    var processedTokens = [];
    for (var i = 0; i < nestedProcessedTokens.length; i += 1) {
        var currentVal = nestedProcessedTokens[i];
        if (Array.isArray(currentVal)) {
            processedTokens.push.apply(processedTokens, currentVal);
        }
        else {
            processedTokens.push(currentVal);
        }
    }
    return processedTokens;
};
/**
 * Converts arrays of tokens into array of their values
 *
 * @param tokens array of arbitrary tokens
 * @returns array of tokens' values
 */
var makeWords = function (tokens) {
    var words = [];
    for (var i = 0; i < tokens.length; i += 1) {
        var token = tokens[i];
        if (token.type !== "delim" /* TokenType.Delimiter */) {
            words.push(token.value);
        }
    }
    return words;
};
/**
 * Parses special modifier value
 *
 * @param modifierName name of modifier to be parsed
 * @param string options string
 * @returns object with Modifier token value and next index to keep iterating from
 */
function parseSpecialModifier(modifierName, string) {
    var tokenValue = "".concat(modifierName).concat("=" /* SpecialCharacter.ModifierValueMarker */);
    var modifierValueStartIndex = string.indexOf(tokenValue) + tokenValue.length;
    // Define modifier value type
    var valueType = string[modifierValueStartIndex] === "/" /* SpecialCharacter.RegexpDelimiter */
        ? "regexp" /* ModifierValueType.Regexp */
        : "plain" /* ModifierValueType.Plain */;
    // Pick parser for specific type of modifier value
    var parser = modifierValueParsers[valueType];
    // Get pattern of current modifier
    var pattern = modifiersPatterns[modifierName];
    var _a = parser(string, modifierValueStartIndex, pattern), modifierValue = _a.modifierValue, modifierEndIndex = _a.modifierEndIndex;
    if (modifierEndIndex === -1) {
        throw new Error("Invalid $".concat(modifierName, " modifier value."));
    }
    tokenValue += modifierValue;
    var nextIndex = modifierEndIndex;
    return {
        tokenValue: tokenValue,
        nextIndex: nextIndex,
    };
}
/**
 * Converts options string into array of Raw and Modifier tokens
 *
 * @param string options string
 * @returns array of preprocessed tokens
 */
function splitBySpecialModifierTokens(string) {
    var tokens = [];
    var chars = [];
    var makeToken = function (tokenType, tokenValue) {
        tokens.push({
            type: tokenType,
            value: tokenValue,
        });
        chars = [];
    };
    for (var i = 0; i < string.length; i += 1) {
        var c = string[i];
        var isUnescapedChar = i > 0 && !(string[i - 1] === "\\" /* SpecialCharacter.OptionEscape */);
        if (c === "=" /* SpecialCharacter.ModifierValueMarker */ && isUnescapedChar) {
            // Parse current chars array to get modifier name
            // Assume that modifier name is everything after last ',' and before current '='
            var charsStr = chars.join('');
            var lastCommaIndex = charsStr.lastIndexOf("," /* SpecialCharacter.OptionDelimiter */, i);
            // Assertion is used to avoid type-guard for SpecialModifier, making it faster,
            // and reduce call stack size
            var modifierName = charsStr.substring(lastCommaIndex + 1);
            // Check if this is modifier that requires custom parsing logic
            if (!SpecialModifiers.includes(modifierName)) {
                chars.push(c);
                // Last character case
                if (i === (string.length - 1)) {
                    makeToken("raw" /* TokenType.Raw */, charsStr);
                }
                continue;
            }
            // Remove modifier name from char stack,
            // make token from whats left and empty chars
            makeToken("raw" /* TokenType.Raw */, charsStr.substring(0, charsStr.lastIndexOf(modifierName)));
            // Extract predefined token value and next iteration index
            // Token value includes both name, separator('=') and value of modifier
            var _a = parseSpecialModifier(modifierName, string), tokenValue = _a.tokenValue, nextIndex = _a.nextIndex;
            makeToken("specialModifier" /* TokenType.SpecialModifier */, tokenValue);
            i = nextIndex;
        }
        else {
            chars.push(c);
            // Last character case
            if (i === (string.length - 1)) {
                makeToken("raw" /* TokenType.Raw */, chars.join(''));
            }
        }
    }
    return tokens;
}
/**
 * Splits options string into array of modifier=value pairs
 *
 * @param string - string to split
 * @param unescape - if true, remove escape characters from string
 * @return array of string parts
 * @throws on invalid special modifier value
 */
function parseOptionsString(string, unescape) {
    if (unescape === void 0) { unescape = true; }
    if (!string) {
        return [];
    }
    if (string.startsWith("," /* SpecialCharacter.OptionDelimiter */)) {
        // eslint-disable-next-line no-param-reassign
        string = string.substring(1);
    }
    /**
     * Extract modifier tokens for modifiers that require custom parsing
     * https://github.com/AdguardTeam/tsurlfilter/issues/79
     */
    var preprocessedTokens = splitBySpecialModifierTokens(string);
    /**
     * Split raw tokens by delimiter
     */
    var tokens = tokenize(preprocessedTokens, "," /* SpecialCharacter.OptionDelimiter */, "\\" /* SpecialCharacter.OptionEscape */, unescape);
    /**
     * Join tokens into words
     */
    return makeWords(tokens);
}

/**
 * Replace modifier class
 */
var ReplaceModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     */
    function ReplaceModifier(value) {
        var parsed = ReplaceModifier.parseReplaceOption(value);
        this.replaceOption = parsed.optionText;
        this.replaceApply = parsed.apply;
    }
    /**
     *
     * @param option
     */
    ReplaceModifier.parseReplaceOption = function (option) {
        if (!option) {
            return {
                apply: function (x) { return x; },
                optionText: '',
            };
        }
        var parts = splitByDelimiterWithEscapeCharacter(option, '/', '\\', true);
        var modifiers = (parts[2] || '');
        if (modifiers.indexOf('g') < 0) {
            modifiers += 'g';
        }
        var pattern = new RegExp(parts[0], modifiers);
        // unescape replacement alias
        var replacement = parts[1].replace(/\\\$/g, '$');
        replacement = SimpleRegex.unescapeSpecials(replacement);
        var apply = function (input) { return input.replace(pattern, replacement); };
        return {
            apply: apply,
            optionText: option,
        };
    };
    /**
     * Replace content
     */
    ReplaceModifier.prototype.getValue = function () {
        return this.replaceOption;
    };
    /**
     * Replace apply function
     */
    ReplaceModifier.prototype.getApplyFunc = function () {
        return this.replaceApply;
    };
    return ReplaceModifier;
}());

var CSP_HEADER_NAME = 'Content-Security-Policy';
/**
 * Csp modifier class
 */
var CspModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     * @param isAllowlist
     */
    function CspModifier(value, isAllowlist) {
        this.cspDirective = value;
        this.isAllowlist = isAllowlist;
        this.validateCspDirective();
    }
    /**
     * Csp directive
     */
    CspModifier.prototype.getValue = function () {
        return this.cspDirective;
    };
    /**
     * Validates CSP rule
     */
    CspModifier.prototype.validateCspDirective = function () {
        /**
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/685
         * CSP directive may be empty in case of allowlist rule,
         * it means to disable all $csp rules matching the allowlist rule
         */
        if (!this.isAllowlist && !this.cspDirective) {
            throw new Error('Invalid $CSP rule: CSP directive must not be empty');
        }
        if (this.cspDirective) {
            /**
             * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/685#issue-228287090
             * Forbids report-to and report-uri directives
             */
            var cspDirective = this.cspDirective.toLowerCase();
            if (cspDirective.indexOf('report-') >= 0) {
                throw new Error("Forbidden CSP directive: ".concat(cspDirective));
            }
        }
    };
    return CspModifier;
}());

/**
 * Cookie modifier class
 *
 * Learn more about it here:
 * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/961
 */
var CookieModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     */
    function CookieModifier(value) {
        // Save the source text of the option modifier
        this.optionValue = value || '';
        this.regex = null;
        this.cookieName = null;
        this.sameSite = null;
        this.maxAge = null;
        // Parse cookie name/regex
        var parts = this.optionValue.split(/;/);
        if (parts.length < 1) {
            throw new Error("Cannot parse ".concat(this.optionValue));
        }
        var cookieName = parts[0];
        if (cookieName.startsWith('/') && cookieName.endsWith('/')) {
            var pattern = cookieName.substring(1, cookieName.length - 1);
            // Save regex to be used further for matching cookies
            this.regex = new RegExp(pattern);
        }
        else {
            // Match by cookie name
            this.cookieName = cookieName;
        }
        // Parse other cookie options
        if (parts.length > 1) {
            for (var i = 1; i < parts.length; i += 1) {
                var nameValue = parts[i].split('=');
                var optionName = nameValue[0];
                var optionValue = nameValue[1];
                if (optionName === CookieModifier.MAX_AGE) {
                    this.maxAge = parseInt(optionValue, 10);
                }
                else if (optionName === CookieModifier.SAME_SITE) {
                    this.sameSite = optionValue;
                }
                else {
                    throw new Error("Unknown $cookie option: ".concat(optionName));
                }
            }
        }
    }
    /**
     * Modifier value
     */
    CookieModifier.prototype.getValue = function () {
        return this.optionValue;
    };
    /**
     * First cookie name
     */
    CookieModifier.prototype.getCookieName = function () {
        return this.cookieName;
    };
    /**
     * Max age cookie value
     */
    CookieModifier.prototype.getMaxAge = function () {
        return this.maxAge;
    };
    /**
     * Same site cookie value
     */
    CookieModifier.prototype.getSameSite = function () {
        return this.sameSite;
    };
    /**
     * Checks if cookie with the specified name matches this option
     *
     * @param {string} name Cookie name
     * @return {boolean} true if it does
     */
    CookieModifier.prototype.matches = function (name) {
        if (!name) {
            return false;
        }
        if (this.regex) {
            return this.regex.test(name);
        }
        if (this.cookieName) {
            return this.cookieName === name;
        }
        // Empty regex and cookieName means that we must match all cookies
        return true;
    };
    /**
     * Checks if cookie rule has an empty $cookie option
     *
     * @return {boolean} True if $cookie option is empty
     */
    CookieModifier.prototype.isEmpty = function () {
        return !this.regex && !this.cookieName;
    };
    /**
     * Cookie name maxAge
     */
    CookieModifier.MAX_AGE = 'maxAge';
    /**
     * Cookie name sameSite
     */
    CookieModifier.SAME_SITE = 'sameSite';
    return CookieModifier;
}());

var NETWORK_RULE_OPTIONS = {
    THIRD_PARTY: 'third-party',
    FIRST_PARTY: 'first-party',
    MATCH_CASE: 'match-case',
    IMPORTANT: 'important',
    DOMAIN: 'domain',
    DENYALLOW: 'denyallow',
    ELEMHIDE: 'elemhide',
    GENERICHIDE: 'generichide',
    SPECIFICHIDE: 'specifichide',
    GENERICBLOCK: 'genericblock',
    JSINJECT: 'jsinject',
    URLBLOCK: 'urlblock',
    CONTENT: 'content',
    DOCUMENT: 'document',
    DOC: 'doc',
    STEALTH: 'stealth',
    POPUP: 'popup',
    EMPTY: 'empty',
    MP4: 'mp4',
    SCRIPT: 'script',
    STYLESHEET: 'stylesheet',
    SUBDOCUMENT: 'subdocument',
    OBJECT: 'object',
    IMAGE: 'image',
    XMLHTTPREQUEST: 'xmlhttprequest',
    MEDIA: 'media',
    FONT: 'font',
    WEBSOCKET: 'websocket',
    OTHER: 'other',
    PING: 'ping',
    BADFILTER: 'badfilter',
    CSP: 'csp',
    REPLACE: 'replace',
    COOKIE: 'cookie',
    REDIRECT: 'redirect',
    REDIRECTRULE: 'redirect-rule',
    REMOVEPARAM: 'removeparam',
    REMOVEHEADER: 'removeheader',
    JSONPRUNE: 'jsonprune',
    HLS: 'hls',
    REFERRERPOLICY: 'referrerpolicy',
    APP: 'app',
    NETWORK: 'network',
    EXTENSION: 'extension',
    NOOP: '_',
    CLIENT: 'client',
    DNSREWRITE: 'dnsrewrite',
    DNSTYPE: 'dnstype',
    CTAG: 'ctag',
    METHOD: 'method',
    TO: 'to',
    PERMISSIONS: 'permissions',
    ALL: 'all',
};
var OPTIONS_DELIMITER = '$';
var MASK_ALLOWLIST = '@@';
var NOT_MARK = '~';
var ESCAPE_CHARACTER = '\\';

/**
 * Redirect modifier class
 */
var RedirectModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     * @param ruleText
     * @param isAllowlist
     * @param isRedirectingOnlyBlocked is redirect-rule modifier
     */
    function RedirectModifier(value, ruleText, isAllowlist, isRedirectingOnlyBlocked) {
        if (isRedirectingOnlyBlocked === void 0) { isRedirectingOnlyBlocked = false; }
        /**
         * Is redirecting only blocked requests
         * See $redirect-rule options
         */
        this.isRedirectingOnlyBlocked = false;
        RedirectModifier.validate(ruleText, value, isAllowlist);
        this.redirectTitle = value;
        this.isRedirectingOnlyBlocked = isRedirectingOnlyBlocked;
    }
    /**
     * Redirect title
     */
    RedirectModifier.prototype.getValue = function () {
        return this.redirectTitle;
    };
    /**
     * Validates redirect rule
     *
     * @param ruleText
     * @param redirectTitle
     * @param isAllowlist
     */
    RedirectModifier.validate = function (ruleText, redirectTitle, isAllowlist) {
        if (isAllowlist && !redirectTitle) {
            return;
        }
        if (!redirectTitle) {
            throw new SyntaxError('Invalid $redirect rule, redirect value must not be empty');
        }
        var redirects = scriptlets.redirects;
        var ruleTextToValidate = ruleText.replace(NETWORK_RULE_OPTIONS.REDIRECTRULE, NETWORK_RULE_OPTIONS.REDIRECT);
        if (!redirects.isAdgRedirectRule(ruleTextToValidate) || !redirects.isValidAdgRedirectRule(ruleTextToValidate)) {
            throw new SyntaxError('$redirect modifier is invalid');
        }
    };
    return RedirectModifier;
}());

/**
 * Splits url into parts
 *
 * @param url
 */
function splitUrl(url) {
    var strippedUrl = url;
    var hash = '';
    var hashIndex = url.indexOf('#');
    if (hashIndex >= 0) {
        hash = url.slice(hashIndex);
        strippedUrl = url.slice(0, hashIndex);
    }
    var query = '';
    var queryIndex = url.indexOf('?');
    if (queryIndex >= 0) {
        query = strippedUrl.slice(queryIndex + 1);
        strippedUrl = strippedUrl.slice(0, queryIndex);
    }
    return {
        path: strippedUrl,
        query: query,
        hash: hash,
    };
}
/**
 * Normalizes url query parameters
 *
 * @param query
 */
function normalizeQuery(query) {
    // Cleanup empty params (p0=0&=2&=3)
    var result = query
        .split('&')
        .filter(function (x) { return x && !x.startsWith('='); })
        .join('&');
    // If we've collapsed the URL to the point where there's an '&' against the '?'
    // then we need to get rid of that.
    while (result.charAt(0) === '&') {
        result = result.substr(1);
    }
    return result;
}
/**
 * Removes query params from url by regexp
 *
 * @param url
 * @param regExp
 * @param invert remove every parameter in url except the ones matched regexp
 */
function cleanUrlParamByRegExp(url, regExp, invert) {
    if (invert === void 0) { invert = false; }
    var searchIndex = url.indexOf('?');
    // If no params, nothing to modify
    if (searchIndex === -1) {
        return url;
    }
    var split = splitUrl(url);
    var modifiedQuery;
    if (invert) {
        modifiedQuery = split.query
            .split('&')
            .filter(function (x) { return x; })
            .filter(function (x) { return x && x.match(regExp); })
            .join('&');
    }
    else {
        modifiedQuery = split.query
            .split('&')
            .filter(function (x) {
            var test = x.includes('=') ? x : "".concat(x, "=");
            return !test.match(regExp);
        })
            .join('&');
    }
    // Do not normalize if regexp is not applied
    if (modifiedQuery === split.query) {
        return url;
    }
    modifiedQuery = normalizeQuery(modifiedQuery);
    var result = split.path;
    if (modifiedQuery) {
        result += "?".concat(modifiedQuery);
    }
    return result + split.hash;
}
var DOMAIN_REGEX = /^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9](?:\.[a-zA-Z]{2,})+$/;
/**
 * Check if the string could be a domain name
 *
 * @param text
 */
var isDomainName = function (text) {
    if (text.indexOf('.') < 0 || text.endsWith('.')) {
        return false;
    }
    return DOMAIN_REGEX.test(text);
};
/**
 * Extract relative part from hierarchical structured URL
 * @param url
 */
var getRelativeUrl = function (url) {
    var i = url.indexOf('/', url.indexOf('://') + 3);
    return i !== -1 ? url.substr(i) : null;
};

/**
 * Query parameters filtering modifier class
 * Works with '$removeparam' modifier
 */
var RemoveParamModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     */
    function RemoveParamModifier(value) {
        /**
         * Is modifier valid for MV3 or not
         */
        this.mv3Valid = true;
        this.value = value;
        var rawValue = value;
        // TODO: Seems like negation not using in valueRegExp
        if (value.startsWith('~')) {
            rawValue = value.substring(1);
            this.mv3Valid = false;
        }
        if (rawValue.startsWith('/')) {
            this.valueRegExp = SimpleRegex.patternFromString(rawValue);
            this.mv3Valid = false;
        }
        else {
            if (rawValue.includes('|')) {
                throw new Error('Unsupported option in $removeparam: multiple values are not allowed');
            }
            this.valueRegExp = new RegExp("((^|&)(".concat(SimpleRegex.escapeRegexSpecials(rawValue), ")=[^&#]*)"), 'g');
        }
    }
    /**
     * Modifier value
     */
    RemoveParamModifier.prototype.getValue = function () {
        return this.value;
    };
    /**
     * Is modifier valid for MV3 or not
     */
    RemoveParamModifier.prototype.getMV3Validity = function () {
        return this.mv3Valid;
    };
    /**
     * Removes query parameters from url
     *
     * @param url
     */
    RemoveParamModifier.prototype.removeParameters = function (url) {
        var sepIndex = url.indexOf('?');
        if (sepIndex < 0) {
            return url;
        }
        if (!this.value) {
            return url.substring(0, sepIndex);
        }
        if (sepIndex === url.length - 1) {
            return url;
        }
        if (this.value.startsWith('~')) {
            return cleanUrlParamByRegExp(url, this.valueRegExp, true);
        }
        return cleanUrlParamByRegExp(url, this.valueRegExp);
    };
    return RemoveParamModifier;
}());

/**
 * Headers filtering modifier class.
 * Rules with $removeheader modifier are intended to remove headers from HTTP requests and responses.
 */
var RemoveHeaderModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     * @param isAllowlist
     */
    function RemoveHeaderModifier(value, isAllowlist) {
        this.value = value.toLowerCase();
        if (!isAllowlist && !this.value) {
            throw new SyntaxError('Invalid $removeheader rule, removeheader value must not be empty');
        }
        this.isRequestModifier = this.value.startsWith(RemoveHeaderModifier.REQUEST_PREFIX);
        var headerName = this.isRequestModifier
            ? this.value.substring(RemoveHeaderModifier.REQUEST_PREFIX.length)
            : this.value;
        // Values with ":" are not supported in MV3 declarative rules, e.g. "$removeheader=dnt:1"
        this.valid = RemoveHeaderModifier.isAllowedHeader(headerName) && !headerName.includes(':');
        this.applicableHeaderName = this.valid ? headerName : null;
    }
    /**
     * Modifier value
     */
    RemoveHeaderModifier.prototype.getValue = function () {
        return this.value;
    };
    Object.defineProperty(RemoveHeaderModifier.prototype, "isValid", {
        /**
         * Modifier validity
         */
        get: function () {
            return this.valid;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns effective header name to be removed
     *
     * @param isRequestHeaders
     */
    RemoveHeaderModifier.prototype.getApplicableHeaderName = function (isRequestHeaders) {
        if (!this.applicableHeaderName) {
            return null;
        }
        if (isRequestHeaders !== this.isRequestModifier) {
            return null;
        }
        return this.applicableHeaderName;
    };
    /**
     * Some headers are forbidden to remove
     *
     * @param headerName
     */
    RemoveHeaderModifier.isAllowedHeader = function (headerName) {
        return !this.FORBIDDEN_HEADERS.includes(headerName);
    };
    /**
     * List of forbidden headers
     */
    RemoveHeaderModifier.FORBIDDEN_HEADERS = [
        'access-control-allow-origin',
        'access-control-allow-credentials',
        'access-control-allow-headers',
        'access-control-allow-methods',
        'access-control-expose-headers',
        'access-control-max-age',
        'access-control-request-headers',
        'access-control-request-method',
        'origin',
        'timing-allow-origin',
        'allow',
        'cross-origin-embedder-policy',
        'cross-origin-opener-policy',
        'cross-origin-resource-policy',
        'content-security-policy',
        'content-security-policy-report-only',
        'expect-ct',
        'feature-policy',
        'origin-isolation',
        'strict-transport-security',
        'upgrade-insecure-requests',
        'x-content-type-options',
        'x-download-options',
        'x-frame-options',
        'x-permitted-cross-domain-policies',
        'x-powered-by',
        'x-xss-protection',
        'public-key-pins',
        'public-key-pins-report-only',
        'sec-websocket-key',
        'sec-websocket-extensions',
        'sec-websocket-accept',
        'sec-websocket-protocol',
        'sec-websocket-version',
        'p3p',
        'sec-fetch-mode',
        'sec-fetch-dest',
        'sec-fetch-site',
        'sec-fetch-user',
        'referrer-policy',
        'content-type',
        'content-length',
        'accept',
        'accept-encoding',
        'host',
        'connection',
        'transfer-encoding',
        'upgrade',
    ];
    /**
     * Request prefix
     */
    RemoveHeaderModifier.REQUEST_PREFIX = 'request:';
    return RemoveHeaderModifier;
}());

var ErrorStatusCodes;
(function (ErrorStatusCodes) {
    ErrorStatusCodes[ErrorStatusCodes["ComplexRegex"] = 1001] = "ComplexRegex";
    ErrorStatusCodes[ErrorStatusCodes["RuleLimit"] = 1002] = "RuleLimit";
    ErrorStatusCodes[ErrorStatusCodes["RegexpRuleLimit"] = 1003] = "RegexpRuleLimit";
    ErrorStatusCodes[ErrorStatusCodes["RemoveparamRegexpIsNotSupported"] = 1004] = "RemoveparamRegexpIsNotSupported";
    ErrorStatusCodes[ErrorStatusCodes["RemoveparamInversionIsNotSupported"] = 1005] = "RemoveparamInversionIsNotSupported";
})(ErrorStatusCodes || (ErrorStatusCodes = {}));
var SEPARATOR = '|';

/**
 * This is a helper class that is used specifically to work with app restrictions.
 *
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
 *
 * Examples:
 * ||baddomain.com^$app=org.example.app
 * ||baddomain.com^$app=org.example.app1|org.example.app2
 */
var AppModifier = /** @class */ (function () {
    /**
     * Parses the `apps` string
     *
     * @param apps - apps string
     *
     * @throws an error if the app string is empty or invalid
     */
    function AppModifier(apps) {
        if (!apps) {
            throw new SyntaxError('$app modifier cannot be empty');
        }
        var permittedApps = [];
        var restrictedApps = [];
        var parts = apps.split(SEPARATOR);
        for (var i = 0; i < parts.length; i += 1) {
            var app = parts[i];
            var restricted = false;
            if (app.startsWith('~')) {
                restricted = true;
                app = app.substring(1).trim();
            }
            if (app === '') {
                throw new SyntaxError("Empty app specified in \"".concat(apps, "\""));
            }
            if (restricted) {
                restrictedApps.push(app);
            }
            else {
                permittedApps.push(app);
            }
        }
        this.restrictedApps = restrictedApps.length > 0 ? restrictedApps : null;
        this.permittedApps = permittedApps.length > 0 ? permittedApps : null;
    }
    return AppModifier;
}());

var HTTPMethod;
(function (HTTPMethod) {
    HTTPMethod["GET"] = "GET";
    HTTPMethod["POST"] = "POST";
    HTTPMethod["PUT"] = "PUT";
    HTTPMethod["DELETE"] = "DELETE";
    HTTPMethod["PATCH"] = "PATCH";
    HTTPMethod["HEAD"] = "HEAD";
    HTTPMethod["OPTIONS"] = "OPTIONS";
    HTTPMethod["CONNECT"] = "CONNECT";
    HTTPMethod["TRACE"] = "TRACE";
})(HTTPMethod || (HTTPMethod = {}));
/**
 * Method modifier class.
 * Rules with $method modifier will be applied only to requests with specified methods.
 *
 * Learn more about it here:
 * https://adguard.com/kb/general/ad-filtering/create-own-filters/#method-modifier
 */
var MethodModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     */
    function MethodModifier(methodsStr) {
        if (methodsStr === '') {
            throw new SyntaxError('$method modifier value cannot be empty');
        }
        var permittedMethods = [];
        var restrictedMethods = [];
        var parts = methodsStr.toUpperCase().split(MethodModifier.PIPE_SEPARATOR);
        for (var i = 0; i < parts.length; i += 1) {
            var method = parts[i].trim();
            var restricted = false;
            if (method.startsWith('~')) {
                restricted = true;
                method = method.substring(1);
            }
            if (!MethodModifier.isHTTPMethod(method)) {
                throw new SyntaxError("Invalid $method modifier value: ".concat(method));
            }
            if (restricted) {
                restrictedMethods.push(method);
            }
            else {
                permittedMethods.push(method);
            }
        }
        if (restrictedMethods.length > 0 && permittedMethods.length > 0) {
            throw new SyntaxError("Negated values cannot be mixed with non-negated values: ".concat(methodsStr));
        }
        this.restrictedValues = restrictedMethods.length > 0 ? restrictedMethods : null;
        this.permittedValues = permittedMethods.length > 0 ? permittedMethods : null;
    }
    /**
     * Request methods separator
     */
    MethodModifier.PIPE_SEPARATOR = '|';
    MethodModifier.isHTTPMethod = function (value) { return value in HTTPMethod; };
    return MethodModifier;
}());

/**
 * To modifier class.
 * Rules with $to modifier are limited to requests made to the specified domains and their subdomains.
 *
 * Learn more about it here:
 * https://adguard.com/kb/general/ad-filtering/create-own-filters/#to-modifier
 */
var ToModifier = /** @class */ (function () {
    /**
     * Constructor
     */
    function ToModifier(domainsStr) {
        if (!domainsStr) {
            throw new SyntaxError('$to modifier value cannot be empty');
        }
        var permittedDomains = [];
        var restrictedDomains = [];
        var parts = domainsStr.toLowerCase().split(ToModifier.PIPE_SEPARATOR);
        for (var i = 0; i < parts.length; i += 1) {
            var domain = parts[i].trim();
            var restricted = false;
            if (domain.startsWith('~')) {
                restricted = true;
                domain = domain.substring(1);
            }
            if (domain === '') {
                throw new SyntaxError("Empty domain specified in \"".concat(domainsStr, "\""));
            }
            if (restricted) {
                restrictedDomains.push(domain);
            }
            else {
                permittedDomains.push(domain);
            }
        }
        this.restrictedValues = restrictedDomains.length > 0 ? restrictedDomains : null;
        this.permittedValues = permittedDomains.length > 0 ? permittedDomains : null;
    }
    /**
     * Domains separator
     */
    ToModifier.PIPE_SEPARATOR = '|';
    return ToModifier;
}());

/**
 * Compatibility types are used to configure engine for better support of different libraries
 * For example:
 *  extension doesn't support $app modifier. So if we set in configuration CompatibilityTypes.Extension,
 *  engine would ignore rules with $app modifier
 */
var CompatibilityTypes;
(function (CompatibilityTypes) {
    CompatibilityTypes[CompatibilityTypes["Extension"] = 1] = "Extension";
    CompatibilityTypes[CompatibilityTypes["CoreLibs"] = 2] = "CoreLibs";
    CompatibilityTypes[CompatibilityTypes["Dns"] = 4] = "Dns";
})(CompatibilityTypes || (CompatibilityTypes = {}));
/**
 * Application configuration class
 */
var Configuration = /** @class */ (function () {
    function Configuration(inputConfig) {
        this.defaultConfig = {
            engine: null,
            version: null,
            verbose: false,
            compatibility: null,
        };
        /**
         * {'extension'|'corelibs'} engine application type
         */
        this.engine = null;
        /**
         * {string} version
         */
        this.version = null;
        /**
         * {boolean} verbose flag
         */
        this.verbose = false;
        /**
         * compatibility flag
         */
        this.compatibility = CompatibilityTypes.Extension;
        var config = __assign(__assign({}, this.defaultConfig), inputConfig);
        this.engine = config.engine;
        this.version = config.version;
        this.verbose = config.verbose;
        this.compatibility = config.compatibility;
    }
    return Configuration;
}());
// eslint-disable-next-line import/no-mutable-exports
var config = new Configuration();
/**
 * Checks config is compatible with input level
 * @param compatibilityLevel
 * @private
 */
function isCompatibleWith(compatibilityLevel) {
    if (config.compatibility === null) {
        return false;
    }
    return (config.compatibility & compatibilityLevel) === compatibilityLevel;
}

/**
 * RequestType is the request types enumeration.
 * Important: the enumeration is marked as const to avoid side effects when
 * importing it into an extension.
 */
var RequestType = {
    /** No value is set. Syntax sugar to simplify code. */
    NotSet: 0,
    /** main frame */
    Document: 1,
    /** (iframe) $subdocument */
    SubDocument: 2,
    /** (javascript, etc) $script */
    Script: 4,
    /** (css) $stylesheet */
    Stylesheet: 8,
    /** (flash, etc) $object */
    Object: 16,
    /** (any image) $image */
    Image: 32,
    /** (ajax/fetch) $xmlhttprequest */
    XmlHttpRequest: 64,
    /** (video/music) $media */
    Media: 128,
    /** (any custom font) $font */
    Font: 256,
    /** (a websocket connection) $websocket */
    WebSocket: 512,
    /** (navigator.sendBeacon()) $ping */
    Ping: 1024,
    /** csp_report */
    CspReport: 2048,
    /** any other request type */
    Other: 4096, // 1 << 12
};

/**
 * This is the base class representing double values modifiers
 */
var BaseValuesModifier = /** @class */ (function () {
    /**
     * Parses the values string
     *
     * @param values - values string
     *
     * @throws an error if the string is empty or invalid
     */
    function BaseValuesModifier(values) {
        if (!values) {
            throw new SyntaxError('Modifier cannot be empty');
        }
        this.value = values;
        var permittedValues = [];
        var restrictedValues = [];
        var parts = values.split(SEPARATOR);
        for (var i = 0; i < parts.length; i += 1) {
            var app = parts[i];
            var restricted = false;
            if (app.startsWith('~')) {
                restricted = true;
                app = app.substring(1).trim();
            }
            if (app === '') {
                throw new SyntaxError("Empty values specified in \"".concat(values, "\""));
            }
            if (restricted) {
                restrictedValues.push(app);
            }
            else {
                permittedValues.push(app);
            }
        }
        this.restricted = restrictedValues.length > 0 ? restrictedValues : null;
        this.permitted = permittedValues.length > 0 ? permittedValues : null;
    }
    BaseValuesModifier.prototype.getPermitted = function () {
        return this.permitted;
    };
    BaseValuesModifier.prototype.getRestricted = function () {
        return this.restricted;
    };
    BaseValuesModifier.prototype.getValue = function () {
        return this.value;
    };
    BaseValuesModifier.prototype.match = function (value) {
        if (!this.restricted && !this.permitted) {
            return true;
        }
        if (this.restricted && this.restricted.includes(value)) {
            return false;
        }
        if (this.permitted) {
            return this.permitted.includes(value);
        }
        return true;
    };
    return BaseValuesModifier;
}());

/**
 * Netmasks class
 */
var NetmasksCollection = /** @class */ (function () {
    function NetmasksCollection() {
        this.ipv4Masks = [];
        this.ipv6Masks = [];
    }
    /**
     * Returns true if any of the containing masks contains provided value
     *
     * @param value
     */
    NetmasksCollection.prototype.contains = function (value) {
        if (isIp.v4(value)) {
            return this.ipv4Masks.some(function (x) { return contains(x, value); });
        }
        return this.ipv6Masks.some(function (x) { return contains(x, value); });
    };
    return NetmasksCollection;
}());
/**
 * The client modifier allows specifying clients this rule will be working for.
 * It accepts client names (not ClientIDs), IP addresses, or CIDR ranges.
 */
var ClientModifier = /** @class */ (function (_super) {
    __extends(ClientModifier, _super);
    /**
     * Constructor
     *
     * @param value
     */
    function ClientModifier(value) {
        var _this = _super.call(this, value) || this;
        var permitted = _this.getPermitted();
        if (permitted) {
            _this.permitted = ClientModifier.stripValues(permitted);
            _this.permittedNetmasks = ClientModifier.parseNetmasks(_this.permitted);
        }
        var restricted = _this.getRestricted();
        if (restricted) {
            _this.restricted = ClientModifier.stripValues(restricted);
            _this.restrictedNetmasks = ClientModifier.parseNetmasks(_this.restricted);
        }
        return _this;
    }
    /**
     * Unquotes and unescapes string
     *
     * @param values
     */
    ClientModifier.stripValues = function (values) {
        return values.map(function (v) {
            if ((v.startsWith('"') && v.endsWith('"'))
                || (v.startsWith('\'') && v.endsWith('\''))) {
                // eslint-disable-next-line no-param-reassign
                v = v.substr(1, v.length - 2);
            }
            return v.replace(/\\/ig, '');
        });
    };
    /**
     * Checks if this modifier matches provided params
     *
     * @param clientName
     * @param clientIP
     */
    ClientModifier.prototype.matchAny = function (clientName, clientIP) {
        if (this.restricted) {
            if (clientName && this.restricted.includes(clientName)) {
                return false;
            }
            if (clientIP && this.restricted.includes(clientIP)) {
                return false;
            }
            return true;
        }
        if (this.restrictedNetmasks) {
            if (clientIP && this.restrictedNetmasks.contains(clientIP)) {
                return false;
            }
            return true;
        }
        if (this.permitted) {
            if (clientName && this.permitted.includes(clientName)) {
                return true;
            }
            if (clientIP && this.permitted.includes(clientIP)) {
                return true;
            }
        }
        if (this.permittedNetmasks) {
            if (clientIP && this.permittedNetmasks.contains(clientIP)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Parses netmasks from client's strings
     *
     * @param values
     */
    ClientModifier.parseNetmasks = function (values) {
        var result = new NetmasksCollection();
        values.forEach(function (x) {
            var cidrVersion = isCidr(x);
            if (cidrVersion === 4) {
                result.ipv4Masks.push(x);
            }
            else if (cidrVersion === 6) {
                result.ipv6Masks.push(x);
            }
        });
        return result;
    };
    return ClientModifier;
}(BaseValuesModifier));

/**
 * The dnsrewrite response modifier allows replacing the content of the response
 * to the DNS request for the matching hosts.
 *
 * TODO: This modifier is not yet implemented
 * https://github.com/AdguardTeam/AdGuardHome/wiki/Hosts-Blocklists#dnsrewrite
 */
var DnsRewriteModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     */
    function DnsRewriteModifier(value) {
        this.value = value;
    }
    /**
     * Modifier value
     */
    DnsRewriteModifier.prototype.getValue = function () {
        return this.value;
    };
    return DnsRewriteModifier;
}());

/**
 * The dnstype modifier allows specifying DNS request type on which this rule will be triggered.
 */
var DnsTypeModifier = /** @class */ (function (_super) {
    __extends(DnsTypeModifier, _super);
    /**
     * Constructor
     *
     * @param value
     */
    function DnsTypeModifier(value) {
        var _this = _super.call(this, value) || this;
        if (_this.permitted) {
            _this.restricted = null;
        }
        return _this;
    }
    return DnsTypeModifier;
}(BaseValuesModifier));

/**
 * The ctag modifier allows to block domains only for specific types of DNS client tags.
 */
var CtagModifier = /** @class */ (function (_super) {
    __extends(CtagModifier, _super);
    /**
     * Constructor
     *
     * @param value
     */
    function CtagModifier(value) {
        var _this = _super.call(this, value) || this;
        _this.validate();
        return _this;
    }
    /**
     * Validates tag values
     */
    CtagModifier.prototype.validate = function () {
        if (!this.getValue()) {
            throw new Error('Invalid rule: Ctag modifier must not be empty');
        }
        var tags = this.permitted ? this.permitted : this.restricted;
        if (tags && tags.some(function (x) { return !CtagModifier.ALLOWED_TAGS.includes(x); })) {
            throw new Error('Invalid rule: Invalid ctag modifier');
        }
    };
    /**
     * The list of allowed tags
     */
    CtagModifier.ALLOWED_TAGS = [
        // By device type:
        'device_audio',
        'device_camera',
        'device_gameconsole',
        'device_laptop',
        'device_nas',
        'device_pc',
        'device_phone',
        'device_printer',
        'device_securityalarm',
        'device_tablet',
        'device_tv',
        'device_other',
        // By operating system:
        'os_android',
        'os_ios',
        'os_linux',
        'os_macos',
        'os_windows',
        'os_other',
        // By user group:
        'user_admin',
        'user_regular',
        'user_child',
    ];
    return CtagModifier;
}(BaseValuesModifier));

/**
 * Rule pattern class
 *
 * This class parses rule pattern text to simple fields.
 */
var Pattern = /** @class */ (function () {
    /**
     * Constructor
     * @param pattern
     * @param matchcase
     */
    function Pattern(pattern, matchcase) {
        if (matchcase === void 0) { matchcase = false; }
        this.pattern = pattern;
        this.shortcut = SimpleRegex.extractShortcut(this.pattern);
        this.matchcase = matchcase;
    }
    /**
     * Checks if this rule pattern matches the specified request.
     *
     * @param request - request to check
     * @param shortcutMatched if true, it means that the request already matches
     * this pattern's shortcut and we don't need to match it again.
     * @returns true if pattern matches
     */
    Pattern.prototype.matchPattern = function (request, shortcutMatched) {
        this.prepare();
        if (this.patternShortcut) {
            return shortcutMatched || this.matchShortcut(request.urlLowercase);
        }
        if (this.hostname) {
            // If we have a `||example.org^` rule, it's easier to match
            // against the request's hostname only without matching
            // a regular expression.
            return request.hostname === this.hostname
                || ( // First light check without new string memory allocation
                request.hostname.endsWith(this.hostname)
                    // Strict check
                    && request.hostname.endsWith(".".concat(this.hostname)));
        }
        // If the regular expression is invalid, just return false right away.
        if (this.regexInvalid || !this.regex) {
            return false;
        }
        // This is needed for DNS filtering only, not used in browser blocking.
        if (this.shouldMatchHostname(request)) {
            return this.regex.test(request.hostname);
        }
        return this.regex.test(request.url);
    };
    /**
     * Checks if this rule pattern matches the specified relative path string.
     * This method is used in cosmetic rules to implement the $path modifier matching logic.
     *
     * @param path - path to check
     * @returns true if pattern matches
     */
    Pattern.prototype.matchPathPattern = function (path) {
        this.prepare();
        if (this.hostname) {
            return false;
        }
        var pathIsEmptyString = this.pattern === '';
        // No-value $path should match root URL
        if (pathIsEmptyString && path === '/') {
            return true;
        }
        if (!pathIsEmptyString && this.patternShortcut) {
            return this.matchShortcut(path);
        }
        // If the regular expression is invalid, just return false right away.
        if (this.regexInvalid || !this.regex) {
            return false;
        }
        return this.regex.test(path);
    };
    /**
     * matchShortcut simply checks if shortcut is a substring of the URL.
     * @param request - request to check.
     */
    Pattern.prototype.matchShortcut = function (str) {
        return str.indexOf(this.shortcut) >= 0;
    };
    /**
     * Prepares this pattern
     */
    Pattern.prototype.prepare = function () {
        if (this.prepared) {
            return;
        }
        this.prepared = true;
        // If shortcut and pattern are the same, we don't need to actually compile
        // a regex and can simply use matchShortcut instead,
        // except for the $match-case modifier
        if (this.pattern === this.shortcut && !this.matchcase) {
            this.patternShortcut = true;
            return;
        }
        // Rules like `/example/*` are rather often in the real-life filters,
        // we might want to process them.
        if (this.pattern.startsWith(this.shortcut)
            && this.pattern.length === this.shortcut.length + 1
            && this.pattern.endsWith('*')) {
            this.patternShortcut = true;
            return;
        }
        if (this.pattern.startsWith(SimpleRegex.MASK_START_URL)
            && this.pattern.endsWith(SimpleRegex.MASK_SEPARATOR)
            && this.pattern.indexOf('*') < 0
            && this.pattern.indexOf('/') < 0) {
            this.hostname = this.pattern.slice(2, this.pattern.length - 1);
            return;
        }
        this.compileRegex();
    };
    /**
     * Compiles this pattern regex
     */
    Pattern.prototype.compileRegex = function () {
        var regexText = SimpleRegex.patternToRegexp(this.pattern);
        try {
            var flags = 'i';
            if (this.matchcase) {
                flags = '';
            }
            this.regex = new RegExp(regexText, flags);
        }
        catch (e) {
            this.regexInvalid = true;
        }
    };
    /**
     * Checks if we should match hostnames and not the URL
     * this is important for the cases when we use urlfilter for DNS-level blocking
     * Note, that even though we may work on a DNS-level, we should still sometimes match full URL instead
     *
     * @param request
     */
    Pattern.prototype.shouldMatchHostname = function (request) {
        if (!request.isHostnameRequest) {
            return false;
        }
        return !this.isPatternDomainSpecific();
    };
    /**
     * In case pattern starts with the following it targets some specific domain
     */
    Pattern.prototype.isPatternDomainSpecific = function () {
        if (this.patternDomainSpecific === undefined) {
            this.patternDomainSpecific = this.pattern.startsWith(SimpleRegex.MASK_START_URL)
                || this.pattern.startsWith('http://')
                || this.pattern.startsWith('https:/')
                || this.pattern.startsWith('://');
        }
        return this.patternDomainSpecific;
    };
    return Pattern;
}());

/**
 * Counts the number of bits in the number and returns it
 *
 * @param a number to count bits
 *
 * @returns The number of bits in the number.
 */
function getBitCount(a) {
    var count = 0;
    var n = a;
    while (n > 0) {
        count += n & 1;
        n >>= 1;
    }
    return count;
}
/**
 * Count the number of bits enabled in a number based on a bit mask
 *
 * @param base Base number to check
 * @param mask Mask to check
 *
 * @returns The number of bits enabled in the base number based on the mask
 *
 * @example
 * countEnabledBits(0b100, 0b110); // 1
 * countEnabledBits(0b111, 0b000); // 0
 */
function countEnabledBits(base, mask) {
    // Get the common bits between the base and the mask
    var common = base & mask;
    // Count the number of bits enabled in the common bits
    return getBitCount(common);
}

/**
 * NetworkRuleOption is the enumeration of various rule options.
 * In order to save memory, we store some options as a flag.
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#modifiers
 */
var NetworkRuleOption;
(function (NetworkRuleOption) {
    /** No value is set. Syntax sugar to simplify code. */
    NetworkRuleOption[NetworkRuleOption["NotSet"] = 0] = "NotSet";
    /** $third-party modifier */
    NetworkRuleOption[NetworkRuleOption["ThirdParty"] = 1] = "ThirdParty";
    /** $match-case modifier */
    NetworkRuleOption[NetworkRuleOption["MatchCase"] = 2] = "MatchCase";
    /** $important modifier */
    NetworkRuleOption[NetworkRuleOption["Important"] = 4] = "Important";
    // Allowlist rules modifiers
    // Each of them can disable part of the functionality
    /** $elemhide modifier */
    NetworkRuleOption[NetworkRuleOption["Elemhide"] = 8] = "Elemhide";
    /** $generichide modifier */
    NetworkRuleOption[NetworkRuleOption["Generichide"] = 16] = "Generichide";
    /** $specifichide modifier */
    NetworkRuleOption[NetworkRuleOption["Specifichide"] = 32] = "Specifichide";
    /** $genericblock modifier */
    NetworkRuleOption[NetworkRuleOption["Genericblock"] = 64] = "Genericblock";
    /** $jsinject modifier */
    NetworkRuleOption[NetworkRuleOption["Jsinject"] = 128] = "Jsinject";
    /** $urlblock modifier */
    NetworkRuleOption[NetworkRuleOption["Urlblock"] = 256] = "Urlblock";
    /** $content modifier */
    NetworkRuleOption[NetworkRuleOption["Content"] = 512] = "Content";
    /** $extension modifier */
    NetworkRuleOption[NetworkRuleOption["Extension"] = 1024] = "Extension";
    /** $stealth modifier */
    NetworkRuleOption[NetworkRuleOption["Stealth"] = 2048] = "Stealth";
    // Other modifiers
    /** $popup modifier */
    NetworkRuleOption[NetworkRuleOption["Popup"] = 4096] = "Popup";
    /** $csp modifier */
    NetworkRuleOption[NetworkRuleOption["Csp"] = 8192] = "Csp";
    /** $replace modifier */
    NetworkRuleOption[NetworkRuleOption["Replace"] = 16384] = "Replace";
    /** $cookie modifier */
    NetworkRuleOption[NetworkRuleOption["Cookie"] = 32768] = "Cookie";
    /** $redirect modifier */
    NetworkRuleOption[NetworkRuleOption["Redirect"] = 65536] = "Redirect";
    /** $badfilter modifier */
    NetworkRuleOption[NetworkRuleOption["Badfilter"] = 131072] = "Badfilter";
    /** $removeparam modifier */
    NetworkRuleOption[NetworkRuleOption["RemoveParam"] = 262144] = "RemoveParam";
    /** $removeheader modifier */
    NetworkRuleOption[NetworkRuleOption["RemoveHeader"] = 524288] = "RemoveHeader";
    /** $jsonprune modifier */
    NetworkRuleOption[NetworkRuleOption["JsonPrune"] = 1048576] = "JsonPrune";
    /** $hls modifier */
    NetworkRuleOption[NetworkRuleOption["Hls"] = 2097152] = "Hls";
    // Compatibility dependent
    /** $network modifier */
    NetworkRuleOption[NetworkRuleOption["Network"] = 4194304] = "Network";
    /** dns modifiers */
    NetworkRuleOption[NetworkRuleOption["Client"] = 8388608] = "Client";
    NetworkRuleOption[NetworkRuleOption["DnsRewrite"] = 16777216] = "DnsRewrite";
    NetworkRuleOption[NetworkRuleOption["DnsType"] = 33554432] = "DnsType";
    NetworkRuleOption[NetworkRuleOption["Ctag"] = 67108864] = "Ctag";
    /* $method modifier */
    NetworkRuleOption[NetworkRuleOption["Method"] = 134217728] = "Method";
    /* $to modifier */
    NetworkRuleOption[NetworkRuleOption["To"] = 268435456] = "To";
    /* $permissions modifier */
    NetworkRuleOption[NetworkRuleOption["Permissions"] = 536870912] = "Permissions";
    // Groups (for validation)
    /** Allowlist-only modifiers */
    NetworkRuleOption[NetworkRuleOption["AllowlistOnly"] = 4088] = "AllowlistOnly";
    /** Options supported by host-level network rules * */
    NetworkRuleOption[NetworkRuleOption["OptionHostLevelRules"] = 125960196] = "OptionHostLevelRules";
    /**
     * Removeparam compatible modifiers
     *
     * $removeparam rules are compatible only with content type modifiers ($subdocument, $script, $stylesheet, etc)
     * except $document (using by default) and this list of modifiers:
     */
    NetworkRuleOption[NetworkRuleOption["RemoveParamCompatibleOptions"] = 393223] = "RemoveParamCompatibleOptions";
    /**
     * Removeheader compatible modifiers
     *
     * $removeheader rules are compatible only with content type modifiers ($subdocument, $script, $stylesheet, etc)
     * except $document (using by default) and this list of modifiers:
     */
    NetworkRuleOption[NetworkRuleOption["RemoveHeaderCompatibleOptions"] = 655367] = "RemoveHeaderCompatibleOptions";
})(NetworkRuleOption || (NetworkRuleOption = {}));
/**
 * Helper class that is used for passing {@link NetworkRule.parseRuleText}
 * result to the caller. Should not be used outside of this file.
 */
var BasicRuleParts = /** @class */ (function () {
    function BasicRuleParts() {
    }
    return BasicRuleParts;
}());
/**
 * Basic network filtering rule.
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules
 */
var NetworkRule = /** @class */ (function () {
    /**
     * Creates an instance of the {@link NetworkRule}.
     * It parses this rule and extracts the rule pattern (see {@link SimpleRegex}),
     * and rule modifiers.
     *
     * @param ruleText - original rule text.
     * @param filterListId - ID of the filter list this rule belongs to.
     *
     * @throws error if it fails to parse the rule.
     */
    function NetworkRule(ruleText, filterListId) {
        this.permittedDomains = null;
        this.restrictedDomains = null;
        /**
         * Domains in denyallow modifier providing exceptions for permitted domains
         * https://github.com/AdguardTeam/CoreLibs/issues/1304
         */
        this.denyAllowDomains = null;
        /**
         * Flag with all enabled rule options.
         */
        this.enabledOptions = NetworkRuleOption.NotSet;
        /**
         * Flag with all disabled rule options.
         */
        this.disabledOptions = NetworkRuleOption.NotSet;
        /**
         * Flag with all permitted request types.
         */
        this.permittedRequestTypes = RequestType.NotSet;
        /**
         * Flag with all restricted request types.
         */
        this.restrictedRequestTypes = RequestType.NotSet;
        /**
         * Rule Advanced modifier
         */
        this.advancedModifier = null;
        /**
         * Rule App modifier
         */
        this.appModifier = null;
        /**
         * Rule Method modifier
         */
        this.methodModifier = null;
        /**
         * Rule To modifier
         */
        this.toModifier = null;
        /**
         * Rule priority, which is needed when the engine has to choose between
         * several rules matching the query. This value is calculated based on
         * the rule modifiers enabled or disabled and rounded up
         * to the smallest integer greater than or equal to the calculated weight
         * in the {@link calculatePriorityWeight}.
         *
         * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-1
         */
        this.priorityWeight = 1;
        this.ruleText = ruleText;
        this.filterListId = filterListId;
        var ruleParts = NetworkRule.parseRuleText(ruleText);
        this.allowlist = !!ruleParts.allowlist;
        var pattern = ruleParts.pattern;
        if (pattern && NetworkRule.hasSpaces(pattern)) {
            throw new SyntaxError('Rule has spaces, seems to be an host rule');
        }
        if (ruleParts.options) {
            this.loadOptions(ruleParts.options);
        }
        if (pattern === SimpleRegex.MASK_START_URL
            || pattern === SimpleRegex.MASK_ANY_CHARACTER
            || pattern === ''
            || pattern.length < SimpleRegex.MIN_GENERIC_RULE_LENGTH) {
            // Except cookie, removeparam rules and dns compatible rules, they have their own atmosphere
            var hasCookieModifier = this.advancedModifier instanceof CookieModifier;
            var hasRemoveParamModifier = this.advancedModifier instanceof RemoveParamModifier;
            // https://github.com/AdguardTeam/tsurlfilter/issues/56
            var isDnsCompatible = isCompatibleWith(CompatibilityTypes.Dns);
            if (!hasCookieModifier && !hasRemoveParamModifier && !isDnsCompatible) {
                if (!(this.hasPermittedDomains() || this.hasPermittedApps())) {
                    // Rule matches too much and does not have any domain restriction
                    // We should not allow this kind of rules
                    // eslint-disable-next-line max-len
                    throw new SyntaxError('The rule is too wide, add domain restriction or make the pattern more specific');
                }
            }
        }
        this.calculatePriorityWeight();
        this.pattern = new Pattern(pattern, this.isOptionEnabled(NetworkRuleOption.MatchCase));
    }
    /**
     * Returns the original text of the rule from which it was parsed.
     *
     * @returns Original text of the rule.
     */
    NetworkRule.prototype.getText = function () {
        return this.ruleText;
    };
    /**
     * Returns the identifier of the filter from which the rule was received.
     *
     * @returns Identifier of the filter from which the rule was received.
     */
    NetworkRule.prototype.getFilterListId = function () {
        return this.filterListId;
    };
    /**
     * Each rule has its own priority, which is necessary when several rules
     * match the request and the filtering system needs to select one of them.
     * Priority is measured as a positive integer.
     * In the case of a conflict between two rules with the same priority value,
     * it is not specified which one of them will be chosen.
     *
     * @returns Rule priority.
     */
    NetworkRule.prototype.getPriorityWeight = function () {
        return this.priorityWeight;
    };
    /**
     * Returns rule pattern,
     * which currently is used only in the rule validator module
     */
    NetworkRule.prototype.getPattern = function () {
        return this.pattern.pattern;
    };
    /**
     * Returns `true` if the rule is "allowlist", e.g. if it disables other
     * rules when the pattern matches the request.
     */
    NetworkRule.prototype.isAllowlist = function () {
        return this.allowlist;
    };
    /**
     * Checks if the rule is a document-level allowlist rule with $urlblock or
     * $genericblock or $content.
     * This means that the rule is supposed to disable or modify blocking
     * of the page subrequests.
     * For instance, `@@||example.org^$urlblock` unblocks all sub-requests.
     */
    NetworkRule.prototype.isDocumentLevelAllowlistRule = function () {
        if (!this.isAllowlist()) {
            return false;
        }
        return this.isOptionEnabled(NetworkRuleOption.Urlblock)
            || this.isOptionEnabled(NetworkRuleOption.Genericblock)
            || this.isOptionEnabled(NetworkRuleOption.Content);
    };
    /**
     * Checks if the rule completely disables filtering.
     */
    NetworkRule.prototype.isFilteringDisabled = function () {
        if (!this.isAllowlist()) {
            return false;
        }
        return this.isOptionEnabled(NetworkRuleOption.Elemhide)
            && this.isOptionEnabled(NetworkRuleOption.Content)
            && this.isOptionEnabled(NetworkRuleOption.Urlblock)
            && this.isOptionEnabled(NetworkRuleOption.Jsinject);
    };
    /**
     * The longest part of pattern without any special characters.
     * It is used to improve the matching performance.
     */
    NetworkRule.prototype.getShortcut = function () {
        return this.pattern.shortcut;
    };
    /**
     * Gets list of permitted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
     */
    NetworkRule.prototype.getPermittedDomains = function () {
        return this.permittedDomains;
    };
    /**
     * Gets list of denyAllow domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#denyallow-modifier
     */
    NetworkRule.prototype.getDenyAllowDomains = function () {
        return this.denyAllowDomains;
    };
    /**
     * Gets list of restricted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
     */
    NetworkRule.prototype.getRestrictedDomains = function () {
        return this.restrictedDomains;
    };
    /**
     * Get list of permitted $to domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#to-modifier
     */
    NetworkRule.prototype.getPermittedToDomains = function () {
        if (this.toModifier) {
            return this.toModifier.permittedValues;
        }
        return null;
    };
    /**
     * Get list of restricted $to domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#to-modifier
     */
    NetworkRule.prototype.getRestrictedToDomains = function () {
        if (this.toModifier) {
            return this.toModifier.restrictedValues;
        }
        return null;
    };
    /**
     * Gets list of permitted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
     */
    NetworkRule.prototype.getPermittedApps = function () {
        if (this.appModifier) {
            return this.appModifier.permittedApps;
        }
        return null;
    };
    /**
     * Gets list of restricted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
     */
    NetworkRule.prototype.getRestrictedApps = function () {
        if (this.appModifier) {
            return this.appModifier.restrictedApps;
        }
        return null;
    };
    /**
     * Gets list of permitted methods.
     * See https://kb.adguard.com/general/how-to-create-your-own-ad-filters#method-modifier
     */
    NetworkRule.prototype.getRestrictedMethods = function () {
        if (this.methodModifier) {
            return this.methodModifier.restrictedValues;
        }
        return null;
    };
    /**
     * Gets list of restricted methods.
     * See https://kb.adguard.com/general/how-to-create-your-own-ad-filters#method-modifier
     */
    NetworkRule.prototype.getPermittedMethods = function () {
        if (this.methodModifier) {
            return this.methodModifier.permittedValues;
        }
        return null;
    };
    /**
     * Flag with all permitted request types.
     * The value {@link RequestType.NotSet} here means "all request types are allowed".
     */
    NetworkRule.prototype.getPermittedRequestTypes = function () {
        return this.permittedRequestTypes;
    };
    /**
     * Flag with all restricted request types.
     * The value {@link RequestType.NotSet} here means "no type of request is restricted".
     */
    NetworkRule.prototype.getRestrictedRequestTypes = function () {
        return this.restrictedRequestTypes;
    };
    /**
     * Advanced modifier
     */
    NetworkRule.prototype.getAdvancedModifier = function () {
        return this.advancedModifier;
    };
    /**
     * Advanced modifier value
     */
    NetworkRule.prototype.getAdvancedModifierValue = function () {
        return this.advancedModifier && this.advancedModifier.getValue();
    };
    /**
     * isRegexRule returns true if rule's pattern is a regular expression.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#regexp-support
     */
    NetworkRule.prototype.isRegexRule = function () {
        return (this.getPattern().startsWith(SimpleRegex.MASK_REGEX_RULE)
            && this.getPattern().endsWith(SimpleRegex.MASK_REGEX_RULE));
    };
    NetworkRule.prototype.matchesPermittedDomains = function (hostname) {
        if (this.hasPermittedDomains()
            && DomainModifier.isDomainOrSubdomainOfAny(hostname, this.permittedDomains)) {
            return true;
        }
        return false;
    };
    /**
     * Checks if this filtering rule matches the specified request.
     * @param request - request to check.
     * @param useShortcut - the flag to use this rule shortcut
     *
     * In case we use Trie in lookup table, we don't need to use shortcut cause we already check if request's url
     * includes full rule shortcut.
     */
    NetworkRule.prototype.match = function (request, useShortcut) {
        if (useShortcut === void 0) { useShortcut = true; }
        // Regex rules should not be tested by shortcut
        if (useShortcut && !this.matchShortcut(request)) {
            return false;
        }
        if (this.isOptionEnabled(NetworkRuleOption.Method) && !this.matchMethod(request.method)) {
            return false;
        }
        if (this.isOptionEnabled(NetworkRuleOption.ThirdParty) && !request.thirdParty) {
            return false;
        }
        if (this.isOptionDisabled(NetworkRuleOption.ThirdParty) && request.thirdParty) {
            return false;
        }
        if (!this.matchRequestType(request.requestType)) {
            return false;
        }
        if (!this.matchDomainModifier(request)) {
            return false;
        }
        if (this.isOptionEnabled(NetworkRuleOption.RemoveParam)) {
            if (!this.matchRequestTypeExplicit(request.requestType)) {
                return false;
            }
        }
        if (!this.matchDenyAllowDomains(request.hostname)) {
            return false;
        }
        if (this.isOptionEnabled(NetworkRuleOption.To) && !this.matchToModifier(request.hostname)) {
            return false;
        }
        if (!this.matchDnsType(request.dnsType)) {
            return false;
        }
        if (!this.matchClientTags(request.clientTags)) {
            return false;
        }
        if (!this.matchClient(request.clientName, request.clientIP)) {
            return false;
        }
        return this.pattern.matchPattern(request, true);
    };
    /**
     * matchShortcut simply checks if shortcut is a substring of the URL.
     * @param request - request to check.
     */
    NetworkRule.prototype.matchShortcut = function (request) {
        return request.urlLowercase.indexOf(this.getShortcut()) >= 0;
    };
    /**
     * matchDomain checks if the filtering rule is allowed on this domain.
     * @param domain - domain to check.
     */
    NetworkRule.prototype.matchDomain = function (domain) {
        if (this.hasRestrictedDomains()) {
            if (DomainModifier.isDomainOrSubdomainOfAny(domain, this.restrictedDomains)) {
                // Domain or host is restricted
                // i.e. $domain=~example.org
                return false;
            }
        }
        if (this.hasPermittedDomains()) {
            if (!DomainModifier.isDomainOrSubdomainOfAny(domain, this.permittedDomains)) {
                // Domain is not among permitted
                // i.e. $domain=example.org and we're checking example.com
                return false;
            }
        }
        return true;
    };
    /**
     * Check if request matches domain modifier by request referrer (general case) or by request target
     *
     * In some cases the $domain modifier can match not only the referrer domain, but also the target domain.
     * This happens when the following is true (1 AND ((2 AND 3) OR 4):
     *
     * 1) The request has document type
     * 2) The rule's pattern doesn't match any particular domain(s)
     * 3) The rule's pattern doesn't contain regular expressions
     * 4) The $domain modifier contains only excluded domains (e.g., $domain=~example.org|~example.com)
     *
     * When all these conditions are met, the domain modifier will match both the referrer domain and the target domain.
     * https://github.com/AdguardTeam/tsurlfilter/issues/45
     * @param request
     */
    NetworkRule.prototype.matchDomainModifier = function (request) {
        if (!this.permittedDomains && !this.restrictedDomains) {
            return true;
        }
        var isDocumentType = request.requestType === RequestType.Document
            || request.requestType === RequestType.SubDocument;
        var hasOnlyExcludedDomains = (!this.permittedDomains || this.permittedDomains.length === 0)
            && this.restrictedDomains
            && this.restrictedDomains.length > 0;
        var patternIsRegex = this.isRegexRule();
        var patternIsDomainSpecific = this.pattern.isPatternDomainSpecific();
        var matchesTargetByPatternCondition = !patternIsRegex && !patternIsDomainSpecific;
        if (isDocumentType && (hasOnlyExcludedDomains || matchesTargetByPatternCondition)) {
            // check if matches source hostname if exists or if matches target hostname
            return (request.sourceHostname && this.matchDomain(request.sourceHostname))
                || this.matchDomain(request.hostname);
        }
        return this.matchDomain(request.sourceHostname || '');
    };
    /**
     * checks if the filtering rule is allowed on this domain.
     * @param domain
     */
    NetworkRule.prototype.matchDenyAllowDomains = function (domain) {
        if (!this.denyAllowDomains) {
            return true;
        }
        if (this.denyAllowDomains.length > 0) {
            if (DomainModifier.isDomainOrSubdomainOfAny(domain, this.denyAllowDomains)) {
                return false;
            }
        }
        return true;
    };
    /**
     * Checks if request target matches with specified domains
     *
     * @param domain request's domain
     * @return true if request domain matches with specified domains
     */
    NetworkRule.prototype.matchToModifier = function (domain) {
        if (!this.toModifier) {
            return true;
        }
        /**
         * Request's domain must be either explicitly
         * permitted and not be included in list of restricted domains
         * for the rule to apply
         */
        var permittedDomains = this.getPermittedToDomains();
        var restrictedDomains = this.getRestrictedToDomains();
        var isPermittedDomain = !!permittedDomains
            && DomainModifier.isDomainOrSubdomainOfAny(domain, permittedDomains);
        var isRestrictedDomain = !!restrictedDomains
            && DomainModifier.isDomainOrSubdomainOfAny(domain, restrictedDomains);
        return isPermittedDomain && !isRestrictedDomain;
    };
    /**
     * Return TRUE if this rule matches with the tags associated with a client
     *
     * @param clientTags
     */
    NetworkRule.prototype.matchClientTags = function (clientTags) {
        var advancedModifier = this.getAdvancedModifier();
        if (!advancedModifier || !(advancedModifier instanceof CtagModifier)) {
            return true;
        }
        if (!clientTags) {
            return false;
        }
        var cTagsModifier = advancedModifier;
        return clientTags.every(function (x) { return cTagsModifier.match(x); });
    };
    /**
     * returns TRUE if the rule matches with the specified client
     *
     * @param clientName
     * @param clientIP
     */
    NetworkRule.prototype.matchClient = function (clientName, clientIP) {
        var advancedModifier = this.getAdvancedModifier();
        if (!advancedModifier || !(advancedModifier instanceof ClientModifier)) {
            return true;
        }
        if (!clientName && !clientIP) {
            return false;
        }
        var modifier = advancedModifier;
        return modifier.matchAny(clientName, clientIP);
    };
    /**
     * Return TRUE if this rule matches with the request dnstype
     *
     * @param dnstype
     */
    NetworkRule.prototype.matchDnsType = function (dnstype) {
        var advancedModifier = this.getAdvancedModifier();
        if (!advancedModifier || !(advancedModifier instanceof DnsTypeModifier)) {
            return true;
        }
        if (!dnstype) {
            return false;
        }
        var modifier = advancedModifier;
        return modifier.match(dnstype);
    };
    /**
     * Checks if rule has permitted domains
     */
    NetworkRule.prototype.hasPermittedDomains = function () {
        return this.permittedDomains != null && this.permittedDomains.length > 0;
    };
    /**
     * Checks if rule has restricted domains
     */
    NetworkRule.prototype.hasRestrictedDomains = function () {
        return this.restrictedDomains != null && this.restrictedDomains.length > 0;
    };
    /**
     * Checks if rule has permitted apps
     */
    NetworkRule.prototype.hasPermittedApps = function () {
        if (!this.appModifier) {
            return false;
        }
        return this.appModifier.permittedApps !== null && this.appModifier.permittedApps.length > 0;
    };
    /**
     * matchRequestType checks if the request's type matches the rule properties
     * @param requestType - request type to check.
     */
    NetworkRule.prototype.matchRequestType = function (requestType) {
        if (this.permittedRequestTypes !== RequestType.NotSet) {
            if ((this.permittedRequestTypes & requestType) !== requestType) {
                return false;
            }
        }
        if (this.restrictedRequestTypes !== RequestType.NotSet) {
            if ((this.restrictedRequestTypes & requestType) === requestType) {
                return false;
            }
        }
        return true;
    };
    /**
     * In case of $removeparam modifier,
     * we only allow it to target other content types if the rule has an explicit content-type modifier.
     */
    NetworkRule.prototype.matchRequestTypeExplicit = function (requestType) {
        if (this.permittedRequestTypes === RequestType.NotSet
            && this.restrictedRequestTypes === RequestType.NotSet
            && requestType !== RequestType.Document
            && requestType !== RequestType.SubDocument) {
            return false;
        }
        return this.matchRequestType(requestType);
    };
    /**
     * Checks if request's method matches with the rule
     *
     * @param method request's method
     * @returns true, if rule must be applied to the request
     */
    NetworkRule.prototype.matchMethod = function (method) {
        if (!method || !MethodModifier.isHTTPMethod(method)) {
            return false;
        }
        /**
         * Request's method must be either explicitly
         * permitted or not be included in list of restricted methods
         * for the rule to apply
         */
        var permittedMethods = this.getPermittedMethods();
        if (permittedMethods === null || permittedMethods === void 0 ? void 0 : permittedMethods.includes(method)) {
            return true;
        }
        var restrictedMethods = this.getRestrictedMethods();
        return !!restrictedMethods && !restrictedMethods.includes(method);
    };
    /**
     * Checks if pattern has spaces
     * Used in order to do not create network rules from host rules
     * @param pattern
     * @private
     */
    NetworkRule.hasSpaces = function (pattern) {
        return pattern.indexOf(' ') > -1;
    };
    /**
     * Parses the options string and saves them.
     * More on the rule modifiers:
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers
     *
     * @param options - string with the rule modifiers
     *
     * @throws an error if there is an unsupported modifier
     */
    NetworkRule.prototype.loadOptions = function (options) {
        var optionParts;
        try {
            optionParts = parseOptionsString(options);
        }
        catch (e) {
            var errorMessage = getErrorMessage(e);
            throw new Error("Cannot parse ".concat(options, ": ").concat(errorMessage));
        }
        for (var i = 0; i < optionParts.length; i += 1) {
            var option = optionParts[i];
            var valueIndex = option.indexOf('=');
            var optionName = option;
            var optionValue = '';
            if (valueIndex > 0) {
                optionName = option.substring(0, valueIndex);
                optionValue = option.substring(valueIndex + 1);
            }
            this.loadOption(optionName, optionValue);
        }
        this.validateOptions();
    };
    /**
     * Returns true if rule contains (enabled or disabled) specified option.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option - rule option to check.
     */
    NetworkRule.prototype.hasOption = function (option) {
        return this.isOptionEnabled(option) || this.isOptionDisabled(option);
    };
    /**
     * Returns true if the specified option is enabled.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option - rule option to check.
     */
    NetworkRule.prototype.isOptionEnabled = function (option) {
        return (this.enabledOptions & option) === option;
    };
    /**
     * Returns true if one and only option is enabled
     *
     * @param option
     */
    NetworkRule.prototype.isSingleOptionEnabled = function (option) {
        return this.enabledOptions === option;
    };
    /**
     * Returns true if the specified option is disabled.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option - rule option to check.
     */
    NetworkRule.prototype.isOptionDisabled = function (option) {
        return (this.disabledOptions & option) === option;
    };
    /**
     * Checks if the rule has higher priority that the specified rule
     * allowlist + $important > $important > redirect > allowlist > basic rules
     */
    NetworkRule.prototype.isHigherPriority = function (r) {
        return this.priorityWeight > r.priorityWeight;
    };
    /**
     * Returns true if the rule is considered "generic"
     * "generic" means that the rule is not restricted to a limited set of domains
     * Please note that it might be forbidden on some domains, though.
     *
     * @return {boolean}
     */
    NetworkRule.prototype.isGeneric = function () {
        return !this.hasPermittedDomains();
    };
    /**
     * Returns true if this rule negates the specified rule
     * Only makes sense when this rule has a `badfilter` modifier
     */
    NetworkRule.prototype.negatesBadfilter = function (specifiedRule) {
        if (!this.isOptionEnabled(NetworkRuleOption.Badfilter)) {
            return false;
        }
        if (this.allowlist !== specifiedRule.allowlist) {
            return false;
        }
        if (this.pattern.pattern !== specifiedRule.pattern.pattern) {
            return false;
        }
        if (this.permittedRequestTypes !== specifiedRule.permittedRequestTypes) {
            return false;
        }
        if (this.restrictedRequestTypes !== specifiedRule.restrictedRequestTypes) {
            return false;
        }
        if ((this.enabledOptions ^ NetworkRuleOption.Badfilter) !== specifiedRule.enabledOptions) {
            return false;
        }
        if (this.disabledOptions !== specifiedRule.disabledOptions) {
            return false;
        }
        if (!stringArraysEquals(this.restrictedDomains, specifiedRule.restrictedDomains)) {
            return false;
        }
        if (!stringArraysHaveIntersection(this.permittedDomains, specifiedRule.permittedDomains)) {
            return false;
        }
        return true;
    };
    /**
     * Checks if this rule can be used for hosts-level blocking
     */
    NetworkRule.prototype.isHostLevelNetworkRule = function () {
        if (this.hasPermittedDomains() || this.hasRestrictedDomains()) {
            return false;
        }
        if (this.permittedRequestTypes !== 0 && this.restrictedRequestTypes !== 0) {
            return false;
        }
        if (this.disabledOptions !== NetworkRuleOption.NotSet) {
            return false;
        }
        if (this.enabledOptions !== NetworkRuleOption.NotSet) {
            return ((this.enabledOptions
                & NetworkRuleOption.OptionHostLevelRules)
                | (this.enabledOptions
                    ^ NetworkRuleOption.OptionHostLevelRules)) === NetworkRuleOption.OptionHostLevelRules;
        }
        return true;
    };
    /**
     * Enables or disables the specified option.
     *
     * @param option - option to enable or disable.
     * @param enabled - true to enable, false to disable.
     * @param skipRestrictions - skip options allowlist/blacklist restrictions
     *
     * @throws an error if the option we're trying to enable cannot be.
     * For instance, you cannot enable $elemhide for blacklist rules.
     */
    NetworkRule.prototype.setOptionEnabled = function (option, enabled, skipRestrictions) {
        if (skipRestrictions === void 0) { skipRestrictions = false; }
        if (!skipRestrictions) {
            if (!this.allowlist && (option & NetworkRuleOption.AllowlistOnly) === option) {
                throw new SyntaxError("Modifier ".concat(NetworkRuleOption[option], " cannot be used in blacklist rule"));
            }
        }
        if (enabled) {
            this.enabledOptions |= option;
        }
        else {
            this.disabledOptions |= option;
        }
    };
    /**
     * Permits or forbids the specified request type.
     * "Permits" means that the rule will match **only** the types that are permitted.
     * "Restricts" means that the rule will match **all but restricted**.
     *
     * @param requestType - request type.
     * @param permitted - true if it's permitted (whic)
     */
    NetworkRule.prototype.setRequestType = function (requestType, permitted) {
        if (permitted) {
            this.permittedRequestTypes |= requestType;
        }
        else {
            this.restrictedRequestTypes |= requestType;
        }
    };
    /**
     * Sets and validates exceptionally allowed domains presented in $denyallow modifier
     *
     * @param optionValue
     */
    NetworkRule.prototype.setDenyAllowDomains = function (optionValue) {
        var domainModifier = new DomainModifier(optionValue, PIPE_SEPARATOR);
        if (domainModifier.restrictedDomains && domainModifier.restrictedDomains.length > 0) {
            throw new SyntaxError('Invalid modifier: $denyallow domains cannot be negated');
        }
        if (domainModifier.permittedDomains
            && domainModifier.permittedDomains.some(function (x) { return x.includes(SimpleRegex.MASK_ANY_CHARACTER); })) {
            throw new SyntaxError('Invalid modifier: $denyallow domains wildcards are not supported');
        }
        this.denyAllowDomains = domainModifier.permittedDomains;
    };
    /**
     * Loads the specified modifier:
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers
     *
     * @param optionName - modifier name.
     * @param optionValue - modifier value.
     *
     * @throws an error if there is an unsupported modifier
     */
    NetworkRule.prototype.loadOption = function (optionName, optionValue) {
        var _this = this;
        var OPTIONS = NetworkRule.OPTIONS;
        if (optionName.startsWith(OPTIONS.NOOP)) {
            /**
             * A noop modifier does nothing and can be used to increase some rules readability.
             * It consists of the sequence of underscore characters (_) of any length
             * and can appear in a rule as many times as it's needed.
             */
            if (!optionName.split(OPTIONS.NOOP).some(function (s) { return !!s; })) {
                return;
            }
        }
        switch (optionName) {
            // General options
            // $third-party, $~first-party
            case OPTIONS.THIRD_PARTY:
            case NOT_MARK + OPTIONS.FIRST_PARTY:
                this.setOptionEnabled(NetworkRuleOption.ThirdParty, true);
                break;
            // $first-party, $~third-party
            case NOT_MARK + OPTIONS.THIRD_PARTY:
            case OPTIONS.FIRST_PARTY:
                this.setOptionEnabled(NetworkRuleOption.ThirdParty, false);
                break;
            // $match-case
            case OPTIONS.MATCH_CASE:
                this.setOptionEnabled(NetworkRuleOption.MatchCase, true);
                break;
            // $~match-case
            case NOT_MARK + OPTIONS.MATCH_CASE:
                this.setOptionEnabled(NetworkRuleOption.MatchCase, false);
                break;
            // $important
            case OPTIONS.IMPORTANT:
                this.setOptionEnabled(NetworkRuleOption.Important, true);
                break;
            // $domain
            case OPTIONS.DOMAIN:
                // eslint-disable-next-line no-case-declarations
                var domainModifier = new DomainModifier(optionValue, PIPE_SEPARATOR);
                this.permittedDomains = domainModifier.permittedDomains;
                this.restrictedDomains = domainModifier.restrictedDomains;
                break;
            // $denyallow
            case OPTIONS.DENYALLOW:
                this.setDenyAllowDomains(optionValue);
                break;
            // $method modifier
            case OPTIONS.METHOD: {
                this.setOptionEnabled(NetworkRuleOption.Method, true);
                this.methodModifier = new MethodModifier(optionValue);
                break;
            }
            // $to modifier
            case OPTIONS.TO: {
                this.setOptionEnabled(NetworkRuleOption.To, true);
                this.toModifier = new ToModifier(optionValue);
                break;
            }
            // Document-level allowlist rules
            // $elemhide
            case OPTIONS.ELEMHIDE:
                this.setOptionEnabled(NetworkRuleOption.Elemhide, true);
                this.setRequestType(RequestType.Document, true);
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $generichide
            case OPTIONS.GENERICHIDE:
                this.setOptionEnabled(NetworkRuleOption.Generichide, true);
                this.setRequestType(RequestType.Document, true);
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $specifichide
            case OPTIONS.SPECIFICHIDE:
                this.setOptionEnabled(NetworkRuleOption.Specifichide, true);
                this.setRequestType(RequestType.Document, true);
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $genericblock
            case OPTIONS.GENERICBLOCK:
                this.setOptionEnabled(NetworkRuleOption.Genericblock, true);
                this.setRequestType(RequestType.Document, true);
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $jsinject
            case OPTIONS.JSINJECT:
                this.setOptionEnabled(NetworkRuleOption.Jsinject, true);
                this.setRequestType(RequestType.Document, true);
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $urlblock
            case OPTIONS.URLBLOCK:
                this.setOptionEnabled(NetworkRuleOption.Urlblock, true);
                this.setRequestType(RequestType.Document, true);
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $content
            case OPTIONS.CONTENT:
                this.setOptionEnabled(NetworkRuleOption.Content, true);
                this.setRequestType(RequestType.Document, true);
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $document, $doc
            case OPTIONS.DOCUMENT:
            case OPTIONS.DOC:
                this.setRequestType(RequestType.Document, true);
                // In the case of allowlist rules $document implicitly includes
                // all these modifiers: `$content`, `$elemhide`, `$jsinject`,
                // `$urlblock`.
                if (this.isAllowlist()) {
                    this.setOptionEnabled(NetworkRuleOption.Elemhide, true, true);
                    this.setOptionEnabled(NetworkRuleOption.Jsinject, true, true);
                    this.setOptionEnabled(NetworkRuleOption.Urlblock, true, true);
                    this.setOptionEnabled(NetworkRuleOption.Content, true, true);
                }
                break;
            // $~document, $~doc
            case NOT_MARK + OPTIONS.DOCUMENT:
            case NOT_MARK + OPTIONS.DOC:
                this.setRequestType(RequestType.Document, false);
                break;
            // $stealh
            case OPTIONS.STEALTH:
                this.setOptionEnabled(NetworkRuleOption.Stealth, true);
                break;
            // $popup
            case OPTIONS.POPUP:
                this.setRequestType(RequestType.Document, true);
                this.setOptionEnabled(NetworkRuleOption.Popup, true);
                break;
            // Content type options
            // $script
            case OPTIONS.SCRIPT:
                this.setRequestType(RequestType.Script, true);
                break;
            // $~script
            case NOT_MARK + OPTIONS.SCRIPT:
                this.setRequestType(RequestType.Script, false);
                break;
            // $stylesheet
            case OPTIONS.STYLESHEET:
                this.setRequestType(RequestType.Stylesheet, true);
                break;
            // $~stylesheet
            case NOT_MARK + OPTIONS.STYLESHEET:
                this.setRequestType(RequestType.Stylesheet, false);
                break;
            // $subdocument
            case OPTIONS.SUBDOCUMENT:
                this.setRequestType(RequestType.SubDocument, true);
                break;
            // $~subdocument
            case NOT_MARK + OPTIONS.SUBDOCUMENT:
                this.setRequestType(RequestType.SubDocument, false);
                break;
            // $object
            case OPTIONS.OBJECT:
                this.setRequestType(RequestType.Object, true);
                break;
            // $~object
            case NOT_MARK + OPTIONS.OBJECT:
                this.setRequestType(RequestType.Object, false);
                break;
            // $image
            case OPTIONS.IMAGE:
                this.setRequestType(RequestType.Image, true);
                break;
            // $~image
            case NOT_MARK + OPTIONS.IMAGE:
                this.setRequestType(RequestType.Image, false);
                break;
            // $xmlhttprequest
            case OPTIONS.XMLHTTPREQUEST:
                this.setRequestType(RequestType.XmlHttpRequest, true);
                break;
            // $~xmlhttprequest
            case NOT_MARK + OPTIONS.XMLHTTPREQUEST:
                this.setRequestType(RequestType.XmlHttpRequest, false);
                break;
            // $media
            case OPTIONS.MEDIA:
                this.setRequestType(RequestType.Media, true);
                break;
            // $~media
            case NOT_MARK + OPTIONS.MEDIA:
                this.setRequestType(RequestType.Media, false);
                break;
            // $font
            case OPTIONS.FONT:
                this.setRequestType(RequestType.Font, true);
                break;
            // $~font
            case NOT_MARK + OPTIONS.FONT:
                this.setRequestType(RequestType.Font, false);
                break;
            // $websocket
            case OPTIONS.WEBSOCKET:
                this.setRequestType(RequestType.WebSocket, true);
                break;
            // $~websocket
            case NOT_MARK + OPTIONS.WEBSOCKET:
                this.setRequestType(RequestType.WebSocket, false);
                break;
            // $other
            case OPTIONS.OTHER:
                this.setRequestType(RequestType.Other, true);
                break;
            // $~other
            case NOT_MARK + OPTIONS.OTHER:
                this.setRequestType(RequestType.Other, false);
                break;
            // $ping
            case OPTIONS.PING:
                this.setRequestType(RequestType.Ping, true);
                break;
            // $~ping
            case NOT_MARK + OPTIONS.PING:
                this.setRequestType(RequestType.Ping, false);
                break;
            // Special modifiers
            // $badfilter
            case OPTIONS.BADFILTER:
                this.setOptionEnabled(NetworkRuleOption.Badfilter, true);
                break;
            // $csp
            case OPTIONS.CSP:
                this.setOptionEnabled(NetworkRuleOption.Csp, true);
                this.advancedModifier = new CspModifier(optionValue, this.isAllowlist());
                break;
            // $replace
            case OPTIONS.REPLACE:
                this.setOptionEnabled(NetworkRuleOption.Replace, true);
                this.advancedModifier = new ReplaceModifier(optionValue);
                break;
            // $cookie
            case OPTIONS.COOKIE:
                this.setOptionEnabled(NetworkRuleOption.Cookie, true);
                this.advancedModifier = new CookieModifier(optionValue);
                break;
            // $redirect
            case OPTIONS.REDIRECT:
                this.setOptionEnabled(NetworkRuleOption.Redirect, true);
                this.advancedModifier = new RedirectModifier(optionValue, this.ruleText, this.isAllowlist());
                break;
            // $redirect-rule
            case OPTIONS.REDIRECTRULE:
                this.setOptionEnabled(NetworkRuleOption.Redirect, true);
                this.advancedModifier = new RedirectModifier(optionValue, this.ruleText, this.isAllowlist(), true);
                break;
            // $removeparam
            case OPTIONS.REMOVEPARAM:
                this.setOptionEnabled(NetworkRuleOption.RemoveParam, true);
                this.advancedModifier = new RemoveParamModifier(optionValue);
                break;
            // $removeheader
            case OPTIONS.REMOVEHEADER:
                this.setOptionEnabled(NetworkRuleOption.RemoveHeader, true);
                this.advancedModifier = new RemoveHeaderModifier(optionValue, this.isAllowlist());
                break;
            // $permissions
            case OPTIONS.PERMISSIONS:
                // simple validation of permissions rules for compiler.
                // should be fully supported in tsurlfilter v2.3 and the browser extension v4.4. AG-17467
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension does not support $permissions modifier yet');
                }
                this.setOptionEnabled(NetworkRuleOption.Permissions, true);
                break;
            // $jsonprune
            // simple validation of jsonprune rules for compiler
            // https://github.com/AdguardTeam/FiltersCompiler/issues/168
            case OPTIONS.JSONPRUNE:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension does not support $jsonprune modifier yet');
                }
                this.setOptionEnabled(NetworkRuleOption.JsonPrune, true);
                // TODO: should be properly implemented later
                // https://github.com/AdguardTeam/tsurlfilter/issues/71
                break;
            // $hls
            // simple validation of hls rules for compiler
            // https://github.com/AdguardTeam/FiltersCompiler/issues/169
            case OPTIONS.HLS:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension does not support $hls modifier yet');
                }
                this.setOptionEnabled(NetworkRuleOption.Hls, true);
                // TODO: should be properly implemented later
                // https://github.com/AdguardTeam/tsurlfilter/issues/72
                break;
            // $referrerpolicy
            // simple validation of referrerpolicy rules for compiler
            // https://github.com/AdguardTeam/FiltersCompiler/issues/191
            case OPTIONS.REFERRERPOLICY:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension does not support $referrerpolicy modifier');
                }
                // do nothing as $referrerpolicy is supported by CoreLibs-based apps only.
                // it is needed for proper rule conversion performed by FiltersCompiler
                // so rules with $referrerpolicy modifier is not marked as invalid
                break;
            // Dns modifiers
            // $client
            case OPTIONS.CLIENT:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $client modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Client, true);
                this.advancedModifier = new ClientModifier(optionValue);
                break;
            // $dnsrewrite
            case OPTIONS.DNSREWRITE:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $dnsrewrite modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.DnsRewrite, true);
                this.advancedModifier = new DnsRewriteModifier(optionValue);
                break;
            // $dnstype
            case OPTIONS.DNSTYPE:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $dnstype modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.DnsType, true);
                this.advancedModifier = new DnsTypeModifier(optionValue);
                break;
            // $ctag
            case OPTIONS.CTAG:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $ctag modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Ctag, true);
                this.advancedModifier = new CtagModifier(optionValue);
                break;
            // $app
            case OPTIONS.APP:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $app modifier');
                }
                this.appModifier = new AppModifier(optionValue);
                break;
            // $network
            case OPTIONS.NETWORK:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $network modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Network, true);
                break;
            // $extension
            case OPTIONS.EXTENSION:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $extension modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Extension, true);
                break;
            // $~extension
            case NOT_MARK + OPTIONS.EXTENSION:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $extension modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Extension, false);
                break;
            // $all
            case OPTIONS.ALL:
                if (this.isAllowlist()) {
                    throw new SyntaxError('Rule with $all modifier can not be allowlist rule');
                }
                // Set all request types
                Object.values(RequestType).forEach(function (type) {
                    _this.setRequestType(type, true);
                });
                this.setOptionEnabled(NetworkRuleOption.Popup, true);
                break;
            // $empty and $mp4
            // Deprecated in favor of $redirect
            case OPTIONS.EMPTY:
            case OPTIONS.MP4:
                // Do nothing.
                break;
            default: {
                // clear empty values
                var modifierView = [optionName, optionValue]
                    .filter(function (i) { return i; })
                    .join('=');
                throw new SyntaxError("Unknown modifier: ".concat(modifierView));
            }
        }
    };
    /**
     * To calculate priority, we've categorized modifiers into different groups.
     * These groups are ranked based on their priority, from lowest to highest.
     * A modifier that significantly narrows the scope of a rule adds more
     * weight to its total priority. Conversely, if a rule applies to a broader
     * range of requests, its priority decreases.
     *
     * It's worth noting that there are cases where a single-parameter modifier
     * has a higher priority than multi-parameter ones. For instance, in
     * the case of `$domain=example.com|example.org`, a rule that includes two
     * domains has a slightly broader effective area than a rule with one
     * specified domain, therefore its priority is lower.
     *
     * The base priority weight of any rule is 1. If the calculated priority
     * is a floating-point number, it will be **rounded up** to the smallest
     * integer greater than or equal to the calculated weight.
     *
     * @see {@link NetworkRule.PermittedRequestTypeWeight}
     * @see {@link NetworkRule.PermittedDomainWeight}
     * @see {@link NetworkRule.SpecificExceptionsWeight}
     * @see {@link NetworkRule.AllowlistRuleWeight}
     * @see {@link NetworkRule.RedirectRuleWeight}
     * @see {@link NetworkRule.ImportantRuleWeight}
     *
     * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-counting}
     */
    NetworkRule.prototype.calculatePriorityWeight = function () {
        var _a, _b;
        // Base modifiers, category 1.
        this.priorityWeight += countEnabledBits(this.enabledOptions, NetworkRule.CATEGORY_1_OPTIONS_MASK);
        this.priorityWeight += countEnabledBits(this.disabledOptions, NetworkRule.CATEGORY_1_OPTIONS_MASK);
        /**
         * When dealing with a negated domain, app, method, or content-type,
         * we add a point for the existence of the modifier itself, regardless
         * of the quantity of negated domains or content-types. This is because
         * the rule's scope is already infinitely broad. Put simply,
         * by prohibiting multiple domains, content-types, methods or apps,
         * the scope of the rule becomes only minimally smaller.
         */
        if (this.denyAllowDomains && this.denyAllowDomains.length > 0) {
            this.priorityWeight += 1;
        }
        if (this.restrictedDomains && this.restrictedDomains.length > 0) {
            this.priorityWeight += 1;
        }
        if (((_a = this.methodModifier) === null || _a === void 0 ? void 0 : _a.restrictedValues) && this.methodModifier.restrictedValues.length > 0) {
            this.priorityWeight += 1;
        }
        if (this.restrictedRequestTypes !== RequestType.NotSet) {
            this.priorityWeight += 1;
        }
        // $to modifier is basically a replacement for a regular expression
        // See https://github.com/AdguardTeam/KnowledgeBase/pull/196#discussion_r1221401215
        if (this.toModifier) {
            this.priorityWeight += 1;
        }
        /**
         * Category 2: permitted request types and methods.
         * Specified content-types add `50 + 50 / number_of_content_types`,
         * for example: `||example.com^$image,script` will add
         * `50 + 50 / 2 = 50 + 25 = 75` to the total weight of the rule.
         * The `$popup` also belongs to this category, because it implicitly
         * adds the modifier `$document`.
         * Similarly, specific exceptions add `$document,subdocument`.
         */
        if (this.permittedRequestTypes !== RequestType.NotSet) {
            var numberOfPermittedRequestTypes = getBitCount(this.permittedRequestTypes);
            // More permitted request types mean less priority weight.
            var relativeWeight = NetworkRule.CategoryTwoWeight / numberOfPermittedRequestTypes;
            this.priorityWeight += NetworkRule.CategoryTwoWeight + relativeWeight;
        }
        if (((_b = this.methodModifier) === null || _b === void 0 ? void 0 : _b.permittedValues) && this.methodModifier.permittedValues.length > 0) {
            // More permitted request methods mean less priority weight.
            var relativeWeight = NetworkRule.CategoryTwoWeight / this.methodModifier.permittedValues.length;
            this.priorityWeight += NetworkRule.CategoryTwoWeight + relativeWeight;
        }
        /**
         * Category 3: permitted domains.
         * Specified domains through `$domain` and specified applications
         * through `$app` add `100 + 100 / number_domains (or number_applications)`,
         * for example:
         * `||example.com^$domain=example.com|example.org|example.net`
         * will add `100 + 100 / 3 = 134.3 = 134` or
         * `||example.com^$app=org.example.app1|org.example.app2`
         * will add `100 + 100 / 2 = 151`.
         */
        if (this.permittedDomains && this.permittedDomains.length > 0) {
            // More permitted domains mean less priority weight.
            var relativeWeight = NetworkRule.CategoryThreeWeight / this.permittedDomains.length;
            this.priorityWeight += NetworkRule.CategoryThreeWeight + relativeWeight;
        }
        // Category 4: redirect rules.
        if (this.isOptionEnabled(NetworkRuleOption.Redirect)) {
            this.priorityWeight += NetworkRule.CategoryFourWeight;
        }
        // Category 5: specific exceptions.
        this.priorityWeight += NetworkRule.CategoryFiveWeight * countEnabledBits(this.enabledOptions, NetworkRule.SPECIFIC_EXCLUSIONS_MASK);
        // Category 6: allowlist rules.
        if (this.isAllowlist()) {
            this.priorityWeight += NetworkRule.CategorySixWeight;
        }
        // Category 7: important rules.
        if (this.isOptionEnabled(NetworkRuleOption.Important)) {
            this.priorityWeight += NetworkRule.CategorySevenWeight;
        }
        // Round up to avoid overlap between different categories of rules.
        this.priorityWeight = Math.ceil(this.priorityWeight);
    };
    /**
     * Validates rule options
     */
    NetworkRule.prototype.validateOptions = function () {
        if (this.advancedModifier instanceof RemoveParamModifier) {
            this.validateRemoveParamRule();
        }
        else if (this.advancedModifier instanceof RemoveHeaderModifier) {
            this.validateRemoveHeaderRule();
        }
        else if (this.toModifier !== null) {
            this.validateToRule();
        }
        else if (this.denyAllowDomains !== null) {
            this.validateDenyallowRule();
        }
    };
    /**
     * $removeparam rules are not compatible with any other modifiers except $domain,
     * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
     * The rules with any other modifiers are considered invalid and will be discarded.
     */
    NetworkRule.prototype.validateRemoveParamRule = function () {
        if ((this.enabledOptions | NetworkRuleOption.RemoveParamCompatibleOptions)
            !== NetworkRuleOption.RemoveParamCompatibleOptions) {
            throw new SyntaxError('$removeparam rules are not compatible with some other modifiers');
        }
    };
    /**
     * $removeheader rules are not compatible with any other modifiers except $domain,
     * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
     * The rules with any other modifiers are considered invalid and will be discarded.
     */
    NetworkRule.prototype.validateRemoveHeaderRule = function () {
        if ((this.enabledOptions | NetworkRuleOption.RemoveHeaderCompatibleOptions)
            !== NetworkRuleOption.RemoveHeaderCompatibleOptions) {
            throw new SyntaxError('$removeheader rules are not compatible with some other modifiers');
        }
    };
    /**
     * $to rules are not compatible $denyallow - these rules considered invalid
     * and will be discarded.
     */
    NetworkRule.prototype.validateToRule = function () {
        if (this.denyAllowDomains) {
            throw new SyntaxError('modifier $to is not compatible with $denyallow modifier');
        }
    };
    /**
     * $denyallow rules are not compatible $to - these rules considered invalid
     * and will be discarded.
     */
    NetworkRule.prototype.validateDenyallowRule = function () {
        if (this.toModifier) {
            throw new SyntaxError('modifier $to is not compatible with $denyallow modifier');
        }
    };
    /**
     * parseRuleText splits the rule text into multiple parts.
     * @param ruleText - original rule text
     * @returns basic rule parts
     *
     * @throws error if the rule is empty (for instance, empty string or `@@`)
     */
    NetworkRule.parseRuleText = function (ruleText) {
        var ruleParts = new BasicRuleParts();
        ruleParts.allowlist = false;
        var startIndex = 0;
        if (ruleText.startsWith(NetworkRule.MASK_ALLOWLIST)) {
            ruleParts.allowlist = true;
            startIndex = NetworkRule.MASK_ALLOWLIST.length;
        }
        if (ruleText.length <= startIndex) {
            throw new SyntaxError('Rule is too short');
        }
        // Setting pattern to rule text (for the case of empty options)
        ruleParts.pattern = ruleText.substring(startIndex);
        // Avoid parsing options inside of a regex rule
        if (ruleParts.pattern.startsWith(SimpleRegex.MASK_REGEX_RULE)
            && ruleParts.pattern.endsWith(SimpleRegex.MASK_REGEX_RULE)
            && !ruleParts.pattern.includes("".concat(NetworkRule.OPTIONS.REPLACE, "="))) {
            return ruleParts;
        }
        var removeParamIndex = ruleText.lastIndexOf("".concat(NetworkRule.OPTIONS.REMOVEPARAM, "="));
        var endIndex = removeParamIndex >= 0 ? removeParamIndex : ruleText.length - 2;
        var foundEscaped = false;
        for (var i = endIndex; i >= startIndex; i -= 1) {
            var c = ruleText.charAt(i);
            if (c === NetworkRule.OPTIONS_DELIMITER) {
                if (i > startIndex && ruleText.charAt(i - 1) === NetworkRule.ESCAPE_CHARACTER) {
                    foundEscaped = true;
                }
                else {
                    ruleParts.pattern = ruleText.substring(startIndex, i);
                    ruleParts.options = ruleText.substring(i + 1);
                    if (foundEscaped) {
                        // Find and replace escaped options delimiter
                        ruleParts.options = ruleParts.options.replace(NetworkRule.RE_ESCAPED_OPTIONS_DELIMITER, NetworkRule.OPTIONS_DELIMITER);
                        // Reset the regexp state
                        NetworkRule.RE_ESCAPED_OPTIONS_DELIMITER.lastIndex = 0;
                    }
                    // Options delimiter was found, exiting loop
                    break;
                }
            }
        }
        return ruleParts;
    };
    /**
     * Rules with base modifiers, from category 1, each of them adds 1
     * to the weight of the rule.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-1
     */
    NetworkRule.CATEGORY_1_OPTIONS_MASK = NetworkRuleOption.ThirdParty
        | NetworkRuleOption.MatchCase
        | NetworkRuleOption.DnsRewrite;
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with permitted request types and methods.
     * The value 50 is chosen in order to cover (with a margin) all possible
     * combinations and variations of rules from categories with a lower
     * priority (each of them adds 1 to the rule priority).
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-2
     */
    NetworkRule.CategoryTwoWeight = 50;
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with allowed domains.
     * The value 100 is chosen to cover all possible combinations and variations
     * of rules from categories with a lower priority, for example a rule with
     * one allowed query type will get priority 100 (50 + 50/1), but for allowed
     * domains with any number of domains we will get at least 101 (for 100
     * domains: 100 + 100/100; for 200 100 + 100/200; or even for 10000:
     * 100 + 100/10000) because the resulting weight is rounded up.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-3
     */
    NetworkRule.CategoryThreeWeight = 100;
    /**
     * The priority weight used in {@link calculatePriorityWeight}
     * for $redirect rules.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-6
     */
    NetworkRule.CategoryFourWeight = Math.pow(10, 3);
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with specific exceptions.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-4
     */
    NetworkRule.CategoryFiveWeight = Math.pow(10, 4);
    /**
     * Rules with specific exclusions, from category 4, each of them adds
     * {@link SpecificExceptionsWeight} to the weight of the rule.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-4
     */
    NetworkRule.SPECIFIC_EXCLUSIONS_MASK = NetworkRuleOption.Elemhide
        | NetworkRuleOption.Generichide
        | NetworkRuleOption.Specifichide
        | NetworkRuleOption.Content
        | NetworkRuleOption.Urlblock
        | NetworkRuleOption.Genericblock
        | NetworkRuleOption.Jsinject
        | NetworkRuleOption.Extension;
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with allowlist mark '@@'.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-5
     */
    NetworkRule.CategorySixWeight = Math.pow(10, 5);
    /**
     * The priority weight used in {@link calculatePriorityWeight}
     * for $important rules.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-7
     */
    NetworkRule.CategorySevenWeight = Math.pow(10, 6);
    /**
     * Separates the rule pattern from the list of modifiers.
     *
     * ```
     * rule = ["@@"] pattern [ "$" modifiers ]
     * modifiers = [modifier0, modifier1[, ...[, modifierN]]]
     * ```
     */
    NetworkRule.OPTIONS_DELIMITER = OPTIONS_DELIMITER;
    /**
     * This character is used to escape special characters in modifiers values
     */
    NetworkRule.ESCAPE_CHARACTER = ESCAPE_CHARACTER;
    // eslint-disable-next-line max-len
    NetworkRule.RE_ESCAPED_OPTIONS_DELIMITER = new RegExp("".concat(NetworkRule.ESCAPE_CHARACTER).concat(NetworkRule.OPTIONS_DELIMITER), 'g');
    /**
     * A marker that is used in rules of exception.
     * To turn off filtering for a request, start your rule with this marker.
     */
    NetworkRule.MASK_ALLOWLIST = MASK_ALLOWLIST;
    /**
     * Mark that negates options
     */
    NetworkRule.NOT_MARK = NOT_MARK;
    /**
     * Rule options
     */
    NetworkRule.OPTIONS = NETWORK_RULE_OPTIONS;
    return NetworkRule;
}());

/**
 * Rule with index
 */
var IndexedRule = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param rule
     * @param index
     */
    function IndexedRule(rule, index) {
        this.rule = rule;
        this.index = index;
    }
    return IndexedRule;
}());

/**
 * Export logger implementation
 */
var logger = console;

/**
 * Enumeration with the cosmetic rules markers.
 *
 * All cosmetic rules have similar structure:
 * ```
 * rule = [domains] "marker" content
 * domains = [domain0, domain1[, ...[, domainN]]]
 * ```
 *
 * For instance, element hiding rules look like:
 * `example.org##.banner`
 *
 * In this case:
 * * `[domains]` is `example.org` (comma-separated list of domains)
 * * `marker` is `##` (marker of element hiding rules)
 * * `content` is `.banner` (CSS selector)
 */
var CosmeticRuleMarker;
(function (CosmeticRuleMarker) {
    /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-elemhide-rules */
    CosmeticRuleMarker["ElementHiding"] = "##";
    /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#element-hiding-rules-exceptions */
    CosmeticRuleMarker["ElementHidingException"] = "#@#";
    /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#extended-css-selectors */
    CosmeticRuleMarker["ElementHidingExtCSS"] = "#?#";
    /** Basically the same as {@link CosmeticRuleMarker.ElementHidingException} */
    CosmeticRuleMarker["ElementHidingExtCSSException"] = "#@?#";
    /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules */
    CosmeticRuleMarker["Css"] = "#$#";
    /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules-exceptions */
    CosmeticRuleMarker["CssException"] = "#@$#";
    /**
     * CSS rules that use extended CSS selectors:
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#extended-css-selectors
     */
    CosmeticRuleMarker["CssExtCSS"] = "#$?#";
    /** Basically the same as {@link CosmeticRuleMarker.CssException} */
    CosmeticRuleMarker["CssExtCSSException"] = "#@$?#";
    /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#javascript-rules */
    CosmeticRuleMarker["Js"] = "#%#";
    /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#javascript-rules-exceptions-1 */
    CosmeticRuleMarker["JsException"] = "#@%#";
    /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules */
    CosmeticRuleMarker["Html"] = "$$";
    /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules-exceptions-1 */
    CosmeticRuleMarker["HtmlException"] = "$@$";
})(CosmeticRuleMarker || (CosmeticRuleMarker = {}));
/**
 * findCosmeticRuleMarker looks for a cosmetic rule marker in the rule text
 * and returns the start index of the marker and the marker found.
 * If nothing found, it returns -1 and null.
 *
 * @privateRemarks
 *
 * The idea is to search for the rule marker as quickly as possible.
 * If we were simply using `Array.includes` we had to call it a dozen of times (for every marker),
 * and that'd have been much slower.
 *
 * @param ruleText - rule text to scan.
 */
function findCosmeticRuleMarker(ruleText) {
    var maxIndex = ruleText.length - 1;
    for (var i = 0; i < maxIndex; i += 1) {
        var char = ruleText.charAt(i);
        switch (char) {
            case '#':
                if (i + 4 <= maxIndex) {
                    if (ruleText.charAt(i + 1) === '@'
                        && ruleText.charAt(i + 2) === '$'
                        && ruleText.charAt(i + 3) === '?'
                        && ruleText.charAt(i + 4) === '#') {
                        return [i, CosmeticRuleMarker.CssExtCSSException];
                    }
                }
                if (i + 3 <= maxIndex) {
                    if (ruleText.charAt(i + 1) === '@'
                        && ruleText.charAt(i + 2) === '?' && ruleText.charAt(i + 3) === '#') {
                        return [i, CosmeticRuleMarker.ElementHidingExtCSSException];
                    }
                    if (ruleText.charAt(i + 1) === '@'
                        && ruleText.charAt(i + 2) === '$' && ruleText.charAt(i + 3) === '#') {
                        return [i, CosmeticRuleMarker.CssException];
                    }
                    if (ruleText.charAt(i + 1) === '@'
                        && ruleText.charAt(i + 2) === '%' && ruleText.charAt(i + 3) === '#') {
                        return [i, CosmeticRuleMarker.JsException];
                    }
                    if (ruleText.charAt(i + 1) === '$'
                        && ruleText.charAt(i + 2) === '?' && ruleText.charAt(i + 3) === '#') {
                        return [i, CosmeticRuleMarker.CssExtCSS];
                    }
                }
                if (i + 2 <= maxIndex) {
                    if (ruleText.charAt(i + 1) === '@' && ruleText.charAt(i + 2) === '#') {
                        return [i, CosmeticRuleMarker.ElementHidingException];
                    }
                    if (ruleText.charAt(i + 1) === '?' && ruleText.charAt(i + 2) === '#') {
                        return [i, CosmeticRuleMarker.ElementHidingExtCSS];
                    }
                    if (ruleText.charAt(i + 1) === '%' && ruleText.charAt(i + 2) === '#') {
                        return [i, CosmeticRuleMarker.Js];
                    }
                    if (ruleText.charAt(i + 1) === '$' && ruleText.charAt(i + 2) === '#') {
                        return [i, CosmeticRuleMarker.Css];
                    }
                }
                if (i + 1 <= maxIndex) {
                    if (ruleText.charAt(i + 1) === '#') {
                        // Handling false positives while looking for cosmetic rules in host files.
                        //
                        // For instance, it could look like this:
                        // 127.0.0.1 localhost ## this is just a comment
                        if (i > 0 && ruleText.charAt(i - 1) === ' ') {
                            return [-1, null];
                        }
                        return [i, CosmeticRuleMarker.ElementHiding];
                    }
                }
                break;
            case '$':
                if (i + 2 <= maxIndex) {
                    if (ruleText.charAt(i + 1) === '@' && ruleText.charAt(i + 2) === '$') {
                        return [i, CosmeticRuleMarker.HtmlException];
                    }
                }
                if (i + 1 <= maxIndex) {
                    if (ruleText.charAt(i + 1) === '$') {
                        return [i, CosmeticRuleMarker.Html];
                    }
                }
                break;
        }
    }
    return [-1, null];
}
/**
 * Detects is the rule is extended css rule
 * @param marker - string to check
 */
function isExtCssMarker(marker) {
    var EXTENDED_CSS_MARKERS = [
        CosmeticRuleMarker.CssExtCSS,
        CosmeticRuleMarker.CssExtCSSException,
        CosmeticRuleMarker.ElementHidingExtCSS,
        CosmeticRuleMarker.ElementHidingExtCSSException,
    ];
    return EXTENDED_CSS_MARKERS.indexOf(marker) !== -1;
}
/**
 * AdGuard scriptlet rule mask
 */
var ADG_SCRIPTLET_MASK = '//scriptlet';

var CosmeticRuleModifiers;
(function (CosmeticRuleModifiers) {
    CosmeticRuleModifiers["Path"] = "path";
    CosmeticRuleModifiers["Domain"] = "domain";
})(CosmeticRuleModifiers || (CosmeticRuleModifiers = {}));
var CosmeticRuleModifiersSyntax = {
    OpenBracket: '[',
    CloseBracket: ']',
    SpecialSymbol: '$',
    Delimiter: ',',
    Assigner: '=',
    EscapeCharacter: '\\',
};

var cosmeticRuleModifiersList = Object.values(CosmeticRuleModifiers);
/**
 * Helper class for parsing text of cosmetic rules
 * used by CosmeticRule and [Filter compiler](https://github.com/AdguardTeam/FiltersCompiler)
 *
 *
 * The cosmetic rule contains of the following parts:
 *
 * `pattern##content`
 *
 * `pattern` contains the list of the rule modifiers and domains.
 *
 * `##` is a marker (might be a different marker depending on the rule type).
 * You can find the list of markers in the CosmeticRuleMarker enumeration.
 *
 * `content` might be a CSS selector, a scriptlet or something else, depending on the rule type.
 */
var CosmeticRuleParser = /** @class */ (function () {
    function CosmeticRuleParser() {
    }
    /**
     * Parse the rule's pattern, cosmetic marker and the content parts from the rule text.
     * If the content is empty, throws a SyntaxError.
     *
     * @param ruleText
     * @returns Object with pattern, marker and content text parts
     */
    CosmeticRuleParser.parseRuleTextByMarker = function (ruleText) {
        var _a = findCosmeticRuleMarker(ruleText), markerIndex = _a[0], marker = _a[1];
        if (marker === null) {
            throw new SyntaxError('Not a cosmetic rule');
        }
        var content = ruleText.substring(markerIndex + marker.length).trim();
        if (!content) {
            throw new SyntaxError('Rule content is empty');
        }
        var pattern;
        if (markerIndex > 0) {
            pattern = ruleText.substring(0, markerIndex);
        }
        return {
            pattern: pattern,
            marker: marker,
            content: content,
        };
    };
    /**
     * Extracts the rule modifiers and domains from the rule pattern.
     * @param rulePattern
     * @returns Object with modifiers and domains text parts
     */
    CosmeticRuleParser.parseRulePatternText = function (rulePattern) {
        var OpenBracket = CosmeticRuleModifiersSyntax.OpenBracket, CloseBracket = CosmeticRuleModifiersSyntax.CloseBracket, SpecialSymbol = CosmeticRuleModifiersSyntax.SpecialSymbol, EscapeCharacter = CosmeticRuleModifiersSyntax.EscapeCharacter;
        if (!rulePattern.startsWith("".concat(OpenBracket + SpecialSymbol))) {
            return { domainsText: rulePattern };
        }
        var closeBracketIndex;
        // The first two characters cannot be closing brackets
        for (var i = 2; i < rulePattern.length; i += 1) {
            if (rulePattern[i] === CloseBracket && rulePattern[i - 1] !== EscapeCharacter) {
                closeBracketIndex = i;
                break;
            }
        }
        if (!closeBracketIndex) {
            throw new SyntaxError('Can\'t parse modifiers list');
        }
        // Handle this case: `[$]`
        if (closeBracketIndex === 2) {
            throw new SyntaxError('Modifiers list can\'t be empty');
        }
        var modifiersText = rulePattern.slice(2, closeBracketIndex);
        var domainsText;
        if (closeBracketIndex < rulePattern.length - 1) {
            domainsText = rulePattern.slice(closeBracketIndex + 1);
        }
        return {
            modifiersText: modifiersText,
            domainsText: domainsText,
        };
    };
    /**
     * Parses the list of modifiers. Parsing is done in the same way as it's done in the NetworkRule, i.e.
     * we have a comma-separated list of modifier-value pairs.
     * If we encounter an invalid modifier, this method throws a SyntaxError.
     *
     * @param modifiersText - list of modifiers splited by comma
     * @returns - modifiers collection object
     */
    CosmeticRuleParser.parseRuleModifiers = function (modifiersText) {
        if (!modifiersText) {
            return null;
        }
        var Assigner = CosmeticRuleModifiersSyntax.Assigner;
        var modifiersTextArray = parseOptionsString(modifiersText, false);
        var modifiers = Object.create(null);
        for (var i = 0; i < modifiersTextArray.length; i += 1) {
            var modifierText = modifiersTextArray[i];
            var assignerIndex = modifierText.indexOf(Assigner);
            if (modifierText === 'path') {
                // Empty path modifier without assigner and value will match only main page
                modifiers[modifierText] = '';
                continue;
            }
            if (assignerIndex === -1) {
                throw new SyntaxError('Modifier must have assigned value');
            }
            var modifierKey = modifierText.substring(0, assignerIndex);
            if (cosmeticRuleModifiersList.includes(modifierKey)) {
                var modifierValue = modifierText.substring(assignerIndex + 1);
                modifiers[modifierKey] = modifierValue;
            }
            else {
                throw new SyntaxError("'".concat(modifierKey, "' is not valid modifier"));
            }
        }
        return modifiers;
    };
    /**
     * Parses the rule pattern and extracts the permitted/restricted domains and the unescaped path modifier value,
     * If domains are declared through $domain modifier and pattern domain list, this method throws a SyntaxError.
     * @param rulePattern - rule pattern text
     *
     * @returns Object with permitted/restricted domains list and the path modifier string value
     */
    CosmeticRuleParser.parseRulePattern = function (rulePattern) {
        var _a = CosmeticRuleParser.parseRulePatternText(rulePattern), domainsText = _a.domainsText, modifiersText = _a.modifiersText;
        var domains = domainsText;
        var path;
        var modifiers = CosmeticRuleParser.parseRuleModifiers(modifiersText);
        if (modifiers) {
            if (modifiers.path || modifiers.path === '') {
                path = modifiers.path;
                if (SimpleRegex.isRegexPattern(path)) {
                    path = SimpleRegex.unescapeRegexSpecials(path, SimpleRegex.reModifierPatternEscapedSpecialCharacters);
                }
            }
            if (modifiers.domain) {
                if (domains) {
                    throw new SyntaxError('The $domain modifier is not allowed in a domain-specific rule');
                }
                else {
                    domains = modifiers.domain;
                }
            }
        }
        var permittedDomains;
        var restrictedDomains;
        // Skip wildcard domain
        if (domains && domains !== SimpleRegex.MASK_ANY_CHARACTER) {
            var separator = (modifiers === null || modifiers === void 0 ? void 0 : modifiers.domain) ? PIPE_SEPARATOR : COMMA_SEPARATOR;
            var domainModifier = new DomainModifier(domains, separator);
            if (domainModifier.permittedDomains) {
                permittedDomains = domainModifier.permittedDomains;
            }
            if (domainModifier.restrictedDomains) {
                restrictedDomains = domainModifier.restrictedDomains;
            }
        }
        return {
            path: path,
            permittedDomains: permittedDomains,
            restrictedDomains: restrictedDomains,
        };
    };
    return CosmeticRuleParser;
}());

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Scriptlets helper class
 */
// eslint-disable-next-line max-classes-per-file
var ScriptletParser = /** @class */ (function () {
    function ScriptletParser() {
    }
    /**
     * Iterate over iterable argument and evaluate current state with transitions
     *
     * @param {Array|Collection|string} iterable
     * @param {Object} transitions transition functions
     * @param {string} initState first transition name
     * @param {any} args arguments which should be passed to transition functions
     * @returns {string} transition
     */
    ScriptletParser.iterateWithTransitions = function (iterable, transitions, initState, args) {
        var state = initState;
        for (var i = 0; i < iterable.length; i += 1) {
            state = transitions[state](iterable, i, args);
        }
        return state;
    };
    /**
     * Parse and validate scriptlet rule
     * @param {*} ruleContent
     * @returns {{name: string, args: Array<string>}}
     */
    ScriptletParser.parseRule = function (ruleContent) {
        var _a;
        var transitions = (_a = {},
            _a[ScriptletParser.TRANSITION.OPENED] = ScriptletParser.opened,
            _a[ScriptletParser.TRANSITION.PARAM] = ScriptletParser.param,
            _a[ScriptletParser.TRANSITION.CLOSED] = function () { },
            _a);
        var sep = { symb: null };
        var saver = new ScriptletParser.WordSaver();
        var state = ScriptletParser.iterateWithTransitions(ruleContent, transitions, ScriptletParser.TRANSITION.OPENED, { sep: sep, saver: saver });
        if (state !== 'closed') {
            throw new Error("Invalid scriptlet ".concat(ruleContent));
        }
        var args = saver.getAll();
        return {
            name: args[0],
            args: args.slice(1),
        };
    };
    /**
     * Helper class to accumulate an array of strings char by char
     */
    ScriptletParser.WordSaver = /** @class */ (function () {
        function class_1() {
            /**
             * String cursor
             */
            this.str = '';
            /**
             * Strings array
             */
            this.collectedStrings = [];
        }
        /**
         * Saves symbol to cursor
         *
         * @param s
         */
        class_1.prototype.saveSymbol = function (s) {
            this.str += s;
        };
        /**
         * Saves cursor to strings
         */
        class_1.prototype.saveStr = function () {
            this.collectedStrings.push(this.str);
            this.str = '';
        };
        /**
         * Returns collected strings
         */
        class_1.prototype.getAll = function () {
            return __spreadArray([], this.collectedStrings, true);
        };
        return class_1;
    }());
    /**
     * Transition names
     */
    ScriptletParser.TRANSITION = {
        OPENED: 'opened',
        PARAM: 'param',
        CLOSED: 'closed',
    };
    /**
     * Transition function: the current index position in start, end or between params
     * @param {string} rule
     * @param {number} index
     * @param {Object} Object
     * @property {Object} Object.sep contains prop symb with current separator char
     * @returns {string} transition
     */
    ScriptletParser.opened = function (rule, index, _a) {
        var sep = _a.sep;
        var char = rule[index];
        switch (char) {
            case ' ':
            case '(':
            case ',':
                return ScriptletParser.TRANSITION.OPENED;
            case '\'':
            case '"':
                // eslint-disable-next-line no-param-reassign
                sep.symb = char;
                return ScriptletParser.TRANSITION.PARAM;
            case ')':
                return index === rule.length - 1
                    ? ScriptletParser.TRANSITION.CLOSED
                    : ScriptletParser.TRANSITION.OPENED;
        }
        return undefined;
    };
    /**
     * Transition function: the current index position inside param
     *
     * @param {string} rule
     * @param {number} index
     * @param {Object} Object
     * @property {Object} Object.sep contains prop `symb` with current separator char
     * @property {Object} Object.saver helper which allow to save strings by car by char
     * @returns {string} transition
     */
    ScriptletParser.param = function (rule, index, _a) {
        var saver = _a.saver, sep = _a.sep;
        var char = rule[index];
        switch (char) {
            case '\'':
            case '"':
                if (char === sep.symb && rule[index - 1] !== '\\') {
                    // eslint-disable-next-line no-param-reassign
                    sep.symb = null;
                    saver.saveStr();
                    return ScriptletParser.TRANSITION.OPENED;
                }
                saver.saveSymbol(char);
                return ScriptletParser.TRANSITION.PARAM;
            default:
                saver.saveSymbol(char);
                return ScriptletParser.TRANSITION.PARAM;
        }
    };
    return ScriptletParser;
}());

/**
 * CosmeticRuleType is an enumeration of the possible
 * cosmetic rule types.
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-rules
 */
var CosmeticRuleType;
(function (CosmeticRuleType) {
    /**
     * Cosmetic rules that just hide page elements.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#element-hiding-rules
     */
    CosmeticRuleType[CosmeticRuleType["ElementHiding"] = 0] = "ElementHiding";
    /**
     * Cosmetic rules that allow adding custom CSS styles.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules
     */
    CosmeticRuleType[CosmeticRuleType["Css"] = 1] = "Css";
    /**
     * Cosmetic rules that allow executing custom JS scripts.
     * Some restrictions are applied to this type of rules by default.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#javascript-rules
     */
    CosmeticRuleType[CosmeticRuleType["Js"] = 2] = "Js";
    /**
     * Special type of rules that allows filtering HTML code of web pages.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules
     */
    CosmeticRuleType[CosmeticRuleType["Html"] = 3] = "Html";
})(CosmeticRuleType || (CosmeticRuleType = {}));
/**
 * Pseudo class indicators. They are used to detect if rule is extended or not even if rule does not
 * have extended css marker
 */
var EXT_CSS_PSEUDO_INDICATORS = [
    /**
     * Pseudo-classes :is(), and :not() may use native implementation
     * so they are not listed here
     * https://github.com/AdguardTeam/ExtendedCss#extended-css-is
     * https://github.com/AdguardTeam/ExtendedCss#extended-css-not
     */
    /**
     * :has() should also be conditionally considered as extended and should not be in this list
     * https://github.com/AdguardTeam/ExtendedCss#extended-css-has
     * but there is a bug with content blocker in safari
     * https://bugs.webkit.org/show_bug.cgi?id=248868
     *
     * TODO: remove ':has(' later
     */
    ':has(',
    ':contains(',
    ':matches-css(',
    ':matches-attr(',
    ':matches-property(',
    ':xpath(',
    ':upward(',
    ':nth-ancestor(',
    ':remove(',
    // aliases for :has()
    ':-abp-has(',
    // aliases for :contains()
    ':has-text(',
    ':-abp-contains(',
    // old syntax
    '[-ext-has=',
    '[-ext-contains=',
    '[-ext-has-text=',
    '[-ext-matches-css=',
    '[-ext-matches-css-before=',
    '[-ext-matches-css-after=',
    // obsolete since ExtendedCss v2.0.2 but still compatible
    // https://github.com/AdguardTeam/ExtendedCss/releases/tag/v2.0.2
    ':matches-css-before(',
    ':matches-css-after(',
];
/**
 * Implements a basic cosmetic rule.
 *
 * Cosmetic rules syntax are almost similar and looks like this:
 * ```
 * rule = [domains] "marker" content
 * domains = [domain0, domain1[, ...[, domainN]]]
 * ```
 *
 * The rule type is defined by the `marker` value, you can find the list of them
 * in the {@see CosmeticRuleMarker} enumeration.
 *
 * What matters, though, is what's in the `content` part of it.
 *
 * Examples:
 * * `example.org##.banner` -- element hiding rule
 * * `example.org#$#.banner { display: block; }` -- CSS rule
 * * `example.org#%#window.x=1;` -- JS rule
 * * `example.org#%#//scriptlet('scriptlet-name')` -- Scriptlet rule
 * * `example.org$$div[id="test"]` -- HTML filtering rule
 */
var CosmeticRule = /** @class */ (function () {
    /**
     * Creates an instance of the {@link CosmeticRule}.
     * It parses the rule and extracts the permitted/restricted domains,
     * and also the cosmetic rule's content.
     *
     * Depending on the rule type, the content might be transformed in
     * one of the helper classes, or kept as string when it's appropriate.
     *
     * @param ruleText - original rule text.
     * @param filterListId - ID of the filter list this rule belongs to.
     *
     * @throws error if it fails to parse the rule.
     */
    function CosmeticRule(ruleText, filterListId) {
        this.allowlist = false;
        this.extendedCss = false;
        this.permittedDomains = undefined;
        this.restrictedDomains = undefined;
        /**
         * Js script to execute
         */
        this.script = undefined;
        /**
         * Object with script code ready to execute and debug, domain values
         * @private
         */
        this.scriptData = null;
        /**
         * Object with scriptlet function and params
         * @private
         */
        this.scriptletData = null;
        /**
         * If the rule contains scriptlet content
         */
        this.isScriptlet = false;
        this.ruleText = ruleText;
        this.filterListId = filterListId;
        var _a = CosmeticRuleParser.parseRuleTextByMarker(ruleText), pattern = _a.pattern, marker = _a.marker, content = _a.content;
        this.content = content;
        this.type = CosmeticRule.parseType(marker);
        this.extendedCss = isExtCssMarker(marker);
        if (!this.extendedCss
            && (this.type === CosmeticRuleType.ElementHiding
                || this.type === CosmeticRuleType.Css)) {
            // additional check if rule is extended css rule by pseudo class indicators
            for (var i = 0; i < EXT_CSS_PSEUDO_INDICATORS.length; i += 1) {
                if (this.content.indexOf(EXT_CSS_PSEUDO_INDICATORS[i]) !== -1) {
                    this.extendedCss = true;
                    break;
                }
            }
        }
        CosmeticRule.validate(ruleText, this.type, content, this.extendedCss);
        if (pattern) {
            // This means that the marker is preceded by the list of domains and modifiers
            // Now it's a good time to parse them.
            var _b = CosmeticRuleParser.parseRulePattern(pattern), path = _b.path, permittedDomains = _b.permittedDomains, restrictedDomains = _b.restrictedDomains;
            if (path || path === '') {
                this.pathModifier = new Pattern(path);
            }
            if (permittedDomains) {
                this.permittedDomains = permittedDomains;
            }
            if (restrictedDomains) {
                this.restrictedDomains = restrictedDomains;
            }
        }
        this.allowlist = CosmeticRule.parseAllowlist(marker);
        this.isScriptlet = this.content.startsWith(ADG_SCRIPTLET_MASK);
    }
    /**
     * Parses first pseudo class from the specified CSS selector
     *
     * @param selector
     * @returns pseudo class name if found or null
     */
    CosmeticRule.parsePseudoClass = function (selector) {
        var beginIndex = 0;
        var nameStartIndex = -1;
        var squareBracketIndex = 0;
        while (squareBracketIndex >= 0) {
            nameStartIndex = selector.indexOf(':', beginIndex);
            if (nameStartIndex < 0) {
                return null;
            }
            if (nameStartIndex > 0 && selector.charAt(nameStartIndex - 1) === '\\') {
                // Escaped colon character
                return null;
            }
            squareBracketIndex = selector.indexOf('[', beginIndex);
            while (squareBracketIndex >= 0) {
                if (nameStartIndex > squareBracketIndex) {
                    var squareEndBracketIndex = selector.indexOf(']', squareBracketIndex + 1);
                    beginIndex = squareEndBracketIndex + 1;
                    if (nameStartIndex < squareEndBracketIndex) {
                        // Means that colon character is somewhere inside attribute selector
                        // Something like a[src^="http://domain.com"]
                        break;
                    }
                    if (squareEndBracketIndex > 0) {
                        squareBracketIndex = selector.indexOf('[', beginIndex);
                    }
                    else {
                        // bad rule, example: a[src="http:
                        return null;
                    }
                }
                else {
                    squareBracketIndex = -1;
                    break;
                }
            }
        }
        var nameEndIndex = indexOfAny(selector, [' ', ',', '\t', '>', '(', '[', '.', '#', ':', '+', '~', '"', '\''], nameStartIndex + 1);
        if (nameEndIndex < 0) {
            nameEndIndex = selector.length;
        }
        var name = selector.substring(nameStartIndex, nameEndIndex);
        if (name.length <= 1) {
            // Either empty name or a pseudo element (like ::content)
            return null;
        }
        return name;
    };
    CosmeticRule.prototype.getText = function () {
        return this.ruleText;
    };
    CosmeticRule.prototype.getFilterListId = function () {
        return this.filterListId;
    };
    /**
     * Cosmetic rule type (always present)
     */
    CosmeticRule.prototype.getType = function () {
        return this.type;
    };
    /**
     * Allowlist means that this rule is meant to disable other rules.
     * For instance, https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#elemhide-exceptions
     */
    CosmeticRule.prototype.isAllowlist = function () {
        return this.allowlist;
    };
    /**
     * Gets the rule content. The meaning of this field depends on the rule type.
     * For instance, for an element hiding rule, this is just a CSS selector.
     * While, for a CSS rule, this is a CSS selector + style.
     */
    CosmeticRule.prototype.getContent = function () {
        return this.content;
    };
    /**
     * Returns script ready to execute or null
     * Rebuilds scriptlet script if debug or domain params change
     * @param options script options
     * @returns script code or null
     */
    CosmeticRule.prototype.getScript = function (options) {
        var _a, _b;
        if (options === void 0) { options = {}; }
        var _c = options.debug, debug = _c === void 0 ? false : _c, frameUrl = options.frameUrl;
        var scriptData = this.scriptData;
        if (scriptData && !this.isScriptlet) {
            return scriptData.code;
        }
        if (scriptData && scriptData.debug === debug) {
            if (frameUrl) {
                if (frameUrl === scriptData.frameUrl) {
                    return scriptData.code;
                }
            }
            else {
                return scriptData.code;
            }
        }
        this.initScript(options);
        return (_b = (_a = this.scriptData) === null || _a === void 0 ? void 0 : _a.code) !== null && _b !== void 0 ? _b : null;
    };
    /**
     * Gets list of permitted domains.
     */
    CosmeticRule.prototype.getPermittedDomains = function () {
        return this.permittedDomains;
    };
    /**
     * Returns true if the rule is considered "generic"
     * "generic" means that the rule is not restricted to a limited set of domains
     * Please note that it might be forbidden on some domains, though.
     *
     * @return {boolean}
     */
    CosmeticRule.prototype.isGeneric = function () {
        return !this.permittedDomains || this.permittedDomains.length === 0;
    };
    /**
     * Gets list of restricted domains.
     */
    CosmeticRule.prototype.getRestrictedDomains = function () {
        return this.restrictedDomains;
    };
    CosmeticRule.prototype.isExtendedCss = function () {
        return this.extendedCss;
    };
    /**
     * Match returns true if this rule can be used on the specified request.
     *
     * @param request - request to check
     */
    CosmeticRule.prototype.match = function (request) {
        if (!this.permittedDomains && !this.restrictedDomains && !this.pathModifier) {
            return true;
        }
        if (this.matchesRestrictedDomains(request.hostname)) {
            /**
             * Domain or host is restricted
             * i.e. ~example.org##rule
             */
            return false;
        }
        if (this.hasPermittedDomains()) {
            if (!DomainModifier.isDomainOrSubdomainOfAny(request.hostname, this.permittedDomains)) {
                /**
                 * Domain is not among permitted
                 * i.e. example.org##rule and we're checking example.org
                 */
                return false;
            }
        }
        if (this.pathModifier) {
            var path = getRelativeUrl(request.urlLowercase);
            if (path) {
                return this.pathModifier.matchPathPattern(path);
            }
            return false;
        }
        return true;
    };
    CosmeticRule.parseType = function (marker) {
        switch (marker) {
            case CosmeticRuleMarker.ElementHiding:
            case CosmeticRuleMarker.ElementHidingExtCSS:
                return CosmeticRuleType.ElementHiding;
            case CosmeticRuleMarker.ElementHidingException:
            case CosmeticRuleMarker.ElementHidingExtCSSException:
                return CosmeticRuleType.ElementHiding;
            case CosmeticRuleMarker.Css:
            case CosmeticRuleMarker.CssExtCSS:
                return CosmeticRuleType.Css;
            case CosmeticRuleMarker.CssException:
            case CosmeticRuleMarker.CssExtCSSException:
                return CosmeticRuleType.Css;
            case CosmeticRuleMarker.Js:
                return CosmeticRuleType.Js;
            case CosmeticRuleMarker.JsException:
                return CosmeticRuleType.Js;
            case CosmeticRuleMarker.Html:
                return CosmeticRuleType.Html;
            case CosmeticRuleMarker.HtmlException:
                return CosmeticRuleType.Html;
            default:
                throw new SyntaxError('Unsupported rule type');
        }
    };
    /**
     * Determines if rule is allowlist rule
     * @param marker
     * @private
     */
    CosmeticRule.parseAllowlist = function (marker) {
        switch (marker) {
            case CosmeticRuleMarker.ElementHidingException:
            case CosmeticRuleMarker.ElementHidingExtCSSException:
            case CosmeticRuleMarker.CssException:
            case CosmeticRuleMarker.CssExtCSSException:
            case CosmeticRuleMarker.JsException:
            case CosmeticRuleMarker.HtmlException:
                return true;
            default:
                return false;
        }
    };
    /**
     * Validate pseudo-classes
     *
     * @param ruleText
     * @param ruleContent
     * @throws SyntaxError
     */
    CosmeticRule.validatePseudoClasses = function (ruleText, ruleContent) {
        var pseudoClass = CosmeticRule.parsePseudoClass(ruleContent);
        if (pseudoClass !== null) {
            if (CosmeticRule.SUPPORTED_PSEUDO_CLASSES.indexOf(pseudoClass) < 0) {
                throw new SyntaxError("Unknown pseudo-class '".concat(pseudoClass, "' in selector: '").concat(ruleContent, "'"));
            }
        }
    };
    /**
     * Simple validation for elemhide rules
     *
     * @param ruleText
     * @param ruleContent
     * @throws SyntaxError
     */
    CosmeticRule.validateElemhideRule = function (ruleText, ruleContent) {
        if (ruleText.startsWith(SimpleRegex.MASK_START_URL)) {
            throw new SyntaxError('Element hiding rule shouldn\'t start with "||"');
        }
        if (CosmeticRule.ELEMHIDE_VALIDATION_REGEX.test(ruleContent)) {
            throw new SyntaxError('Invalid elemhide rule, style presented');
        }
    };
    CosmeticRule.validateJsRules = function (ruleText, ruleContent) {
        if (ruleContent.startsWith(ADG_SCRIPTLET_MASK)) {
            if (!scriptlets.isValidScriptletRule(ruleText)) {
                throw new SyntaxError('Invalid scriptlet');
            }
        }
    };
    /**
     * Validates css injection rules
     *
     * @param ruleText
     * @param ruleContent
     * @throws SyntaxError
     */
    CosmeticRule.validateCssRules = function (ruleText, ruleContent) {
        // Simple validation for css injection rules
        if (!/{.+}/.test(ruleContent)) {
            throw new SyntaxError('Invalid CSS modifying rule, no style presented');
        }
        // discard css inject rules containing "url"
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1196
        if (/{.*url\(.*\)/gi.test(ruleContent)) {
            throw new SyntaxError('CSS modifying rule with \'url\' was omitted');
        }
        // discard css inject rules containing other unsafe selectors
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1920
        if (/{.*image-set\(.*\)/gi.test(ruleContent)
            || /{.*image\(.*\)/gi.test(ruleContent)
            || /{.*cross-fade\(.*\)/gi.test(ruleContent)) {
            throw new SyntaxError('CSS modifying rule with unsafe style was omitted');
        }
        // Prohibit "\" character in style of CSS injection rules
        // Check slash character only after the index of last opening curly brackets
        if (ruleContent.indexOf('\\', ruleContent.lastIndexOf('{')) > -1) {
            throw new SyntaxError('CSS injection rule with \'\\\' was omitted');
        }
    };
    /**
     * Checks if the rule has permitted domains
     */
    CosmeticRule.prototype.hasPermittedDomains = function () {
        return this.permittedDomains != null && this.permittedDomains.length > 0;
    };
    /**
     * Checks if the rule has restricted domains
     */
    CosmeticRule.prototype.hasRestrictedDomains = function () {
        return this.restrictedDomains != null && this.restrictedDomains.length > 0;
    };
    /**
     * Checks if the hostname matches permitted domains
     * @param hostname
     */
    CosmeticRule.prototype.matchesPermittedDomains = function (hostname) {
        return this.hasPermittedDomains() && DomainModifier.isDomainOrSubdomainOfAny(hostname, this.permittedDomains);
    };
    /**
     * Checks if the hostname matches the restricted domains.
     * @param hostname
     */
    CosmeticRule.prototype.matchesRestrictedDomains = function (hostname) {
        return this.hasRestrictedDomains()
            && DomainModifier.isDomainOrSubdomainOfAny(hostname, this.restrictedDomains);
    };
    /**
     * Validates cosmetic rule text
     * @param ruleText
     * @param type
     * @param content
     * @param isExtCss
     * @private
     */
    CosmeticRule.validate = function (ruleText, type, content, isExtCss) {
        if (type !== CosmeticRuleType.Css
            && type !== CosmeticRuleType.Js
            && type !== CosmeticRuleType.Html) {
            CosmeticRule.validatePseudoClasses(ruleText, content);
            if (hasUnquotedSubstring(content, '{')) {
                throw new SyntaxError('Invalid cosmetic rule, wrong brackets');
            }
        }
        if (type === CosmeticRuleType.ElementHiding) {
            CosmeticRule.validateElemhideRule(ruleText, content);
        }
        if (type === CosmeticRuleType.Css) {
            CosmeticRule.validateCssRules(ruleText, content);
        }
        if (type === CosmeticRuleType.Js) {
            CosmeticRule.validateJsRules(ruleText, content);
        }
        if ((!isExtCss && hasUnquotedSubstring(content, '/*'))
            || hasUnquotedSubstring(content, ' /*')
            || hasUnquotedSubstring(content, ' //')) {
            throw new SyntaxError('Cosmetic rule should not contain comments');
        }
    };
    /**
     * Returns the scriptlet's data consisting of the scriptlet function and its arguments.
     * This method is supposed to be used in the manifest V3 extension.
     */
    CosmeticRule.prototype.getScriptletData = function () {
        if (this.scriptletData) {
            return this.scriptletData;
        }
        this.initScript();
        return this.scriptletData;
    };
    /**
     * Updates this.scriptData and if scriptlet this.scriptletData with js ready to execute
     *
     * @param options
     */
    CosmeticRule.prototype.initScript = function (options) {
        var _a;
        if (options === void 0) { options = {}; }
        var _b = options.debug, debug = _b === void 0 ? false : _b, frameUrl = options.frameUrl;
        var ruleContent = this.getContent();
        if (!this.isScriptlet) {
            this.scriptData = {
                code: ruleContent,
            };
            return;
        }
        var scriptletContent = ruleContent.substring(ADG_SCRIPTLET_MASK.length);
        var scriptletParams = ScriptletParser.parseRule(scriptletContent);
        var params = {
            args: scriptletParams.args,
            engine: config.engine || '',
            name: scriptletParams.name,
            ruleText: this.getText(),
            verbose: debug,
            domainName: frameUrl,
            version: config.version || '',
        };
        this.scriptData = {
            code: (_a = scriptlets.invoke(params)) !== null && _a !== void 0 ? _a : null,
            debug: debug,
            frameUrl: frameUrl,
        };
        this.scriptletData = {
            func: scriptlets.getScriptletFunction(params.name),
            params: params,
        };
    };
    /**
     * The problem with pseudo-classes is that any unknown pseudo-class makes browser ignore the whole CSS rule,
     * which contains a lot more selectors. So, if CSS selector contains a pseudo-class, we should try to validate it.
     * <p>
     * One more problem with pseudo-classes is that they are actively used in uBlock, hence it may mess AG styles.
     */
    CosmeticRule.SUPPORTED_PSEUDO_CLASSES = [':active',
        ':checked', ':contains', ':disabled', ':empty', ':enabled', ':first-child', ':first-of-type',
        ':focus', ':has', ':has-text', ':hover', ':if', ':if-not', ':in-range', ':invalid', ':lang',
        ':last-child', ':last-of-type', ':link', ':matches-css', ':matches-css-before', ':matches-css-after',
        ':not', ':nth-child', ':nth-last-child', ':nth-last-of-type', ':nth-of-type',
        ':only-child', ':only-of-type', ':optional', ':out-of-range', ':read-only',
        ':read-write', ':required', ':root', ':target', ':valid', ':visited',
        ':-abp-has', ':-abp-contains', ':xpath', ':nth-ancestor', ':upward', ':remove',
        ':matches-attr', ':matches-property', ':is', ':where'];
    CosmeticRule.ELEMHIDE_VALIDATION_REGEX = / {.+}/;
    return CosmeticRule;
}());

/**
 * Implements a host rule.
 *
 * HostRule is a structure for simple host-level rules (i.e. /etc/hosts syntax).
 * http://man7.org/linux/man-pages/man5/hosts.5.html
 * It also supports "just domain" syntax. In this case, the IP will be set to 0.0.0.0.
 *
 * Rules syntax looks like this:
 * ```
 * IP_address canonical_hostname [aliases...]
 * ```
 *
 * Examples:
 * * `192.168.1.13 bar.mydomain.org bar` -- ipv4
 * * `ff02::1 ip6-allnodes` -- ipv6
 * * `::1 localhost ip6-localhost ip6-loopback` -- ipv6 aliases
 * * `example.org` -- "just domain" syntax
 */
var HostRule = /** @class */ (function () {
    /**
     * Constructor
     *
     * Parses the rule and creates a new HostRule instance
     *
     * @param ruleText - original rule text.
     * @param filterListId - ID of the filter list this rule belongs to.
     *
     * @throws error if it fails to parse the rule.
     */
    function HostRule(ruleText, filterListId) {
        this.hostnames = [];
        this.ip = '';
        this.invalid = false;
        this.ruleText = ruleText;
        this.filterListId = filterListId;
        var commentIndex = ruleText.indexOf('#');
        var stripped = commentIndex >= 0 ? ruleText.substring(0, commentIndex) : ruleText;
        var parts = stripped.trim().split(' ');
        if (parts.length >= 2) {
            if (!isIp(parts[0])) {
                this.invalid = true;
                return;
            }
            // eslint-disable-next-line prefer-destructuring
            this.ip = parts[0];
            this.hostnames = parts.slice(1).filter(function (x) { return !!x; });
        }
        else if (parts.length === 1 && isDomainName(parts[0])) {
            this.hostnames = [parts[0]];
            this.ip = '0.0.0.0';
        }
        else {
            this.invalid = true;
        }
    }
    /**
     * Match returns true if this rule can be used on the specified hostname.
     *
     * @param hostname - hostname to check
     */
    HostRule.prototype.match = function (hostname) {
        return this.hostnames.includes(hostname);
    };
    /**
     * Returns list id
     */
    HostRule.prototype.getFilterListId = function () {
        return this.filterListId;
    };
    /**
     * Return rule text
     */
    HostRule.prototype.getText = function () {
        return this.ruleText;
    };
    /**
     * Returns ip address
     */
    HostRule.prototype.getIp = function () {
        return this.ip;
    };
    /**
     * Returns hostnames
     */
    HostRule.prototype.getHostnames = function () {
        return this.hostnames;
    };
    /**
     * Is invalid rule
     */
    HostRule.prototype.isInvalid = function () {
        return this.invalid;
    };
    return HostRule;
}());

/**
 * Rule builder class
 */
var RuleFactory = /** @class */ (function () {
    function RuleFactory() {
    }
    /**
     * Creates rule of suitable class from text string
     * It returns null if the line is empty or if it is a comment
     *
     * TODO: Pack `ignore*` parameters and `silent` into one object with flags.
     *
     * @param text rule string
     * @param filterListId list id
     * @param ignoreNetwork do not create network rules
     * @param ignoreCosmetic do not create cosmetic rules
     * @param ignoreHost do not create host rules
     * @param silent Log the error for `true`, otherwise throw an exception on
     * a rule creation
     *
     * @throws Error when `silent` flag is passed as false on rule creation error.
     *
     * @return IRule object or null
     */
    RuleFactory.createRule = function (text, filterListId, ignoreNetwork, ignoreCosmetic, ignoreHost, silent) {
        if (ignoreNetwork === void 0) { ignoreNetwork = false; }
        if (ignoreCosmetic === void 0) { ignoreCosmetic = false; }
        if (ignoreHost === void 0) { ignoreHost = true; }
        if (silent === void 0) { silent = true; }
        if (!text || RuleFactory.isComment(text)) {
            return null;
        }
        if (RuleFactory.isShort(text)) {
            logger.info("The rule is too short: ".concat(text));
        }
        var line = text.trim();
        try {
            if (RuleFactory.isCosmetic(line)) {
                if (ignoreCosmetic) {
                    return null;
                }
                return new CosmeticRule(line, filterListId);
            }
            if (!ignoreHost) {
                var hostRule = RuleFactory.createHostRule(line, filterListId);
                if (hostRule) {
                    return hostRule;
                }
            }
            if (!ignoreNetwork) {
                return new NetworkRule(line, filterListId);
            }
        }
        catch (e) {
            var msg = "\"".concat(getErrorMessage(e), "\" in the rule: \"").concat(line, "\"");
            if (silent) {
                logger.info("Error: ".concat(msg));
            }
            else {
                throw new Error(msg);
            }
        }
        return null;
    };
    /**
     * Creates host rule from text
     *
     * @param ruleText
     * @param filterListId
     */
    RuleFactory.createHostRule = function (ruleText, filterListId) {
        var rule = new HostRule(ruleText, filterListId);
        return rule.isInvalid() ? null : rule;
    };
    /**
     * Checks if rule is short
     */
    RuleFactory.isShort = function (rule) {
        if (!rule) {
            return true;
        }
        return !!(rule && rule.length <= 3);
    };
    /**
     * Checks if the rule is cosmetic or not.
     * @param ruleText - rule text to check.
     */
    RuleFactory.isCosmetic = function (ruleText) {
        var marker = findCosmeticRuleMarker(ruleText);
        return marker[0] !== -1;
    };
    /**
     * If text is comment
     *
     * @param text
     */
    RuleFactory.isComment = function (text) {
        if (text.charAt(0) === '!') {
            return true;
        }
        if (text.charAt(0) === '#') {
            if (text.length === 1) {
                return true;
            }
            // Now we should check that this is not a cosmetic rule
            return !RuleFactory.isCosmetic(text);
        }
        return false;
    };
    return RuleFactory;
}());

/**
 * Rule converter class
 */
var RuleConverter = /** @class */ (function () {
    function RuleConverter() {
    }
    /**
     * Converts rules text
     *
     * @param rulesText
     */
    RuleConverter.convertRules = function (rulesText) {
        var result = [];
        var lines = rulesText.split(/\r?\n/);
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
            var line = lines_1[_i];
            try {
                result.push.apply(result, RuleConverter.convertRule(line));
            }
            catch (e) {
                logger.warn(e.message);
            }
        }
        return result.join('\n');
    };
    /**
     * TODO for more efficient conversion build AST. And then use the modified AST for creating a
     *  rule object.
     * Convert external scriptlet rule to AdGuard scriptlet syntax
     *
     * @param rawRule
     */
    RuleConverter.convertRule = function (rawRule) {
        var rule = rawRule.trim();
        if (rule.startsWith(SimpleRegex.MASK_COMMENT) || rule === '') {
            return [rule];
        }
        var comment = RuleConverter.convertUboComments(rule);
        if (comment) {
            return [comment];
        }
        var converted = rule;
        if (RuleFactory.isCosmetic(rule)) {
            converted = RuleConverter.convertCssInjection(converted);
            converted = RuleConverter.convertPseudoElements(converted);
            converted = RuleConverter.convertRemoveRule(converted);
            converted = RuleConverter.convertScriptHasTextToScriptTagContent(converted);
            converted = RuleConverter.convertUboMatchesPathRule(converted);
            // special case for ubo response header rule, it looks like cosmetic rule, but is converted to network rule
            var removeHeaderRule = RuleConverter.convertUboResponseHeaderRule(converted);
            if (removeHeaderRule) {
                return [removeHeaderRule];
            }
        }
        else {
            var domainAndOptions = RuleConverter.splitIntoDomainAndOptions(converted);
            var domain = domainAndOptions[0];
            var optionsParts = domainAndOptions[1];
            if (optionsParts) {
                optionsParts = RuleConverter.replaceOptions(optionsParts);
                var ruleWithConvertedOptions = RuleConverter.convertOptions(domain, optionsParts);
                if (ruleWithConvertedOptions) {
                    return ruleWithConvertedOptions;
                }
                converted = "".concat(domain, "$").concat(optionsParts.join(','));
            }
        }
        var scriptletRules = scriptlets.convertScriptletToAdg(converted);
        // TODO Check if isValidScriptletRule call is needed here, looks like convertScriptletToAdg
        //  should already return a valid scriptlet.
        if (scriptletRules && scriptletRules.every(function (x) { return RuleConverter.isValidScriptletRule(x); })) {
            return scriptletRules;
        }
        var adgRedirectRule = RuleConverter.convertUboAndAbpRedirectsToAdg(converted);
        if (adgRedirectRule) {
            return [adgRedirectRule];
        }
        if (converted.includes(RuleConverter.UBO_HTML_RULE_MASK)) {
            throw new SyntaxError("Invalid UBO script rule: ".concat(converted));
        }
        return [converted];
    };
    /**
     * Validates AdGuard syntax scriptlet rule.
     *
     * @param ruleText AdGuard scriptlet rule.
     */
    RuleConverter.isValidScriptletRule = function (ruleText) {
        try {
            // checks whether the ADG scriptlet rule name is valid
            return scriptlets.isValidScriptletRule(ruleText);
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Converts UBO Script rule
     *
     * @param {string} ruleText rule text
     * @returns {string} converted rule
     */
    RuleConverter.convertScriptHasTextToScriptTagContent = function (ruleText) {
        if (ruleText.startsWith(SimpleRegex.MASK_COMMENT)
            || !RuleConverter.SCRIPT_HAS_TEXT_REGEX.test(ruleText)
            || RuleConverter.CSS_COMBINATORS_REGEX.test(ruleText)) {
            return ruleText;
        }
        var convertedRuleText = ruleText;
        var attributeStrings = [];
        // Cut all attributes substrings from rule text into array
        // https://github.com/AdguardTeam/tsurlfilter/issues/55
        if (RuleConverter.ATTRIBUTE_REGEX.test(ruleText)) {
            var globalAttributeRegExp = new RegExp(RuleConverter.ATTRIBUTE_REGEX, 'gi');
            attributeStrings = ruleText.match(globalAttributeRegExp);
            attributeStrings === null || attributeStrings === void 0 ? void 0 : attributeStrings.forEach(function (attrStr) {
                convertedRuleText = convertedRuleText.replace(attrStr, '');
            });
        }
        // Convert base of the rule ##^script:has-text(text) to $$script[tag-content='text']
        convertedRuleText = "".concat(convertedRuleText
            .replace(RuleConverter.SCRIPT_HAS_TEXT_REGEX_SHORT, RuleConverter.SCRIPT_HAS_TEXT_REPLACEMENT)
            .slice(0, -1), "\"][max-length=\"262144\"]");
        // Escape double quotes inside tag-content, like it is required by AdGuard syntax
        // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#tag-content
        convertedRuleText = convertedRuleText.replace(RuleConverter.TAG_CONTENT_VALUE_REGEX, function (match, group) {
            return "[tag-content=\"".concat(group.replace(/"/g, '""'), "\"]");
        });
        // Return attributes if there were any
        attributeStrings === null || attributeStrings === void 0 ? void 0 : attributeStrings.forEach(function (attrStr) {
            convertedRuleText += attrStr;
        });
        return convertedRuleText;
    };
    /**
     * Converts UBO and ABP redirect rules to AdGuard redirect rules
     * @param rule
     * @return {string} convertedRule
     */
    RuleConverter.convertUboAndAbpRedirectsToAdg = function (rule) {
        var redirects = scriptlets.redirects;
        if (redirects.isUboRedirectCompatibleWithAdg(rule) || redirects.isAbpRedirectCompatibleWithAdg(rule)) {
            return redirects.convertRedirectToAdg(rule);
        }
        return null;
    };
    /**
     * Converts the rule options according to the conversion map and handles special cases.
     * @param domainPart - The domain part of the rule.
     * @param optionsParts - The options part of the rule as an array of strings.
     * @private
     */
    RuleConverter.convertOptions = function (domainPart, optionsParts) {
        var NAME_VALUE_SPLITTER = '=';
        var areOptionsConverted = false;
        var updatedOptionsParts = optionsParts.map(function (optionsPart) {
            var convertedOptionsPart = RuleConverter.OPTIONS_CONVERSION_MAP.get(optionsPart);
            // If option is $mp4, then it should go with $media option together
            if (optionsPart === 'mp4') {
                // Check if media is not already among options
                if (!optionsParts.some(function (option) { return option === 'media'; })) {
                    convertedOptionsPart = "".concat(convertedOptionsPart, ",media");
                }
            }
            if (convertedOptionsPart) {
                areOptionsConverted = true;
                return convertedOptionsPart;
            }
            return optionsPart;
        });
        // If options have more than one csp modifiers, we merge them into one;
        var cspParts = updatedOptionsParts.filter(function (optionsPart) { return optionsPart.startsWith('csp'); });
        if (cspParts.length > 1) {
            var allButCsp = updatedOptionsParts.filter(function (optionsPart) { return !optionsPart.startsWith('csp'); });
            var cspValues = cspParts.map(function (cspPart) { return cspPart.split(NAME_VALUE_SPLITTER)[1]; });
            var updatedCspOption = "csp".concat(NAME_VALUE_SPLITTER).concat(cspValues.join('; '));
            updatedOptionsParts = allButCsp.concat(updatedCspOption);
        }
        if (areOptionsConverted) {
            var updatedOptions = updatedOptionsParts.join(',');
            return ["".concat(domainPart, "$").concat(updatedOptions)];
        }
        return null;
    };
    /**
     * Converts ubo syntax comments (rules starting with #)
     * Note: It's not possible to detect 100% cause rules starting with ## are valid elemhide rules
     *
     * @param rule
     * @return {string}
     */
    RuleConverter.convertUboComments = function (rule) {
        if (rule.startsWith('# ') || rule.startsWith('####')) {
            return "! ".concat(rule);
        }
        return null;
    };
    /**
     * Executes rule css conversion
     *
     * @param rule
     * @param parts
     * @param ruleMark
     */
    RuleConverter.executeConversion = function (rule, parts, ruleMark) {
        var result = rule;
        var domain = parts[0];
        if (domain) {
            var rulePart = parts[1];
            if (rulePart.match(RuleConverter.CSS_RULE_REPLACE_PATTERN)) {
                var groups = RuleConverter.CSS_RULE_REPLACE_PATTERN.exec(rulePart);
                if (groups != null) {
                    if (groups.length === 3) {
                        result = domain + ruleMark;
                        result += "".concat(groups[1], " { ").concat(groups[2], " }");
                    }
                }
            }
        }
        return result;
    };
    /**
     * Adds colon to the pseudo elements written with one colon (:before, :after);
     * e.g.
     *  "hotline.ua##.reset-scroll:before" -> "hotline.ua##.reset-scroll::before"
     * @param rule
     * @private
     */
    RuleConverter.convertPseudoElements = function (rule) {
        var BEFORE = 'before';
        var AFTER = 'after';
        var SINGLE_COLON = ':';
        // does not have parts to convert
        if (!(rule.includes(SINGLE_COLON + BEFORE) || rule.includes(SINGLE_COLON + AFTER))) {
            return rule;
        }
        // not an css rule
        if (!(rule.includes(RuleConverter.MASK_ELEMENT_HIDING)
            || rule.includes(RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION)
            || rule.includes(RuleConverter.MASK_CSS)
            || rule.includes(RuleConverter.MASK_CSS_EXCEPTION))) {
            return rule;
        }
        var modifiedRule = '';
        for (var i = 0; i < rule.length; i += 1) {
            if (rule[i] !== SINGLE_COLON) {
                modifiedRule += rule[i];
                continue;
            }
            if ((rule.indexOf(BEFORE, i) === i + 1
                || rule.indexOf(AFTER, i) === i + 1)
                && rule[i - 1] !== SINGLE_COLON) {
                modifiedRule += SINGLE_COLON;
                modifiedRule += rule[i];
                continue;
            }
            modifiedRule += rule[i];
        }
        return modifiedRule;
    };
    /**
     * Converts CSS injection
     * example.com##h1:style(background-color: blue !important)
     * into
     * example.com#$#h1 { background-color: blue !important }
     * <p>
     * OR (for exceptions):
     * example.com#@#h1:style(background-color: blue !important)
     * into
     * example.com#@$#h1 { background-color: blue !important }
     *
     * @param {string} rule
     * @return {string} convertedRule
     */
    RuleConverter.convertCssInjection = function (rule) {
        if (rule.includes(':style')) {
            var parts = void 0;
            var resultMask = void 0;
            var resultRule = rule;
            var isExtendedCss = false;
            for (var i = 0; i < EXT_CSS_PSEUDO_INDICATORS.length; i += 1) {
                isExtendedCss = rule.indexOf(EXT_CSS_PSEUDO_INDICATORS[i]) !== -1;
                if (isExtendedCss) {
                    break;
                }
            }
            if (rule.includes(RuleConverter.MASK_CSS_EXTENDED_CSS_RULE)) {
                parts = rule.split(RuleConverter.MASK_CSS_EXTENDED_CSS_RULE, 2);
                resultMask = RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE;
            }
            else if (rule.includes(RuleConverter.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE)) {
                parts = rule.split(RuleConverter.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE, 2);
                resultMask = RuleConverter.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE;
                // firstly we check for exception rule in order not to confuse with id selectors
                // e.g. yourconroenews.com#@##siteNav:style(transform: none !important;)
            }
            else if (rule.includes(RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION)) {
                parts = rule.split(RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION, 2);
                if (isExtendedCss) {
                    resultMask = RuleConverter.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE;
                }
                else {
                    resultMask = RuleConverter.MASK_CSS_EXCEPTION;
                }
            }
            else if (rule.includes(RuleConverter.MASK_ELEMENT_HIDING)) {
                parts = rule.split(RuleConverter.MASK_ELEMENT_HIDING, 2);
                if (isExtendedCss) {
                    resultMask = RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE;
                }
                else {
                    resultMask = RuleConverter.MASK_CSS;
                }
            }
            if (parts && resultMask) {
                resultRule = RuleConverter.executeConversion(rule, parts, resultMask);
            }
            return resultRule;
        }
        return rule;
    };
    /**
     * Converts ':remove()' rule to AdGuard extended css rule
     * example.com###banner:remove() -> example.com#$?##banner { remove: true; }
     * @param {string} rule
     * @return {string} rule or converted rule
     */
    RuleConverter.convertRemoveRule = function (rule) {
        // if rule is already extended css, do not convert it
        if (rule.includes(RuleConverter.MASK_CSS_EXTENDED_CSS_RULE)) {
            return rule;
        }
        if (rule.includes(RuleConverter.MASK_ELEMENT_HIDING) && rule.endsWith(RuleConverter.REMOVE_RULE_PATTERN)) {
            return rule
                .replace(RuleConverter.MASK_ELEMENT_HIDING, RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE)
                .replace(RuleConverter.REMOVE_RULE_PATTERN, RuleConverter.REMOVE_RULE_REPLACER);
        }
        return rule;
    };
    /**
     * Converts '^responseheader()' rule to AdGuard's $removeheader modifier
     * "ya.ru##^responseheader(header-name)" -> "||ya.ru^$removeheader=header-name"
     *
     * @param {string} ruleText
     * @return {string} ruleText or converted rule
     */
    RuleConverter.convertUboResponseHeaderRule = function (ruleText) {
        if (ruleText.startsWith(SimpleRegex.MASK_COMMENT) || !ruleText.includes(RuleConverter.UBO_RESPONSE_HEADER)) {
            return null;
        }
        if (RuleConverter.UBO_RESPONSE_HEADER_REGEX.test(ruleText)) {
            return "||".concat(ruleText.replace(RuleConverter.UBO_RESPONSE_HEADER_REGEX, RuleConverter.UBO_RESPONSE_HEADER_REPLACEMENT)
                .slice(0, -1));
        }
        if (RuleConverter.UBO_RESPONSE_HEADER_EXCEPTION_REGEX.test(ruleText)) {
            return "@@||".concat(ruleText.replace(RuleConverter.UBO_RESPONSE_HEADER_EXCEPTION_REGEX, RuleConverter.UBO_RESPONSE_HEADER_REPLACEMENT).slice(0, -1));
        }
        return ruleText;
    };
    /**
     * Converts cosmetic 'matches-path()' rule to AdGuard's $path modifier
     * "ya.ru##:matches-path(/page) p" -> "[$path=/page]ya.ru##p"
     *
     * @param {string} ruleText
     * @return {string} ruleText or converted rule
     */
    RuleConverter.convertUboMatchesPathRule = function (ruleText) {
        if (ruleText.startsWith(SimpleRegex.MASK_COMMENT)) {
            return ruleText;
        }
        var _b = findCosmeticRuleMarker(ruleText), markerIndex = _b[0], marker = _b[1];
        if (!marker) {
            return ruleText;
        }
        var expressionStartIndex = markerIndex + marker.length;
        var matchesPathStartIndex = ruleText.indexOf(RuleConverter.UBO_MATCHES_PATH, expressionStartIndex);
        if (matchesPathStartIndex === -1) {
            return ruleText;
        }
        var reversedMatchesPathStartIndex = ruleText.indexOf(RuleConverter.UBO_REVERSED_MATCHES_PATH, expressionStartIndex);
        var isReversed = reversedMatchesPathStartIndex !== -1;
        var pathStartIndex = isReversed
            ? reversedMatchesPathStartIndex + RuleConverter.UBO_REVERSED_MATCHES_PATH.length
            : matchesPathStartIndex + RuleConverter.UBO_MATCHES_PATH.length;
        var matchPathOperatorCloseBracketIndex;
        var openBracketCounter = 1;
        var closeBracketCounter = 0;
        for (var i = pathStartIndex; i < ruleText.length; i += 1) {
            if (ruleText[i - 1] !== '\\') {
                if (ruleText[i] === '(') {
                    openBracketCounter += 1;
                }
                else if (ruleText[i] === ')') {
                    closeBracketCounter += 1;
                    if (openBracketCounter === closeBracketCounter) {
                        matchPathOperatorCloseBracketIndex = i;
                        break;
                    }
                }
            }
        }
        if (!matchPathOperatorCloseBracketIndex) {
            return ruleText;
        }
        var domains = ruleText.slice(0, markerIndex);
        var expressionMiddle = ruleText.slice(expressionStartIndex, isReversed ? reversedMatchesPathStartIndex : matchesPathStartIndex);
        var expressionTail = ruleText
            .slice(matchPathOperatorCloseBracketIndex + (isReversed ? 2 : 1))
            .trim();
        var path = ruleText.slice(pathStartIndex, matchPathOperatorCloseBracketIndex);
        var isRegex = SimpleRegex.isRegexPattern(path);
        if (isReversed) {
            path = "/^((?!".concat(isRegex ? path.slice(1, path.length - 1) : SimpleRegex.patternToRegexp(path), ").)*$/");
        }
        if (isRegex) {
            path = SimpleRegex.escapeRegexSpecials(path, SimpleRegex.reModifierPatternSpecialCharacters);
        }
        return "[$path=".concat(path, "]").concat(domains).concat(marker).concat(expressionMiddle).concat(expressionTail);
    };
    /**
     * Substitutes option aliases in the provided options array with their corresponding aliases.
     *
     * @param optionsParts - An array of options to replace aliases in.
     * @returns - An array of options with aliases replaced.
     */
    RuleConverter.replaceOptions = function (optionsParts) {
        var resultOptions = optionsParts.map(function (option) {
            var _b = option.split('=', 2), optionNameRaw = _b[0], optionValue = _b[1];
            var isNegated = optionNameRaw.startsWith('~');
            var optionName = isNegated ? optionNameRaw.slice(1) : optionNameRaw;
            var convertedOptionName = RuleConverter.OPTIONS_ALIASES[optionName];
            if (!convertedOptionName) {
                return option;
            }
            var negationPrefix = isNegated ? '~' : '';
            return optionValue
                ? "".concat(negationPrefix).concat(convertedOptionName, "=").concat(optionValue)
                : "".concat(negationPrefix).concat(convertedOptionName);
        });
        return resultOptions;
    };
    var _a;
    _a = RuleConverter;
    RuleConverter.CSS_RULE_REPLACE_PATTERN = /(.*):style\((.*)\)/g;
    // eslint-disable-next-line max-len
    RuleConverter.SCRIPT_HAS_TEXT_REGEX = /##\^(script(\[[{a-z0-9-_.:}]*(="[{a-z0-9-_.:}]*")*\])*:(has-text|contains))\((?!\/.+\/\))/i;
    RuleConverter.SCRIPT_HAS_TEXT_REGEX_SHORT = /(##\^script:(has-text|contains))\((?!\/.+\/\))/i;
    RuleConverter.TAG_CONTENT_VALUE_REGEX = /\[tag-content="(.*?)"]/g;
    RuleConverter.ATTRIBUTE_REGEX = /(\[[{a-z0-9-_.:}]*(="[{a-z0-9-_.:}]*")*\])/i;
    RuleConverter.CSS_COMBINATORS_REGEX = />|\+|~/;
    RuleConverter.SCRIPT_HAS_TEXT_REPLACEMENT = '$$$$script[tag-content="';
    RuleConverter.UBO_RESPONSE_HEADER = '#^responseheader(';
    RuleConverter.UBO_RESPONSE_HEADER_REGEX = /##\^responseheader\((?!\/.+\/\))/i;
    RuleConverter.UBO_RESPONSE_HEADER_EXCEPTION_REGEX = /#@#\^responseheader\((?!\/.+\/\))/i;
    RuleConverter.UBO_RESPONSE_HEADER_REPLACEMENT = '^$removeheader=';
    RuleConverter.UBO_MATCHES_PATH = ':matches-path(';
    RuleConverter.UBO_REVERSED_MATCHES_PATH = ':not(:matches-path(';
    /**
     * Rule masks
     */
    RuleConverter.MASK_ELEMENT_HIDING = '##';
    RuleConverter.UBO_HTML_RULE_MASK = '##^';
    RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION = '#@#';
    RuleConverter.MASK_CSS = '#$#';
    RuleConverter.MASK_CSS_EXCEPTION = '#@$#';
    RuleConverter.MASK_CSS_EXTENDED_CSS_RULE = '#?#';
    RuleConverter.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE = '#@?#';
    RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE = '#$?#';
    RuleConverter.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE = '#@$?#';
    RuleConverter.REMOVE_RULE_PATTERN = ':remove()';
    RuleConverter.REMOVE_RULE_REPLACER = ' { remove: true; }';
    /**
     * Special characters
     */
    RuleConverter.REGEXP_DELIMITER = '/';
    RuleConverter.ESCAPING_SLASH = '\\';
    /**
     * Splits the given rule text into domain and options parts using the options delimiter ($).
     * Returns the domain part and an array of options, or null if no options are present.
     *
     * @param ruleText - The rule text to be split.
     * @returns [domain, options] or [domain, null] if no options are present.
     */
    RuleConverter.splitIntoDomainAndOptions = function (ruleText) {
        var optionsDelimiterIdx = -1;
        var inRegExp = false;
        for (var i = ruleText.length - 1; i >= 0; i -= 1) {
            if (!inRegExp && ruleText[i] === OPTIONS_DELIMITER) {
                optionsDelimiterIdx = i;
                break;
            }
            if (ruleText[i] === _a.REGEXP_DELIMITER
                && (i === 0 || ruleText[i - 1] !== _a.ESCAPING_SLASH)) {
                inRegExp = !inRegExp;
            }
        }
        if (optionsDelimiterIdx === -1) {
            return [ruleText, null];
        }
        var domainPart = ruleText.slice(0, optionsDelimiterIdx);
        var optionsPart = ruleText.slice(optionsDelimiterIdx + 1);
        // do not remove escape characters from regexp modifiers values
        var optionsParts = parseOptionsString(optionsPart, false);
        return [domainPart, optionsParts];
    };
    /**
     * These option shortcuts will be converted to a more wordy AdGuard options.
     * @private
     */
    RuleConverter.OPTIONS_CONVERSION_MAP = new Map([
        // See https://adguard.com/kb/general/ad-filtering/create-own-filters/#empty-modifier
        ['empty', 'redirect=nooptext'],
        // See https://adguard.com/kb/general/ad-filtering/create-own-filters/#mp4-modifier
        ['mp4', 'redirect=noopmp4-1s'],
        ['inline-script', "csp=script-src 'self' 'unsafe-eval' http: https: data: blob: mediastream: filesystem:"],
        ['inline-font', "csp=font-src 'self' 'unsafe-eval' http: https: data: blob: mediastream: filesystem:"],
    ]);
    /**
     * Options aliases, used to convert non-AdGuard options to AdGuard options
     */
    RuleConverter.OPTIONS_ALIASES = {
        'first-party': '~third-party',
        xhr: 'xmlhttprequest',
        css: 'stylesheet',
        frame: 'subdocument',
        queryprune: 'removeparam',
        doc: 'document',
        '1p': '~third-party',
        '3p': 'third-party',
        ghide: 'generichide',
        ehide: 'elemhide',
        shide: 'specifichide',
    };
    return RuleConverter;
}());

/**
 * Network rule with index and hash.
 */
var IndexedNetworkRuleWithHash = /** @class */ (function (_super) {
    __extends(IndexedNetworkRuleWithHash, _super);
    /**
     * Constructor.
     *
     * @param rule Item of {@link NetworkRule}.
     * @param index Rule's index.
     * @param hash Hash of the rule.
     */
    function IndexedNetworkRuleWithHash(rule, index, hash) {
        var _this = _super.call(this, rule, index) || this;
        _this.hash = hash;
        _this.rule = rule;
        return _this;
    }
    /**
     * Creates hash for pattern part of the network rule and return it. Needed
     * to quickly compare two different rules with the same pattern part for
     * future checking of $badfilter application from one of them to another.
     *
     * @param networkRule Item of {@link NetworkRule}.
     *
     * @returns Hash for patter part of the network rule.
     */
    IndexedNetworkRuleWithHash.createRuleHash = function (networkRule) {
        // TODO: Improve this part: maybe use trie-lookup-table and .getShortcut()?
        // or use agtree to collect pattern + all enabled network options without values
        var significantPart = networkRule.getPattern();
        var hash = fastHash(significantPart);
        return hash;
    };
    /**
     * Create {@link IndexedNetworkRuleWithHash} from rule. If an error
     * was detected during the conversion - return it.
     *
     * @param filterId Filter id.
     * @param lineIndex Rule's line index in that filter.
     * @param ruleConvertedToAGSyntax Rule which was converted to AG syntax.
     *
     * @throws Error when conversion failed.
     *
     * @returns Item of {@link IndexedNetworkRuleWithHash} or Error.
     */
    IndexedNetworkRuleWithHash.createIndexedNetworkRuleWithHash = function (filterId, lineIndex, ruleConvertedToAGSyntax) {
        // Create indexed network rule from AG rule. These rules will be used in
        // declarative rules, that's why we ignore cosmetic and host rules.
        var networkRule;
        try {
            networkRule = RuleFactory.createRule(ruleConvertedToAGSyntax, filterId, false, // convert only network rules
            true, // ignore cosmetic rules
            true, // ignore host rules
            false);
        }
        catch (e) {
            // eslint-disable-next-line max-len
            throw new Error("Cannot create IRule from filter \"".concat(filterId, "\" and line \"").concat(lineIndex, "\": ").concat(getErrorMessage(e)));
        }
        /**
         * The converted rule will be null when there was a comment or
         * an ignored cosmetic/host rule.
         */
        if (networkRule === null) {
            return null;
        }
        if (!(networkRule instanceof NetworkRule)) {
            // eslint-disable-next-line max-len
            throw new Error("Rule from filter \"".concat(filterId, "\" and line \"").concat(lineIndex, "\" is not network rule: ").concat(networkRule));
        }
        var hash = IndexedNetworkRuleWithHash.createRuleHash(networkRule);
        // If rule is not empty - pack to IndexedNetworkRuleWithHash and add it
        // to the result array.
        var indexedNetworkRuleWithHash = new IndexedNetworkRuleWithHash(networkRule, lineIndex, hash);
        if (!indexedNetworkRuleWithHash) {
            // eslint-disable-next-line max-len
            throw new Error("Cannot create indexed network rule with hash from filter \"".concat(filterId, "\" and line \"").concat(lineIndex, "\""));
        }
        return indexedNetworkRuleWithHash;
    };
    /**
     * Creates {@link IndexedNetworkRuleWithHash} from text string.
     *
     * @param filterId Filter's id from which rule was extracted.
     * @param lineIndex Line index of rule in that filter.
     * @param rawString Text string.
     *
     * @throws Error when rule cannot be converted to AG syntax or when indexed
     * rule cannot be created from the rule which is already converted to AG
     * syntax.
     *
     * @returns Item of {@link IndexedNetworkRuleWithHash}.
     */
    IndexedNetworkRuleWithHash.createFromRawString = function (filterId, lineIndex, rawString) {
        // Converts a raw string rule to AG syntax (apply aliases, etc.)
        var rulesConvertedToAGSyntax;
        try {
            rulesConvertedToAGSyntax = RuleConverter.convertRule(rawString);
        }
        catch (e) {
            // eslint-disable-next-line max-len
            throw new Error("Unknown error during conversion rule to AG syntax: ".concat(getErrorMessage(e)));
        }
        var rules = [];
        var convertedAGRules = rulesConvertedToAGSyntax;
        // Now convert to IRule and then IndexedRule.
        for (var rulesIndex = 0; rulesIndex < convertedAGRules.length; rulesIndex += 1) {
            var ruleConvertedToAGSyntax = convertedAGRules[rulesIndex];
            try {
                var networkIndexedRuleWithHash = IndexedNetworkRuleWithHash.createIndexedNetworkRuleWithHash(filterId, lineIndex, ruleConvertedToAGSyntax);
                if (networkIndexedRuleWithHash) {
                    rules.push(networkIndexedRuleWithHash);
                }
            }
            catch (e) {
                // eslint-disable-next-line max-len
                throw new Error("Error during creating indexed rule with hash: ".concat(getErrorMessage(e)));
            }
        }
        return rules;
    };
    return IndexedNetworkRuleWithHash;
}(IndexedRule));

/* eslint-disable jsdoc/require-description-complete-sentence */
/**
 * @file Describes types from declarativeNetRequest,
 * since @types/chrome does not contain actual information.
 *
 * Updated 07/09/2022.
 */
var _a$1, _b;
/**
 * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-DomainType
 */
var DomainType;
(function (DomainType) {
    DomainType["FirstParty"] = "firstParty";
    DomainType["ThirdParty"] = "thirdParty";
})(DomainType || (DomainType = {}));
/**
 * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-ResourceType
 */
var ResourceType;
(function (ResourceType) {
    ResourceType["MainFrame"] = "main_frame";
    ResourceType["SubFrame"] = "sub_frame";
    ResourceType["Stylesheet"] = "stylesheet";
    ResourceType["Script"] = "script";
    ResourceType["Image"] = "image";
    ResourceType["Font"] = "font";
    ResourceType["Object"] = "object";
    ResourceType["XmlHttpRequest"] = "xmlhttprequest";
    ResourceType["Ping"] = "ping";
    ResourceType["Media"] = "media";
    ResourceType["WebSocket"] = "websocket";
    ResourceType["Other"] = "other";
    // Temporary not using
    // TODO: Add csp_report handler similar to AG-24613 but in declarative way.
    // CspReport = 'csp_report',
    // WebTransport = 'webtransport',
    // WebBundle = 'webbundle',
})(ResourceType || (ResourceType = {}));
/**
 * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-QueryKeyValue
 */
var QueryKeyValueValidator = z.strictObject({
    key: z.string(),
    replaceOnly: z.boolean().optional(),
    value: z.string(),
});
/**
 * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-QueryTransform
 */
var QueryTransformValidator = z.strictObject({
    addOrReplaceParams: QueryKeyValueValidator.array().optional(),
    removeParams: z.string().array().optional(),
});
/**
 * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-URLTransform
 */
var URLTransformValidator = z.strictObject({
    fragment: z.string().optional(),
    host: z.string().optional(),
    password: z.string().optional(),
    path: z.string().optional(),
    port: z.string().optional(),
    query: z.string().optional(),
    queryTransform: QueryTransformValidator.optional(),
    scheme: z.string().optional(),
    username: z.string().optional(),
});
/**
 * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-Redirect
 */
var RedirectValidator = z.strictObject({
    extensionPath: z.string().optional(),
    regexSubstitution: z.string().optional(),
    transform: URLTransformValidator.optional(),
    url: z.string().optional(),
});
/**
 * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-HeaderOperation
 */
var HeaderOperation;
(function (HeaderOperation) {
    HeaderOperation["Append"] = "append";
    HeaderOperation["Set"] = "set";
    HeaderOperation["Remove"] = "remove";
})(HeaderOperation || (HeaderOperation = {}));
/**
 * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-ModifyHeaderInfo
 */
var ModifyHeaderInfoValidator = z.strictObject({
    header: z.string(),
    operation: z.nativeEnum(HeaderOperation),
    value: z.string().optional(),
});
/**
 * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-RuleActionType
 */
var RuleActionType;
(function (RuleActionType) {
    RuleActionType["BLOCK"] = "block";
    RuleActionType["REDIRECT"] = "redirect";
    RuleActionType["ALLOW"] = "allow";
    RuleActionType["UPGRADE_SCHEME"] = "upgradeScheme";
    RuleActionType["MODIFY_HEADERS"] = "modifyHeaders";
    /**
     * For allowAllRequests rules {@link RuleCondition.resourceTypes} may only
     * include the 'sub_frame' and 'main_frame' resource types.
     */
    RuleActionType["ALLOW_ALL_REQUESTS"] = "allowAllRequests";
})(RuleActionType || (RuleActionType = {}));
/**
 * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-RuleAction
 */
var RuleActionValidator = z.strictObject({
    redirect: RedirectValidator.optional(),
    requestHeaders: ModifyHeaderInfoValidator.array().optional(),
    responseHeaders: ModifyHeaderInfoValidator.array().optional(),
    type: z.nativeEnum(RuleActionType),
});
/**
 * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-RequestMethod
 */
var RequestMethod;
(function (RequestMethod) {
    RequestMethod["Connect"] = "connect";
    RequestMethod["Delete"] = "delete";
    RequestMethod["Get"] = "get";
    RequestMethod["Head"] = "head";
    RequestMethod["Options"] = "options";
    RequestMethod["Patch"] = "patch";
    RequestMethod["Post"] = "post";
    RequestMethod["Put"] = "put";
})(RequestMethod || (RequestMethod = {}));
/**
 * Map {@link HTTPMethod} to declarative {@link RequestMethod}.
 */
var DECLARATIVE_REQUEST_METHOD_MAP = (_a$1 = {},
    _a$1[HTTPMethod.GET] = RequestMethod.Get,
    _a$1[HTTPMethod.POST] = RequestMethod.Post,
    _a$1[HTTPMethod.PUT] = RequestMethod.Put,
    _a$1[HTTPMethod.DELETE] = RequestMethod.Delete,
    _a$1[HTTPMethod.PATCH] = RequestMethod.Patch,
    _a$1[HTTPMethod.HEAD] = RequestMethod.Head,
    _a$1[HTTPMethod.OPTIONS] = RequestMethod.Options,
    _a$1[HTTPMethod.CONNECT] = RequestMethod.Connect,
    _a$1);
/**
 * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-RuleCondition
 */
var RuleConditionValidator = z.strictObject({
    domainType: z.nativeEnum(DomainType).optional(),
    excludedInitiatorDomains: z.string().array().optional(),
    excludedRequestDomains: z.string().array().optional(),
    excludedRequestMethods: z.nativeEnum(RequestMethod).array().optional(),
    excludedResourceTypes: z.nativeEnum(ResourceType).array().optional(),
    excludedTabIds: z.number().array().optional(),
    initiatorDomains: z.string().array().optional(),
    isUrlFilterCaseSensitive: z.boolean().optional(),
    regexFilter: z.string().optional(),
    requestDomains: z.string().array().optional(),
    requestMethods: z.nativeEnum(RequestMethod).array().optional(),
    /**
     * If none of the `excludedResourceTypes` and `resourceTypes` are specified,
     * all resource types except "main_frame" will be matched.
     */
    resourceTypes: z.nativeEnum(ResourceType).array().optional(),
    tabIds: z.number().array().optional(),
    urlFilter: z.string().optional(),
});
/**
 * https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-Rule
 */
var DeclarativeRuleValidator = z.strictObject({
    action: RuleActionValidator,
    condition: RuleConditionValidator,
    id: z.number(),
    priority: z.number().optional(),
});
/**
 * Map request types to declarative types.
 */
var DECLARATIVE_RESOURCE_TYPES_MAP = (_b = {},
    _b[ResourceType.MainFrame] = RequestType.Document,
    _b[ResourceType.SubFrame] = RequestType.SubDocument,
    _b[ResourceType.Stylesheet] = RequestType.Stylesheet,
    _b[ResourceType.Script] = RequestType.Script,
    _b[ResourceType.Image] = RequestType.Image,
    _b[ResourceType.Font] = RequestType.Font,
    _b[ResourceType.Object] = RequestType.Object,
    _b[ResourceType.XmlHttpRequest] = RequestType.XmlHttpRequest,
    _b[ResourceType.Ping] = RequestType.Ping,
    // TODO: what should match this resource type?
    // [ResourceType.CSP_REPORT]: RequestType.Document,
    _b[ResourceType.Media] = RequestType.Media,
    _b[ResourceType.WebSocket] = RequestType.WebSocket,
    _b[ResourceType.Other] = RequestType.Other,
    _b);

/**
 * Describes an error when rule set source is not available.
 */
var UnavailableRuleSetSourceError = /** @class */ (function (_super) {
    __extends(UnavailableRuleSetSourceError, _super);
    /**
     * Describes an error when rule set source is not available.
     *
     * @param message Message of error.
     * @param ruleSetId Rule set id, the source of which is not available.
     * @param cause Basic error, describes why the source is unavailable.
     */
    function UnavailableRuleSetSourceError(message, ruleSetId, cause) {
        var _this = _super.call(this, message, { cause: cause }) || this;
        _this.name = 'UnavailableRuleSetSourceError';
        _this.ruleSetId = ruleSetId;
        // For proper work of the "instanceof" operator
        Object.setPrototypeOf(_this, UnavailableRuleSetSourceError.prototype);
        return _this;
    }
    return UnavailableRuleSetSourceError;
}(Error));

/**
 * Contains a list of records with source rule ID, converted rule ID
 * and filter ID.
 * Can return the source filter and rule for the provided conversion rule ID.
 */
var SourceMap = /** @class */ (function () {
    /**
     * Creates new SourceMap from provided list of sources.
     *
     * @param sources List of sources.
     */
    function SourceMap(sources) {
        var _this = this;
        this.sources = [];
        /**
         * Needs for fast search for source rule.
         */
        this.ruleIdMap = new Map();
        /**
         * Needs for fast search for source rule.
         */
        this.declarativeIdMap = new Map();
        this.sources = sources;
        // For fast search
        this.sources.forEach(function (item) {
            var sourceRuleIndex = item.sourceRuleIndex, filterId = item.filterId, declarativeRuleId = item.declarativeRuleId;
            // Fill source rules map.
            var existingSourcePairs = _this.ruleIdMap.get(declarativeRuleId);
            var value = {
                sourceRuleIndex: sourceRuleIndex,
                filterId: filterId,
            };
            var newSourceValue = existingSourcePairs
                ? existingSourcePairs.concat(value)
                : [value];
            _this.ruleIdMap.set(declarativeRuleId, newSourceValue);
            // Fill
            var key = SourceMap.getKeyFromSource(value);
            var existingDeclarativeIdsPairs = _this.declarativeIdMap.get(key);
            var newDeclarativeIdsValue = existingDeclarativeIdsPairs
                ? existingDeclarativeIdsPairs.concat(declarativeRuleId)
                : [declarativeRuleId];
            _this.declarativeIdMap.set(key, newDeclarativeIdsValue);
        });
    }
    /**
     * Creates unique key for provided pair of source rule and filter id.
     *
     * @param source Pair of source rule and filter id.
     *
     * @returns Unique key for dictionary.
     */
    SourceMap.getKeyFromSource = function (source) {
        return "".concat(source.filterId, "_").concat(source.sourceRuleIndex);
    };
    /**
     * Returns source filter id and source text rule id
     * for provided declarative rule id.
     *
     * @param ruleId Converted rule id.
     *
     * @returns List of pairs: source filter id and source rule id.
     */
    SourceMap.prototype.getByDeclarativeRuleId = function (ruleId) {
        return this.ruleIdMap.get(ruleId) || [];
    };
    /**
     * Returns ids of converted declarative rules for provided pairs of source
     * filter id and source text rule.
     *
     * @param source Pair of source rule and filter id.
     *
     * @returns List of ids of converted declarative rules.
     */
    SourceMap.prototype.getBySourceRuleIndex = function (source) {
        var key = SourceMap.getKeyFromSource(source);
        return this.declarativeIdMap.get(key) || [];
    };
    /**
     * Deserializes array of sources from string.
     *
     * @param sourceString The original map that was serialized into a string.
     *
     * @returns List of sources.
     */
    SourceMap.deserializeSources = function (sourceString) {
        // TODO: Add validation
        var arr = JSON.parse(sourceString);
        return arr.map(function (item) { return ({
            declarativeRuleId: item[0],
            sourceRuleIndex: item[1],
            filterId: item[2],
        }); });
    };
    /**
     * Serializes source map to JSON string.
     *
     * @todo (TODO:) Can use protocol VLQ.
     *
     * @returns JSON string.
     */
    SourceMap.prototype.serialize = function () {
        // Remove fields names to reduce size of serialized string
        var plainArray = this.sources.map(function (_a) {
            var declarativeRuleId = _a.declarativeRuleId, sourceRuleIndex = _a.sourceRuleIndex, filterId = _a.filterId;
            return ([declarativeRuleId, sourceRuleIndex, filterId]);
        });
        return JSON.stringify(plainArray);
    };
    return SourceMap;
}());

var serializedRuleSetLazyDataValidator = z.strictObject({
    sourceMapRaw: z.string(),
    filterIds: z.number().array(),
});
var serializedRuleSetDataValidator = z.strictObject({
    regexpRulesCount: z.number(),
    rulesCount: z.number(),
    ruleSetHashMapRaw: z.string(),
    badFilterRulesRaw: z.string().array(),
});
/**
 * Keeps converted declarative rules, counters of rules and source map for them.
 */
var RuleSet = /** @class */ (function () {
    /**
     * Constructor of RuleSet.
     *
     * @param id Id of rule set.
     * @param rulesCount Number of rules.
     * @param regexpRulesCount Number of regexp rules.
     * @param ruleSetContentProvider Rule set content provider.
     * @param badFilterRules List of rules with $badfilter modifier.
     * @param rulesHashMap Dictionary with hashes for all source rules.
     */
    function RuleSet(id, rulesCount, regexpRulesCount, ruleSetContentProvider, badFilterRules, rulesHashMap) {
        /**
         * Array of converted declarative rules.
         */
        this.declarativeRules = [];
        /**
         * Number of converted declarative rules.
         * This is needed for the lazy version of the rule set,
         * when content not loaded.
         */
        this.rulesCount = 0;
        /**
         * Converted declarative regexp rules.
         */
        this.regexpRulesCount = 0;
        /**
         * Keeps array of source filter lists
         * TODO: ? May it leads to memory leaks,
         * because one FilterList with its content
         * can be in the several RuleSet's at the same time ?
         */
        this.filterList = new Map();
        /**
         * Whether the content is loaded or not.
         */
        this.initialized = false;
        this.id = id;
        this.rulesCount = rulesCount;
        this.regexpRulesCount = regexpRulesCount;
        this.ruleSetContentProvider = ruleSetContentProvider;
        this.badFilterRules = badFilterRules;
        this.rulesHashMap = rulesHashMap;
    }
    /** @inheritdoc */
    RuleSet.prototype.getRulesCount = function () {
        return this.rulesCount || this.declarativeRules.length;
    };
    /** @inheritdoc */
    RuleSet.prototype.getRegexpRulesCount = function () {
        return this.regexpRulesCount;
    };
    /** @inheritdoc */
    RuleSet.prototype.getId = function () {
        return this.id;
    };
    /**
     * Returns a list of pairs of source text rules and their filter identifiers
     * for a given declarative rule identifier.
     *
     * @param declarativeRuleId {@link DeclarativeRule|declarative rule} Id.
     *
     * @throws An error when filter is not found or filter content is unavailable.
     *
     * @returns Promise with list of source rules.
     */
    RuleSet.prototype.findSourceRules = function (declarativeRuleId) {
        var _this = this;
        if (!this.sourceMap) {
            return Promise.resolve([]);
        }
        var sourcePairs = this.sourceMap.getByDeclarativeRuleId(declarativeRuleId);
        var sourceRules = sourcePairs.map(function (_a) {
            var filterId = _a.filterId, sourceRuleIndex = _a.sourceRuleIndex;
            return __awaiter(_this, void 0, void 0, function () {
                var filter, sourceRule;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            filter = this.filterList.get(filterId);
                            if (!filter) {
                                throw new Error("Not found filter list with id: ".concat(filterId));
                            }
                            return [4 /*yield*/, filter.getRuleByIndex(sourceRuleIndex)];
                        case 1:
                            sourceRule = _b.sent();
                            return [2 /*return*/, {
                                    sourceRule: sourceRule,
                                    filterId: filterId,
                                }];
                    }
                });
            });
        });
        return Promise.all(sourceRules);
    };
    /**
     * Run inner lazy deserialization from rule set content provider to load
     * data which is not needed on the creation of rule set:
     * the source map, filter list and declarative rules list.
     */
    RuleSet.prototype.loadContent = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, loadSourceMap, loadFilterList, loadDeclarativeRules, _b, _c, filtersList;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (this.initialized) {
                            return [2 /*return*/];
                        }
                        _a = this.ruleSetContentProvider, loadSourceMap = _a.loadSourceMap, loadFilterList = _a.loadFilterList, loadDeclarativeRules = _a.loadDeclarativeRules;
                        _b = this;
                        return [4 /*yield*/, loadSourceMap()];
                    case 1:
                        _b.sourceMap = _d.sent();
                        _c = this;
                        return [4 /*yield*/, loadDeclarativeRules()];
                    case 2:
                        _c.declarativeRules = _d.sent();
                        return [4 /*yield*/, loadFilterList()];
                    case 3:
                        filtersList = _d.sent();
                        filtersList.forEach(function (filter) {
                            _this.filterList.set(filter.getId(), filter);
                        });
                        this.initialized = true;
                        return [2 /*return*/];
                }
            });
        });
    };
    /** @inheritdoc */
    RuleSet.prototype.getRulesById = function (declarativeRuleId) {
        return __awaiter(this, void 0, void 0, function () {
            var originalRules, e_1, id, msg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        return [4 /*yield*/, this.loadContent()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.findSourceRules(declarativeRuleId)];
                    case 2:
                        originalRules = _a.sent();
                        return [2 /*return*/, originalRules];
                    case 3:
                        e_1 = _a.sent();
                        id = this.getId();
                        msg = "Cannot extract source rule for given declarativeRuleId ".concat(declarativeRuleId, " in rule set '").concat(id, "'");
                        throw new UnavailableRuleSetSourceError(msg, id, e_1);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /** @inheritdoc */
    RuleSet.prototype.getBadFilterRules = function () {
        return this.badFilterRules;
    };
    /** @inheritdoc */
    RuleSet.prototype.getRulesHashMap = function () {
        return this.rulesHashMap;
    };
    /** @inheritdoc */
    RuleSet.prototype.getDeclarativeRulesIdsBySourceRuleIndex = function (source) {
        return __awaiter(this, void 0, void 0, function () {
            var filterId, sourceRuleIndex;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.loadContent()];
                    case 1:
                        _a.sent();
                        if (!this.sourceMap) {
                            filterId = source.filterId, sourceRuleIndex = source.sourceRuleIndex;
                            // eslint-disable-next-line max-len
                            throw new Error("Cannot find declarative rules for filter id - ".concat(filterId, ", rule index - ").concat(sourceRuleIndex, " because source map is undefined in ruleset: ").concat(this.getId()));
                        }
                        return [2 /*return*/, this.sourceMap.getBySourceRuleIndex(source)];
                }
            });
        });
    };
    /** @inheritdoc */
    RuleSet.prototype.getDeclarativeRules = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.loadContent()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.declarativeRules];
                }
            });
        });
    };
    /**
     * For provided source rule and filter id return network rule.
     * This method is needed for checking the applicability of $badfilter after
     * a fast-check of rules by comparing only hashes. Afterward, we should
     * build the 'full' Network rule from provided source, not just the hash,
     * to determine the applicability of $badfilter.
     *
     * @param source Source rule and filter id.
     *
     * @returns List of {@link NetworkRule | network rules}.
     */
    RuleSet.getNetworkRuleBySourceRule = function (source) {
        var sourceRule = source.sourceRule, filterId = source.filterId;
        var networkIndexedRulesWithHash = [];
        try {
            networkIndexedRulesWithHash = IndexedNetworkRuleWithHash.createFromRawString(filterId, 
            // We don't need line index because this indexedNetworkRulesWithHash
            // will be used only for matching $badfilter rules.
            0, sourceRule);
        }
        catch (e) {
            return [];
        }
        var networkRules = networkIndexedRulesWithHash.map(function (_a) {
            var rule = _a.rule;
            return rule;
        });
        return networkRules;
    };
    /**
     * Deserializes rule set to primitives values with lazy load.
     *
     * @param id Id of rule set.
     * @param rawData An item of {@link SerializedRuleSetData} for instant
     * creating ruleset. It contains counters for regular declarative and regexp
     * declarative rules, a map of hashes for all rules, and a list of rules
     * with the `$badfilter` modifier.
     * @param loadLazyData An item of {@link SerializedRuleSetLazyData} for lazy
     * loading ruleset data to find and display source rules when declarative
     * filtering log is enabled. It includes a map of sources for all rules,
     * a list of declarative rules, and a list of source filter IDs.
     * @param loadDeclarativeRules Loader for ruleset's declarative rules from
     * raw file as a string.
     * @param filterList List of {@link IFilter}.
     *
     * @returns Deserialized rule set.
     *
     * @throws Error {@link UnavailableRuleSetSourceError} if rule set source
     * is not available.
     */
    RuleSet.deserialize = function (id, rawData, loadLazyData, loadDeclarativeRules, filterList) {
        return __awaiter(this, void 0, void 0, function () {
            var data, objectFromString, msg, deserializedLazyData, getLazyData, deserialized;
            var _this = this;
            return __generator(this, function (_a) {
                try {
                    objectFromString = JSON.parse(rawData);
                    data = serializedRuleSetDataValidator.parse(objectFromString);
                }
                catch (e) {
                    msg = "Cannot parse serialized ruleset's data with id \"".concat(id, "\" because of not available source");
                    throw new UnavailableRuleSetSourceError(msg, id, e);
                }
                getLazyData = function () { return __awaiter(_this, void 0, void 0, function () {
                    var lazyData, objectFromString, e_2, msg;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (deserializedLazyData !== undefined) {
                                    return [2 /*return*/, deserializedLazyData];
                                }
                                _a.label = 1;
                            case 1:
                                _a.trys.push([1, 3, , 4]);
                                return [4 /*yield*/, loadLazyData()];
                            case 2:
                                lazyData = _a.sent();
                                objectFromString = JSON.parse(lazyData);
                                deserializedLazyData = serializedRuleSetLazyDataValidator.parse(objectFromString);
                                return [2 /*return*/, deserializedLazyData];
                            case 3:
                                e_2 = _a.sent();
                                msg = "Cannot parse or load data for lazy metadata for rule set with id \"".concat(id, "\": ").concat(getErrorMessage(e_2));
                                throw new UnavailableRuleSetSourceError(msg, id, e_2);
                            case 4: return [2 /*return*/];
                        }
                    });
                }); };
                deserialized = {
                    id: id,
                    data: data,
                    ruleSetContentProvider: {
                        loadSourceMap: function () { return __awaiter(_this, void 0, void 0, function () {
                            var sourceMapRaw, sources;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, getLazyData()];
                                    case 1:
                                        sourceMapRaw = (_a.sent()).sourceMapRaw;
                                        sources = SourceMap.deserializeSources(sourceMapRaw);
                                        return [2 /*return*/, new SourceMap(sources)];
                                }
                            });
                        }); },
                        loadFilterList: function () { return __awaiter(_this, void 0, void 0, function () {
                            var filterIds;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, getLazyData()];
                                    case 1:
                                        filterIds = (_a.sent()).filterIds;
                                        return [2 /*return*/, filterList.filter(function (filter) { return filterIds.includes(filter.getId()); })];
                                }
                            });
                        }); },
                        loadDeclarativeRules: function () { return __awaiter(_this, void 0, void 0, function () {
                            var rawFileContent, objectFromString, declarativeRules;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, loadDeclarativeRules()];
                                    case 1:
                                        rawFileContent = _a.sent();
                                        objectFromString = JSON.parse(rawFileContent);
                                        declarativeRules = DeclarativeRuleValidator
                                            .array()
                                            .parse(objectFromString);
                                        return [2 /*return*/, declarativeRules];
                                }
                            });
                        }); },
                    },
                };
                return [2 /*return*/, deserialized];
            });
        });
    };
    /** @inheritdoc */
    RuleSet.prototype.serialize = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var e_3, id, msg, data, lazyData, serialized;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.loadContent()];
                    case 1:
                        _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_3 = _b.sent();
                        id = this.getId();
                        msg = "Cannot serialize rule set '".concat(id, "' because of not available source");
                        throw new UnavailableRuleSetSourceError(msg, id, e_3);
                    case 3:
                        data = {
                            regexpRulesCount: this.regexpRulesCount,
                            rulesCount: this.rulesCount,
                            ruleSetHashMapRaw: this.rulesHashMap.serialize(),
                            badFilterRulesRaw: this.badFilterRules.map(function (r) { return r.rule.getText(); }) || [],
                        };
                        lazyData = {
                            sourceMapRaw: ((_a = this.sourceMap) === null || _a === void 0 ? void 0 : _a.serialize()) || '',
                            filterIds: Array.from(this.filterList.keys()),
                        };
                        serialized = {
                            id: this.id,
                            data: JSON.stringify(data),
                            lazyData: JSON.stringify(lazyData),
                        };
                        return [2 /*return*/, serialized];
                }
            });
        });
    };
    return RuleSet;
}());

/**
 * Describes abstract error when declarative rule is invalid.
 */
var InvalidDeclarativeRuleError = /** @class */ (function (_super) {
    __extends(InvalidDeclarativeRuleError, _super);
    /**
     * Describes abstract error when declarative rule is invalid.
     *
     * @param message Message of error.
     * @param networkRule {@link NetworkRule}.
     * @param declarativeRule {@link DeclarativeRule}.
     */
    function InvalidDeclarativeRuleError(message, networkRule, declarativeRule) {
        var _this = _super.call(this, message) || this;
        _this.name = 'InvalidDeclarativeRuleError';
        _this.networkRule = networkRule;
        _this.declarativeRule = declarativeRule;
        // For proper work of the "instanceof" operator
        Object.setPrototypeOf(_this, InvalidDeclarativeRuleError.prototype);
        return _this;
    }
    return InvalidDeclarativeRuleError;
}(Error));

/**
 * Describes error when converted rule contains empty list of resources types.
 */
var EmptyResourcesError = /** @class */ (function (_super) {
    __extends(EmptyResourcesError, _super);
    /**
     * Describes error when converted rule contains empty list of resources types.
     *
     * @param message Message of error.
     * @param networkRule {@link NetworkRule}.
     * @param declarativeRule {@link DeclarativeRule}.
     */
    function EmptyResourcesError(message, networkRule, declarativeRule) {
        var _this = _super.call(this, message, networkRule, declarativeRule) || this;
        _this.name = 'EmptyResourcesError';
        // For proper work of the "instanceof" operator
        Object.setPrototypeOf(_this, EmptyResourcesError.prototype);
        return _this;
    }
    return EmptyResourcesError;
}(InvalidDeclarativeRuleError));

/**
 * Describes error when converted rule contains too complex regexp error.
 */
var TooComplexRegexpError = /** @class */ (function (_super) {
    __extends(TooComplexRegexpError, _super);
    /**
     * Describes error when converted rule contains too complex regexp error.
     *
     * @param message Message of error.
     * @param networkRule {@link NetworkRule}.
     * @param declarativeRule {@link DeclarativeRule}.
     */
    function TooComplexRegexpError(message, networkRule, declarativeRule) {
        var _this = _super.call(this, message, networkRule, declarativeRule) || this;
        _this.name = 'TooComplexRegexpError';
        // For proper work of the "instanceof" operator
        Object.setPrototypeOf(_this, TooComplexRegexpError.prototype);
        return _this;
    }
    return TooComplexRegexpError;
}(InvalidDeclarativeRuleError));

/**
 * Describes an error when a source network rule contains some of
 * the unsupported modifiers.
 *
 * @see {@link DeclarativeRuleConverter.checkNetworkRuleConvertible} for more details.
 */
var UnsupportedModifierError = /** @class */ (function (_super) {
    __extends(UnsupportedModifierError, _super);
    /**
     * Describes an error when a source network rule contains some of
     * the unsupported modifiers.
     *
     * @param message Message of error.
     * @param networkRule {@link NetworkRule}.
     */
    function UnsupportedModifierError(message, networkRule) {
        var _this = _super.call(this, message) || this;
        _this.name = 'UnsupportedModifierError';
        _this.networkRule = networkRule;
        // For proper work of the "instanceof" operator
        Object.setPrototypeOf(_this, UnsupportedModifierError.prototype);
        return _this;
    }
    return UnsupportedModifierError;
}(Error));

/**
 * Describes an error when the converted rule contains an unsupported RE2
 * regexp syntax error.
 *
 * @see https://github.com/google/re2/wiki/Syntax
 */
var UnsupportedRegexpError = /** @class */ (function (_super) {
    __extends(UnsupportedRegexpError, _super);
    /**
     * Describes an error when the converted rule contains an unsupported RE2
     * regexp syntax error.
     *
     * @param message Message of error.
     * @param networkRule {@link NetworkRule}.
     * @param declarativeRule {@link DeclarativeRule}.
     */
    function UnsupportedRegexpError(message, networkRule, declarativeRule) {
        var _this = _super.call(this, message, networkRule, declarativeRule) || this;
        _this.name = 'UnsupportedRegexpError';
        // For proper work of the "instanceof" operator
        Object.setPrototypeOf(_this, UnsupportedRegexpError.prototype);
        return _this;
    }
    return UnsupportedRegexpError;
}(InvalidDeclarativeRuleError));

/**
 * Describes error when maximum number of rules is equal or less than 0.
 */
var EmptyOrNegativeNumberOfRulesError = /** @class */ (function (_super) {
    __extends(EmptyOrNegativeNumberOfRulesError, _super);
    /**
     * Describes error when maximum number of rules is equal or less than 0.
     *
     * @param message Message of error.
     */
    function EmptyOrNegativeNumberOfRulesError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'EmptyOrNegativeNumberOfRulesError';
        // For proper work of the "instanceof" operator
        Object.setPrototypeOf(_this, EmptyOrNegativeNumberOfRulesError.prototype);
        return _this;
    }
    return EmptyOrNegativeNumberOfRulesError;
}(Error));

/**
 * Describes error when maximum number of rules is less than 0.
 */
var NegativeNumberOfRegexpRulesError = /** @class */ (function (_super) {
    __extends(NegativeNumberOfRegexpRulesError, _super);
    /**
     * Describes error when maximum number of rules is less than 0.
     *
     * @param message Message of error.
     */
    function NegativeNumberOfRegexpRulesError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'NegativeNumberOfRegexpRulesError';
        // For proper work of the "instanceof" operator
        Object.setPrototypeOf(_this, NegativeNumberOfRegexpRulesError.prototype);
        return _this;
    }
    return NegativeNumberOfRegexpRulesError;
}(Error));

/**
 * Describes error when the resources path does not start with a slash
 * or it ends with a slash.
 */
var ResourcesPathError = /** @class */ (function (_super) {
    __extends(ResourcesPathError, _super);
    /**
     * Describes error when the resources path does not start with a slash
     * or it ends with a slash.
     *
     * @param message Message of error.
     */
    function ResourcesPathError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'ResourcesPathError';
        // For proper work of the "instanceof" operator
        Object.setPrototypeOf(_this, ResourcesPathError.prototype);
        return _this;
    }
    return ResourcesPathError;
}(Error));

/* eslint-disable jsdoc/require-description-complete-sentence */
/**
 * Contains the generic logic for converting a {@link NetworkRule}
 * into a {@link DeclarativeRule}.
 *
 * Descendant classes must override the {@link convert} method,
 * where some logic must be defined for each rule type.
 *
 * Also descendant classes can use {@link convertRules}, {@link convertRule} and
 * {@link groupConvertedRules} methods, which contains the general logic of
 * transformation and grouping of rules.
 */
var DeclarativeRuleConverter = /** @class */ (function () {
    /**
     * Creates an instance of DeclarativeRuleConverter.
     *
     * @param webAccessibleResourcesPath Path to web accessible resources.
     */
    function DeclarativeRuleConverter(webAccessibleResourcesPath) {
        this.webAccessibleResourcesPath = webAccessibleResourcesPath;
    }
    /**
     * Gets resource type matching request type.
     *
     * @param requestTypes Request type.
     *
     * @returns List of resource types.
     */
    DeclarativeRuleConverter.getResourceTypes = function (requestTypes) {
        return Object.entries(DECLARATIVE_RESOURCE_TYPES_MAP)
            // Skips the first element
            .filter(function (_a) {
            var requestType = _a[1];
            return (requestTypes & requestType) === requestType;
        })
            .map(function (_a) {
            var resourceTypeKey = _a[0];
            return resourceTypeKey;
        });
    };
    /**
     * Converts list of tsurlfilter {@link HTTPMethod|methods} to declarative
     * supported http {@link RequestMethod|methods} via excluding 'trace' method.
     *
     * @param methods List of {@link HTTPMethod|methods}.
     *
     * @returns List of {@link RequestMethod|methods}.
     */
    DeclarativeRuleConverter.mapHttpMethodToDeclarativeHttpMethod = function (methods) {
        return methods
            // Filters unsupported `trace` method
            .filter(function (m) { return m !== HTTPMethod.TRACE; })
            // Map tsurlfilter http method to supported declarative http method
            .map(function (m) { return DECLARATIVE_REQUEST_METHOD_MAP[m]; });
    };
    /**
     * Checks if the string contains only ASCII characters.
     *
     * @param str String to test.
     *
     * @returns True if string contains only ASCII characters.
     */
    DeclarativeRuleConverter.isASCII = function (str) {
        // eslint-disable-next-line no-control-regex
        return /^[\x00-\x7F]+$/.test(str);
    };
    /**
     * Converts to punycode if string contains non ASCII characters.
     *
     * @param str String to convert.
     *
     * @returns A transformed string containing only ASCII characters or
     * the original string.
     */
    DeclarativeRuleConverter.prepareASCII = function (str) {
        return DeclarativeRuleConverter.isASCII(str)
            ? str
            : punycode.toASCII(str);
    };
    /**
     * Converts a list of strings into strings containing only ASCII characters.
     *
     * @param strings List of strings.
     *
     * @returns List of string containing only ASCII characters.
     */
    DeclarativeRuleConverter.toASCII = function (strings) {
        return strings.map(function (s) {
            return DeclarativeRuleConverter.prepareASCII(s);
        });
    };
    /**
     * Checks if network rule can be converted to {@link RuleActionType.ALLOW_ALL_REQUESTS}.
     *
     * @param rule Network rule.
     *
     * @returns Is rule compatible with {@link RuleActionType.ALLOW_ALL_REQUESTS}.
     */
    DeclarativeRuleConverter.isCompatibleWithAllowAllRequests = function (rule) {
        var types = DeclarativeRuleConverter.getResourceTypes(rule.getPermittedRequestTypes());
        var allowedRequestTypes = [ResourceType.MainFrame, ResourceType.SubFrame];
        // If found resource type which is incompatible with allowAllRequest field
        if (types.some(function (type) { return !allowedRequestTypes.includes(type); })) {
            return false;
        }
        return true;
    };
    /**
     * Rule priority.
     *
     * @see {@link NetworkRule.getPriorityWeight}
     * @see {@link NetworkRule.priorityWeight}
     * @see {@link NetworkRule.calculatePriorityWeight}
     * @see {@link https://adguard.com/kb/en/general/ad-filtering/create-own-filters/#rule-priorities}
     *
     * @param rule Network rule.
     *
     * @returns Priority of the rule or null.
     */
    DeclarativeRuleConverter.getPriority = function (rule) {
        return rule.getPriorityWeight();
    };
    /**
     * Rule redirect action.
     *
     * @param rule Network rule.
     *
     * @throws Error {@link ResourcesPathError} when a network rule has
     * a $redirect modifier and no path to web-accessible resources
     * is specified.
     *
     * @returns Redirect, which describes where and how the request
     * should be redirected.
     */
    DeclarativeRuleConverter.prototype.getRedirectAction = function (rule) {
        if (rule.isOptionEnabled(NetworkRuleOption.Redirect)) {
            var resourcesPath = this.webAccessibleResourcesPath;
            if (!resourcesPath) {
                var ruleText = rule.getText();
                var msg = "Empty web accessible resources path: ".concat(ruleText);
                throw new ResourcesPathError(msg);
            }
            var advancedModifier = rule.getAdvancedModifier();
            var redirectTo = advancedModifier;
            var filename = redirects.getRedirectFilename(redirectTo.getValue());
            return { extensionPath: "".concat(resourcesPath, "/").concat(filename) };
        }
        if (rule.isOptionEnabled(NetworkRuleOption.RemoveParam)) {
            var advancedModifier = rule.getAdvancedModifier();
            var removeParamModifier = advancedModifier;
            var value = removeParamModifier.getValue();
            if (value === '') {
                return { transform: { query: '' } };
            }
            return {
                transform: {
                    queryTransform: {
                        removeParams: DeclarativeRuleConverter.toASCII([value]),
                    },
                },
            };
        }
        return {};
    };
    /**
     * Returns rule modify headers action.
     *
     * @param rule Network rule.
     *
     * @returns Modify headers action, which describes which headers should
     * be changed: added, set or deleted.
     */
    DeclarativeRuleConverter.getModifyHeadersAction = function (rule) {
        if (!rule.isOptionEnabled(NetworkRuleOption.RemoveHeader)) {
            return null;
        }
        var removeHeaderModifier = rule.getAdvancedModifier();
        var removeRequestHeader = removeHeaderModifier.getApplicableHeaderName(true);
        if (removeRequestHeader) {
            return {
                requestHeaders: [{
                        header: removeRequestHeader,
                        operation: HeaderOperation.Remove,
                    }],
            };
        }
        var removeResponseHeader = removeHeaderModifier.getApplicableHeaderName(false);
        if (removeResponseHeader) {
            return {
                responseHeaders: [{
                        header: removeResponseHeader,
                        operation: HeaderOperation.Remove,
                    }],
            };
        }
        return null;
    };
    /**
     * Returns rule modify headers action with adding CSP headers to response.
     *
     * @param rule Network rule.
     *
     * @returns Add headers action, which describes which headers should be added.
     */
    DeclarativeRuleConverter.getAddingCspHeadersAction = function (rule) {
        if (!rule.isOptionEnabled(NetworkRuleOption.Csp)) {
            return null;
        }
        var cspHeaderValue = rule.getAdvancedModifierValue();
        if (cspHeaderValue) {
            return {
                operation: HeaderOperation.Append,
                header: CSP_HEADER_NAME,
                value: cspHeaderValue,
            };
        }
        return null;
    };
    /**
     * Rule action.
     *
     * @param rule Network rule.
     *
     * @throws Error {@link ResourcesPathError} when specified an empty
     * path to the web accessible resources.
     *
     * @returns The action of a rule that describes what should be done
     * with the request.
     */
    DeclarativeRuleConverter.prototype.getAction = function (rule) {
        if (rule.isAllowlist()) {
            if (rule.isFilteringDisabled() && DeclarativeRuleConverter.isCompatibleWithAllowAllRequests(rule)) {
                return { type: RuleActionType.ALLOW_ALL_REQUESTS };
            }
            return { type: RuleActionType.ALLOW };
        }
        if (rule.isOptionEnabled(NetworkRuleOption.Redirect)
            || rule.isOptionEnabled(NetworkRuleOption.RemoveParam)) {
            return {
                type: RuleActionType.REDIRECT,
                redirect: this.getRedirectAction(rule),
            };
        }
        if (rule.isOptionEnabled(NetworkRuleOption.RemoveHeader)) {
            var modifyHeadersAction = DeclarativeRuleConverter.getModifyHeadersAction(rule);
            if (modifyHeadersAction === null || modifyHeadersAction === void 0 ? void 0 : modifyHeadersAction.requestHeaders) {
                return {
                    type: RuleActionType.MODIFY_HEADERS,
                    requestHeaders: modifyHeadersAction.requestHeaders,
                };
            }
            if (modifyHeadersAction === null || modifyHeadersAction === void 0 ? void 0 : modifyHeadersAction.responseHeaders) {
                return {
                    type: RuleActionType.MODIFY_HEADERS,
                    responseHeaders: modifyHeadersAction.responseHeaders,
                };
            }
        }
        if (rule.isOptionEnabled(NetworkRuleOption.Csp)) {
            var addCspHeadersAction = DeclarativeRuleConverter.getAddingCspHeadersAction(rule);
            if (addCspHeadersAction) {
                return {
                    type: RuleActionType.MODIFY_HEADERS,
                    responseHeaders: [addCspHeadersAction],
                };
            }
        }
        return { type: RuleActionType.BLOCK };
    };
    /**
     * Rule condition.
     *
     * @param rule Network rule.
     *
     * @returns A rule condition that describes to which request the declarative
     * rule should be applied.
     */
    DeclarativeRuleConverter.getCondition = function (rule) {
        var condition = {};
        var pattern = rule.getPattern();
        if (pattern) {
            // set regexFilter
            if (rule.isRegexRule()) {
                condition.regexFilter = DeclarativeRuleConverter.prepareASCII(pattern);
            }
            else {
                // A pattern beginning with ||* is not allowed. Use * instead.
                var patternWithoutVerticals = pattern.startsWith('||*')
                    ? pattern.substring(2)
                    : pattern;
                condition.urlFilter = DeclarativeRuleConverter.prepareASCII(patternWithoutVerticals);
            }
        }
        // set domainType
        if (rule.isOptionEnabled(NetworkRuleOption.ThirdParty)) {
            condition.domainType = DomainType.ThirdParty;
        }
        else if (rule.isOptionDisabled(NetworkRuleOption.ThirdParty)) {
            condition.domainType = DomainType.FirstParty;
        }
        // set initiatorDomains
        var permittedDomains = rule.getPermittedDomains();
        if (permittedDomains && permittedDomains.length !== 0) {
            condition.initiatorDomains = this.toASCII(permittedDomains);
        }
        // set excludedInitiatorDomains
        var excludedDomains = rule.getRestrictedDomains();
        if (excludedDomains && excludedDomains.length !== 0) {
            condition.excludedInitiatorDomains = this.toASCII(excludedDomains);
        }
        var permittedToDomains = rule.getPermittedToDomains();
        if (permittedToDomains && permittedToDomains.length > 0) {
            condition.requestDomains = this.toASCII(permittedToDomains);
        }
        // Can be specified $to or $denyallow, but not together.
        var denyAllowDomains = rule.getDenyAllowDomains();
        var restrictedToDomains = rule.getRestrictedToDomains();
        if (denyAllowDomains && denyAllowDomains.length !== 0) {
            condition.excludedRequestDomains = this.toASCII(denyAllowDomains);
        }
        else if (restrictedToDomains && restrictedToDomains.length !== 0) {
            condition.excludedRequestDomains = this.toASCII(restrictedToDomains);
        }
        // set excludedResourceTypes
        var restrictedRequestTypes = rule.getRestrictedRequestTypes();
        var hasExcludedResourceTypes = restrictedRequestTypes !== 0;
        if (hasExcludedResourceTypes) {
            condition.excludedResourceTypes = this.getResourceTypes(restrictedRequestTypes);
        }
        // set resourceTypes
        var permittedRequestTypes = rule.getPermittedRequestTypes();
        if (!hasExcludedResourceTypes && permittedRequestTypes !== 0) {
            condition.resourceTypes = this.getResourceTypes(permittedRequestTypes);
        }
        var permittedMethods = rule.getPermittedMethods();
        if (permittedMethods && permittedMethods.length !== 0) {
            condition.requestMethods = this.mapHttpMethodToDeclarativeHttpMethod(permittedMethods);
        }
        var restrictedMethods = rule.getRestrictedMethods();
        if (restrictedMethods && restrictedMethods.length !== 0) {
            condition.excludedRequestMethods = this.mapHttpMethodToDeclarativeHttpMethod(restrictedMethods);
        }
        // set isUrlFilterCaseSensitive
        condition.isUrlFilterCaseSensitive = rule.isOptionEnabled(NetworkRuleOption.MatchCase);
        /**
         * Here we need to set 'main_frame' to apply to document requests
         * as well (because by default it applies to all requests except
         * document).
         * And if we specify 'main_frame', then we also need to specify all
         * other types, so that it works not only for document requests, but
         * also for all other types of requests.
         */
        var shouldMatchAllResourcesTypes = rule.isOptionEnabled(NetworkRuleOption.RemoveHeader)
            || rule.isOptionEnabled(NetworkRuleOption.RemoveParam)
            || rule.isOptionEnabled(NetworkRuleOption.Csp)
            || rule.isOptionEnabled(NetworkRuleOption.To)
            || rule.isOptionEnabled(NetworkRuleOption.Method);
        var emptyResourceTypes = !condition.resourceTypes && !condition.excludedResourceTypes;
        if (shouldMatchAllResourcesTypes && emptyResourceTypes) {
            condition.resourceTypes = [
                ResourceType.MainFrame,
                ResourceType.SubFrame,
                ResourceType.Stylesheet,
                ResourceType.Script,
                ResourceType.Image,
                ResourceType.Font,
                ResourceType.Object,
                ResourceType.XmlHttpRequest,
                ResourceType.Ping,
                ResourceType.Media,
                ResourceType.WebSocket,
                ResourceType.Other,
            ];
        }
        return condition;
    };
    /**
     * Converts the network rule into an array of declarative rules.
     *
     * Method to use only in class heirs.
     *
     * @protected
     *
     * @param rule Network rule.
     * @param id Rule identifier.
     *
     * @throws An {@link UnsupportedModifierError} if the network rule
     * contains an unsupported modifier
     * OR a {@link TooComplexRegexpError} if regexp is too complex
     * OR an {@link EmptyResourcesError} if there is empty resources in the rule
     * OR an {@link UnsupportedRegexpError} if regexp is not supported in
     * the RE2 syntax.
     * OR a {@link ResourcesPathError} when specified an empty
     * path to the web accessible resources.
     *
     * @returns A list of declarative rules.
     */
    DeclarativeRuleConverter.prototype.convertRule = function (rule, id) {
        // If the rule is not convertible - method will throw an error.
        var shouldConvert = DeclarativeRuleConverter.checkNetworkRuleConvertible(rule);
        // The rule does not require conversion.
        if (!shouldConvert) {
            return [];
        }
        var declarativeRule = {
            id: id,
            action: this.getAction(rule),
            condition: DeclarativeRuleConverter.getCondition(rule),
        };
        var priority = DeclarativeRuleConverter.getPriority(rule);
        if (priority) {
            declarativeRule.priority = priority;
        }
        var conversionErr = DeclarativeRuleConverter.checkDeclarativeRuleApplicable(rule, declarativeRule);
        if (conversionErr) {
            throw conversionErr;
        }
        return [declarativeRule];
    };
    /**
     * TODO: Move this method to separate static class, because it accumulates
     * a lot of logic tied to different types of rules and the method gets
     * really puffy.
     *
     * Checks if a network rule can be converted to a declarative format or not.
     * We skip the following modifiers:
     *
     * All specific exceptions:
     * $genericblock;
     * $jsinject;
     * $urlblock;
     * $content;
     * $extension;
     * $stealth;
     *
     * Following specific exceptions are not require conversion, but they
     * are used in the {@link MatchingResult.getCosmeticOption}:
     * $elemhide
     * $generichide;
     * $specifichide;
     *
     * Other:
     * $popup;
     * $csp;
     * $replace;
     * $cookie;
     * $redirect - if the rule is a allowlist;
     * $removeparam - if it contains a negation, or regexp,
     * or the rule is a allowlist;
     * $removeheader - if it contains a title from a prohibited list
     * (see {@link RemoveHeaderModifier.FORBIDDEN_HEADERS});
     * $jsonprune;
     * $method - if the modifier contains 'trace' method,
     * $hls.
     *
     * @param rule - Network rule.
     *
     * @throws Error with type {@link UnsupportedModifierError} if the rule is not
     * convertible.
     *
     * @returns Boolean flag - `false` if the rule does not require conversion
     * and `true` if the rule is convertible.
     */
    DeclarativeRuleConverter.checkNetworkRuleConvertible = function (rule) {
        /**
         * Checks if the $redirect values in the provided network rule
         * are supported for conversion to MV3.
         *
         * @param r Network rule.
         * @param name Modifier's name.
         *
         * @returns Error {@link UnsupportedModifierError} or null if rule is supported.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var checkRemoveParamModifierFn = function (r, name) {
            var removeParam = r.getAdvancedModifier();
            if (!removeParam.getMV3Validity()) {
                // eslint-disable-next-line max-len
                var msg = "Network rule with $removeparam modifier with negation or regexp is not supported: \"".concat(r.getText(), "\"");
                return new UnsupportedModifierError(msg, r);
            }
            return null;
        };
        /**
         * Checks if the provided rule is an allowlist rule.
         *
         * @param r Network rule.
         * @param name Modifier's name.
         *
         * @returns Error {@link UnsupportedModifierError} or null if rule is supported.
         */
        var checkAllowRulesFn = function (r, name) {
            if (r.isAllowlist()) {
                var msg = "Network allowlist rule with ".concat(name, " modifier is not supported: \"").concat(rule.getText(), "\"");
                return new UnsupportedModifierError(msg, r);
            }
            return null;
        };
        /**
         * Checks if the specified modifier is the only one the rule has.
         *
         * @param r Network rule.
         * @param name Modifier's name.
         *
         * @returns Error {@link UnsupportedModifierError} or null if rule is supported.
         */
        var checkOnlyOneModifier = function (r, name) {
            // TODO: Remove small hack with "reparsing" rule to extract only options part.
            var options = NetworkRule.parseRuleText(r.getText()).options;
            if (options === name.replace('$', '')) {
                var msg = "Network rule with only one enabled modifier ".concat(name, " is not supported: \"").concat(rule.getText(), "\"");
                return new UnsupportedModifierError(msg, r);
            }
            return null;
        };
        /**
         * Checks if the $removeparam values in the provided network rule
         * are supported for conversion to MV3.
         *
         * @param r Network rule.
         * @param name Modifier's name.
         *
         * @returns Error {@link UnsupportedModifierError} or null if rule is supported.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var checkRemoveHeaderModifierFn = function (r, name) {
            var removeHeader = r.getAdvancedModifier();
            if (!removeHeader.isValid) {
                return new UnsupportedModifierError(
                // eslint-disable-next-line max-len
                "Network rule with $removeheader modifier containing some of the unsupported headers is not supported: \"".concat(r.getText(), "\""), r);
            }
            return null;
        };
        /**
         * Checks if the $method values in the provided network rule
         * are supported for conversion to MV3.
         *
         * @param r Network rule.
         * @param name Modifier's name.
         *
         * @returns Error {@link UnsupportedModifierError} or null if rule is supported.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var checkMethodModifierFn = function (r, name) {
            var permittedMethods = r.getPermittedMethods();
            var restrictedMethods = r.getRestrictedMethods();
            if ((permittedMethods === null || permittedMethods === void 0 ? void 0 : permittedMethods.some(function (method) { return method === HTTPMethod.TRACE; }))
                || (restrictedMethods === null || restrictedMethods === void 0 ? void 0 : restrictedMethods.some(function (method) { return method === HTTPMethod.TRACE; }))) {
                return new UnsupportedModifierError("Network rule with $method modifier containing 'trace' method is not supported: \"".concat(r.getText(), "\""), r);
            }
            return null;
        };
        /**
         * Checks if rule is a "document"-allowlist and contains all these
         * `$elemhide,content,urlblock,jsinject` modifiers at the same time.
         * If it is - we allow partially convert this rule, because `$content`
         * is not supported in the MV3 at all and `$jsinject` and `$urlblock`
         * are not implemented yet, but we can support at least allowlist-rule
         * with `$elemhide` modifier (not in the DNR, but with tsurlfilter engine).
         *
         * TODO: Change the description when `$jsinject` and `$urlblock`
         * are implemented.
         *
         * @param r Network rule.
         * @param name Modifier's name.
         *
         * @returns Error {@link UnsupportedModifierError} or null if rule is supported.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var checkDocumentAllowlistFn = function (r, name) {
            if (rule.isFilteringDisabled()) {
                return null;
            }
            return new UnsupportedModifierError("Network rule with \"".concat(name, "\" modifier is not supported: \"").concat(r.getText(), "\""), r);
        };
        var unsupportedOptions = [
            /* Specific exceptions */
            { option: NetworkRuleOption.Elemhide, name: '$elemhide', skipConversion: true },
            { option: NetworkRuleOption.Generichide, name: '$generichide', skipConversion: true },
            { option: NetworkRuleOption.Specifichide, name: '$specifichide', skipConversion: true },
            { option: NetworkRuleOption.Genericblock, name: '$genericblock' },
            {
                option: NetworkRuleOption.Jsinject,
                name: '$jsinject',
                customChecks: [checkDocumentAllowlistFn],
            },
            {
                option: NetworkRuleOption.Urlblock,
                name: '$urlblock',
                customChecks: [checkDocumentAllowlistFn],
            },
            {
                option: NetworkRuleOption.Content,
                name: '$content',
                customChecks: [checkDocumentAllowlistFn],
            },
            { option: NetworkRuleOption.Extension, name: '$extension' },
            { option: NetworkRuleOption.Stealth, name: '$stealth' },
            /* Specific exceptions */
            {
                option: NetworkRuleOption.Popup,
                name: '$popup',
                customChecks: [checkOnlyOneModifier],
            },
            {
                option: NetworkRuleOption.Csp,
                name: '$csp',
                customChecks: [checkAllowRulesFn],
            },
            { option: NetworkRuleOption.Replace, name: '$replace' },
            { option: NetworkRuleOption.Cookie, name: '$cookie' },
            {
                option: NetworkRuleOption.Redirect,
                name: '$redirect',
                customChecks: [checkAllowRulesFn],
            },
            {
                option: NetworkRuleOption.RemoveParam,
                name: '$removeparam',
                customChecks: [checkAllowRulesFn, checkRemoveParamModifierFn],
            },
            {
                option: NetworkRuleOption.RemoveHeader,
                name: '$removeheader',
                customChecks: [checkAllowRulesFn, checkRemoveHeaderModifierFn],
            },
            {
                option: NetworkRuleOption.Method,
                name: '$method',
                customChecks: [checkMethodModifierFn],
            },
            { option: NetworkRuleOption.JsonPrune, name: '$jsonprune' },
            { option: NetworkRuleOption.Hls, name: '$hls' },
        ];
        for (var i = 0; i < unsupportedOptions.length; i += 1) {
            var _a = unsupportedOptions[i], option = _a.option, name_1 = _a.name, customChecks = _a.customChecks, skipConversion = _a.skipConversion;
            if (!rule.isOptionEnabled(option)) {
                continue;
            }
            if (skipConversion) {
                if (rule.isSingleOptionEnabled(option)) {
                    return false;
                }
                continue;
            }
            if (customChecks) {
                for (var j = 0; j < customChecks.length; j += 1) {
                    var err = customChecks[j](rule, name_1);
                    if (err !== null) {
                        throw err;
                    }
                }
            }
            else {
                var msg = "Unsupported option \"".concat(name_1, "\" found in the rule: \"").concat(rule.getText(), "\"");
                throw new UnsupportedModifierError(msg, rule);
            }
        }
        return true;
    };
    /**
     * Checks if the converted declarative rule passes the regexp validation
     * (too complex regexps are not allowed also back reference,
     * possessive and negative lookahead are not supported)
     * and if it contains resource types.
     *
     * @param networkRule Network rule.
     * @param declarativeRule Declarative rule.
     *
     * @returns Error {@link TooComplexRegexpError} if regexp is too complex
     * OR Error {@link EmptyResourcesError} if there is empty resources
     * in the rule
     * OR Error {@link UnsupportedRegexpError} if regexp is not supported
     * in the RE2 syntax @see https://github.com/google/re2/wiki/Syntax
     * OR null.
     */
    DeclarativeRuleConverter.checkDeclarativeRuleApplicable = function (networkRule, declarativeRule) {
        var _a = declarativeRule.condition, regexFilter = _a.regexFilter, resourceTypes = _a.resourceTypes;
        if ((resourceTypes === null || resourceTypes === void 0 ? void 0 : resourceTypes.length) === 0) {
            var ruleText = networkRule.getText();
            var msg = "Conversion resourceTypes is empty: \"".concat(ruleText, "\"");
            return new EmptyResourcesError(msg, networkRule, declarativeRule);
        }
        // More complex regex than allowed as part of the "regexFilter" key.
        if (regexFilter === null || regexFilter === void 0 ? void 0 : regexFilter.match(/\|/g)) {
            var regexArr = regexFilter.split('|');
            // TODO: Find how exactly the complexity of a rule is calculated.
            // The values maxGroups & maxGroupLength are obtained by testing.
            // TODO: Fix these values based on Chrome Errors
            var maxGroups = 15;
            var maxGroupLength_1 = 31;
            if (regexArr.length > maxGroups
                || regexArr.some(function (i) { return i.length > maxGroupLength_1; })) {
                var ruleText = networkRule.getText();
                var msg = "More complex regex than allowed: \"".concat(ruleText, "\"");
                return new TooComplexRegexpError(msg, networkRule, declarativeRule);
            }
        }
        // Back reference, possessive and negative lookahead are not supported
        // See more: https://github.com/google/re2/wiki/Syntax
        if (regexFilter === null || regexFilter === void 0 ? void 0 : regexFilter.match(/\\[1-9]|\(\?<?(!|=)|{\S+}/g)) {
            var msg = "Invalid regex in the: \"".concat(networkRule.getText(), "\"");
            return new UnsupportedRegexpError(msg, networkRule, declarativeRule);
        }
        return null;
    };
    /**
     * Checks the captured conversion error, if it is one of the expected
     * conversion errors - returns it, otherwise adds information about
     * the original rule, packages it into a new error and returns it.
     *
     * @param rule An error was caught while converting this rule.
     * @param index Index of {@link IndexedNetworkRuleWithHash}.
     * @param id Identifier of the desired declarative rule.
     * @param e Captured error.
     *
     * @returns Initial error or new packaged error.
     */
    DeclarativeRuleConverter.catchErrorDuringConversion = function (rule, index, id, e) {
        if (e instanceof EmptyResourcesError
            || e instanceof TooComplexRegexpError
            || e instanceof UnsupportedModifierError
            || e instanceof UnsupportedRegexpError) {
            return e;
        }
        var msg = "Non-categorized error during a conversion rule: ".concat(rule.getText(), " (index - ").concat(index, ", id - ").concat(id, ")");
        return e instanceof Error
            ? new Error(msg, { cause: e })
            : new Error(msg);
    };
    /**
     * Converts the provided set of indexed rules into declarative rules,
     * collecting source rule identifiers for declarative rules
     * and catching conversion errors.
     *
     * @param filterId An identifier for the filter.
     * @param rules Indexed rules.
     * @param offsetId Offset for the IDs of the converted rules.
     *
     * @returns Transformed declarative rules with their sources
     * and caught conversion errors.
     */
    DeclarativeRuleConverter.prototype.convertRules = function (filterId, rules, offsetId) {
        var _this = this;
        var res = {
            declarativeRules: [],
            errors: [],
            sourceMapValues: [],
        };
        rules.forEach(function (_a) {
            var rule = _a.rule, index = _a.index;
            var id = offsetId + index;
            var converted = [];
            try {
                converted = _this.convertRule(rule, id);
            }
            catch (e) {
                var err = DeclarativeRuleConverter.catchErrorDuringConversion(rule, index, id, e);
                res.errors.push(err);
                return;
            }
            // For each converted declarative rule save it's source.
            converted.forEach(function (dRule) {
                res.sourceMapValues.push({
                    declarativeRuleId: dRule.id,
                    sourceRuleIndex: index,
                    filterId: filterId,
                });
                res.declarativeRules.push(dRule);
            });
        });
        return res;
    };
    /**
     * This function groups similar rules among those already converted into
     * declarative rules. If a similar rule is found, it combines the two
     * declarative rules into one.
     *
     * @param converted An instance of {@link ConvertedRules} that includes
     * converted declarative rules, recorded errors, and a hash mapping
     * declarative rule IDs to corresponding source test rule IDs.
     * @param createRuleTemplate A function that stores the template of
     * a declarative rule. This template is used to compare different
     * declarative rules.
     * @param combineRulePair A function that attempts to find a similar
     * declarative rule by comparing rule templates. If a match is found,
     * it merges the two declarative rules into one and returns combined rule.
     *
     * @returns Object with grouped similar declarative rules.
     */
    // eslint-disable-next-line class-methods-use-this
    DeclarativeRuleConverter.prototype.groupConvertedRules = function (converted, createRuleTemplate, combineRulePair) {
        var rulesTemplates = new Map();
        var saveRuleTemplate = function (rule) {
            var template = createRuleTemplate(rule);
            rulesTemplates.set(template, rule);
        };
        var result = {
            declarativeRules: [],
            sourceMapValues: [],
            errors: converted.errors,
        };
        var sourceMapValues = converted.sourceMapValues, declarativeRules = converted.declarativeRules;
        declarativeRules.forEach(function (dRule) {
            // Trying to find a declarative rule for siblings.
            var template = createRuleTemplate(dRule);
            var siblingDeclarativeRule = rulesTemplates.get(template);
            // Finds the source rule identifier.
            var source = sourceMapValues.find(function (s) { return s.declarativeRuleId === dRule.id; });
            if (source === undefined) {
                result.errors.push(new Error("Cannot find source for converted rule \"".concat(dRule, "\"")));
                return;
            }
            // If a similar rule is found, the function combines the two
            // declarative rules into one and returns the resulting combined rule.
            if (siblingDeclarativeRule) {
                var combinedRule = combineRulePair(siblingDeclarativeRule, dRule);
                // Updates template.
                saveRuleTemplate(combinedRule);
                // Updates the declarative rule identified for the merged rule.
                result.sourceMapValues.push(__assign(__assign({}, source), { declarativeRuleId: combinedRule.id }));
            }
            else {
                // If not found - saves the template part of the declarative
                // rule to compare it with next values.
                saveRuleTemplate(dRule);
                // Keeps the source unchanged because the current rule
                // has not been merged.
                result.sourceMapValues.push(source);
            }
        });
        result.declarativeRules = Array.from(rulesTemplates.values());
        return result;
    };
    return DeclarativeRuleConverter;
}());

/**
 * Describes how to convert all rules that are not grouped
 * for separate conversion.
 *
 * @see {@link RulesGroup}
 */
var RegularRulesConverter = /** @class */ (function (_super) {
    __extends(RegularRulesConverter, _super);
    function RegularRulesConverter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Converts ungrouped, basic indexed rules into declarative rules.
     *
     * @param filterId Filter id.
     * @param rules List of indexed network rules with hash.
     * @param offsetId Offset for the IDs of the converted rules.
     *
     * @returns Converted rules.
     */
    RegularRulesConverter.prototype.convert = function (filterId, rules, offsetId) {
        return this.convertRules(filterId, rules, offsetId);
    };
    return RegularRulesConverter;
}(DeclarativeRuleConverter));

/**
 * Describes how to convert $removeparam rules.
 */
var RemoveParamRulesConverter = /** @class */ (function (_super) {
    __extends(RemoveParamRulesConverter, _super);
    function RemoveParamRulesConverter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Converts indexed rules grouped by $removeparam into declarative rules:
     * for each rule looks for similar rules and groups them into a new rule.
     *
     * @param filterId Filter id.
     * @param rules List of indexed network rules with hash.
     * @param offsetId Offset for the IDs of the converted rules.
     *
     * @returns Converted rules.
     */
    RemoveParamRulesConverter.prototype.convert = function (filterId, rules, offsetId) {
        var createRuleTemplate = function (rule) {
            var _a, _b, _c, _d;
            // Deep copy without relation to source rule
            // Note: Partial type is used because we need to delete some fields,
            // but we cannot mark them as optional in the parent type.
            var template = JSON.parse(JSON.stringify(rule));
            delete template.id;
            (_d = (_c = (_b = (_a = template.action) === null || _a === void 0 ? void 0 : _a.redirect) === null || _b === void 0 ? void 0 : _b.transform) === null || _c === void 0 ? void 0 : _c.queryTransform) === null || _d === void 0 ? true : delete _d.removeParams;
            return JSON.stringify(template);
        };
        var combineRulePair = function (sourceRule, ruleToMerge) {
            var _a, _b, _c, _d, _e, _f, _g;
            var resultRule = JSON.parse(JSON.stringify(sourceRule));
            var params = ((_c = (_b = (_a = ruleToMerge.action.redirect) === null || _a === void 0 ? void 0 : _a.transform) === null || _b === void 0 ? void 0 : _b.queryTransform) === null || _c === void 0 ? void 0 : _c.removeParams) || [];
            (_g = (_f = (_e = (_d = resultRule.action.redirect) === null || _d === void 0 ? void 0 : _d.transform) === null || _e === void 0 ? void 0 : _e.queryTransform) === null || _f === void 0 ? void 0 : _f.removeParams) === null || _g === void 0 ? void 0 : _g.push.apply(_g, params);
            return resultRule;
        };
        var converted = this.convertRules(filterId, rules, offsetId);
        var result = this.groupConvertedRules(converted, createRuleTemplate, combineRulePair);
        return result;
    };
    return RemoveParamRulesConverter;
}(DeclarativeRuleConverter));

/**
 * Describes how to convert $removeheader rules.
 *
 * TODO: Add checks for rules containing the $removeheader and
 * incompatible modifiers: '$domain', '$third-party', '$important', '$app',
 * '$match-case', '$script', '$stylesheet, etc.
 *
 */
var RemoveHeaderRulesConverter = /** @class */ (function (_super) {
    __extends(RemoveHeaderRulesConverter, _super);
    function RemoveHeaderRulesConverter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Converts indexed rules grouped by $removeheader into declarative rules:
     * for each rule looks for similar rules and groups them into a new rule.
     *
     * @param filterId Filter id.
     * @param rules List of indexed network rules with hash.
     * @param offsetId Offset for the IDs of the converted rules.
     *
     * @returns Converted rules.
     */
    RemoveHeaderRulesConverter.prototype.convert = function (filterId, rules, offsetId) {
        var createRuleTemplate = function (rule) {
            // Deep copy without relation to source rule
            var template = JSON.parse(JSON.stringify(rule));
            delete template.id;
            delete template.action.requestHeaders;
            delete template.action.responseHeaders;
            return JSON.stringify(template);
        };
        var combineRulePair = function (sourceRule, ruleToMerge) {
            var _a, _b;
            var resultRule = JSON.parse(JSON.stringify(sourceRule));
            var _c = ruleToMerge.action, responseHeaders = _c.responseHeaders, requestHeaders = _c.requestHeaders;
            if (responseHeaders) {
                if (resultRule.action.responseHeaders) {
                    (_a = resultRule.action.responseHeaders).push.apply(_a, responseHeaders);
                }
                else {
                    resultRule.action.responseHeaders = responseHeaders;
                }
            }
            if (requestHeaders) {
                if (resultRule.action.requestHeaders) {
                    (_b = resultRule.action.requestHeaders).push.apply(_b, requestHeaders);
                }
                else {
                    resultRule.action.requestHeaders = requestHeaders;
                }
            }
            return resultRule;
        };
        var converted = this.convertRules(filterId, rules, offsetId);
        var result = this.groupConvertedRules(converted, createRuleTemplate, combineRulePair);
        return result;
    };
    return RemoveHeaderRulesConverter;
}(DeclarativeRuleConverter));

/**
 * Describes how to convert $csp rules.
 */
var CspRulesConverter = /** @class */ (function (_super) {
    __extends(CspRulesConverter, _super);
    function CspRulesConverter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Converts indexed rules grouped by $csp into declarative rules:
     * for each rule looks for similar rules and groups them into a new rule.
     *
     * @param filterId Filter id.
     * @param rules List of indexed rules.
     * @param offsetId Offset for the IDs of the converted rules.
     *
     * @returns Converted rules.
     */
    CspRulesConverter.prototype.convert = function (filterId, rules, offsetId) {
        var createRuleTemplate = function (rule) {
            // Deep copy without relation to source rule
            var template = JSON.parse(JSON.stringify(rule));
            delete template.id;
            // Converted $csp rules contain only one response headers action.
            delete template.action.responseHeaders[0].value;
            return JSON.stringify(template);
        };
        var combineRulePair = function (sourceRule, ruleToMerge) {
            var resultRule = JSON.parse(JSON.stringify(sourceRule));
            // If the headers are empty in the rule to merge, do not take any action.
            if (!ruleToMerge.action.responseHeaders || ruleToMerge.action.responseHeaders.length === 0) {
                return resultRule;
            }
            // Try to find CSP header in the rule to merge - if not found, do not take any action.
            var cspHeaderToMerge = ruleToMerge.action.responseHeaders
                .find(function (h) { return h.header === CSP_HEADER_NAME; });
            if (!cspHeaderToMerge) {
                return resultRule;
            }
            // Combine the CSP header from the rule to merge with a copy of the source rule.
            if (resultRule.action.responseHeaders && resultRule.action.responseHeaders.length > 0) {
                var idx = resultRule.action.responseHeaders
                    .findIndex(function (h) { return h.header === CSP_HEADER_NAME; });
                if (idx === -1) {
                    return resultRule;
                }
                var cspHeaderValue = resultRule.action.responseHeaders[idx].value;
                if (cspHeaderValue) {
                    resultRule.action.responseHeaders[idx].value = "".concat(cspHeaderValue, "; ").concat(cspHeaderToMerge.value);
                }
                else {
                    resultRule.action.responseHeaders[idx].value = cspHeaderToMerge.value;
                }
            }
            else {
                resultRule.action.responseHeaders = [cspHeaderToMerge];
            }
            return resultRule;
        };
        var converted = this.convertRules(filterId, rules, offsetId);
        var result = this.groupConvertedRules(converted, createRuleTemplate, combineRulePair);
        return result;
    };
    return CspRulesConverter;
}(DeclarativeRuleConverter));

/**
 * Describes an error when the maximum number of regexp rules is reached.
 */
var TooManyRegexpRulesError = /** @class */ (function (_super) {
    __extends(TooManyRegexpRulesError, _super);
    /**
     * Describes an error when the maximum number of regexp rules is reached.
     *
     * @param message Message of error.
     * @param excludedRulesIds List of excluded source (important!)
     * {@link Source} rules ids.
     * @param numberOfMaximumRules Number of maximum rules.
     * @param numberOfExcludedDeclarativeRules Number of excluded declarative
     * rules.
     */
    function TooManyRegexpRulesError(message, excludedRulesIds, numberOfMaximumRules, numberOfExcludedDeclarativeRules) {
        var _this = _super.call(this, message) || this;
        _this.name = 'TooManyRegexpRulesError';
        _this.excludedRulesIds = excludedRulesIds;
        _this.numberOfMaximumRules = numberOfMaximumRules;
        _this.numberOfExcludedDeclarativeRules = numberOfExcludedDeclarativeRules;
        // For proper work of the "instanceof" operator
        Object.setPrototypeOf(_this, TooManyRegexpRulesError.prototype);
        return _this;
    }
    return TooManyRegexpRulesError;
}(Error));

/**
 * Describes an error when the maximum number of rules is reached.
 */
var TooManyRulesError = /** @class */ (function (_super) {
    __extends(TooManyRulesError, _super);
    /**
     * Describes an error when the maximum number of rules is reached.
     *
     * @param message Message of error.
     * @param excludedRulesIds List of excluded source (important!)
     * {@link Source} rules ids.
     * @param numberOfMaximumRules Number of maximum rules.
     * @param numberOfExcludedDeclarativeRules Number of excluded declarative
     * rules.
     */
    function TooManyRulesError(message, excludedRulesIds, numberOfMaximumRules, numberOfExcludedDeclarativeRules) {
        var _this = _super.call(this, message) || this;
        _this.name = 'TooManyRulesError';
        _this.excludedRulesIds = excludedRulesIds;
        _this.numberOfMaximumRules = numberOfMaximumRules;
        _this.numberOfExcludedDeclarativeRules = numberOfExcludedDeclarativeRules;
        // For proper work of the "instanceof" operator
        Object.setPrototypeOf(_this, TooManyRulesError.prototype);
        return _this;
    }
    return TooManyRulesError;
}(Error));

/**
 * Just a dummy for $badfilter-rules, because they don't need to be converted.
 */
var BadFilterRulesConverter = /** @class */ (function (_super) {
    __extends(BadFilterRulesConverter, _super);
    function BadFilterRulesConverter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Skips converting bad rules.
     *
     * @param filterId Filter id.
     * @param rules List of indexed rules.
     * @param offsetId Offset for the IDs of the converted rules.
     *
     * @returns Empty converted rules.
     */
    // eslint-disable-next-line class-methods-use-this
    BadFilterRulesConverter.prototype.convert = function (
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    filterId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    rules, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    offsetId) {
        return {
            sourceMapValues: [],
            declarativeRules: [],
            errors: [],
        };
    };
    return BadFilterRulesConverter;
}(DeclarativeRuleConverter));

var RulesGroup;
(function (RulesGroup) {
    RulesGroup[RulesGroup["Regular"] = 0] = "Regular";
    RulesGroup[RulesGroup["RemoveParam"] = 1] = "RemoveParam";
    RulesGroup[RulesGroup["RemoveHeader"] = 2] = "RemoveHeader";
    RulesGroup[RulesGroup["Csp"] = 3] = "Csp";
    RulesGroup[RulesGroup["BadFilter"] = 4] = "BadFilter";
})(RulesGroup || (RulesGroup = {}));
/**
 * Contains logic on how to divide the rules into certain groups.
 *
 * @see {@link RulesGroup}
 */
var DeclarativeRulesGrouper = /** @class */ (function () {
    function DeclarativeRulesGrouper() {
    }
    /**
     * Returns group of the indexed rule.
     *
     * @param indexedNetworkRuleWithHash Indexed network rule with hash.
     *
     * @returns Group of the indexed rule.
     */
    DeclarativeRulesGrouper.getRuleGroup = function (indexedNetworkRuleWithHash) {
        var rule = indexedNetworkRuleWithHash.rule;
        if (rule.isOptionEnabled(NetworkRuleOption.RemoveParam)) {
            return RulesGroup.RemoveParam;
        }
        if (rule.isOptionEnabled(NetworkRuleOption.RemoveHeader)) {
            return RulesGroup.RemoveHeader;
        }
        if (rule.isOptionEnabled(NetworkRuleOption.Csp)) {
            return RulesGroup.Csp;
        }
        if (rule.isOptionEnabled(NetworkRuleOption.Badfilter)) {
            return RulesGroup.BadFilter;
        }
        return RulesGroup.Regular;
    };
    /**
     * Splits the list of indexed rules into an index with groups.
     *
     * @param rules List of indexed rules.
     *
     * @returns Index with grouped, indexed rules.
     */
    DeclarativeRulesGrouper.splitRulesByGroups = function (rules) {
        var _a;
        var rulesToProcess = (_a = {},
            _a[RulesGroup.RemoveParam] = [],
            _a[RulesGroup.RemoveHeader] = [],
            _a[RulesGroup.BadFilter] = [],
            _a[RulesGroup.Regular] = [],
            _a[RulesGroup.Csp] = [],
            _a);
        // Categorizing rule groups
        rules.forEach(function (indexedNetworkRuleWithHash) {
            var group = DeclarativeRulesGrouper.getRuleGroup(indexedNetworkRuleWithHash);
            rulesToProcess[group].push(indexedNetworkRuleWithHash);
        });
        return rulesToProcess;
    };
    return DeclarativeRulesGrouper;
}());

/* eslint-disable jsdoc/require-description-complete-sentence  */
/**
 * @file Describes the conversion process from {@link IndexedNetworkRuleWithHash}
 * to declarative rules {@link DeclarativeRule} via applying $badfilter-rules
 * {@link DeclarativeRulesConverter#applyBadFilter} and checks for specified
 * limitations {@link DeclarativeRulesConverter#checkLimitations}.
 *
 *                                                                           Conversion
 *
 *
 *
 *
 *       Two entry points        │                FilterConverter             │             RulesConverter
 *                               │                                            │
 *                               │       Perform the conversion at the        │      Perform the conversion at the
 *                               │       filter level.                        │      rules level.
 *                               │                                            │
 *  Converting static rules      │       Validate passed number of rules      │
 *  during extension assembly.   │       and path to web accessible resources.│
 * ┌─────────────────────────┐   │      ┌────────────────────────────────┐    │
 * │                         ├─┬─┼─────►│                                │    │
 * │  convertStaticRuleSet() │ │ │      │      checkConverterOptions()   │    │
 * │                         │ │ │  ┌───┤                                │    │
 * └─────────────────────────┘ │ │  │   └────────────────────────────────┘    │
 *                             │ │  │                                         │
 *  On-the-fly conversion      │ │  │    Filter only network rules and create │
 *  for dynamic rules.         │ │  │    indexed rule with hash.              │
 * ┌─────────────────────────┐ │ │  │    In this method, when converting      │
 * │                         │ │ │  │    dynamic rules, the rules canceled by │
 * │ convertDynamicRuleSets()├─┘ │  │    $badfilter rules from static filters │
 * │                         │   │  │    are filtered out - such rules are    │
 * └─────────────────────────┘   │  │    discarded during filter scanning.    │
 *                               │  │   ┌────────────────────────────────┐    │
 *                               │  └──►│                                │    │
 *                               │      │ NetworkRulesScanner.scanRules()│    │
 *                               │  ┌───┤                                │    │
 *                               │  │   └────────────────────────────────┘    │  Filter rules affected by $badfilter
 *                               │  │                                         │  within one filter, then group the rules
 *                               │  │                                         │  based on modifiers, requiring specific
 *                               │  │    Convert our network rule to DNR.     │  conversion processes such as
 *                               │  │   ┌────────────────────────────────┐    │  post-processing for similar rules.
 *                               │  └──►│                                │    │   ┌────────────────────────────────┐
 *                               │      │           convert()            ├────┼───┤                                │
 *                               │      │                                │    │   │        applyBadFilter()        │
 *                               │      └────────────────────────────────┘    │ ┌─┤                                │
 *                               │                                            │ │ └────────────────────────────────┘
 *                               │                                            │ │
 *                               │                                            │ │ Each group of rules within a single
 *                               │                                            │ │ filter has its converter that performs
 *                               │                                            │ │ the conversion, then combines the
 *                               │                                            │ │ results and returns them.
 *                               │                                            │ │
 *                               │                                            │ │ For details, please go to the
 *                               │                                            │ │ abstract-rule-converter.ts schema.
 *                               │                                            │ │ ┌────────────────────────────────┐
 *                               │                                            │ └►│                                │
 *                               │                                            │   │          convertRules()        │
 *                               │                                            │ ┌─┤                                │
 *                               │                                            │ │ └────────────────────────────────┘
 *                               │                                            │ │
 *                               │                                            │ │ The declarative rules are checked to
 *                               │                                            │ │ ensure they meet the specified
 *                               │                                            │ │ constraints, and if necessary,
 *                               │                                            │ │ some rules are removed.
 *                               │                                            │ │ ┌────────────────────────────────┐
 *                               │                                            │ └►│                                │
 *                               │                                            │   │         checkLimitations()     │
 *                               │   ┌────────────────────────────────────────┼───┤                                │
 *                               │   │                                        │   └────────────────────────────────┘
 *                               │   │   Wrap conversion result into RuleSet. │
 *                               │   │  ┌────────────────────────────────┐    │
 *                               │   └─►│                                │    │
 *                               │      │    collectConvertedResult()    │    │
 *                               │  ┌───┤                                │    │
 *                               │  │   └────────────────────────────────┘    │
 *                               │  │                                         │
 *                               │  │    This method is only called during the│
 *                               │  │    conversion of dynamic rules.         │
 *                               │  │    Applies rules with $badfilter        │
 *                               │  │    modifier from dynamic rulesets to    │
 *                               │  │    all rules from static rulesets and   │
 *                               │  │    returns list of ids of declarative   │
 *                               │  │    rules to disable them.               │
 *                               │  │   ┌──────────────────────────────────┐  │
 *                               │  └──►│                                  │  │
 *                               │      │ collectDeclarativeRulesToCancel()│  │
 *                               │      │                                  │  │
 *                               │      └──────────────────────────────────┘  │
 *                               │                                            │
 */
/* eslint-enable jsdoc/require-description-complete-sentence */
var _a;
/**
 * Describes how to convert {@link IndexedNetworkRuleWithHash|indexed network rules}
 * into list of {@link DeclarativeRule|declarative rules}.
 */
var DeclarativeRulesConverter = /** @class */ (function () {
    function DeclarativeRulesConverter() {
    }
    /**
     * Converts list of filters ids with indexed rules to declarative rules:
     * applies $badfilter rules, then for each group of rules (inside one
     * filter) runs specified converter.
     *
     * TODO: The $removeparam, $removeheader, $csp converters can also combine
     * rules across multiple filters.
     *
     * @see {@link DeclarativeRulesConverter.converters}.
     *
     * @param filtersWithRules List of filters ids with indexed rules.
     * @param options Options for conversion.
     *
     * @returns A list of declarative rules, a regexp rule counter,
     * and a list of sourcemap values that contain the relationship between the
     * transformed declarative rule and the source rule.
     */
    DeclarativeRulesConverter.convert = function (filtersWithRules, options) {
        var _this = this;
        var filters = this.applyBadFilter(filtersWithRules);
        var converted = {
            sourceMapValues: [],
            declarativeRules: [],
            errors: [],
        };
        filters.forEach(function (_a) {
            var filterId = _a[0], groupedRules = _a[1];
            var lastUsedId = converted.declarativeRules.length > 0
                ? converted.declarativeRules[converted.declarativeRules.length - 1].id + 1
                : DeclarativeRulesConverter.START_DECLARATIVE_RULE_ID;
            var _b = _this.convertRules(filterId, groupedRules, lastUsedId, options), sourceMapValues = _b.sourceMapValues, declarativeRules = _b.declarativeRules, errors = _b.errors;
            converted.sourceMapValues = converted.sourceMapValues.concat(sourceMapValues);
            converted.declarativeRules = converted.declarativeRules.concat(declarativeRules);
            converted.errors = converted.errors.concat(errors);
        });
        converted = this.checkLimitations(converted, options === null || options === void 0 ? void 0 : options.maxNumberOfRules, options === null || options === void 0 ? void 0 : options.maxNumberOfRegexpRules);
        return converted;
    };
    /**
     * Converts filter's indexed rules into declarative rules.
     *
     * @param filterId Filed id.
     * @param groupsRules Grouped rules.
     * @param lastUsedId To avoid intersections between the identifiers of
     * the converted rules, we start converting new group rules with an offset.
     * @param options Options for conversion.
     *
     * @returns A list of declarative rules, a regexp rule counter,
     * and a list of sourcemap values that contain the relationship between the
     * transformed declarative rule and the source rule.
     */
    DeclarativeRulesConverter.convertRules = function (filterId, groupsRules, lastUsedId, options) {
        var converted = {
            sourceMapValues: [],
            declarativeRules: [],
            errors: [],
        };
        // Map because RulesGroup values are numbers
        var groups = Object.keys(groupsRules).map(Number);
        groups.forEach(function (key) {
            var converter = new DeclarativeRulesConverter.converters[key](options === null || options === void 0 ? void 0 : options.resourcesPath);
            var _a = converter.convert(filterId, groupsRules[key], lastUsedId), sourceMapValues = _a.sourceMapValues, declarativeRules = _a.declarativeRules, errors = _a.errors;
            converted.sourceMapValues = converted.sourceMapValues.concat(sourceMapValues);
            converted.declarativeRules = converted.declarativeRules.concat(declarativeRules);
            converted.errors = converted.errors.concat(errors);
        });
        return converted;
    };
    /**
     * Check that declarative rules matches the specified constraints and
     * cuts rules if needed as from list also from source map.
     *
     * @param converted Converted rules, errors, sourcemap and counters.
     * @param maxNumberOfRules Maximum number of converted rules.
     * @param maxNumberOfRegexpRules Maximum number of converted regexp rules.
     *
     * @returns Transformed converted rules with modified (if abbreviated)
     * counters, declarative rules list, source map and errors.
     */
    DeclarativeRulesConverter.checkLimitations = function (converted, maxNumberOfRules, maxNumberOfRegexpRules) {
        var limitations = [];
        // We apply restrictions only to transformed rules, so we need to filter
        // rule conversion errors if we remove the transformed rule associated
        // with those errors
        var declarativeRules = converted.declarativeRules, sourceMapValues = converted.sourceMapValues, errors = converted.errors;
        var convertedRulesErrors = [];
        var otherErrors = [];
        for (var i = 0; i < errors.length; i += 1) {
            var e = errors[i];
            // Checks only errors of converted declarative rules
            if (e instanceof InvalidDeclarativeRuleError) {
                convertedRulesErrors.push(e);
            }
            else {
                otherErrors.push(e);
            }
        }
        // TODO: Lazy creation of index
        // Create index of errors for fast search and filtering
        var convertedRulesErrorsIndex = new Map();
        convertedRulesErrors.forEach(function (e) {
            // Checks only errors of converted declarative rules
            var errorsList = convertedRulesErrorsIndex.get(e.declarativeRule.id);
            var newValue = errorsList
                ? errorsList.concat(e)
                : [e];
            convertedRulesErrorsIndex.set(e.declarativeRule.id, newValue);
        });
        // TODO: Lazy creation of index
        // Create index of sources for fast search and filtering
        var sourcesIndex = new Map();
        sourceMapValues.forEach(function (source) {
            var sources = sourcesIndex.get(source.declarativeRuleId);
            var newValue = sources
                ? sources.concat(source)
                : [source];
            sourcesIndex.set(source.declarativeRuleId, newValue);
        });
        // Checks and, if necessary, trims the maximum number of rules
        if (maxNumberOfRules && declarativeRules.length > maxNumberOfRules) {
            var filteredRules = [];
            var excludedRulesIds = [];
            for (var i = 0; i < declarativeRules.length; i += 1) {
                var rule = declarativeRules[i];
                if (i < maxNumberOfRules) {
                    filteredRules.push(rule);
                    continue;
                }
                // Removing an source for a truncated rule
                var sources = sourcesIndex.get(rule.id) || [];
                var sourcesRulesIds = sources.map(function (_a) {
                    var sourceRuleIndex = _a.sourceRuleIndex;
                    return sourceRuleIndex;
                });
                sourcesIndex.set(rule.id, []);
                // Removing an error for a truncated rule
                convertedRulesErrorsIndex.set(rule.id, []);
                excludedRulesIds = excludedRulesIds.concat(sourcesRulesIds);
            }
            var msg = 'After conversion, too many declarative rules remain: '
                + "".concat(declarativeRules.length, " exceeds ")
                + "the limit provided - ".concat(maxNumberOfRules);
            var err = new TooManyRulesError(msg, excludedRulesIds, maxNumberOfRules, declarativeRules.length - maxNumberOfRules);
            limitations.push(err);
            declarativeRules = filteredRules;
        }
        // Checks and, if necessary, trims the maximum number of regexp rules
        if (maxNumberOfRegexpRules) {
            var filteredRules = [];
            var excludedRulesIds = [];
            var regexpRulesCounter = 0;
            for (var i = 0; i < declarativeRules.length; i += 1) {
                var rule = declarativeRules[i];
                var isRegexp = rule.condition.regexFilter !== undefined;
                if (isRegexp) {
                    regexpRulesCounter += 1;
                    if (regexpRulesCounter > maxNumberOfRegexpRules) {
                        // Removing an source for a truncated rule
                        var sources = sourcesIndex.get(rule.id) || [];
                        var sourcesRulesIds = sources.map(function (_a) {
                            var sourceRuleIndex = _a.sourceRuleIndex;
                            return sourceRuleIndex;
                        });
                        sourcesIndex.set(rule.id, []);
                        // Removing an error for a truncated rule
                        convertedRulesErrorsIndex.set(rule.id, []);
                        excludedRulesIds = excludedRulesIds.concat(sourcesRulesIds);
                        continue;
                    }
                }
                filteredRules.push(rule);
            }
            if (regexpRulesCounter > maxNumberOfRegexpRules) {
                var msg = 'After conversion, too many regexp rules remain: '
                    + "".concat(regexpRulesCounter, " exceeds ")
                    + "the limit provided - ".concat(maxNumberOfRegexpRules);
                var err = new TooManyRegexpRulesError(msg, excludedRulesIds, maxNumberOfRegexpRules, regexpRulesCounter - maxNumberOfRegexpRules);
                limitations.push(err);
            }
            declarativeRules = filteredRules;
        }
        // Make array from index
        sourceMapValues = Array.from(sourcesIndex.values())
            .filter(function (arr) { return arr.length > 0; })
            .flat();
        // Make array from index
        errors = Array.from(convertedRulesErrorsIndex.values())
            .filter(function (arr) { return arr.length > 0; })
            .flat();
        return {
            sourceMapValues: sourceMapValues,
            declarativeRules: declarativeRules,
            errors: errors.concat(otherErrors),
            limitations: limitations,
        };
    };
    /**
     * Filters rules that have been affected by $badfilter rules and
     * groups them by modifiers.
     *
     * @param filtersWithRules List with filters ids and indexed rules.
     *
     * @returns List with filters ids and grouped indexed rules.
     */
    DeclarativeRulesConverter.applyBadFilter = function (filtersWithRules) {
        var allBadFilterRules = [];
        // Group rules
        var filterIdsWithGroupedRules = filtersWithRules
            .map(function (_a) {
            var id = _a.id, rules = _a.rules;
            var rulesToProcess = DeclarativeRulesGrouper.splitRulesByGroups(rules);
            allBadFilterRules = allBadFilterRules.concat(rulesToProcess[RulesGroup.BadFilter]);
            var tuple = [id, rulesToProcess];
            return tuple;
        });
        // Define filter function
        var filterByBadFilterFn = function (ruleToTest) {
            var networkRuleToTest = ruleToTest.rule;
            for (var _i = 0, allBadFilterRules_1 = allBadFilterRules; _i < allBadFilterRules_1.length; _i++) {
                var rule = allBadFilterRules_1[_i].rule;
                if (rule.negatesBadfilter(networkRuleToTest)) {
                    return false;
                }
            }
            return true;
        };
        // For each group of filters' rules apply filter function
        return filterIdsWithGroupedRules.map(function (_a) {
            var filterId = _a[0], groupedRules = _a[1];
            var filtered = groupedRules;
            // Map because RulesGroup values are numbers
            var groups = Object.keys(filtered).map(Number);
            groups.forEach(function (key) {
                filtered[key] = filtered[key].filter(filterByBadFilterFn);
            });
            // Clean up bad filters rules
            filtered[RulesGroup.BadFilter] = [];
            return [filterId, filtered];
        });
    };
    /**
     * The declarative identifier of a rule must be a natural number.
     */
    DeclarativeRulesConverter.START_DECLARATIVE_RULE_ID = 1;
    /**
     * Describes for which group of rules which converter should be used.
     */
    DeclarativeRulesConverter.converters = (_a = {},
        _a[RulesGroup.Regular] = RegularRulesConverter,
        _a[RulesGroup.Csp] = CspRulesConverter,
        _a[RulesGroup.RemoveParam] = RemoveParamRulesConverter,
        _a[RulesGroup.RemoveHeader] = RemoveHeaderRulesConverter,
        _a[RulesGroup.BadFilter] = BadFilterRulesConverter,
        _a);
    return DeclarativeRulesConverter;
}());

/**
 * Contains a dictionary where the key is the hash of the rule and the value is
 * a list of sources for the rule. Storing this dictionary is necessary for fast
 * rule matching, which can be negated by $badfilter.
 */
var RulesHashMap = /** @class */ (function () {
    /**
     * Creates new {@link RulesHashMap}.
     *
     * @param listOfRulesWithHash List of rules hashes and rules sources:
     * filter id with rule index.
     */
    function RulesHashMap(listOfRulesWithHash) {
        var _this = this;
        this.map = new Map();
        listOfRulesWithHash.forEach(function (_a) {
            var hash = _a.hash, source = _a.source;
            var existingValue = _this.map.get(hash);
            if (existingValue) {
                existingValue.push(source);
            }
            else {
                _this.map.set(hash, [source]);
            }
        });
    }
    /** @inheritdoc */
    RulesHashMap.prototype.findRules = function (hash) {
        return this.map.get(hash) || [];
    };
    /**
     * Deserializes dictionary from raw string.
     *
     * @param rawString The original dictionary that was serialized into a string.
     *
     * @returns Deserialized dictionary.
     */
    RulesHashMap.deserializeSources = function (rawString) {
        var plainArray = JSON.parse(rawString);
        var allPairs = plainArray
            .map(function (_a) {
            var hash = _a[0], sources = _a[1];
            return sources.map(function (_a) {
                var filterId = _a[0], sourceRuleIndex = _a[1];
                return {
                    hash: hash,
                    source: {
                        filterId: filterId,
                        sourceRuleIndex: sourceRuleIndex,
                    },
                };
            });
        })
            .flat();
        return allPairs;
    };
    /** @inheritdoc */
    RulesHashMap.prototype.serialize = function () {
        var arr = Array.from(this.map);
        var serializedValues = arr
            .map(function (_a) {
            var hash = _a[0], source = _a[1];
            var sources = source.map(function (s) {
                return [s.filterId, s.sourceRuleIndex];
            });
            return [hash, sources];
        });
        return JSON.stringify(serializedValues);
    };
    return RulesHashMap;
}());

/**
 * FilterScanner returns indexed, only network rules from IFilter's content.
 */
var FilterScanner = /** @class */ (function () {
    /**
     * Constructor of FilterScanner.
     *
     * @param filterContent Filter rules.
     * @param filterId Filter id.
     */
    function FilterScanner(filterContent, filterId) {
        this.filterContent = filterContent;
        this.filterId = filterId;
    }
    /**
     * Creates new filter scanner.
     *
     * @param filter From which filter the rules should be scanned.
     *
     * @returns New FilterScanner.
     */
    FilterScanner.createNew = function (filter) {
        return __awaiter(this, void 0, void 0, function () {
            var content;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, filter.getContent()];
                    case 1:
                        content = _a.sent();
                        return [2 /*return*/, new FilterScanner(content, filter.getId())];
                }
            });
        });
    };
    /**
     * Gets the entire contents of the filter, extracts only the network rules
     * (ignore cosmetic and host rules) and tries to convert each line into an
     * indexed rule with hash.
     *
     * @param filterFn If this function is specified, it will be applied to each
     * rule after it has been parsed and transformed. This function is needed
     * for example to apply $badfilter: to exclude negated rules from the array
     * of rules that will be returned.
     *
     * @returns List of indexed rules with hash. If filterFn was specified then
     * out values will be filtered with this function.
     */
    FilterScanner.prototype.getIndexedRules = function (filterFn) {
        var _a;
        var _b = this, filterContent = _b.filterContent, filterId = _b.filterId;
        var result = {
            errors: [],
            rules: [],
        };
        for (var lineIndex = 0; lineIndex < filterContent.length; lineIndex += 1) {
            var line = filterContent[lineIndex];
            if (!line) {
                continue;
            }
            var indexedNetworkRulesWithHash = [];
            try {
                indexedNetworkRulesWithHash = IndexedNetworkRuleWithHash.createFromRawString(filterId, lineIndex, line);
            }
            catch (e) {
                if (e instanceof Error) {
                    result.errors.push(e);
                }
                else {
                    // eslint-disable-next-line max-len
                    var err = new Error("Unknown error during creating indexed rule with hash from raw string: filter id - ".concat(filterId, ", line index - ").concat(lineIndex, ", line - ").concat(line));
                    result.errors.push(err);
                }
                continue;
            }
            var filteredRules = filterFn
                ? indexedNetworkRulesWithHash.filter(filterFn)
                : indexedNetworkRulesWithHash;
            (_a = result.rules).push.apply(_a, filteredRules);
        }
        return result;
    };
    return FilterScanner;
}());

/**
 * Scanner for network rules from list of filters.
 */
var NetworkRulesScanner = /** @class */ (function () {
    function NetworkRulesScanner() {
    }
    /**
     * Asynchronous scans the list of filters for network rules.
     *
     * @param filterList List of {@link IFilter}.
     * @param filterFn If this function is specified, it will be applied to each
     * rule after it has been parsed and transformed. This function is needed
     * for example to apply $badfilter: to exclude negated rules from the array
     * of rules that will be returned.
     *
     * @returns List of filters includes the scanned filters and any errors that
     * may occur during the scan.
     */
    NetworkRulesScanner.scanRules = function (filterList, filterFn) {
        return __awaiter(this, void 0, void 0, function () {
            var res, promises, tasks;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        res = {
                            errors: [],
                            filters: [],
                        };
                        promises = filterList.map(function (filter) { return __awaiter(_this, void 0, void 0, function () {
                            var scanner, _a, errors, rules, badFilterRules;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0: return [4 /*yield*/, FilterScanner.createNew(filter)];
                                    case 1:
                                        scanner = _b.sent();
                                        _a = scanner.getIndexedRules(filterFn), errors = _a.errors, rules = _a.rules;
                                        res.errors = res.errors.concat(errors);
                                        badFilterRules = rules.filter(function (_a) {
                                            var rule = _a.rule;
                                            return rule.isOptionEnabled(NetworkRuleOption.Badfilter);
                                        });
                                        return [2 /*return*/, {
                                                id: filter.getId(),
                                                rules: rules,
                                                badFilterRules: badFilterRules,
                                            }];
                                }
                            });
                        }); });
                        return [4 /*yield*/, Promise.allSettled(promises)];
                    case 1:
                        tasks = _a.sent();
                        tasks.forEach(function (task, index) {
                            if (task.status === 'rejected') {
                                var filterId = filterList[index].getId();
                                res.errors.push(new Error("Cannot scan rules from filter ".concat(filterId, ": ").concat(task.reason)));
                                return;
                            }
                            res.filters.push(task.value);
                        });
                        return [2 /*return*/, res];
                }
            });
        });
    };
    return NetworkRulesScanner;
}());

/* eslint-disable jsdoc/require-description-complete-sentence  */
/**
 * Converts a list of IFilters to a single rule set or to a list of rule sets.
 */
var DeclarativeFilterConverter = /** @class */ (function () {
    function DeclarativeFilterConverter() {
    }
    /**
     * Checks that provided converter options are correct.
     *
     * @param options Contains path to web accessible resources,
     * maximum number of converter rules and regexp rules. @see
     * {@link DeclarativeConverterOptions} for details.
     *
     * @throws An {@link ResourcesPathError} if the resources path does not
     * start with a slash or it ends with a slash
     * OR an {@link EmptyOrNegativeNumberOfRulesError} if maximum number of
     * rules is equal or less than 0.
     * OR an {@link NegativeNumberOfRegexpRulesError} if maximum number of
     * regexp rules is less than 0.
     */
    DeclarativeFilterConverter.checkConverterOptions = function (options) {
        var resourcesPath = options.resourcesPath, maxNumberOfRules = options.maxNumberOfRules, maxNumberOfRegexpRules = options.maxNumberOfRegexpRules;
        if (resourcesPath !== undefined) {
            var firstChar = 0;
            var lastChar = resourcesPath.length > 0
                ? resourcesPath.length - 1
                : 0;
            if (resourcesPath[firstChar] !== '/') {
                var msg = 'Path to web accessible resources should '
                    + "be started with leading slash: ".concat(resourcesPath);
                throw new ResourcesPathError(msg);
            }
            if (resourcesPath[lastChar] === '/') {
                var msg = 'Path to web accessible resources should '
                    + "not be ended with slash: ".concat(resourcesPath);
                throw new ResourcesPathError(msg);
            }
        }
        if (maxNumberOfRules !== undefined && maxNumberOfRules <= 0) {
            var msg = 'Maximum number of rules cannot be equal or less than 0';
            throw new EmptyOrNegativeNumberOfRulesError(msg);
        }
        if (maxNumberOfRegexpRules && maxNumberOfRegexpRules < 0) {
            var msg = 'Maximum number of regexp rules cannot be less than 0';
            throw new NegativeNumberOfRegexpRulesError(msg);
        }
    };
    /** @inheritdoc */
    // eslint-disable-next-line class-methods-use-this
    DeclarativeFilterConverter.prototype.convertStaticRuleSet = function (filter, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, errors, filters, scannedStaticFilter, id, badFilterRules, convertedRules, conversionResult;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (options) {
                            DeclarativeFilterConverter.checkConverterOptions(options);
                        }
                        return [4 /*yield*/, NetworkRulesScanner.scanRules([filter])];
                    case 1:
                        _a = _b.sent(), errors = _a.errors, filters = _a.filters;
                        scannedStaticFilter = filters[0];
                        id = scannedStaticFilter.id, badFilterRules = scannedStaticFilter.badFilterRules;
                        convertedRules = DeclarativeRulesConverter.convert(filters, options);
                        conversionResult = DeclarativeFilterConverter.collectConvertedResult("ruleset_".concat(id), [filter], filters, convertedRules, badFilterRules);
                        return [2 /*return*/, {
                                ruleSet: conversionResult.ruleSet,
                                errors: errors.concat(conversionResult.errors),
                                limitations: conversionResult.limitations,
                            }];
                }
            });
        });
    };
    /** @inheritdoc */
    // eslint-disable-next-line class-methods-use-this
    DeclarativeFilterConverter.prototype.convertDynamicRuleSets = function (filterList, staticRuleSets, options) {
        return __awaiter(this, void 0, void 0, function () {
            var allStaticBadFilterRules, skipNegatedRulesFn, scanned, convertedRules, dynamicBadFilterRules, conversionResult, _a, declarativeRulesToCancel, errors;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (options) {
                            DeclarativeFilterConverter.checkConverterOptions(options);
                        }
                        allStaticBadFilterRules = DeclarativeFilterConverter.createBadFilterRulesHashMap(staticRuleSets);
                        skipNegatedRulesFn = function (r) {
                            var fastMatchedBadFilterRules = allStaticBadFilterRules.get(r.hash);
                            if (!fastMatchedBadFilterRules) {
                                return true;
                            }
                            for (var i = 0; i < fastMatchedBadFilterRules.length; i += 1) {
                                var rule = fastMatchedBadFilterRules[i];
                                var badFilterRule = rule.rule;
                                var ruleToCheck = r.rule;
                                if (badFilterRule.negatesBadfilter(ruleToCheck)) {
                                    return false;
                                }
                            }
                            return true;
                        };
                        return [4 /*yield*/, NetworkRulesScanner.scanRules(filterList, skipNegatedRulesFn)];
                    case 1:
                        scanned = _b.sent();
                        convertedRules = DeclarativeRulesConverter.convert(scanned.filters, options);
                        dynamicBadFilterRules = scanned.filters
                            .map(function (_a) {
                            var badFilterRules = _a.badFilterRules;
                            return badFilterRules;
                        })
                            .flat();
                        conversionResult = DeclarativeFilterConverter.collectConvertedResult(DeclarativeFilterConverter.COMBINED_RULESET_ID, filterList, scanned.filters, convertedRules, dynamicBadFilterRules);
                        return [4 /*yield*/, DeclarativeFilterConverter.collectDeclarativeRulesToCancel(staticRuleSets, dynamicBadFilterRules)];
                    case 2:
                        _a = _b.sent(), declarativeRulesToCancel = _a.declarativeRulesToCancel, errors = _a.errors;
                        conversionResult.errors = conversionResult.errors
                            .concat(scanned.errors)
                            .concat(errors);
                        conversionResult.declarativeRulesToCancel = declarativeRulesToCancel;
                        return [2 /*return*/, conversionResult];
                }
            });
        });
    };
    /**
     * Collects {@link ConversionResult} from provided list of raw filters,
     * scanned filters, converted rules and bad filter rules.
     * Creates new {@link RuleSet} and wrap all data for {@link RuleSetContentProvider}.
     *
     * @param ruleSetId Rule set id.
     * @param filterList List of raw filters.
     * @param scannedFilters Already scanned filters.
     * @param convertedRules Converted rules.
     * @param badFilterRules List of rules with $badfilter modifier.
     *
     * @returns Item of {@link ConversionResult}.
     */
    DeclarativeFilterConverter.collectConvertedResult = function (ruleSetId, filterList, scannedFilters, convertedRules, badFilterRules) {
        var _this = this;
        var sourceMapValues = convertedRules.sourceMapValues, declarativeRules = convertedRules.declarativeRules, errors = convertedRules.errors, _a = convertedRules.limitations, limitations = _a === void 0 ? [] : _a;
        var ruleSetContent = {
            loadSourceMap: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                return [2 /*return*/, new SourceMap(sourceMapValues)];
            }); }); },
            loadFilterList: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                return [2 /*return*/, filterList];
            }); }); },
            loadDeclarativeRules: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                return [2 /*return*/, declarativeRules];
            }); }); },
        };
        var listOfRulesWithHash = scannedFilters
            .map(function (_a) {
            var id = _a.id, rules = _a.rules;
            return rules.map(function (r) { return ({
                hash: r.hash,
                source: {
                    sourceRuleIndex: r.index,
                    filterId: id,
                },
            }); });
        })
            .flat();
        var rulesHashMap = new RulesHashMap(listOfRulesWithHash);
        var ruleSet = new RuleSet(ruleSetId, declarativeRules.length, declarativeRules.filter(function (d) { return d.condition.regexFilter; }).length, ruleSetContent, badFilterRules, rulesHashMap);
        return {
            ruleSet: ruleSet,
            errors: errors,
            limitations: limitations,
        };
    };
    /**
     * Creates dictionary where key is hash of indexed rule and value is array
     * of rules with this hash.
     *
     * @param ruleSets A list of IRuleSets for each of which a list of
     * $badfilter rules.
     *
     * @returns Dictionary with all $badfilter rules which are extracted from
     * rulesets.
     */
    DeclarativeFilterConverter.createBadFilterRulesHashMap = function (ruleSets) {
        var allStaticBadFilterRules = new Map();
        ruleSets.forEach(function (ruleSet) {
            ruleSet.getBadFilterRules().forEach(function (r) {
                var existingValue = allStaticBadFilterRules.get(r.hash);
                if (existingValue) {
                    existingValue.push(r);
                }
                else {
                    allStaticBadFilterRules.set(r.hash, [r]);
                }
            });
        });
        return allStaticBadFilterRules;
    };
    /**
     * Checks if some rules (fastMatchedRulesByHash) from the staticRuleSet,
     * which have been fast matched by hash, can be negated with the provided
     * badFilterRule via the `$badfilter` option.
     *
     * @param badFilterRule Network rule with hash {@link IndexedNetworkRuleWithHash}
     * and `$badfilter` option.
     * @param staticRuleSet Static rule set which contains fast matched rules.
     * @param fastMatchedRulesByHash Rules that have been fast matched by hash
     * for potential negation.
     *
     * @returns List of declarative rule IDs that have been canceled by
     * the provided badFilterRule.
     */
    DeclarativeFilterConverter.checkFastMatchedRulesCanBeCancelled = function (badFilterRule, staticRuleSet, fastMatchedRulesByHash) {
        return __awaiter(this, void 0, void 0, function () {
            var fastMatchedDeclarativeRulesIds, promises, ids, e_1, disableRuleIds, k, id, matchedSourceRules, e_2, indexedNetworkRulesWithHash, arrayWithRules, e_3, someRulesMatched;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fastMatchedDeclarativeRulesIds = [];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        promises = fastMatchedRulesByHash.map(function (source) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                return [2 /*return*/, staticRuleSet.getDeclarativeRulesIdsBySourceRuleIndex(source)];
                            });
                        }); });
                        return [4 /*yield*/, Promise.all(promises)];
                    case 2:
                        ids = _a.sent();
                        fastMatchedDeclarativeRulesIds.push.apply(fastMatchedDeclarativeRulesIds, ids.flat());
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        // eslint-disable-next-line max-len
                        throw new Error("Not found declarative rule id for some source from list: ".concat(JSON.stringify(fastMatchedDeclarativeRulesIds), ": ").concat(getErrorMessage(e_1)));
                    case 4:
                        disableRuleIds = [];
                        k = 0;
                        _a.label = 5;
                    case 5:
                        if (!(k < fastMatchedDeclarativeRulesIds.length)) return [3 /*break*/, 15];
                        id = fastMatchedDeclarativeRulesIds[k];
                        matchedSourceRules = [];
                        _a.label = 6;
                    case 6:
                        _a.trys.push([6, 8, , 9]);
                        return [4 /*yield*/, staticRuleSet.getRulesById(id)];
                    case 7:
                        // eslint-disable-next-line no-await-in-loop
                        matchedSourceRules = _a.sent();
                        return [3 /*break*/, 9];
                    case 8:
                        e_2 = _a.sent();
                        throw new Error("Not found sources for declarative rule with id \"".concat(id, "\": ").concat(getErrorMessage(e_2)));
                    case 9:
                        indexedNetworkRulesWithHash = [];
                        _a.label = 10;
                    case 10:
                        _a.trys.push([10, 12, , 13]);
                        return [4 /*yield*/, Promise.all(matchedSourceRules.map(function (source) {
                                return RuleSet.getNetworkRuleBySourceRule(source);
                            }))];
                    case 11:
                        arrayWithRules = _a.sent();
                        indexedNetworkRulesWithHash = arrayWithRules.flat();
                        return [3 /*break*/, 13];
                    case 12:
                        e_3 = _a.sent();
                        // eslint-disable-next-line max-len
                        throw new Error("Not found network rules from matched sources \"".concat(JSON.stringify(matchedSourceRules), "\": ").concat(getErrorMessage(e_3)));
                    case 13:
                        someRulesMatched = indexedNetworkRulesWithHash
                            .flat()
                            .some(function (rule) { return badFilterRule.rule.negatesBadfilter(rule); });
                        if (someRulesMatched) {
                            disableRuleIds.push(id);
                        }
                        _a.label = 14;
                    case 14:
                        k += 1;
                        return [3 /*break*/, 5];
                    case 15: return [2 /*return*/, disableRuleIds];
                }
            });
        });
    };
    /**
     * Applies rules with $badfilter modifier from dynamic rulesets to all rules
     * from static rulesets and returns list of ids of declarative rules to
     * disable them.
     *
     * @param staticRuleSets List of converted static rulesets.
     * @param dynamicBadFilterRules List of rules with $badfilter.
     *
     * @returns List of ids of declarative rules to disable them.
     */
    DeclarativeFilterConverter.collectDeclarativeRulesToCancel = function (staticRuleSets, dynamicBadFilterRules) {
        return __awaiter(this, void 0, void 0, function () {
            var declarativeRulesToCancel, errors, i, staticRuleSet, disableRuleIds, j, badFilterRule, hashMap, fastMatchedRulesByHash, ids, e_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        declarativeRulesToCancel = [];
                        errors = [];
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < staticRuleSets.length)) return [3 /*break*/, 9];
                        staticRuleSet = staticRuleSets[i];
                        disableRuleIds = [];
                        j = 0;
                        _a.label = 2;
                    case 2:
                        if (!(j < dynamicBadFilterRules.length)) return [3 /*break*/, 7];
                        badFilterRule = dynamicBadFilterRules[j];
                        hashMap = staticRuleSet.getRulesHashMap();
                        fastMatchedRulesByHash = hashMap.findRules(badFilterRule.hash);
                        if (fastMatchedRulesByHash.length === 0) {
                            return [3 /*break*/, 6];
                        }
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, DeclarativeFilterConverter.checkFastMatchedRulesCanBeCancelled(badFilterRule, staticRuleSet, fastMatchedRulesByHash)];
                    case 4:
                        ids = _a.sent();
                        disableRuleIds.push.apply(disableRuleIds, ids);
                        return [3 /*break*/, 6];
                    case 5:
                        e_4 = _a.sent();
                        // eslint-disable-next-line max-len
                        errors.push(new Error("Cannot apply badfilter rule ".concat(badFilterRule.rule.getText(), ": ").concat(getErrorMessage(e_4))));
                        return [3 /*break*/, 6];
                    case 6:
                        j += 1;
                        return [3 /*break*/, 2];
                    case 7:
                        if (disableRuleIds.length > 0) {
                            declarativeRulesToCancel.push({
                                rulesetId: staticRuleSet.getId(),
                                disableRuleIds: disableRuleIds,
                            });
                        }
                        _a.label = 8;
                    case 8:
                        i += 1;
                        return [3 /*break*/, 1];
                    case 9: return [2 /*return*/, {
                            errors: errors,
                            declarativeRulesToCancel: declarativeRulesToCancel,
                        }];
                }
            });
        });
    };
    /**
     * Same as chrome.declarativeNetRequest.DYNAMIC_RULESET_ID.
     */
    DeclarativeFilterConverter.COMBINED_RULESET_ID = '_dynamic';
    return DeclarativeFilterConverter;
}());

/**
 * Describes an error when filter source is not available.
 */
var UnavailableFilterSourceError = /** @class */ (function (_super) {
    __extends(UnavailableFilterSourceError, _super);
    /**
     * Describes an error when filter source is not available.
     *
     * @param message Message of error.
     * @param filterId Filter id, the source of which is not available.
     * @param cause Basic error, describes why the source is unavailable.
     */
    function UnavailableFilterSourceError(message, filterId, cause) {
        var _this = _super.call(this, message, { cause: cause }) || this;
        _this.name = 'UnavailableFilterSourceError';
        _this.filterId = filterId;
        // For proper work of the "instanceof" operator
        Object.setPrototypeOf(_this, UnavailableFilterSourceError.prototype);
        return _this;
    }
    return UnavailableFilterSourceError;
}(Error));

/**
 * Saves the original rules and can return all original rules or just one,
 * with lazy content loading.
 */
var Filter = /** @class */ (function () {
    /**
     * Creates new FilterList.
     *
     * @param id Number id of filter.
     * @param source Provider of filter content.
     */
    function Filter(id, source) {
        // Content of filter, lazy load
        this.content = [];
        this.id = id;
        this.source = source;
    }
    /**
     * Filter id.
     *
     * @returns Filter id.
     */
    Filter.prototype.getId = function () {
        return this.id;
    };
    /**
     * Loads content from provider to source.
     */
    Filter.prototype.loadContent = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this;
                        return [4 /*yield*/, this.source.getContent()];
                    case 1:
                        _a.content = _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns original filtering rule by provided id with lazy load.
     *
     * @param index Rule index.
     *
     * @throws Error {@link UnavailableFilterSourceError} if content is
     * not available.
     *
     * @returns Original filtering rule by provided identifier.
     */
    Filter.prototype.getRuleByIndex = function (index) {
        return __awaiter(this, void 0, void 0, function () {
            var e_1, msg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.content.length === 0)) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.loadContent()];
                    case 2:
                        _a.sent();
                        if (this.content.length === 0) {
                            throw new Error('Loaded empty content');
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        msg = 'Filter content is unavailable';
                        throw new UnavailableFilterSourceError(msg, this.id, e_1);
                    case 4: return [2 /*return*/, this.content[index]];
                }
            });
        });
    };
    /**
     * Returns the original filter rules with lazy loading.
     *
     * @throws UnavailableFilterSourceError if content is not available.
     *
     * @returns List of original filter rules.
     */
    Filter.prototype.getContent = function () {
        return __awaiter(this, void 0, void 0, function () {
            var e_2, msg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.content.length === 0)) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.loadContent()];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_2 = _a.sent();
                        msg = 'Filter content is unavailable';
                        throw new UnavailableFilterSourceError(msg, this.id, e_2);
                    case 4: return [2 /*return*/, this.content];
                }
            });
        });
    };
    return Filter;
}());

/**
 * @file This file describes the file names for the parts of the rule set that
 * will be saved to/loaded from disk.
 *
 * We split all ruleset data into two parts: one is needed for instant creating
 * ruleset, while the other is needed only when declarative filtering log
 * is enabled - to find and display source rules from raw filters.
 */
/**
 * This metadata needed for instant creating ruleset.
 */
var METADATA_FILENAME = 'metadata.json';
/**
 * This metadata needed for lazy load some data to ruleset
 * to find and show source rules when declarative filtering log is enabled.
 */
var LAZY_METADATA_FILENAME = 'lazy_metadata.json';

export { DECLARATIVE_REQUEST_METHOD_MAP, DECLARATIVE_RESOURCE_TYPES_MAP, DeclarativeFilterConverter, DeclarativeRuleValidator, DomainType, EmptyOrNegativeNumberOfRulesError, EmptyResourcesError, Filter, HeaderOperation, IndexedNetworkRuleWithHash, InvalidDeclarativeRuleError, LAZY_METADATA_FILENAME, METADATA_FILENAME, NegativeNumberOfRegexpRulesError, RequestMethod, ResourceType, ResourcesPathError, RuleActionType, RuleSet, RulesHashMap, SourceMap, TooComplexRegexpError, TooManyRegexpRulesError, TooManyRulesError, UnavailableFilterSourceError, UnavailableRuleSetSourceError, UnsupportedModifierError, UnsupportedRegexpError };
