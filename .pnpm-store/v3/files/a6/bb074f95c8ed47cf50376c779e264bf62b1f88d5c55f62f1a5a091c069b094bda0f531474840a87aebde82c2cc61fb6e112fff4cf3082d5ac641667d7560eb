{"version":3,"file":"sign-addon.js","mappings":"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","sources":["webpack://sign-addon/webpack/bootstrap","webpack://sign-addon/webpack/runtime/compat get default export","webpack://sign-addon/webpack/runtime/define property getters","webpack://sign-addon/webpack/runtime/hasOwnProperty shorthand","webpack://sign-addon/external commonjs \"mz\"","webpack://sign-addon/external node-commonjs \"fs\"","webpack://sign-addon/external node-commonjs \"url\"","webpack://sign-addon/external node-commonjs \"path\"","webpack://sign-addon/external commonjs \"deepcopy\"","webpack://sign-addon/external commonjs \"jsonwebtoken\"","webpack://sign-addon/external commonjs \"request\"","webpack://sign-addon/external commonjs \"common-tags\"","webpack://sign-addon/./src/amo-client.js","webpack://sign-addon/./src/PseudoProgress.js","webpack://sign-addon/./src/index.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"mz\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"url\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"path\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"deepcopy\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"jsonwebtoken\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"request\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"common-tags\");","/* eslint max-classes-per-file: 0 */\nimport defaultFs from 'fs';\nimport url from 'url';\nimport path from 'path';\n\nimport deepcopy from 'deepcopy';\nimport defaultJwt from 'jsonwebtoken';\nimport defaultRequest from 'request';\nimport { oneLine } from 'common-tags';\n\nimport PseudoProgress from './PseudoProgress';\n\n/** @typedef {import(\"request\").OptionsWithUrl} RequestConfig */\n\n/** @typedef {import(\"request\").Response} Response */\n\n/**\n * @typedef {\"listed\" | \"unlisted\"} ReleaseChannel\n */\n\n/**\n * See: https://addons-server.readthedocs.io/en/latest/topics/api/signing.html#checking-the-status-of-your-upload\n *\n * @typedef {{\n *   guid: string,\n *   active: boolean,\n *   automated_signing: boolean,\n *   files: File[],\n *   passed_review: boolean,\n *   pk: string,\n *   processed: boolean,\n *   reviewed: boolean,\n *   url: string,\n *   valid: boolean,\n *   validation_results: object,\n *   validation_url: string,\n *   version: string,\n * }} SigningStatus\n */\n\n/**\n * @typedef {object} ClientParams\n * @property {string} apiKey - API key string from the Developer Hub\n * @property {string} apiSecret - API secret string from the Developer Hub\n * @property {string} apiUrlPrefix - API URL prefix, including any leading paths\n * @property {number=} apiJwtExpiresIn - Number of seconds until the JWT token for the API request expires. This must match the expiration time that the API server accepts\n * @property {boolean=} debugLogging - When true, log more information\n * @property {number=} statusCheckInterval - A period in millesconds between checks when waiting on add-on status\n * @property {number=} statusCheckTimeout -  A length in millesconds to give up if the add-on hasn't been validated and signed\n * @property {typeof console=} logger\n * @property {string=} downloadDir - Absolute path to save downloaded files to. The working directory will be used by default\n * @property {typeof defaultFs=} fs\n * @property {typeof defaultRequest=} request\n * @property {string=} proxyServer - Optional proxy server to use for all requests, such as \"http://yourproxy:6000\"\n * @property {RequestConfig=} requestConfig - Optional configuration object to pass to request(). Not all parameters are guaranteed to be applied\n * @property {PseudoProgress=} progressBar\n * @property {boolean=} disableProgressBar - When true, disables progress bar\n */\n\n/**\n * @typedef {object} SignParams\n * @property {string=} guid - optional add-on GUID (ID in install.rdf)\n * @property {string} version - add-on version string\n * @property {ReleaseChannel=} channel - release channel (listed or unlisted)\n * @property {string} xpiPath - path to xpi file\n */\n\n/**\n * @typedef {(\"SERVER_FAILURE\"|\"ADDON_NOT_AUTO_SIGNED\"|\"VALIDATION_FAILED\")} SignErrorCode\n */\n\n/**\n * @typedef {{\n *   success: boolean,\n *   id: string | null,\n *   downloadedFiles: string[] | null,\n *   errorCode: SignErrorCode | null,\n *   errorDetails: string | null\n * }} SignResult\n */\n\n/**\n * Returns a nicely formatted HTTP response.\n * This makes the response suitable for logging.\n *\n * @param {string|object} response - either the response's body or an object representing a JSON API response.\n * @param {object=} overrides\n * @returns {string}\n */\nexport function formatResponse(response, overrides = {}) {\n  const options = {\n    _stringifyToJson: JSON.stringify,\n    maxLength: 500,\n    ...overrides,\n  };\n  let prettyResponse = response;\n  const stringify = options._stringifyToJson || JSON.stringify;\n  if (typeof prettyResponse === 'object') {\n    try {\n      prettyResponse = stringify(prettyResponse);\n    } catch (e) {\n      //\n    }\n  }\n  if (typeof prettyResponse === 'string') {\n    if (prettyResponse.length > options.maxLength) {\n      prettyResponse = `${prettyResponse.substring(0, options.maxLength)}...`;\n    }\n  }\n  return prettyResponse.toString();\n}\n\n/**\n * Returns the basename of a URL, suitable for saving to disk.\n *\n * @param {string} absUrl\n * @returns {string}\n */\nexport function getUrlBasename(absUrl) {\n  // TODO: `url.parse()` might return `undefined` so we need to check that first.\n  // @ts-ignore\n  const urlPath = path.basename(url.parse(absUrl).path);\n  const parts = urlPath.split('?');\n\n  return parts[0];\n}\n/**\n * addons.mozilla.org API client.\n */\nexport class Client {\n  /**\n   * Type for `this.request()`.\n   *\n   * @typedef {object} RequestMethodOptions\n   * @property {boolean=} throwOnBadResponse - if true, an error will be thrown when response status is not 2xx\n   */\n\n  /**\n   * Type for `this.request()`.\n   *\n   * @typedef {Promise<[Response, SigningStatus]>} RequestMethodReturnValue\n   */\n\n  /**\n   * See: https://addons-server.readthedocs.io/en/latest/topics/api/signing.html#get--api-v4-addons-(string-guid)-versions-(string-version)-[uploads-(string-upload-pk)-]\n   *\n   * @typedef {{ signed: boolean, download_url: string, hash: string }} File\n   */\n\n  /**\n   * @param {ClientParams} params\n   */\n  constructor({\n    apiKey,\n    apiSecret,\n    apiUrlPrefix,\n    // TODO: put this back to something sane after we\n    // address the file upload issue on AMO:\n    // https://github.com/mozilla/addons-server/issues/3688\n    apiJwtExpiresIn = 60 * 5, // 5 minutes\n    debugLogging = false,\n    statusCheckInterval = 1000,\n    statusCheckTimeout = 900000, // 15 minutes.\n    logger = console,\n    downloadDir = process.cwd(),\n    fs = defaultFs,\n    request = defaultRequest,\n    proxyServer,\n    requestConfig,\n    progressBar,\n    disableProgressBar = false,\n  }) {\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n    this.apiUrlPrefix = apiUrlPrefix; // default set in CLI options.\n    this.apiJwtExpiresIn = apiJwtExpiresIn;\n    this.statusCheckInterval = statusCheckInterval;\n    this.statusCheckTimeout = statusCheckTimeout;\n    this.debugLogging = debugLogging;\n    this.logger = logger;\n    this.downloadDir = downloadDir;\n    this.proxyServer = proxyServer;\n    this.requestConfig = requestConfig || {};\n\n    // Set up external dependencies, allowing for overrides.\n    if (!disableProgressBar) {\n      this._progressBar =\n        progressBar ||\n        new PseudoProgress({\n          preamble: 'Validating add-on',\n        });\n    }\n    this._fs = fs;\n    this._request = request;\n  }\n\n  /**\n   * Sign a new version of your add-on at addons.mozilla.org.\n   *\n   * @param {SignParams} signParams\n   * @returns {Promise<SignResult>}\n   */\n  sign({ guid, version, channel, xpiPath }) {\n    /**\n     * @type {{\n     *   upload: defaultFs.ReadStream;\n     *   channel?: string;\n     *   version?: string;\n     * }}\n     */\n    const formData = {\n      upload: this._fs.createReadStream(xpiPath),\n    };\n    let addonUrl = '/addons/';\n    let httpMethod = this.put;\n    if (guid) {\n      // PUT to a specific URL for this add-on + version.\n      addonUrl += `${encodeURIComponent(guid)}/versions/${encodeURIComponent(\n        version,\n      )}/`;\n      if (channel) {\n        formData.channel = channel;\n      }\n    } else {\n      // POST to a generic URL to create a new add-on.\n      this.debug('Signing add-on without an ID');\n      httpMethod = this.post;\n      formData.version = version;\n      if (channel) {\n        this.logger.warn(\n          'Specifying a channel for a new add-on is unsupported. ' +\n            'New add-ons are always in the unlisted channel.',\n        );\n      }\n    }\n\n    return httpMethod\n      .bind(this)(\n        {\n          url: addonUrl,\n          formData,\n        },\n        {\n          throwOnBadResponse: false,\n        },\n      )\n      .then(\n        /**\n         * @param {[\n         *   Response,\n         *   { error?: string, headers?: {[name: string]: string}, url: string }\n         * ]} requestValue\n         * @returns {Promise<SignResult>} result\n         */\n        ([httpResponse, body]) => {\n          const response = body;\n\n          const acceptableStatuses = [200, 201, 202];\n          const receivedError = !!response.error;\n          if (\n            acceptableStatuses.indexOf(httpResponse.statusCode) === -1 ||\n            receivedError\n          ) {\n            if (response.error) {\n              this.logger.error(\n                `Server response: ${response.error}`,\n                `(status: ${httpResponse.statusCode})`,\n              );\n              return Promise.resolve({\n                success: false,\n                id: null,\n                downloadedFiles: null,\n                errorCode: 'SERVER_FAILURE',\n                errorDetails: response.error,\n              });\n            }\n\n            throw new Error(\n              `Received bad response from the server while requesting ${this.absoluteURL(\n                addonUrl,\n              )}\\n\\n` +\n                `status: ${httpResponse.statusCode}\\n` +\n                `response: ${formatResponse(response)}\\n` +\n                `headers: ${JSON.stringify(httpResponse.headers || {})}\\n`,\n            );\n          }\n\n          return this.waitForSignedAddon(response.url);\n        },\n      );\n  }\n\n  /**\n   * Poll a status URL, waiting for the queued add-on to be signed.\n   *\n   * @typedef {object} WaitForSignedAddonParams\n   * @property {typeof clearTimeout=} _clearTimeout\n   * @property {typeof setTimeout=} _setAbortTimeout\n   * @property {typeof setTimeout=} _setStatusCheckTimeout\n   *\n   * @param {string} statusUrl - URL to GET for add-on status\n   * @param {WaitForSignedAddonParams} options\n   * @returns {Promise<SignResult>}\n   */\n  waitForSignedAddon(\n    statusUrl,\n    {\n      _clearTimeout = clearTimeout,\n      _setAbortTimeout = setTimeout,\n      _setStatusCheckTimeout = setTimeout,\n    } = {},\n  ) {\n    return new Promise((resolve, reject) => {\n      /** @type {NodeJS.Timer} */\n      let statusCheckTimeout;\n\n      /** @type {NodeJS.Timer} */\n      const abortTimeout = _setAbortTimeout(() => {\n        this._progressBar?.finish();\n        _clearTimeout(statusCheckTimeout);\n\n        reject(\n          new Error(oneLine`Signing is still pending, you will receive an email\n            once there is an update on the status of your submission. If you\n            donâ€™t see the email after 24 hours, please check your Spam\n            folder.`),\n        );\n      }, this.statusCheckTimeout);\n\n      // This function polls the API until the add-on is signed or requires\n      // manual review. If the add-on is signed, we download the signed files.\n      //\n      // This function resolves the main `Promise` in both cases.\n      const checkSignedStatus = async () => {\n        try {\n          const [\n            // eslint-disable-next-line no-unused-vars\n            httpResponse,\n            status,\n          ] = await this.get({ url: statusUrl });\n          const canBeAutoSigned = status.automated_signing;\n          // The add-on passed validation and all files have been created. There\n          // are many checks for this state because the data will be updated\n          // incrementally by the API server.\n          const signedAndReady =\n            status.valid &&\n            status.active &&\n            status.reviewed &&\n            status.files &&\n            status.files.length > 0;\n          // The add-on is valid but requires a manual review before it can be\n          // signed.\n          const requiresManualReview = status.valid && !canBeAutoSigned;\n\n          if (signedAndReady || requiresManualReview) {\n            this._progressBar?.finish();\n            _clearTimeout(abortTimeout);\n\n            if (requiresManualReview) {\n              this.logger.log(oneLine`Your add-on has been submitted for review.\n              It passed validation but could not be automatically signed\n              because this is a listed add-on.`);\n\n              resolve({\n                success: false,\n                id: null,\n                downloadedFiles: null,\n                errorCode: 'ADDON_NOT_AUTO_SIGNED',\n                errorDetails: null,\n              });\n              return;\n            }\n\n            if (signedAndReady) {\n              // TODO: show some validation warnings if there are any. We should\n              // show things like \"missing update URL in manifest\"\n              const result = await this.downloadSignedFiles(status.files);\n              resolve({ ...result, id: status.guid });\n            }\n          } else {\n            // The add-on has not been fully processed yet.\n            statusCheckTimeout = _setStatusCheckTimeout(\n              checkSignedStatus,\n              this.statusCheckInterval,\n            );\n          }\n        } catch (err) {\n          _clearTimeout(abortTimeout);\n          reject(err);\n        }\n      };\n\n      // This function polls the API until the add-on is processed/validated.\n      // This function only rejects when the add-on is not valid. When the\n      // add-on is valid, we call `checkSignedStatus()`.\n      const checkValidationStatus = async () => {\n        try {\n          const [\n            // eslint-disable-next-line no-unused-vars\n            httpResponse,\n            status,\n          ] = await this.get({ url: statusUrl });\n          if (status.processed) {\n            this._progressBar?.finish();\n            this.logger.log('Validation results:', status.validation_url);\n            // Update pseudo progress preamble for the signing step.\n            this._progressBar?.setPreamble('Signing add-on');\n            this._progressBar?.animate();\n\n            if (status.valid) {\n              checkSignedStatus();\n            } else {\n              this.logger.log(\n                'Your add-on failed validation and could not be signed',\n              );\n\n              _clearTimeout(abortTimeout);\n\n              resolve({\n                success: false,\n                id: null,\n                downloadedFiles: null,\n                errorCode: 'VALIDATION_FAILED',\n                errorDetails: status.validation_url,\n              });\n            }\n          } else {\n            // Validation is not completed yet.\n            statusCheckTimeout = _setStatusCheckTimeout(\n              checkValidationStatus,\n              this.statusCheckInterval,\n            );\n          }\n        } catch (err) {\n          _clearTimeout(abortTimeout);\n          reject(err);\n        }\n      };\n\n      // Goooo\n      this._progressBar?.animate();\n      checkValidationStatus();\n    });\n  }\n\n  /**\n   * Download the signed files.\n   *\n   * @param {File[]} signedFiles - Array of file objects returned from the API.\n   * @param {{\n   *   createWriteStream?: typeof defaultFs.createWriteStream,\n   *   request?: typeof defaultRequest,\n   *   stdout?: typeof process.stdout\n   * }} options\n   * @returns {Promise<SignResult>}\n   */\n  async downloadSignedFiles(\n    signedFiles,\n    {\n      createWriteStream = defaultFs.createWriteStream,\n      request = this._request,\n      stdout = process.stdout,\n    } = {},\n  ) {\n    /** @type {Promise<string>[]} */\n    const allDownloads = [];\n    /** @type {null | number} */\n    let dataExpected = null;\n    let dataReceived = 0;\n\n    function showProgress() {\n      let progress = '...';\n      if (dataExpected !== null) {\n        const amount = ((dataReceived / dataExpected) * 100).toFixed();\n        // Pad the percentage amount so that the line length is consistent.\n        // This should do something like '  0%', ' 25%', '100%'\n        let padding = '';\n        try {\n          padding = Array(4 - amount.length).join(' ');\n        } catch (e) {\n          // Ignore Invalid array length and such.\n        }\n        progress = `${padding + amount}% `;\n      }\n      stdout.write(`\\rDownloading signed files: ${progress}`);\n    }\n\n    /**\n     * @param {string} fileUrl\n     * @returns {Promise<string>}\n     */\n    const download = (fileUrl) => {\n      return new Promise((resolve, reject) => {\n        // The API will give us a signed file named in a sane way.\n        const fileName = path.join(this.downloadDir, getUrlBasename(fileUrl));\n        const out = createWriteStream(fileName);\n\n        request(\n          this.configureRequest({\n            method: 'GET',\n            url: fileUrl,\n            followRedirect: true,\n          }),\n        )\n          .on('error', reject)\n          .on(\n            'response',\n            /**\n             * @param {Response} response\n             * @returns {void}\n             */\n            (response) => {\n              if (response.statusCode < 200 || response.statusCode >= 300) {\n                throw new Error(\n                  `Got a ${response.statusCode} response ` +\n                    `when downloading ${fileUrl}`,\n                );\n              }\n              const contentLength = response.headers['content-length'];\n              if (contentLength) {\n                if (dataExpected !== null) {\n                  dataExpected += parseInt(contentLength, 10);\n                } else {\n                  dataExpected = parseInt(contentLength, 10);\n                }\n              }\n            },\n          )\n          .on(\n            'data',\n            /**\n             * @param {string} chunk\n             * @returns {void}\n             */\n            (chunk) => {\n              dataReceived += chunk.length;\n              showProgress();\n            },\n          )\n          .pipe(out)\n          .on('error', reject);\n\n        out.on('finish', function () {\n          stdout.write('\\n'); // end the progress output\n          resolve(fileName);\n        });\n      });\n    };\n\n    let foundUnsignedFiles = false;\n    signedFiles.forEach((file) => {\n      if (file.signed) {\n        allDownloads.push(download(file.download_url));\n      } else {\n        this.debug('This file was not signed:', file);\n\n        foundUnsignedFiles = true;\n      }\n    });\n\n    let downloadedFiles;\n    if (allDownloads.length) {\n      if (foundUnsignedFiles) {\n        this.logger.log(oneLine`Some files were not signed. Re-run with\n        --verbose for details.`);\n      }\n\n      showProgress();\n\n      downloadedFiles = await Promise.all(allDownloads);\n    } else {\n      throw new Error(oneLine`The XPI was processed but no signed files were\n      found. Check your manifest and make sure it targets Firefox as an\n      application.`);\n    }\n\n    this.logger.log('Downloaded:');\n    downloadedFiles.forEach((fileName) => {\n      this.logger.log(`    ${fileName.replace(process.cwd(), '.')}`);\n    });\n\n    return {\n      success: true,\n      id: null,\n      downloadedFiles,\n      errorCode: null,\n      errorDetails: null,\n    };\n  }\n\n  /**\n   * Make a GET request.\n   *\n   * @param {RequestConfig} requestConf\n   * @param {RequestMethodOptions=} options\n   * @returns {RequestMethodReturnValue}\n   */\n  get(requestConf, options) {\n    return this.request('get', requestConf, options);\n  }\n\n  /**\n   * Make a POST request.\n   *\n   * @param {RequestConfig} requestConf\n   * @param {RequestMethodOptions=} options\n   * @returns {RequestMethodReturnValue}\n   */\n  post(requestConf, options) {\n    return this.request('post', requestConf, options);\n  }\n\n  /**\n   * Make a PUT request.\n   *\n   * @param {RequestConfig} requestConf\n   * @param {RequestMethodOptions=} options\n   * @returns {RequestMethodReturnValue}\n   */\n  put(requestConf, options) {\n    return this.request('put', requestConf, options);\n  }\n\n  /**\n   * Make a PATCH request.\n   *\n   * @param {RequestConfig} requestConf\n   * @param {RequestMethodOptions=} options\n   * @returns {RequestMethodReturnValue}\n   */\n  patch(requestConf, options) {\n    return this.request('patch', requestConf, options);\n  }\n\n  /**\n   * Make a DELETE request.\n   *\n   * @param {RequestConfig} requestConf\n   * @param {RequestMethodOptions=} options\n   * @returns {RequestMethodReturnValue}\n   */\n  delete(requestConf, options) {\n    return this.request('delete', requestConf, options);\n  }\n\n  /**\n   * Returns a URL that is guaranteed to be absolute.\n   *\n   * @param {string} urlString - a relative or already absolute URL\n   * @returns {string} url - an absolute URL, prefixed by the API prefix if necessary.\n   */\n  absoluteURL(urlString) {\n    if (!urlString.match(/^http/i)) {\n      return this.apiUrlPrefix + urlString;\n    }\n\n    return urlString;\n  }\n\n  /**\n   * Configures a request with defaults such as authentication headers.\n   *\n   * @param {RequestConfig} config - as accepted by the `request` module\n   * @param {{ jwt?: typeof defaultJwt}} options\n   * @returns {RequestConfig}\n   */\n  configureRequest(config, { jwt = defaultJwt } = {}) {\n    const requestConf = {\n      ...this.requestConfig,\n      ...config,\n    };\n\n    if (!requestConf.url) {\n      throw new Error('request URL was not specified');\n    }\n\n    // eslint-disable-next-line no-param-reassign\n    requestConf.url = this.absoluteURL(String(requestConf.url));\n\n    if (this.proxyServer) {\n      // eslint-disable-next-line no-param-reassign\n      requestConf.proxy = this.proxyServer;\n    }\n\n    const authToken = jwt.sign({ iss: this.apiKey }, this.apiSecret, {\n      algorithm: 'HS256',\n      expiresIn: this.apiJwtExpiresIn,\n    });\n\n    // Make sure the request won't time out before the JWT expires.\n    // This may be useful for slow file uploads.\n    // eslint-disable-next-line no-param-reassign\n    requestConf.timeout = this.apiJwtExpiresIn * 1000 + 500;\n\n    // eslint-disable-next-line no-param-reassign\n    requestConf.headers = {\n      Authorization: `JWT ${authToken}`,\n      Accept: 'application/json',\n      ...requestConf.headers,\n    };\n\n    return requestConf;\n  }\n\n  /**\n   * Make any HTTP request to the addons.mozilla.org API.\n   *\n   * This includes the necessary authorization header.\n   *\n   * The returned promise will be resolved with an array of arguments that\n   * match the arguments sent to the callback as specified in the `request`\n   * module.\n   *\n   * @param {string} httpMethod - HTTP method name.\n   * @param {RequestConfig} config - options accepted by the `request` module\n   * @param {RequestMethodOptions} options\n   * @returns {RequestMethodReturnValue}\n   */\n  async request(httpMethod, config, { throwOnBadResponse = true } = {}) {\n    const method = httpMethod.toLowerCase();\n    const requestConf = this.configureRequest(config);\n\n    let [\n      // eslint-disable-next-line prefer-const\n      httpResponse,\n      body,\n    ] = await new Promise((resolve, reject) => {\n      this.debug(`[API] ${method.toUpperCase()} request:\\n`, requestConf);\n\n      // Get the caller, like request.get(), request.put() ...\n      // @ts-ignore\n      const requestMethod = this._request[method].bind(this._request);\n      // Wrap the request callback in a promise. Here is an example without\n      // promises:\n      //\n      // request.put(requestConf, function(err, httpResponse, body) {\n      //   // promise gets resolved here\n      // })\n      requestMethod(\n        /** @type RequestConfig */\n        requestConf,\n        /**\n         * @param {Error} error\n         * @param {Response} response\n         * @param {string} responseBody\n         */\n        (error, response, responseBody) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          resolve([response, responseBody]);\n        },\n      );\n    });\n\n    if (throwOnBadResponse) {\n      if (httpResponse.statusCode > 299 || httpResponse.statusCode < 200) {\n        throw new Error(\n          `Received bad response from ${this.absoluteURL(\n            String(requestConf.url),\n          )}; ` +\n            `status: ${httpResponse.statusCode}; ` +\n            `response: ${formatResponse(body)}`,\n        );\n      }\n    }\n\n    if (\n      httpResponse.headers &&\n      httpResponse.headers['content-type'] === 'application/json' &&\n      typeof body === 'string'\n    ) {\n      try {\n        body = JSON.parse(body);\n      } catch (e) {\n        this.logger.log('Failed to parse JSON response from server:', e);\n      }\n    }\n\n    this.debug(\n      `[API] ${method.toUpperCase()} response:\\n`,\n      `Status: ${httpResponse.statusCode}\\n`,\n      { headers: httpResponse.headers, response: body },\n    );\n\n    return [httpResponse, body];\n  }\n\n  /**\n   * Output some debugging info if this instance is configured for it.\n   */\n  debug() {\n    if (!this.debugLogging) {\n      return;\n    }\n\n    /**\n     * @param {{ headers: {[key: string]: string} } & {[prop: string]: any}} obj\n     */\n    function redact(obj) {\n      if (typeof obj !== 'object' || !obj) {\n        return obj;\n      }\n      if (obj.headers) {\n        ['Authorization', 'cookie', 'set-cookie'].forEach(function (hdr) {\n          if (obj.headers[hdr]) {\n            // eslint-disable-next-line no-param-reassign\n            obj.headers[hdr] = '<REDACTED>';\n          }\n        });\n      }\n\n      Object.keys(obj).forEach(function (key) {\n        // eslint-disable-next-line no-param-reassign\n        obj[key] = redact(obj[key]);\n      });\n\n      return obj;\n    }\n\n    // TODO: remove the use of `arguments`\n    // eslint-disable-next-line prefer-rest-params\n    const args = Array.prototype.map.call(arguments, function (val) {\n      let newVal = val;\n      if (typeof newVal === 'object') {\n        newVal = deepcopy(newVal);\n        newVal = redact(newVal);\n      }\n      return newVal;\n    });\n    this.logger.log('[sign-addon]', ...args);\n  }\n}\n","/**\n * @typedef {{\n *   isTTY: boolean;\n *   columns: number;\n *   write: (buffer: string) => boolean;\n * }} Stdout\n */\n\n/**\n * A pseudo progress indicator.\n *\n * This is just a silly shell animation that was meant to simulate how lots of\n * tests would be run on an add-on file. It sort of looks like a torrent file\n * randomly getting filled in.\n */\nclass PseudoProgress {\n  /**\n   * @typedef {object} PseudoProgressParams\n   * @property {string=} preamble\n   * @property {typeof clearInterval=} _clearInterval\n   * @property {Stdout=} stdout\n   * @property {typeof setInterval=} _setInterval\n   *\n   * @param {PseudoProgressParams} params\n   */\n  constructor({\n    _clearInterval = clearInterval,\n    _setInterval = setInterval,\n    preamble = '',\n    stdout = process.stdout,\n  } = {}) {\n    this.interval = null;\n    this.motionCounter = 1;\n\n    this.setInterval = _setInterval;\n    this.clearInterval = _clearInterval;\n    this.stdout = stdout;\n\n    /** @type {string[]} */\n    this.bucket = [];\n    /** @type {number[]} */\n    this.emptyBucketPointers = [];\n\n    this.setPreamble(preamble);\n  }\n\n  /**\n   * @param {string} preamble\n   */\n  setPreamble(preamble) {\n    this.preamble = `${preamble} [`;\n    this.addendum = ']';\n\n    let shellWidth = 80;\n    if (this.stdout.isTTY) {\n      shellWidth = Number(this.stdout.columns);\n    }\n\n    this.emptyBucketPointers = [];\n    this.bucket = [];\n\n    const bucketSize = shellWidth - this.preamble.length - this.addendum.length;\n    for (let i = 0; i < bucketSize; i++) {\n      this.bucket.push(' ');\n      this.emptyBucketPointers.push(i);\n    }\n  }\n\n  /**\n   * @typedef {object} AnimateConfig\n   * @property {number} speed\n   *\n   * @param {AnimateConfig=} animateConfig\n   */\n  animate(animateConfig) {\n    const conf = {\n      speed: 100,\n      ...animateConfig,\n    };\n    let bucketIsFull = false;\n    this.interval = this.setInterval(() => {\n      if (bucketIsFull) {\n        this.moveBucket();\n      } else {\n        bucketIsFull = this.randomlyFillBucket();\n      }\n    }, conf.speed);\n  }\n\n  finish() {\n    if (this.interval) {\n      this.clearInterval(this.interval);\n    }\n\n    this.fillBucket();\n    // The bucket has already filled to the terminal width at this point\n    // but for copy/paste purposes, add a new line:\n    this.stdout.write('\\n');\n  }\n\n  randomlyFillBucket() {\n    // randomly fill a bucket (the width of the shell) with dots.\n    const randomIndex = Math.floor(\n      Math.random() * this.emptyBucketPointers.length,\n    );\n    this.bucket[this.emptyBucketPointers[randomIndex]] = '.';\n\n    this.showBucket();\n\n    let isFull = true;\n    /** @type {number[]} */\n    const newPointers = [];\n    this.emptyBucketPointers.forEach((pointer) => {\n      if (this.bucket[pointer] === ' ') {\n        isFull = false;\n        newPointers.push(pointer);\n      }\n    });\n    this.emptyBucketPointers = newPointers;\n\n    return isFull;\n  }\n\n  fillBucket() {\n    // fill the whole bucket with dots to indicate completion.\n    this.bucket = this.bucket.map(function () {\n      return '.';\n    });\n    this.showBucket();\n  }\n\n  moveBucket() {\n    // animate dots moving in a forward motion.\n    for (let i = 0; i < this.bucket.length; i++) {\n      this.bucket[i] = (i - this.motionCounter) % 3 ? ' ' : '.';\n    }\n    this.showBucket();\n\n    this.motionCounter++;\n  }\n\n  showBucket() {\n    this.stdout.write(\n      `\\r${this.preamble}${this.bucket.join('')}${this.addendum}`,\n    );\n  }\n}\n\nexport default PseudoProgress;\n","import { fs } from 'mz';\n\nimport { Client as DefaultAMOClient } from './amo-client';\n\n/** @typedef {import(\"request\").OptionsWithUrl} RequestConfig */\n/** @typedef {import(\"./amo-client\").ClientParams} ClientParams */\n/** @typedef {import(\"./amo-client\").ReleaseChannel} ReleaseChannel */\n\n/**\n * @typedef {object} SignAddonParams\n * @property {string} xpiPath\n * @property {string} id\n * @property {string} version\n * @property {ClientParams['apiKey']} apiKey\n * @property {ClientParams['apiSecret']} apiSecret\n * @property {ClientParams['apiUrlPrefix']=} apiUrlPrefix\n * @property {ClientParams['apiJwtExpiresIn']=} apiJwtExpiresIn\n * @property {ClientParams['debugLogging']=} verbose\n * @property {ReleaseChannel=} channel\n * @property {ClientParams['statusCheckTimeout']=} timeout\n * @property {ClientParams['downloadDir']=} downloadDir\n * @property {ClientParams['proxyServer']=} apiProxy\n * @property {ClientParams['requestConfig']=} apiRequestConfig\n * @property {typeof DefaultAMOClient=} AMOClient\n * @property {ClientParams['disableProgressBar']=} disableProgressBar\n *\n * @param {SignAddonParams} params\n */\nconst signAddon = async ({\n  // Absolute path to add-on XPI file.\n  xpiPath,\n  // The add-on ID as recognized by AMO. Example: my-addon@jetpack\n  id,\n  // The add-on version number for AMO.\n  version,\n  // Your API key (JWT issuer) from AMO Devhub.\n  apiKey,\n  // Your API secret (JWT secret) from AMO Devhub.\n  apiSecret,\n  // Optional arguments:\n  apiUrlPrefix = 'https://addons.mozilla.org/api/v4',\n  // Number of seconds until the JWT token for the API request expires.\n  // This must match the expiration time that the API server accepts.\n  apiJwtExpiresIn,\n  verbose = false,\n  // The release channel (listed or unlisted).\n  // Ignored for new add-ons, which are always unlisted.\n  // Defaults to most recently used channel.\n  channel,\n  // Number of milliseconds to wait before giving up on a\n  // response from Mozilla's web service.\n  timeout,\n  // Absolute directory to save downloaded files in.\n  downloadDir,\n  // Optional proxy to use for all API requests,\n  // such as \"http://yourproxy:6000\"\n  apiProxy,\n  // Optional object to pass into request() for additional configuration.\n  // Not all properties are guaranteed to be applied.\n  apiRequestConfig,\n  // Optional boolean passed to the AMO client to disable the progress bar.\n  disableProgressBar = false,\n  AMOClient = DefaultAMOClient,\n}) => {\n  /**\n   * @param {string} name\n   */\n  function reportEmpty(name) {\n    throw new Error(`required argument was empty: ${name}`);\n  }\n\n  if (!xpiPath) {\n    reportEmpty('xpiPath');\n  }\n\n  if (!version) {\n    reportEmpty('version');\n  }\n\n  if (!apiSecret) {\n    reportEmpty('apiSecret');\n  }\n\n  if (!apiKey) {\n    reportEmpty('apiKey');\n  }\n\n  try {\n    const stats = await fs.stat(xpiPath);\n\n    if (!stats.isFile) {\n      throw new Error(`not a file: ${xpiPath}`);\n    }\n  } catch (statError) {\n    throw new Error(`error with ${xpiPath}: ${statError}`);\n  }\n\n  const client = new AMOClient({\n    apiKey,\n    apiSecret,\n    apiUrlPrefix,\n    apiJwtExpiresIn,\n    downloadDir,\n    debugLogging: verbose,\n    statusCheckTimeout: timeout,\n    proxyServer: apiProxy,\n    requestConfig: apiRequestConfig,\n    disableProgressBar,\n  });\n\n  return client.sign({\n    xpiPath,\n    guid: id,\n    version,\n    channel,\n  });\n};\n\n/**\n * @param {SignAddonParams} options\n * @param {{\n *   systemProcess?: typeof process,\n *   throwError?: boolean,\n *   logger?: typeof console\n * }} extras\n * @returns {Promise<void>}\n */\nexport const signAddonAndExit = async (\n  options,\n  { systemProcess = process, throwError = false, logger = console },\n) => {\n  try {\n    const result = await signAddon(options);\n    logger.log(result.success ? 'SUCCESS' : 'FAIL');\n    systemProcess.exit(result.success ? 0 : 1);\n  } catch (/** @type {any} */ err) {\n    logger.error('FAIL');\n\n    if (throwError) {\n      throw err;\n    }\n\n    logger.error(err.stack);\n    systemProcess.exit(1);\n  }\n};\n\nexport default { signAddon, signAddonAndExit };\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","require","formatResponse","response","overrides","options","_stringifyToJson","JSON","stringify","maxLength","prettyResponse","e","length","substring","toString","Client","constructor","apiKey","apiSecret","apiUrlPrefix","apiJwtExpiresIn","debugLogging","statusCheckInterval","statusCheckTimeout","logger","console","downloadDir","process","cwd","fs","defaultFs","request","defaultRequest","proxyServer","requestConfig","progressBar","disableProgressBar","this","_progressBar","_clearInterval","clearInterval","_setInterval","setInterval","preamble","stdout","interval","motionCounter","bucket","emptyBucketPointers","setPreamble","addendum","shellWidth","isTTY","Number","columns","bucketSize","i","push","animate","animateConfig","conf","speed","bucketIsFull","moveBucket","randomlyFillBucket","finish","fillBucket","write","randomIndex","Math","floor","random","showBucket","isFull","newPointers","forEach","pointer","map","join","_fs","_request","sign","guid","version","channel","xpiPath","formData","upload","createReadStream","addonUrl","httpMethod","put","encodeURIComponent","debug","post","warn","bind","url","throwOnBadResponse","then","httpResponse","body","receivedError","error","indexOf","statusCode","Promise","resolve","success","id","downloadedFiles","errorCode","errorDetails","Error","absoluteURL","headers","waitForSignedAddon","statusUrl","_clearTimeout","clearTimeout","_setAbortTimeout","setTimeout","_setStatusCheckTimeout","reject","abortTimeout","oneLine","checkSignedStatus","async","status","canBeAutoSigned","automated_signing","signedAndReady","valid","active","reviewed","files","requiresManualReview","log","result","downloadSignedFiles","err","checkValidationStatus","processed","validation_url","signedFiles","createWriteStream","allDownloads","dataExpected","dataReceived","showProgress","progress","amount","toFixed","padding","Array","download","fileUrl","fileName","path","absUrl","split","out","configureRequest","method","followRedirect","on","contentLength","parseInt","chunk","pipe","foundUnsignedFiles","file","signed","download_url","all","replace","requestConf","patch","delete","urlString","match","config","jwt","defaultJwt","String","proxy","authToken","iss","algorithm","expiresIn","timeout","Authorization","Accept","toLowerCase","toUpperCase","requestMethod","responseBody","parse","redact","hdr","keys","args","arguments","val","newVal","deepcopy","signAddon","verbose","apiProxy","apiRequestConfig","AMOClient","DefaultAMOClient","reportEmpty","name","isFile","statError","signAddonAndExit","systemProcess","throwError","exit","stack"],"sourceRoot":""}