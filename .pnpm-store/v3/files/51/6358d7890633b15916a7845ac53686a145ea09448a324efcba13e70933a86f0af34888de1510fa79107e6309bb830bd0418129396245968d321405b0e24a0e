import { s as splitByDelimiterWithEscapeCharacter, S as SimpleRegex, a as stringArraysEquals, b as stringArraysHaveIntersection } from './simple-regex-ea3ddcd2.js';
import { f as getPublicSuffix, c as cleanUrlParamByRegExp } from './url-94de2ee3.js';
import { NETWORK_RULE_OPTIONS, NOT_MARK, OPTIONS_DELIMITER, ESCAPE_CHARACTER, MASK_ALLOWLIST } from './network-rule-options.js';
import { RequestType } from './request-type.js';

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

/**
 * Compatibility types are used to configure engine for better support of different libraries
 * For example:
 *  extension doesn't support $app modifier. So if we set in configuration CompatibilityTypes.extension,
 *  engine would ignore rules with $app modifier
 */
var CompatibilityTypes;
(function (CompatibilityTypes) {
    CompatibilityTypes[CompatibilityTypes["extension"] = 1] = "extension";
    CompatibilityTypes[CompatibilityTypes["corelibs"] = 2] = "corelibs";
    CompatibilityTypes[CompatibilityTypes["dns"] = 4] = "dns";
})(CompatibilityTypes || (CompatibilityTypes = {}));
/**
 * Application configuration class
 */
var Configuration = /** @class */ (function () {
    function Configuration(inputConfig) {
        this.defaultConfig = {
            engine: null,
            version: null,
            verbose: false,
            compatibility: null,
        };
        /**
         * {'extension'|'corelibs'} engine application type
         */
        this.engine = null;
        /**
         * {string} version
         */
        this.version = null;
        /**
         * {boolean} verbose flag
         */
        this.verbose = false;
        /**
         * compatibility flag
         */
        this.compatibility = CompatibilityTypes.extension;
        var config = __assign(__assign({}, this.defaultConfig), inputConfig);
        this.engine = config.engine;
        this.version = config.version;
        this.verbose = config.verbose;
        this.compatibility = config.compatibility;
    }
    return Configuration;
}());
var config$2 = new Configuration();
/**
 * Checks config is compatible with input level
 * @param compatibilityLevel
 * @private
 */
function isCompatibleWith(compatibilityLevel) {
    if (config$2.compatibility === null) {
        return false;
    }
    return (config$2.compatibility & compatibilityLevel) === compatibilityLevel;
}
var setConfiguration = function (outerConfig) {
    config$2 = new Configuration(outerConfig);
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

/**
 * Export logger implementation
 */
var logger = console;
/**
 * Set logger implementation
 *
 * @param loggerImpl
 */
function setLogger(loggerImpl) {
    logger = loggerImpl;
}

/**
 * This is a helper class that is used specifically to work
 * with domains restrictions.
 *
 * There are two options how you can add a domain restriction:
 * * `$domain` modifier: https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
 * * domains list for the cosmetic rules
 *
 * The only difference between them is that in one case we use `|` as a separator,
 * and in the other case - `,`.
 *
 * Examples:
 * * `||example.org^$domain=example.com|~sub.example.com` -- network rule
 * * `example.com,~sub.example.com##banner` -- cosmetic rule
 */
var DomainModifier = /** @class */ (function () {
    /**
     * Parses the `domains` string and initializes the object.
     *
     * @param domainsStr Domains string.
     * @param separator Separator â€” `,` or `|`.
     *
     * @throws An error if the domains string is empty or invalid
     */
    function DomainModifier(domainsStr, separator) {
        if (!domainsStr) {
            throw new SyntaxError('Modifier $domain cannot be empty');
        }
        var permittedDomains = [];
        var restrictedDomains = [];
        var parts = domainsStr.toLowerCase().split(separator);
        for (var i = 0; i < parts.length; i += 1) {
            var domain = parts[i].trim();
            var restricted = false;
            if (domain.startsWith('~')) {
                restricted = true;
                domain = domain.substring(1);
            }
            if (domain === '') {
                throw new SyntaxError("Empty domain specified in \"".concat(domainsStr, "\""));
            }
            if (restricted) {
                restrictedDomains.push(domain);
            }
            else {
                permittedDomains.push(domain);
            }
        }
        this.restrictedDomains = restrictedDomains.length > 0 ? restrictedDomains : null;
        this.permittedDomains = permittedDomains.length > 0 ? permittedDomains : null;
    }
    /**
     * isDomainOrSubdomainOfAny checks if `domain` is the same or a subdomain
     * of any of `domains`.
     *
     * @param domain - domain to check
     * @param domains - domains list to check against
     */
    DomainModifier.isDomainOrSubdomainOfAny = function (domain, domains) {
        for (var i = 0; i < domains.length; i += 1) {
            var d = domains[i];
            if (DomainModifier.isWildcardDomain(d)) {
                if (DomainModifier.matchAsWildcard(d, domain)) {
                    return true;
                }
            }
            if (domain === d || (domain.endsWith(d) && domain.endsWith(".".concat(d)))) {
                return true;
            }
        }
        return false;
    };
    /**
     * Checks if domain ends with wildcard
     *
     * @param domain
     */
    DomainModifier.isWildcardDomain = function (domain) {
        return domain.endsWith('.*');
    };
    /**
     * Checks if wildcard matches domain
     *
     * @param wildcard
     * @param domainNameToCheck
     */
    DomainModifier.matchAsWildcard = function (wildcard, domainNameToCheck) {
        var wildcardedDomainToCheck = DomainModifier.genTldWildcard(domainNameToCheck);
        if (wildcardedDomainToCheck) {
            return wildcardedDomainToCheck === wildcard
                || (wildcardedDomainToCheck.endsWith(wildcard) && wildcardedDomainToCheck.endsWith(".".concat(wildcard)));
        }
        return false;
    };
    /**
     * Generates from domain tld wildcard e.g. google.com -> google.* ; youtube.co.uk -> youtube.*
     *
     * @param {string} domainName
     * @returns {string} string is empty if tld for provided domain name doesn't exists
     */
    DomainModifier.genTldWildcard = function (domainName) {
        var tld = getPublicSuffix(domainName);
        if (tld) {
            return "".concat(domainName.slice(0, domainName.indexOf(".".concat(tld))), ".*");
        }
        return '';
    };
    return DomainModifier;
}());
/**
 * Comma separator
 */
var COMMA_SEPARATOR = ',';
/**
 * Pipe separator
 */
var PIPE_SEPARATOR = '|';

/**
 * Replace modifier class
 */
var ReplaceModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     */
    function ReplaceModifier(value) {
        var parsed = ReplaceModifier.parseReplaceOption(value);
        this.replaceOption = parsed.optionText;
        this.replaceApply = parsed.apply;
    }
    /**
     *
     * @param option
     */
    ReplaceModifier.parseReplaceOption = function (option) {
        if (!option) {
            return {
                apply: function (x) { return x; },
                optionText: '',
            };
        }
        var parts = splitByDelimiterWithEscapeCharacter(option, '/', '\\', true);
        if (parts.length < 2 || parts.length > 3) {
            throw new Error("Cannot parse ".concat(option));
        }
        var modifiers = (parts[2] || '');
        if (modifiers.indexOf('g') < 0) {
            modifiers += 'g';
        }
        var pattern = new RegExp(parts[0], modifiers);
        // unescape replacement alias
        var replacement = parts[1].replace(/\\\$/g, '$');
        replacement = SimpleRegex.unescapeSpecials(replacement);
        var apply = function (input) { return input.replace(pattern, replacement); };
        return {
            apply: apply,
            optionText: option,
        };
    };
    /**
     * Replace content
     */
    ReplaceModifier.prototype.getValue = function () {
        return this.replaceOption;
    };
    /**
     * Replace apply function
     */
    ReplaceModifier.prototype.getApplyFunc = function () {
        return this.replaceApply;
    };
    return ReplaceModifier;
}());

/**
 * Csp modifier class
 */
var CspModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     * @param isAllowlist
     */
    function CspModifier(value, isAllowlist) {
        this.cspDirective = value;
        this.isAllowlist = isAllowlist;
        this.validateCspDirective();
    }
    /**
     * Csp directive
     */
    CspModifier.prototype.getValue = function () {
        return this.cspDirective;
    };
    /**
     * Validates CSP rule
     */
    CspModifier.prototype.validateCspDirective = function () {
        /**
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/685
         * CSP directive may be empty in case of allowlist rule,
         * it means to disable all $csp rules matching the allowlist rule
         */
        if (!this.isAllowlist && !this.cspDirective) {
            throw new Error('Invalid $CSP rule: CSP directive must not be empty');
        }
        if (this.cspDirective) {
            /**
             * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/685#issue-228287090
             * Forbids report-to and report-uri directives
             */
            var cspDirective = this.cspDirective.toLowerCase();
            if (cspDirective.indexOf('report-') >= 0) {
                throw new Error("Forbidden CSP directive: ".concat(cspDirective));
            }
        }
    };
    return CspModifier;
}());

/**
 * Cookie modifier class
 *
 * Learn more about it here:
 * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/961
 */
var CookieModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     */
    function CookieModifier(value) {
        // Save the source text of the option modifier
        this.optionValue = value || '';
        this.regex = null;
        this.cookieName = null;
        this.sameSite = null;
        this.maxAge = null;
        // Parse cookie name/regex
        var parts = this.optionValue.split(/;/);
        if (parts.length < 1) {
            throw new Error("Cannot parse ".concat(this.optionValue));
        }
        var cookieName = parts[0];
        if (cookieName.startsWith('/') && cookieName.endsWith('/')) {
            var pattern = cookieName.substring(1, cookieName.length - 1);
            // Save regex to be used further for matching cookies
            this.regex = new RegExp(pattern);
        }
        else {
            // Match by cookie name
            this.cookieName = cookieName;
        }
        // Parse other cookie options
        if (parts.length > 1) {
            for (var i = 1; i < parts.length; i += 1) {
                var nameValue = parts[i].split('=');
                var optionName = nameValue[0];
                var optionValue = nameValue[1];
                if (optionName === CookieModifier.MAX_AGE) {
                    this.maxAge = parseInt(optionValue, 10);
                }
                else if (optionName === CookieModifier.SAME_SITE) {
                    this.sameSite = optionValue;
                }
                else {
                    throw new Error("Unknown $cookie option: ".concat(optionName));
                }
            }
        }
    }
    /**
     * Modifier value
     */
    CookieModifier.prototype.getValue = function () {
        return this.optionValue;
    };
    /**
     * First cookie name
     */
    CookieModifier.prototype.getCookieName = function () {
        return this.cookieName;
    };
    /**
     * Max age cookie value
     */
    CookieModifier.prototype.getMaxAge = function () {
        return this.maxAge;
    };
    /**
     * Same site cookie value
     */
    CookieModifier.prototype.getSameSite = function () {
        return this.sameSite;
    };
    /**
     * Checks if cookie with the specified name matches this option
     *
     * @param {string} name Cookie name
     * @return {boolean} true if it does
     */
    CookieModifier.prototype.matches = function (name) {
        if (!name) {
            return false;
        }
        if (this.regex) {
            return this.regex.test(name);
        }
        if (this.cookieName) {
            return this.cookieName === name;
        }
        // Empty regex and cookieName means that we must match all cookies
        return true;
    };
    /**
     * Checks if cookie rule has an empty $cookie option
     *
     * @return {boolean} True if $cookie option is empty
     */
    CookieModifier.prototype.isEmpty = function () {
        return !this.regex && !this.cookieName;
    };
    /**
     * Cookie name maxAge
     */
    CookieModifier.MAX_AGE = 'maxAge';
    /**
     * Cookie name sameSite
     */
    CookieModifier.SAME_SITE = 'sameSite';
    return CookieModifier;
}());

var scriptlets_umd = {exports: {}};

(function (factory) {
    factory();
})((function () {
    function attachDependencies(scriptlet) {
      const _scriptlet$injections = scriptlet.injections,
        injections = _scriptlet$injections === void 0 ? [] : _scriptlet$injections;
      return injections.reduce(function (accum, dep) {
        return "".concat(accum, "\n").concat(dep.toString());
      }, scriptlet.toString());
    }
    function addCall(scriptlet, code) {
      return "".concat(code, "\n    const updatedArgs = args ? [].concat(source).concat(args) : [source];\n    try {\n        ").concat(scriptlet.name, ".apply(this, updatedArgs);\n    } catch (e) {\n        console.log(e);\n    }");
    }
    function passSourceAndProps(source, code) {
      let redirect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (source.hit) {
        source.hit = source.hit.toString();
      }
      const sourceString = JSON.stringify(source);
      const argsString = source.args ? "[".concat(source.args.map(JSON.stringify), "]") : undefined;
      const params = argsString ? "".concat(sourceString, ", ").concat(argsString) : sourceString;
      if (redirect) {
        return "(function(source, args){\n".concat(code, "\n})(").concat(params, ");");
      }
      return "(".concat(code, ")(").concat(params, ");");
    }
    function wrapInNonameFunc(code) {
      return "function(source, args){\n".concat(code, "\n}");
    }
    const getObjectEntries = function getObjectEntries(object) {
      const keys = Object.keys(object);
      const entries = [];
      keys.forEach(function (key) {
        return entries.push([key, object[key]]);
      });
      return entries;
    };
    const getObjectFromEntries = function getObjectFromEntries(entries) {
      const output = entries.reduce(function (acc, el) {
        const key = el[0];
        const value = el[1];
        acc[key] = value;
        return acc;
      }, {});
      return output;
    };
    const isEmptyObject = function isEmptyObject(obj) {
      return Object.keys(obj).length === 0 && !obj.prototype;
    };
    const safeGetDescriptor = function safeGetDescriptor(obj, prop) {
      const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      if (descriptor && descriptor.configurable) {
        return descriptor;
      }
      return null;
    };
    function setPropertyAccess(object, property, descriptor) {
      const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
      if (currentDescriptor && !currentDescriptor.configurable) {
        return false;
      }
      Object.defineProperty(object, property, descriptor);
      return true;
    }
    const nativeIsNaN = function nativeIsNaN(num) {
      const native = Number.isNaN || window.isNaN;
      return native(num);
    };
    const nativeIsFinite = function nativeIsFinite(num) {
      const native = Number.isFinite || window.isFinite;
      return native(num);
    };
    const getNumberFromString = function getNumberFromString(rawString) {
      const parsedDelay = parseInt(rawString, 10);
      const validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
      return validDelay;
    };
    function getRandomIntInclusive(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min + 1) + min);
    }
    const replaceAll = function replaceAll(input, substr, newSubstr) {
      return input.split(substr).join(newSubstr);
    };
    const escapeRegExp = function escapeRegExp(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    };
    const toRegExp = function toRegExp() {
      let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      const DEFAULT_VALUE = '.?';
      const FORWARD_SLASH = '/';
      if (input === '') {
        return new RegExp(DEFAULT_VALUE);
      }
      if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
        return new RegExp(input.slice(1, -1));
      }
      const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      return new RegExp(escaped);
    };
    const isValidStrPattern = function isValidStrPattern(input) {
      const FORWARD_SLASH = '/';
      let str = escapeRegExp(input);
      if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
        str = input.slice(1, -1);
      }
      let isValid;
      try {
        isValid = new RegExp(str);
        isValid = true;
      } catch (e) {
        isValid = false;
      }
      return isValid;
    };
    const getBeforeRegExp = function getBeforeRegExp(str, rx) {
      const index = str.search(rx);
      return str.substring(0, index);
    };
    const startsWith$1 = function startsWith(str, prefix) {
      return !!str && str.indexOf(prefix) === 0;
    };
    const endsWith = function endsWith(str, ending) {
      return !!str && str.lastIndexOf(ending) === str.length - ending.length;
    };
    const substringAfter$1 = function substringAfter(str, separator) {
      if (!str) {
        return str;
      }
      const index = str.indexOf(separator);
      return index < 0 ? '' : str.substring(index + separator.length);
    };
    const substringBefore = function substringBefore(str, separator) {
      if (!str || !separator) {
        return str;
      }
      const index = str.indexOf(separator);
      return index < 0 ? str : str.substring(0, index);
    };
    const wrapInSingleQuotes = function wrapInSingleQuotes(str) {
      if (str[0] === '\'' && str[str.length - 1] === '\'' || str[0] === '"' && str[str.length - 1] === '"') {
        str = str.substring(1, str.length - 1);
      }
      str = str.replace(/\'/g, '"');
      return "'".concat(str, "'");
    };
    const getStringInBraces = function getStringInBraces(str) {
      const firstIndex = str.indexOf('(');
      const lastIndex = str.lastIndexOf(')');
      return str.substring(firstIndex + 1, lastIndex);
    };
    const convertRtcConfigToString = function convertRtcConfigToString(config) {
      const UNDEF_STR = 'undefined';
      let str = UNDEF_STR;
      if (config === null) {
        str = 'null';
      } else if (config instanceof Object) {
        const SERVERS_PROP_NAME = 'iceServers';
        const URLS_PROP_NAME = 'urls';
        if (Object.prototype.hasOwnProperty.call(config, SERVERS_PROP_NAME) && Object.prototype.hasOwnProperty.call(config[SERVERS_PROP_NAME][0], URLS_PROP_NAME) && !!config[SERVERS_PROP_NAME][0][URLS_PROP_NAME]) {
          str = config[SERVERS_PROP_NAME][0][URLS_PROP_NAME].toString();
        }
      }
      return str;
    };
    const isValidMatchStr = function isValidMatchStr(match) {
      const INVERT_MARKER = '!';
      let str = match;
      if (startsWith$1(match, INVERT_MARKER)) {
        str = match.slice(1);
      }
      return isValidStrPattern(str);
    };
    const isValidMatchNumber = function isValidMatchNumber(match) {
      const INVERT_MARKER = '!';
      let str = match;
      if (startsWith$1(match, INVERT_MARKER)) {
        str = match.slice(1);
      }
      const num = parseFloat(str);
      return !nativeIsNaN(num) && nativeIsFinite(num);
    };
    const parseMatchArg = function parseMatchArg(match) {
      const INVERT_MARKER = '!';
      const isInvertedMatch = match ? match.startsWith(INVERT_MARKER) : false;
      const matchValue = isInvertedMatch ? match.slice(1) : match;
      const matchRegexp = toRegExp(matchValue);
      return {
        isInvertedMatch,
        matchRegexp,
        matchValue
      };
    };
    const parseDelayArg = function parseDelayArg(delay) {
      const INVERT_MARKER = '!';
      const isInvertedDelayMatch = startsWith$1(delay, INVERT_MARKER);
      let delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;
      delayValue = parseInt(delayValue, 10);
      const delayMatch = nativeIsNaN(delayValue) ? null : delayValue;
      return {
        isInvertedDelayMatch,
        delayMatch
      };
    };
    const objectToString = function objectToString(obj) {
      if (!obj || typeof obj !== 'object') {
        return String(obj);
      }
      return isEmptyObject(obj) ? '{}' : getObjectEntries(obj).map(function (pair) {
        const key = pair[0];
        const value = pair[1];
        let recordValueStr = value;
        if (value instanceof Object) {
          recordValueStr = "{ ".concat(objectToString(value), " }");
        }
        return "".concat(key, ":\"").concat(recordValueStr, "\"");
      }).join(' ');
    };
    const convertTypeToString = function convertTypeToString(value) {
      let output;
      if (typeof value === 'undefined') {
        output = 'undefined';
      } else if (typeof value === 'object') {
        if (value === null) {
          output = 'null';
        } else {
          output = objectToString(value);
        }
      } else {
        output = value.toString();
      }
      return output;
    };
    function getRandomStrByLength(length) {
      let result = '';
      const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+=~';
      const charactersLength = characters.length;
      for (let i = 0; i < length; i += 1) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
      }
      return result;
    }
    function generateRandomResponse(customResponseText) {
      let customResponse = customResponseText;
      if (customResponse === 'true') {
        customResponse = Math.random().toString(36).slice(-10);
        return customResponse;
      }
      customResponse = customResponse.replace('length:', '');
      const rangeRegex = /^\d+-\d+$/;
      if (!rangeRegex.test(customResponse)) {
        return null;
      }
      let rangeMin = getNumberFromString(customResponse.split('-')[0]);
      let rangeMax = getNumberFromString(customResponse.split('-')[1]);
      if (!nativeIsFinite(rangeMin) || !nativeIsFinite(rangeMax)) {
        return null;
      }
      if (rangeMin > rangeMax) {
        const temp = rangeMin;
        rangeMin = rangeMax;
        rangeMax = temp;
      }
      const LENGTH_RANGE_LIMIT = 500 * 1000;
      if (rangeMax > LENGTH_RANGE_LIMIT) {
        return null;
      }
      const length = getRandomIntInclusive(rangeMin, rangeMax);
      customResponse = getRandomStrByLength(length);
      return customResponse;
    }
    function inferValue(value) {
      if (value === 'undefined') {
        return undefined;
      }
      if (value === 'false') {
        return false;
      }
      if (value === 'true') {
        return true;
      }
      if (value === 'null') {
        return null;
      }
      if (value === 'NaN') {
        return NaN;
      }
      const MAX_ALLOWED_NUM = 32767;
      const numVal = Number(value);
      if (!nativeIsNaN(numVal)) {
        if (Math.abs(numVal) > MAX_ALLOWED_NUM) {
          throw new Error('number values bigger than 32767 are not allowed');
        }
        return numVal;
      }
      let errorMessage = "'".concat(value, "' value type can't be inferred");
      try {
        const parsableVal = JSON.parse(value);
        if (parsableVal instanceof Object || typeof parsableVal === 'string') {
          return parsableVal;
        }
      } catch (e) {
        errorMessage += ": ".concat(e);
      }
      throw new TypeError(errorMessage);
    }
    function iterateWithTransitions(iterable, transitions, init, args) {
      let state = init || Object.keys(transitions)[0];
      for (let i = 0; i < iterable.length; i += 1) {
        state = transitions[state](iterable, i, args);
      }
      return state;
    }
    const ADG_SCRIPTLET_MASK = '#//scriptlet';
    const wordSaver = function wordSaver() {
      let str = '';
      const strings = [];
      const saveSymb = function saveSymb(s) {
        str += s;
        return str;
      };
      const saveStr = function saveStr() {
        strings.push(str);
        str = '';
      };
      const getAll = function getAll() {
        return [...strings];
      };
      return {
        saveSymb,
        saveStr,
        getAll
      };
    };
    const substringAfter = function substringAfter(str, separator) {
      if (!str) {
        return str;
      }
      const index = str.indexOf(separator);
      return index < 0 ? '' : str.substring(index + separator.length);
    };
    const parseRule = function parseRule(ruleText) {
      ruleText = substringAfter(ruleText, ADG_SCRIPTLET_MASK);
      const TRANSITION = {
        OPENED: 'opened',
        PARAM: 'param',
        CLOSED: 'closed'
      };
      const opened = function opened(rule, index, _ref) {
        let sep = _ref.sep;
        const char = rule[index];
        let transition;
        switch (char) {
          case ' ':
          case '(':
          case ',':
            {
              transition = TRANSITION.OPENED;
              break;
            }
          case '\'':
          case '"':
            {
              sep.symb = char;
              transition = TRANSITION.PARAM;
              break;
            }
          case ')':
            {
              transition = index === rule.length - 1 ? TRANSITION.CLOSED : TRANSITION.OPENED;
              break;
            }
          default:
            {
              throw new Error('The rule is not a scriptlet');
            }
        }
        return transition;
      };
      const param = function param(rule, index, _ref2) {
        let saver = _ref2.saver,
          sep = _ref2.sep;
        const char = rule[index];
        switch (char) {
          case '\'':
          case '"':
            {
              const preIndex = index - 1;
              const before = rule[preIndex];
              if (char === sep.symb && before !== '\\') {
                sep.symb = null;
                saver.saveStr();
                return TRANSITION.OPENED;
              }
            }
          default:
            {
              saver.saveSymb(char);
              return TRANSITION.PARAM;
            }
        }
      };
      const transitions = {
        [TRANSITION.OPENED]: opened,
        [TRANSITION.PARAM]: param,
        [TRANSITION.CLOSED]: function () {}
      };
      const sep = {
        symb: null
      };
      const saver = wordSaver();
      const state = iterateWithTransitions(ruleText, transitions, TRANSITION.OPENED, {
        sep,
        saver
      });
      if (state !== 'closed') {
        throw new Error("Invalid scriptlet rule ".concat(ruleText));
      }
      const args = saver.getAll();
      return {
        name: args[0],
        args: args.slice(1)
      };
    };
    const validateType = function validateType(type) {
      return typeof type !== 'undefined';
    };
    const validateListener = function validateListener(listener) {
      return typeof listener !== 'undefined' && (typeof listener === 'function' || typeof listener === 'object'
      && listener !== null && typeof listener.handleEvent === 'function');
    };
    const listenerToString = function listenerToString(listener) {
      return typeof listener === 'function' ? listener.toString() : listener.handleEvent.toString();
    };
    const shouldMatchAnyDelay = function shouldMatchAnyDelay(delay) {
      return delay === '*';
    };
    const getMatchDelay = function getMatchDelay(delay) {
      const DEFAULT_DELAY = 1000;
      const parsedDelay = parseInt(delay, 10);
      const delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY
      : parsedDelay;
      return delayMatch;
    };
    const isDelayMatched = function isDelayMatched(inputDelay, realDelay) {
      return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);
    };
    const getBoostMultiplier = function getBoostMultiplier(boost) {
      const DEFAULT_MULTIPLIER = 0.05;
      const MIN_MULTIPLIER = 0.001;
      const MAX_MULTIPLIER = 50;
      const parsedBoost = parseFloat(boost);
      let boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER
      : parsedBoost;
      if (boostMultiplier < MIN_MULTIPLIER) {
        boostMultiplier = MIN_MULTIPLIER;
      }
      if (boostMultiplier > MAX_MULTIPLIER) {
        boostMultiplier = MAX_MULTIPLIER;
      }
      return boostMultiplier;
    };
    const flatten = function flatten(input) {
      const stack = [];
      input.forEach(function (el) {
        return stack.push(el);
      });
      const res = [];
      while (stack.length) {
        const next = stack.pop();
        if (Array.isArray(next)) {
          next.forEach(function (el) {
            return stack.push(el);
          });
        } else {
          res.push(next);
        }
      }
      return res.reverse();
    };
    const isExisting = function isExisting(item) {
      return !!item;
    };
    const isValidCookiePath = function isValidCookiePath(rawPath) {
      return rawPath === '/' || rawPath === 'none';
    };
    const getCookiePath = function getCookiePath(rawPath) {
      if (rawPath === '/') {
        return 'path=/';
      }
      return '';
    };
    const concatCookieNameValuePath = function concatCookieNameValuePath(rawName, rawValue, rawPath) {
      return "".concat(encodeURIComponent(rawName), "=").concat(encodeURIComponent(rawValue), "; ").concat(getCookiePath(rawPath), ";");
    };
    const getLimitedCookieValue = function getLimitedCookieValue(value) {
      if (!value) {
        return null;
      }
      let validValue;
      if (value === 'true') {
        validValue = 'true';
      } else if (value === 'True') {
        validValue = 'True';
      } else if (value === 'false') {
        validValue = 'false';
      } else if (value === 'False') {
        validValue = 'False';
      } else if (value === 'yes') {
        validValue = 'yes';
      } else if (value === 'Yes') {
        validValue = 'Yes';
      } else if (value === 'Y') {
        validValue = 'Y';
      } else if (value === 'no') {
        validValue = 'no';
      } else if (value === 'ok') {
        validValue = 'ok';
      } else if (value === 'OK') {
        validValue = 'OK';
      } else if (/^\d+$/.test(value)) {
        validValue = parseFloat(value);
        if (nativeIsNaN(validValue)) {
          return null;
        }
        if (Math.abs(validValue) < 0 || Math.abs(validValue) > 15) {
          return null;
        }
      } else {
        return null;
      }
      return validValue;
    };
    const parseCookieString = function parseCookieString(cookieString) {
      const COOKIE_DELIMITER = '=';
      const COOKIE_PAIRS_DELIMITER = ';';
      const cookieChunks = cookieString.split(COOKIE_PAIRS_DELIMITER);
      const cookieData = {};
      cookieChunks.forEach(function (singleCookie) {
        let cookieKey;
        let cookieValue;
        const delimiterIndex = singleCookie.indexOf(COOKIE_DELIMITER);
        if (delimiterIndex === -1) {
          cookieKey = singleCookie.trim();
        } else {
          cookieKey = singleCookie.slice(0, delimiterIndex).trim();
          cookieValue = singleCookie.slice(delimiterIndex + 1);
        }
        cookieData[cookieKey] = cookieValue || null;
      });
      return cookieData;
    };
    const isCookieSetWithValue = function isCookieSetWithValue(cookieString, name, value) {
      return cookieString.split(';').some(function (cookieStr) {
        const pos = cookieStr.indexOf('=');
        if (pos === -1) {
          return false;
        }
        const cookieName = cookieStr.slice(0, pos).trim();
        const cookieValue = cookieStr.slice(pos + 1).trim();
        return name === cookieName && value === cookieValue;
      });
    };
    const getTrustedCookieOffsetMs = function getTrustedCookieOffsetMs(offsetExpiresSec) {
      const ONE_YEAR_EXPIRATION_KEYWORD = '1year';
      const ONE_DAY_EXPIRATION_KEYWORD = '1day';
      const MS_IN_SEC = 1000;
      const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
      const SECONDS_IN_DAY = 24 * 60 * 60;
      let parsedSec;
      if (offsetExpiresSec === ONE_YEAR_EXPIRATION_KEYWORD) {
        parsedSec = SECONDS_IN_YEAR;
      } else if (offsetExpiresSec === ONE_DAY_EXPIRATION_KEYWORD) {
        parsedSec = SECONDS_IN_DAY;
      } else {
        parsedSec = Number.parseInt(offsetExpiresSec, 10);
        if (Number.isNaN(parsedSec)) {
          return null;
        }
      }
      return parsedSec * MS_IN_SEC;
    };
    const noopFunc = function noopFunc() {};
    const noopCallbackFunc = function noopCallbackFunc() {
      return noopFunc;
    };
    const noopNull = function noopNull() {
      return null;
    };
    const trueFunc = function trueFunc() {
      return true;
    };
    const falseFunc = function falseFunc() {
      return false;
    };
    function noopThis() {
      return this;
    }
    const noopStr = function noopStr() {
      return '';
    };
    const noopArray = function noopArray() {
      return [];
    };
    const noopObject = function noopObject() {
      return {};
    };
    const throwFunc = function throwFunc() {
      throw new Error();
    };
    const noopPromiseReject = function noopPromiseReject() {
      return Promise.reject();
    };
    const noopPromiseResolve = function noopPromiseResolve() {
      let responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '{}';
      let responseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      let responseType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';
      if (typeof Response === 'undefined') {
        return;
      }
      const response = new Response(responseBody, {
        status: 200,
        statusText: 'OK'
      });
      Object.defineProperties(response, {
        url: {
          value: responseUrl
        },
        type: {
          value: responseType
        }
      });
      return Promise.resolve(response);
    };
    const shouldAbortInlineOrInjectedScript = function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
      const INLINE_SCRIPT_STRING = 'inlineScript';
      const INJECTED_SCRIPT_STRING = 'injectedScript';
      const INJECTED_SCRIPT_MARKER = '<anonymous>';
      const isInlineScript = function isInlineScript(stackMatch) {
        return stackMatch.indexOf(INLINE_SCRIPT_STRING) > -1;
      };
      const isInjectedScript = function isInjectedScript(stackMatch) {
        return stackMatch.indexOf(INJECTED_SCRIPT_STRING) > -1;
      };
      if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
        return false;
      }
      let documentURL = window.location.href;
      const pos = documentURL.indexOf('#');
      if (pos !== -1) {
        documentURL = documentURL.slice(0, pos);
      }
      const stackSteps = stackTrace.split('\n').slice(2).map(function (line) {
        return line.trim();
      });
      const stackLines = stackSteps.map(function (line) {
        let stack;
        const getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
        if (getStackTraceURL) {
          let stackURL = getStackTraceURL[2];
          if (startsWith$1(stackURL, '(')) {
            stackURL = stackURL.slice(1);
          }
          if (startsWith$1(stackURL, INJECTED_SCRIPT_MARKER)) {
            stackURL = INJECTED_SCRIPT_STRING;
            let stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
            if (startsWith$1(stackFunction, 'at')) {
              stackFunction = stackFunction.slice(2).trim();
            }
            stack = "".concat(stackFunction, " ").concat(stackURL).trim();
          } else {
            stack = stackURL;
          }
        } else {
          stack = line;
        }
        return stack;
      });
      if (stackLines) {
        for (let index = 0; index < stackLines.length; index += 1) {
          if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
            return true;
          }
          if (isInjectedScript(stackMatch) && startsWith$1(stackLines[index], INJECTED_SCRIPT_STRING)) {
            return true;
          }
        }
      }
      return false;
    };
    const findHostElements = function findHostElements(rootElement) {
      const hosts = [];
      const domElems = rootElement.querySelectorAll('*');
      domElems.forEach(function (el) {
        if (el.shadowRoot) {
          hosts.push(el);
        }
      });
      return hosts;
    };
    const pierceShadowDom = function pierceShadowDom(selector, hostElements) {
      let targets = [];
      const innerHostsAcc = [];
      hostElements.forEach(function (host) {
        const simpleElems = host.querySelectorAll(selector);
        targets = targets.concat([].slice.call(simpleElems));
        const shadowRootElem = host.shadowRoot;
        const shadowChildren = shadowRootElem.querySelectorAll(selector);
        targets = targets.concat([].slice.call(shadowChildren));
        innerHostsAcc.push(findHostElements(shadowRootElem));
      });
      const innerHosts = flatten(innerHostsAcc);
      return {
        targets,
        innerHosts
      };
    };
    const isValidCallback = function isValidCallback(callback) {
      return callback instanceof Function
      || typeof callback === 'string';
    };
    const parseRawDelay = function parseRawDelay(delay) {
      const parsedDelay = Math.floor(parseInt(delay, 10));
      return typeof parsedDelay === 'number' && !nativeIsNaN(parsedDelay) ? parsedDelay : delay;
    };
    const isPreventionNeeded = function isPreventionNeeded(_ref) {
      let callback = _ref.callback,
        delay = _ref.delay,
        matchCallback = _ref.matchCallback,
        matchDelay = _ref.matchDelay;
      if (!isValidCallback(callback)) {
        return false;
      }
      if (!isValidMatchStr(matchCallback) || matchDelay && !isValidMatchNumber(matchDelay)) {
        return false;
      }
      const _parseMatchArg = parseMatchArg(matchCallback),
        isInvertedMatch = _parseMatchArg.isInvertedMatch,
        matchRegexp = _parseMatchArg.matchRegexp;
      const _parseDelayArg = parseDelayArg(matchDelay),
        isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,
        delayMatch = _parseDelayArg.delayMatch;
      const parsedDelay = parseRawDelay(delay);
      let shouldPrevent = false;
      const callbackStr = String(callback);
      if (delayMatch === null) {
        shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch;
      } else if (!matchCallback) {
        shouldPrevent = parsedDelay === delayMatch !== isInvertedDelayMatch;
      } else {
        shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch && parsedDelay === delayMatch !== isInvertedDelayMatch;
      }
      return shouldPrevent;
    };
    const handleOldReplacement = function handleOldReplacement(replacement) {
      let result;
      if (!replacement) {
        result = noopFunc;
      } else if (replacement === 'trueFunc') {
        result = trueFunc;
      } else if (replacement.indexOf('=') > -1) {
        const isProp = startsWith$1(replacement, '{') && endsWith(replacement, '}');
        if (isProp) {
          const propertyPart = replacement.slice(1, -1);
          const propertyName = substringBefore(propertyPart, '=');
          const propertyValue = substringAfter$1(propertyPart, '=');
          if (propertyValue === 'noopFunc') {
            result = {};
            result[propertyName] = noopFunc;
          }
        }
      }
      return result;
    };
    const createDecoy = function createDecoy(args) {
      const OBJECT_TAG_NAME = 'object';
      const OBJECT_URL_PROP_NAME = 'data';
      const IFRAME_TAG_NAME = 'iframe';
      const IFRAME_URL_PROP_NAME = 'src';
      const replacement = args.replacement,
        url = args.url,
        delay = args.delay;
      let tag;
      let urlProp;
      if (replacement === 'obj') {
        tag = OBJECT_TAG_NAME;
        urlProp = OBJECT_URL_PROP_NAME;
      } else {
        tag = IFRAME_TAG_NAME;
        urlProp = IFRAME_URL_PROP_NAME;
      }
      const decoy = document.createElement(tag);
      decoy[urlProp] = url;
      decoy.style.setProperty('height', '1px', 'important');
      decoy.style.setProperty('position', 'fixed', 'important');
      decoy.style.setProperty('top', '-1px', 'important');
      decoy.style.setProperty('width', '1px', 'important');
      document.body.appendChild(decoy);
      setTimeout(function () {
        return decoy.remove();
      }, delay * 1000);
      return decoy;
    };
    const getPreventGetter = function getPreventGetter(nativeGetter) {
      const preventGetter = function preventGetter(target, prop) {
        if (prop && prop === 'closed') {
          return false;
        }
        if (typeof nativeGetter === 'function') {
          return noopFunc;
        }
        return prop && target[prop];
      };
      return preventGetter;
    };
    const getNativeRegexpTest = function getNativeRegexpTest() {
      return Object.getOwnPropertyDescriptor(RegExp.prototype, 'test').value;
    };
    const getRequestProps = function getRequestProps() {
      return ['url', 'method', 'headers', 'body', 'mode', 'credentials', 'cache', 'redirect', 'referrer', 'referrerPolicy', 'integrity', 'keepalive', 'signal'];
    };
    const getRequestData = function getRequestData(request) {
      const requestInitOptions = getRequestProps();
      const entries = requestInitOptions.map(function (key) {
        const value = request[key];
        return [key, value];
      });
      return getObjectFromEntries(entries);
    };
    const getFetchData = function getFetchData(args) {
      const fetchPropsObj = {};
      let fetchUrl;
      let fetchInit;
      if (args[0] instanceof Request) {
        const requestData = getRequestData(args[0]);
        fetchUrl = requestData.url;
        fetchInit = requestData;
      } else {
        fetchUrl = args[0];
        fetchInit = args[1];
      }
      fetchPropsObj.url = fetchUrl;
      if (fetchInit instanceof Object) {
        Object.keys(fetchInit).forEach(function (prop) {
          fetchPropsObj[prop] = fetchInit[prop];
        });
      }
      return fetchPropsObj;
    };
    const getXhrData = function getXhrData(method, url, async, user, password) {
      return {
        method,
        url,
        async,
        user,
        password
      };
    };
    const parseMatchProps = function parseMatchProps(propsToMatchStr) {
      const PROPS_DIVIDER = ' ';
      const PAIRS_MARKER = ':';
      const LEGAL_MATCH_PROPS = getRequestProps();
      const propsObj = {};
      const props = propsToMatchStr.split(PROPS_DIVIDER);
      props.forEach(function (prop) {
        const dividerInd = prop.indexOf(PAIRS_MARKER);
        const key = prop.slice(0, dividerInd);
        const hasLegalMatchProp = LEGAL_MATCH_PROPS.indexOf(key) !== -1;
        if (hasLegalMatchProp) {
          const value = prop.slice(dividerInd + 1);
          propsObj[key] = value;
        } else {
          propsObj.url = prop;
        }
      });
      return propsObj;
    };
    const validateParsedData = function validateParsedData(data) {
      return Object.values(data).every(function (value) {
        return isValidStrPattern(value);
      });
    };
    const getMatchPropsData = function getMatchPropsData(data) {
      const matchData = {};
      Object.keys(data).forEach(function (key) {
        matchData[key] = toRegExp(data[key]);
      });
      return matchData;
    };
    const logMessage = function logMessage(source, message) {
      let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      const name = source.name,
        ruleText = source.ruleText,
        verbose = source.verbose;
      if (!forced && !verbose) {
        return;
      }
      const nativeConsole = console.log;
      if (!convertMessageToString) {
        nativeConsole("".concat(name, ":"), message);
        return;
      }
      let messageStr = "".concat(name, ": ").concat(message);
      if (ruleText) {
        const RULE_MARKER = '#%#//scriptlet';
        const markerIdx = ruleText.indexOf(RULE_MARKER);
        if (markerIdx > -1) {
          const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
          messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
        }
      }
      nativeConsole(messageStr);
    };
    const setStorageItem = function setStorageItem(source, storage, key, value) {
      try {
        storage.setItem(key, value);
      } catch (e) {
        const message = "Unable to set sessionStorage item due to: ".concat(e.message);
        logMessage(source, message);
      }
    };
    const getLimitedStorageItemValue = function getLimitedStorageItemValue(value) {
      if (typeof value !== 'string') {
        throw new Error('Invalid value');
      }
      let validValue;
      if (value === 'undefined') {
        validValue = undefined;
      } else if (value === 'false') {
        validValue = false;
      } else if (value === 'true') {
        validValue = true;
      } else if (value === 'null') {
        validValue = null;
      } else if (value === 'emptyArr') {
        validValue = '[]';
      } else if (value === 'emptyObj') {
        validValue = '{}';
      } else if (value === '') {
        validValue = '';
      } else if (/^\d+$/.test(value)) {
        validValue = parseFloat(value);
        if (nativeIsNaN(validValue)) {
          throw new Error('Invalid value');
        }
        if (Math.abs(validValue) > 32767) {
          throw new Error('Invalid value');
        }
      } else if (value === 'yes') {
        validValue = 'yes';
      } else if (value === 'no') {
        validValue = 'no';
      } else {
        throw new Error('Invalid value');
      }
      return validValue;
    };
    function createOnErrorHandler(rid) {
      const nativeOnError = window.onerror;
      return function onError(error) {
        if (typeof error === 'string' && error.indexOf(rid) !== -1) {
          return true;
        }
        if (nativeOnError instanceof Function) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          return nativeOnError.apply(this, [error, ...args]);
        }
        return false;
      };
    }
    function randomId() {
      return Math.random().toString(36).slice(2, 9);
    }
    function getDescriptorAddon() {
      return {
        isAbortingSuspended: false,
        isolateCallback(cb) {
          this.isAbortingSuspended = true;
          try {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            const result = cb(...args);
            this.isAbortingSuspended = false;
            return result;
          } catch (_unused) {
            const rid = randomId();
            this.isAbortingSuspended = false;
            throw new ReferenceError(rid);
          }
        }
      };
    }
    function getPropertyInChain(base, chain) {
      const pos = chain.indexOf('.');
      if (pos === -1) {
        return {
          base,
          prop: chain
        };
      }
      const prop = chain.slice(0, pos);
      if (base === null) {
        return {
          base,
          prop,
          chain
        };
      }
      const nextBase = base[prop];
      chain = chain.slice(pos + 1);
      if ((base instanceof Object || typeof base === 'object') && isEmptyObject(base)) {
        return {
          base,
          prop,
          chain
        };
      }
      if (nextBase === null) {
        return {
          base,
          prop,
          chain
        };
      }
      if (nextBase !== undefined) {
        return getPropertyInChain(nextBase, chain);
      }
      Object.defineProperty(base, prop, {
        configurable: true
      });
      return {
        base,
        prop,
        chain
      };
    }
    function getWildcardPropertyInChain(base, chain) {
      let lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      let output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      const pos = chain.indexOf('.');
      if (pos === -1) {
        if (chain === '*' || chain === '[]') {
          for (const key in base) {
            if (Object.prototype.hasOwnProperty.call(base, key)) {
              output.push({
                base,
                prop: key
              });
            }
          }
        } else {
          output.push({
            base,
            prop: chain
          });
        }
        return output;
      }
      const prop = chain.slice(0, pos);
      const shouldLookThrough = prop === '[]' && Array.isArray(base) || prop === '*' && base instanceof Object;
      if (shouldLookThrough) {
        const nextProp = chain.slice(pos + 1);
        const baseKeys = Object.keys(base);
        baseKeys.forEach(function (key) {
          const item = base[key];
          getWildcardPropertyInChain(item, nextProp, lookThrough, output);
        });
      }
      const nextBase = base[prop];
      chain = chain.slice(pos + 1);
      if (nextBase !== undefined) {
        getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
      }
      return output;
    }
    const hit = function hit(source) {
      if (source.verbose !== true) {
        return;
      }
      try {
        const log = console.log.bind(console);
        const trace = console.trace.bind(console);
        let prefix = source.ruleText || '';
        if (source.domainName) {
          const AG_SCRIPTLET_MARKER = '#%#//';
          const UBO_SCRIPTLET_MARKER = '##+js';
          let ruleStartIndex;
          if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
            ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
          } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
            ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
          }
          const rulePart = source.ruleText.slice(ruleStartIndex);
          prefix = "".concat(source.domainName).concat(rulePart);
        }
        log("".concat(prefix, " trace start"));
        if (trace) {
          trace();
        }
        log("".concat(prefix, " trace end"));
      } catch (e) {
      }
      if (typeof window.__debug === 'function') {
        window.__debug(source);
      }
    };
    const matchRequestProps = function matchRequestProps(source, propsToMatch, requestData) {
      if (propsToMatch === '' || propsToMatch === '*') {
        return true;
      }
      let isMatched;
      const parsedData = parseMatchProps(propsToMatch);
      if (!validateParsedData(parsedData)) {
        logMessage(source, "Invalid parameter: ".concat(propsToMatch));
        isMatched = false;
      } else {
        const matchData = getMatchPropsData(parsedData);
        isMatched = Object.keys(matchData).every(function (matchKey) {
          const matchValue = matchData[matchKey];
          return Object.prototype.hasOwnProperty.call(requestData, matchKey) && matchValue.test(requestData[matchKey]);
        });
      }
      return isMatched;
    };
    const matchStackTrace = function matchStackTrace(stackMatch, stackTrace) {
      if (!stackMatch || stackMatch === '') {
        return true;
      }
      if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
        return true;
      }
      const stackRegexp = toRegExp(stackMatch);
      const refinedStackTrace = stackTrace.split('\n').slice(2)
      .map(function (line) {
        return line.trim();
      })
      .join('\n');
      return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
    };
    const throttle = function throttle(cb, delay) {
      let wait = false;
      let savedArgs;
      const wrapper = function wrapper() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (wait) {
          savedArgs = args;
          return;
        }
        cb(...args);
        wait = true;
        setTimeout(function () {
          wait = false;
          if (savedArgs) {
            wrapper(...savedArgs);
            savedArgs = null;
          }
        }, delay);
      };
      return wrapper;
    };
    const observeDOMChanges = function observeDOMChanges(callback) {
      let observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      let attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      const THROTTLE_DELAY_MS = 20;
      const observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
      const connect = function connect() {
        if (attrsToObserve.length > 0) {
          observer.observe(document.documentElement, {
            childList: true,
            subtree: true,
            attributes: observeAttrs,
            attributeFilter: attrsToObserve
          });
        } else {
          observer.observe(document.documentElement, {
            childList: true,
            subtree: true,
            attributes: observeAttrs
          });
        }
      };
      const disconnect = function disconnect() {
        observer.disconnect();
      };
      function callbackWrapper() {
        disconnect();
        callback();
        connect();
      }
      connect();
    };
    const parseFlags = function parseFlags(flags) {
      const FLAGS_DIVIDER = ' ';
      const ASAP_FLAG = 'asap';
      const COMPLETE_FLAG = 'complete';
      const STAY_FLAG = 'stay';
      const VALID_FLAGS = [STAY_FLAG, ASAP_FLAG, COMPLETE_FLAG];
      const passedFlags = flags.trim().split(FLAGS_DIVIDER).filter(function (f) {
        return VALID_FLAGS.indexOf(f) !== -1;
      });
      return {
        ASAP: ASAP_FLAG,
        COMPLETE: COMPLETE_FLAG,
        STAY: STAY_FLAG,
        hasFlag(flag) {
          return passedFlags.indexOf(flag) !== -1;
        }
      };
    };
    const parseKeywordValue = function parseKeywordValue(rawValue) {
      const NOW_VALUE_KEYWORD = '$now$';
      const CURRENT_DATE_KEYWORD = '$currentDate$';
      let parsedValue = rawValue;
      if (rawValue === NOW_VALUE_KEYWORD) {
        parsedValue = Date.now().toString();
      } else if (rawValue === CURRENT_DATE_KEYWORD) {
        parsedValue = Date();
      }
      return parsedValue;
    };
    const hijackAttachShadow = function hijackAttachShadow(context, hostSelector, callback) {
      const handlerWrapper = function handlerWrapper(target, thisArg, args) {
        const shadowRoot = Reflect.apply(target, thisArg, args);
        if (thisArg && thisArg.matches(hostSelector || '*')) {
          callback(shadowRoot);
        }
        return shadowRoot;
      };
      const attachShadowHandler = {
        apply: handlerWrapper
      };
      context.Element.prototype.attachShadow = new Proxy(context.Element.prototype.attachShadow, attachShadowHandler);
    };
    function trustedClickElement$1(source, selectors) {
      let extraMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      let delay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NaN;
      if (!selectors) {
        return;
      }
      const OBSERVER_TIMEOUT_MS = 10000;
      const THROTTLE_DELAY_MS = 20;
      const STATIC_CLICK_DELAY_MS = 150;
      const COOKIE_MATCH_MARKER = 'cookie:';
      const LOCAL_STORAGE_MATCH_MARKER = 'localStorage:';
      const SELECTORS_DELIMITER = ',';
      const COOKIE_STRING_DELIMITER = ';';
      const EXTRA_MATCH_DELIMITER = /(,\s*){1}(?=!?cookie:|!?localStorage:)/;
      const sleep = function sleep(delayMs) {
        return new Promise(function (resolve) {
          return setTimeout(resolve, delayMs);
        });
      };
      let parsedDelay;
      if (delay) {
        parsedDelay = parseInt(delay, 10);
        const isValidDelay = !Number.isNaN(parsedDelay) || parsedDelay < OBSERVER_TIMEOUT_MS;
        if (!isValidDelay) {
          const message = "Passed delay '".concat(delay, "' is invalid or bigger than ").concat(OBSERVER_TIMEOUT_MS, " ms");
          logMessage(source, message);
          return;
        }
      }
      let canClick = !parsedDelay;
      const cookieMatches = [];
      const localStorageMatches = [];
      let isInvertedMatchCookie = false;
      let isInvertedMatchLocalStorage = false;
      if (extraMatch) {
        const parsedExtraMatch = extraMatch.split(EXTRA_MATCH_DELIMITER).map(function (matchStr) {
          return matchStr.trim();
        });
        parsedExtraMatch.forEach(function (matchStr) {
          if (matchStr.indexOf(COOKIE_MATCH_MARKER) > -1) {
            const _parseMatchArg = parseMatchArg(matchStr),
              isInvertedMatch = _parseMatchArg.isInvertedMatch,
              matchValue = _parseMatchArg.matchValue;
            isInvertedMatchCookie = isInvertedMatch;
            const cookieMatch = matchValue.replace(COOKIE_MATCH_MARKER, '');
            cookieMatches.push(cookieMatch);
          }
          if (matchStr.indexOf(LOCAL_STORAGE_MATCH_MARKER) > -1) {
            const _parseMatchArg2 = parseMatchArg(matchStr),
              isInvertedMatch = _parseMatchArg2.isInvertedMatch,
              matchValue = _parseMatchArg2.matchValue;
            isInvertedMatchLocalStorage = isInvertedMatch;
            const localStorageMatch = matchValue.replace(LOCAL_STORAGE_MATCH_MARKER, '');
            localStorageMatches.push(localStorageMatch);
          }
        });
      }
      if (cookieMatches.length > 0) {
        const parsedCookieMatches = parseCookieString(cookieMatches.join(COOKIE_STRING_DELIMITER));
        const parsedCookies = parseCookieString(document.cookie);
        const cookieKeys = Object.keys(parsedCookies);
        if (cookieKeys.length === 0) {
          return;
        }
        const cookiesMatched = Object.keys(parsedCookieMatches).every(function (key) {
          const valueMatch = parsedCookieMatches[key] ? toRegExp(parsedCookieMatches[key]) : null;
          const keyMatch = toRegExp(key);
          return cookieKeys.some(function (key) {
            const keysMatched = keyMatch.test(key);
            if (!keysMatched) {
              return false;
            }
            if (!valueMatch) {
              return true;
            }
            return valueMatch.test(parsedCookies[key]);
          });
        });
        const shouldRun = cookiesMatched !== isInvertedMatchCookie;
        if (!shouldRun) {
          return;
        }
      }
      if (localStorageMatches.length > 0) {
        const localStorageMatched = localStorageMatches.every(function (str) {
          const itemValue = window.localStorage.getItem(str);
          return itemValue || itemValue === '';
        });
        const shouldRun = localStorageMatched !== isInvertedMatchLocalStorage;
        if (!shouldRun) {
          return;
        }
      }
      let selectorsSequence = selectors.split(SELECTORS_DELIMITER).map(function (selector) {
        return selector.trim();
      });
      const createElementObj = function createElementObj(element) {
        return {
          element: element || null,
          clicked: false
        };
      };
      const elementsSequence = Array(selectorsSequence.length).fill(createElementObj());
      const clickElementsBySequence = async function clickElementsBySequence() {
        for (let i = 0; i < elementsSequence.length; i += 1) {
          const elementObj = elementsSequence[i];
          if (i >= 1) {
            await sleep(STATIC_CLICK_DELAY_MS);
          }
          if (!elementObj.element) {
            break;
          }
          if (!elementObj.clicked) {
            elementObj.element.click();
            elementObj.clicked = true;
          }
        }
        const allElementsClicked = elementsSequence.every(function (elementObj) {
          return elementObj.clicked === true;
        });
        if (allElementsClicked) {
          hit(source);
        }
      };
      const handleElement = function handleElement(element, i) {
        const elementObj = createElementObj(element);
        elementsSequence[i] = elementObj;
        if (canClick) {
          clickElementsBySequence();
        }
      };
      const findElements = function findElements(mutations, observer) {
        const fulfilledSelectors = [];
        selectorsSequence.forEach(function (selector, i) {
          if (!selector) {
            return;
          }
          const element = document.querySelector(selector);
          if (!element) {
            return;
          }
          handleElement(element, i);
          fulfilledSelectors.push(selector);
        });
        selectorsSequence = selectorsSequence.map(function (selector) {
          return fulfilledSelectors.indexOf(selector) === -1 ? selector : null;
        });
        const allSelectorsFulfilled = selectorsSequence.every(function (selector) {
          return selector === null;
        });
        if (allSelectorsFulfilled) {
          observer.disconnect();
        }
      };
      const observer = new MutationObserver(throttle(findElements, THROTTLE_DELAY_MS));
      observer.observe(document.documentElement, {
        attributes: true,
        childList: true,
        subtree: true
      });
      if (parsedDelay) {
        setTimeout(function () {
          clickElementsBySequence();
          canClick = true;
        }, parsedDelay);
      }
      setTimeout(function () {
        return observer.disconnect();
      }, OBSERVER_TIMEOUT_MS);
    }
    trustedClickElement$1.names = ['trusted-click-element'
    ];
    trustedClickElement$1.injections = [hit, toRegExp, parseCookieString, throttle, logMessage, parseMatchArg];
    function abortOnPropertyRead$1(source, property) {
      if (!property) {
        return;
      }
      const rid = randomId();
      const abort = function abort() {
        hit(source);
        throw new ReferenceError(rid);
      };
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        setPropertyAccess(base, prop, {
          get: abort,
          set: function set() {}
        });
      };
      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    abortOnPropertyRead$1.names = ['abort-on-property-read',
    'abort-on-property-read.js', 'ubo-abort-on-property-read.js', 'aopr.js', 'ubo-aopr.js', 'ubo-abort-on-property-read', 'ubo-aopr', 'abp-abort-on-property-read'];
    abortOnPropertyRead$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, isEmptyObject];
    function abortOnPropertyWrite$1(source, property) {
      if (!property) {
        return;
      }
      const rid = randomId();
      const abort = function abort() {
        hit(source);
        throw new ReferenceError(rid);
      };
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        setPropertyAccess(base, prop, {
          set: abort
        });
      };
      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    abortOnPropertyWrite$1.names = ['abort-on-property-write',
    'abort-on-property-write.js', 'ubo-abort-on-property-write.js', 'aopw.js', 'ubo-aopw.js', 'ubo-abort-on-property-write', 'ubo-aopw', 'abp-abort-on-property-write'];
    abortOnPropertyWrite$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, isEmptyObject];
    function preventSetTimeout$1(source, matchCallback, matchDelay) {
      const shouldLog = typeof matchCallback === 'undefined' && typeof matchDelay === 'undefined';
      const handlerWrapper = function handlerWrapper(target, thisArg, args) {
        const callback = args[0];
        const delay = args[1];
        let shouldPrevent = false;
        if (shouldLog) {
          hit(source);
          logMessage(source, "setTimeout(".concat(String(callback), ", ").concat(delay, ")"), true);
        } else {
          shouldPrevent = isPreventionNeeded({
            callback,
            delay,
            matchCallback,
            matchDelay
          });
        }
        if (shouldPrevent) {
          hit(source);
          args[0] = noopFunc;
        }
        return target.apply(thisArg, args);
      };
      const setTimeoutHandler = {
        apply: handlerWrapper
      };
      window.setTimeout = new Proxy(window.setTimeout, setTimeoutHandler);
    }
    preventSetTimeout$1.names = ['prevent-setTimeout',
    'no-setTimeout-if.js',
    'ubo-no-setTimeout-if.js', 'nostif.js',
    'ubo-nostif.js', 'ubo-no-setTimeout-if', 'ubo-nostif',
    'setTimeout-defuser.js', 'ubo-setTimeout-defuser.js', 'ubo-setTimeout-defuser', 'std.js', 'ubo-std.js', 'ubo-std'];
    preventSetTimeout$1.injections = [hit, noopFunc, isPreventionNeeded, logMessage,
    parseMatchArg, parseDelayArg, toRegExp, startsWith$1, nativeIsNaN, isValidCallback, isValidMatchStr, escapeRegExp, isValidStrPattern, nativeIsFinite, isValidMatchNumber, parseRawDelay];
    function preventSetInterval$1(source, matchCallback, matchDelay) {
      const shouldLog = typeof matchCallback === 'undefined' && typeof matchDelay === 'undefined';
      const handlerWrapper = function handlerWrapper(target, thisArg, args) {
        const callback = args[0];
        const delay = args[1];
        let shouldPrevent = false;
        if (shouldLog) {
          hit(source);
          logMessage(source, "setInterval(".concat(String(callback), ", ").concat(delay, ")"), true);
        } else {
          shouldPrevent = isPreventionNeeded({
            callback,
            delay,
            matchCallback,
            matchDelay
          });
        }
        if (shouldPrevent) {
          hit(source);
          args[0] = noopFunc;
        }
        return target.apply(thisArg, args);
      };
      const setIntervalHandler = {
        apply: handlerWrapper
      };
      window.setInterval = new Proxy(window.setInterval, setIntervalHandler);
    }
    preventSetInterval$1.names = ['prevent-setInterval',
    'no-setInterval-if.js',
    'ubo-no-setInterval-if.js', 'setInterval-defuser.js',
    'ubo-setInterval-defuser.js', 'nosiif.js',
    'ubo-nosiif.js', 'sid.js',
    'ubo-sid.js', 'ubo-no-setInterval-if', 'ubo-setInterval-defuser', 'ubo-nosiif', 'ubo-sid'];
    preventSetInterval$1.injections = [hit, noopFunc, isPreventionNeeded, logMessage,
    toRegExp, startsWith$1, nativeIsNaN, parseMatchArg, parseDelayArg, isValidCallback, isValidMatchStr, isValidStrPattern, escapeRegExp, nativeIsFinite, isValidMatchNumber, parseRawDelay];
    function preventWindowOpen$1(source) {
      let match = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '*';
      let delay = arguments.length > 2 ? arguments[2] : undefined;
      let replacement = arguments.length > 3 ? arguments[3] : undefined;
      const nativeOpen = window.open;
      const isNewSyntax = match !== '0' && match !== '1';
      const oldOpenWrapper = function oldOpenWrapper(str) {
        match = Number(match) > 0;
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        if (!isValidStrPattern(delay)) {
          logMessage(source, "Invalid parameter: ".concat(delay));
          return nativeOpen.apply(window, [str, ...args]);
        }
        const searchRegexp = toRegExp(delay);
        if (match !== searchRegexp.test(str)) {
          return nativeOpen.apply(window, [str, ...args]);
        }
        hit(source);
        return handleOldReplacement(replacement);
      };
      const newOpenWrapper = function newOpenWrapper(url) {
        const shouldLog = replacement && replacement.indexOf('log') > -1;
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        if (shouldLog) {
          const argsStr = args && args.length > 0 ? ", ".concat(args.join(', ')) : '';
          const message = "".concat(url).concat(argsStr);
          logMessage(source, message, true);
          hit(source);
        }
        let shouldPrevent = false;
        if (match === '*') {
          shouldPrevent = true;
        } else if (isValidMatchStr(match)) {
          const _parseMatchArg = parseMatchArg(match),
            isInvertedMatch = _parseMatchArg.isInvertedMatch,
            matchRegexp = _parseMatchArg.matchRegexp;
          shouldPrevent = matchRegexp.test(url) !== isInvertedMatch;
        } else {
          logMessage(source, "Invalid parameter: ".concat(match));
          shouldPrevent = false;
        }
        if (shouldPrevent) {
          const parsedDelay = parseInt(delay, 10);
          let result;
          if (nativeIsNaN(parsedDelay)) {
            result = noopNull();
          } else {
            const decoyArgs = {
              replacement,
              url,
              delay: parsedDelay
            };
            const decoy = createDecoy(decoyArgs);
            let popup = decoy.contentWindow;
            if (typeof popup === 'object' && popup !== null) {
              Object.defineProperty(popup, 'closed', {
                value: false
              });
              Object.defineProperty(popup, 'opener', {
                value: window
              });
              Object.defineProperty(popup, 'frameElement', {
                value: null
              });
            } else {
              const nativeGetter = decoy.contentWindow && decoy.contentWindow.get;
              Object.defineProperty(decoy, 'contentWindow', {
                get: getPreventGetter(nativeGetter)
              });
              popup = decoy.contentWindow;
            }
            result = popup;
          }
          hit(source);
          return result;
        }
        return nativeOpen.apply(window, [url, ...args]);
      };
      window.open = isNewSyntax ? newOpenWrapper : oldOpenWrapper;
      window.open.toString = nativeOpen.toString.bind(nativeOpen);
    }
    preventWindowOpen$1.names = ['prevent-window-open',
    'window.open-defuser.js', 'ubo-window.open-defuser.js', 'ubo-window.open-defuser', 'nowoif.js', 'ubo-nowoif.js', 'ubo-nowoif'];
    preventWindowOpen$1.injections = [hit, isValidStrPattern, escapeRegExp, isValidMatchStr, toRegExp, nativeIsNaN, parseMatchArg, handleOldReplacement, createDecoy, getPreventGetter, noopNull, logMessage, noopFunc, trueFunc, startsWith$1, endsWith, substringBefore, substringAfter$1];
    function abortCurrentInlineScript$1(source, property, search) {
      const searchRegexp = toRegExp(search);
      const rid = randomId();
      const SRC_DATA_MARKER = 'data:text/javascript;base64,';
      const getCurrentScript = function getCurrentScript() {
        if ('currentScript' in document) {
          return document.currentScript;
        }
        const scripts = document.getElementsByTagName('script');
        return scripts[scripts.length - 1];
      };
      const ourScript = getCurrentScript();
      const abort = function abort() {
        const scriptEl = getCurrentScript();
        if (!scriptEl) {
          return;
        }
        let content = scriptEl.textContent;
        try {
          const textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
          content = textContentGetter.call(scriptEl);
        } catch (e) {}
        if (content.length === 0 && typeof scriptEl.src !== 'undefined' && startsWith$1(scriptEl.src, SRC_DATA_MARKER)) {
          const encodedContent = scriptEl.src.slice(SRC_DATA_MARKER.length);
          content = window.atob(encodedContent);
        }
        if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
          hit(source);
          throw new ReferenceError(rid);
        }
      };
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        if (base instanceof Object === false && base === null) {
          const props = property.split('.');
          const propIndex = props.indexOf(prop);
          const baseName = props[propIndex - 1];
          const message = "The scriptlet had been executed before the ".concat(baseName, " was loaded.");
          logMessage(source, message);
          return;
        }
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        let currentValue = base[prop];
        let origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
        if (origDescriptor instanceof Object === false || origDescriptor.get instanceof Function === false) {
          currentValue = base[prop];
          origDescriptor = undefined;
        }
        const descriptorWrapper = Object.assign(getDescriptorAddon(), {
          currentValue,
          get() {
            if (!this.isAbortingSuspended) {
              this.isolateCallback(abort);
            }
            if (origDescriptor instanceof Object) {
              return origDescriptor.get.call(base);
            }
            return this.currentValue;
          },
          set(newValue) {
            if (!this.isAbortingSuspended) {
              this.isolateCallback(abort);
            }
            if (origDescriptor instanceof Object) {
              origDescriptor.set.call(base, newValue);
            } else {
              this.currentValue = newValue;
            }
          }
        });
        setPropertyAccess(base, prop, {
          get() {
            return descriptorWrapper.get.call(descriptorWrapper);
          },
          set(newValue) {
            descriptorWrapper.set.call(descriptorWrapper, newValue);
          }
        });
      };
      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    abortCurrentInlineScript$1.names = ['abort-current-inline-script',
    'abort-current-script.js', 'ubo-abort-current-script.js', 'acs.js', 'ubo-acs.js',
    'ubo-abort-current-script', 'ubo-acs',
    'abort-current-inline-script.js', 'ubo-abort-current-inline-script.js', 'acis.js', 'ubo-acis.js', 'ubo-abort-current-inline-script', 'ubo-acis', 'abp-abort-current-inline-script'];
    abortCurrentInlineScript$1.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, startsWith$1, createOnErrorHandler, hit, logMessage, isEmptyObject, getDescriptorAddon];
    function setConstant$1(source, property, value, stack) {
      if (!property || !matchStackTrace(stack, new Error().stack)) {
        return;
      }
      const emptyArr = noopArray();
      const emptyObj = noopObject();
      let constantValue;
      if (value === 'undefined') {
        constantValue = undefined;
      } else if (value === 'false') {
        constantValue = false;
      } else if (value === 'true') {
        constantValue = true;
      } else if (value === 'null') {
        constantValue = null;
      } else if (value === 'emptyArr') {
        constantValue = emptyArr;
      } else if (value === 'emptyObj') {
        constantValue = emptyObj;
      } else if (value === 'noopFunc') {
        constantValue = noopFunc;
      } else if (value === 'noopCallbackFunc') {
        constantValue = noopCallbackFunc;
      } else if (value === 'trueFunc') {
        constantValue = trueFunc;
      } else if (value === 'falseFunc') {
        constantValue = falseFunc;
      } else if (value === 'throwFunc') {
        constantValue = throwFunc;
      } else if (value === 'noopPromiseResolve') {
        constantValue = noopPromiseResolve;
      } else if (value === 'noopPromiseReject') {
        constantValue = noopPromiseReject;
      } else if (/^\d+$/.test(value)) {
        constantValue = parseFloat(value);
        if (nativeIsNaN(constantValue)) {
          return;
        }
        if (Math.abs(constantValue) > 32767) {
          return;
        }
      } else if (value === '-1') {
        constantValue = -1;
      } else if (value === '') {
        constantValue = '';
      } else if (value === 'yes') {
        constantValue = 'yes';
      } else if (value === 'no') {
        constantValue = 'no';
      } else {
        return;
      }
      let canceled = false;
      const mustCancel = function mustCancel(value) {
        if (canceled) {
          return canceled;
        }
        canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue && value !== null;
        return canceled;
      };
      const trapProp = function trapProp(base, prop, configurable, handler) {
        if (!handler.init(base[prop])) {
          return false;
        }
        const origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
        let prevSetter;
        if (origDescriptor instanceof Object) {
          if (!origDescriptor.configurable) {
            const message = "Property '".concat(prop, "' is not configurable");
            logMessage(source, message);
            return false;
          }
          base[prop] = constantValue;
          if (origDescriptor.set instanceof Function) {
            prevSetter = origDescriptor.set;
          }
        }
        Object.defineProperty(base, prop, {
          configurable,
          get() {
            return handler.get();
          },
          set(a) {
            if (prevSetter !== undefined) {
              prevSetter(a);
            }
            handler.set(a);
          }
        });
        return true;
      };
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        const base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        const inChainPropHandler = {
          factValue: undefined,
          init(a) {
            this.factValue = a;
            return true;
          },
          get() {
            return this.factValue;
          },
          set(a) {
            if (this.factValue === a) {
              return;
            }
            this.factValue = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          }
        };
        const endPropHandler = {
          init(a) {
            if (mustCancel(a)) {
              return false;
            }
            return true;
          },
          get() {
            return constantValue;
          },
          set(a) {
            if (!mustCancel(a)) {
              return;
            }
            constantValue = a;
          }
        };
        if (!chain) {
          const isTrapped = trapProp(base, prop, false, endPropHandler);
          if (isTrapped) {
            hit(source);
          }
          return;
        }
        if (base !== undefined && base[prop] === null) {
          trapProp(base, prop, true, inChainPropHandler);
          return;
        }
        if ((base instanceof Object || typeof base === 'object') && isEmptyObject(base)) {
          trapProp(base, prop, true, inChainPropHandler);
        }
        const propValue = owner[prop];
        if (propValue instanceof Object || typeof propValue === 'object' && propValue !== null) {
          setChainPropAccess(propValue, chain);
        }
        trapProp(base, prop, true, inChainPropHandler);
      };
      setChainPropAccess(window, property);
    }
    setConstant$1.names = ['set-constant',
    'set-constant.js', 'ubo-set-constant.js', 'set.js', 'ubo-set.js', 'ubo-set-constant', 'ubo-set', 'abp-override-property-read'];
    setConstant$1.injections = [hit, logMessage, noopArray, noopObject, noopFunc, noopCallbackFunc, trueFunc, falseFunc, throwFunc, noopPromiseReject, noopPromiseResolve, getPropertyInChain, setPropertyAccess, toRegExp, matchStackTrace, nativeIsNaN, isEmptyObject, getNativeRegexpTest,
    shouldAbortInlineOrInjectedScript];
    function removeCookie$1(source, match) {
      const matchRegexp = toRegExp(match);
      const removeCookieFromHost = function removeCookieFromHost(cookieName, hostName) {
        const cookieSpec = "".concat(cookieName, "=");
        const domain1 = "; domain=".concat(hostName);
        const domain2 = "; domain=.".concat(hostName);
        const path = '; path=/';
        const expiration = '; expires=Thu, 01 Jan 1970 00:00:00 GMT';
        document.cookie = cookieSpec + expiration;
        document.cookie = cookieSpec + domain1 + expiration;
        document.cookie = cookieSpec + domain2 + expiration;
        document.cookie = cookieSpec + path + expiration;
        document.cookie = cookieSpec + domain1 + path + expiration;
        document.cookie = cookieSpec + domain2 + path + expiration;
        hit(source);
      };
      const rmCookie = function rmCookie() {
        document.cookie.split(';').forEach(function (cookieStr) {
          const pos = cookieStr.indexOf('=');
          if (pos === -1) {
            return;
          }
          const cookieName = cookieStr.slice(0, pos).trim();
          if (!matchRegexp.test(cookieName)) {
            return;
          }
          const hostParts = document.location.hostname.split('.');
          for (let i = 0; i <= hostParts.length - 1; i += 1) {
            const hostName = hostParts.slice(i).join('.');
            if (hostName) {
              removeCookieFromHost(cookieName, hostName);
            }
          }
        });
      };
      rmCookie();
      window.addEventListener('beforeunload', rmCookie);
    }
    removeCookie$1.names = ['remove-cookie',
    'cookie-remover.js', 'ubo-cookie-remover.js', 'ubo-cookie-remover'];
    removeCookie$1.injections = [toRegExp, hit];
    function preventAddEventListener$1(source, typeSearch, listenerSearch) {
      const typeSearchRegexp = toRegExp(typeSearch);
      const listenerSearchRegexp = toRegExp(listenerSearch);
      const nativeAddEventListener = window.EventTarget.prototype.addEventListener;
      function addEventListenerWrapper(type, listener) {
        var _this$constructor;
        let shouldPrevent = false;
        if (validateType(type) && validateListener(listener)) {
          shouldPrevent = typeSearchRegexp.test(type.toString()) && listenerSearchRegexp.test(listenerToString(listener));
        }
        if (shouldPrevent) {
          hit(source);
          return undefined;
        }
        let context = this;
        if (this && ((_this$constructor = this.constructor) === null || _this$constructor === void 0 ? void 0 : _this$constructor.name) === 'Window' && this !== window) {
          context = window;
        }
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return nativeAddEventListener.apply(context, [type, listener, ...args]);
      }
      const descriptor = {
        configurable: true,
        set: function set() {},
        get: function get() {
          return addEventListenerWrapper;
        }
      };
      Object.defineProperty(window.EventTarget.prototype, 'addEventListener', descriptor);
      Object.defineProperty(window, 'addEventListener', descriptor);
      Object.defineProperty(document, 'addEventListener', descriptor);
    }
    preventAddEventListener$1.names = ['prevent-addEventListener',
    'addEventListener-defuser.js', 'ubo-addEventListener-defuser.js', 'aeld.js', 'ubo-aeld.js', 'ubo-addEventListener-defuser', 'ubo-aeld'];
    preventAddEventListener$1.injections = [hit, toRegExp, validateType, validateListener, listenerToString];
    function preventBab$2(source) {
      const nativeSetTimeout = window.setTimeout;
      const babRegex = /\.bab_elementid.$/;
      const timeoutWrapper = function timeoutWrapper(callback) {
        if (typeof callback !== 'string' || !babRegex.test(callback)) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          return nativeSetTimeout.apply(window, [callback, ...args]);
        }
        hit(source);
      };
      window.setTimeout = timeoutWrapper;
      const signatures = [['blockadblock'], ['babasbm'], [/getItem\('babn'\)/], ['getElementById', 'String.fromCharCode', 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', 'charAt', 'DOMContentLoaded', 'AdBlock', 'addEventListener', 'doScroll', 'fromCharCode', '<<2|r>>4', 'sessionStorage', 'clientWidth', 'localStorage', 'Math', 'random']];
      const check = function check(str) {
        if (typeof str !== 'string') {
          return false;
        }
        for (let i = 0; i < signatures.length; i += 1) {
          const tokens = signatures[i];
          let match = 0;
          for (let j = 0; j < tokens.length; j += 1) {
            const token = tokens[j];
            const found = token instanceof RegExp ? token.test(str) : str.indexOf(token) > -1;
            if (found) {
              match += 1;
            }
          }
          if (match / tokens.length >= 0.8) {
            return true;
          }
        }
        return false;
      };
      const nativeEval = window.eval;
      const evalWrapper = function evalWrapper(str) {
        if (!check(str)) {
          return nativeEval(str);
        }
        hit(source);
        const bodyEl = document.body;
        if (bodyEl) {
          bodyEl.style.removeProperty('visibility');
        }
        const el = document.getElementById('babasbmsgx');
        if (el) {
          el.parentNode.removeChild(el);
        }
      };
      window.eval = evalWrapper.bind(window);
    }
    preventBab$2.names = ['prevent-bab'
    ];
    preventBab$2.injections = [hit];
    function nowebrtc$1(source) {
      let propertyName = '';
      if (window.RTCPeerConnection) {
        propertyName = 'RTCPeerConnection';
      } else if (window.webkitRTCPeerConnection) {
        propertyName = 'webkitRTCPeerConnection';
      }
      if (propertyName === '') {
        return;
      }
      const rtcReplacement = function rtcReplacement(config) {
        const message = "Document tried to create an RTCPeerConnection: ".concat(convertRtcConfigToString(config));
        logMessage(source, message);
        hit(source);
      };
      rtcReplacement.prototype = {
        close: noopFunc,
        createDataChannel: noopFunc,
        createOffer: noopFunc,
        setRemoteDescription: noopFunc
      };
      const rtc = window[propertyName];
      window[propertyName] = rtcReplacement;
      if (rtc.prototype) {
        rtc.prototype.createDataChannel = function (a, b) {
          return {
            close: noopFunc,
            send: noopFunc
          };
        }.bind(null);
      }
    }
    nowebrtc$1.names = ['nowebrtc',
    'nowebrtc.js', 'ubo-nowebrtc.js', 'ubo-nowebrtc'];
    nowebrtc$1.injections = [hit, noopFunc, logMessage, convertRtcConfigToString];
    function logAddEventListener$1(source) {
      const nativeAddEventListener = window.EventTarget.prototype.addEventListener;
      function addEventListenerWrapper(type, listener) {
        var _this$constructor;
        if (validateType(type) && validateListener(listener)) {
          const message = "addEventListener(\"".concat(type, "\", ").concat(listenerToString(listener), ")");
          logMessage(source, message, true);
          hit(source);
        }
        const message = "Invalid event type or listener passed to addEventListener:\ntype: ".concat(convertTypeToString(type), "\nlistener: ").concat(convertTypeToString(listener));
        logMessage(source, message, true);
        let context = this;
        if (this && ((_this$constructor = this.constructor) === null || _this$constructor === void 0 ? void 0 : _this$constructor.name) === 'Window' && this !== window) {
          context = window;
        }
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return nativeAddEventListener.apply(context, [type, listener, ...args]);
      }
      const descriptor = {
        configurable: true,
        set: function set() {},
        get: function get() {
          return addEventListenerWrapper;
        }
      };
      Object.defineProperty(window.EventTarget.prototype, 'addEventListener', descriptor);
      Object.defineProperty(window, 'addEventListener', descriptor);
      Object.defineProperty(document, 'addEventListener', descriptor);
    }
    logAddEventListener$1.names = ['log-addEventListener',
    'addEventListener-logger.js', 'ubo-addEventListener-logger.js', 'aell.js', 'ubo-aell.js', 'ubo-addEventListener-logger', 'ubo-aell'];
    logAddEventListener$1.injections = [hit, validateType, validateListener, listenerToString, convertTypeToString, logMessage, objectToString, isEmptyObject, getObjectEntries];
    function logEval$1(source) {
      const nativeEval = window.eval;
      function evalWrapper(str) {
        hit(source);
        logMessage(source, "eval(\"".concat(str, "\")"), true);
        return nativeEval(str);
      }
      window.eval = evalWrapper;
      const nativeFunction = window.Function;
      function FunctionWrapper() {
        hit(source);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        logMessage(source, "new Function(".concat(args.join(', '), ")"), true);
        return nativeFunction.apply(this, [...args]);
      }
      FunctionWrapper.prototype = Object.create(nativeFunction.prototype);
      FunctionWrapper.prototype.constructor = FunctionWrapper;
      window.Function = FunctionWrapper;
    }
    logEval$1.names = ['log-eval'];
    logEval$1.injections = [hit, logMessage];
    function log$1() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      console.log(args);
    }
    log$1.names = ['log'];
    function noeval$1(source) {
      window.eval = function evalWrapper(s) {
        hit(source);
        logMessage(source, "AdGuard has prevented eval:\n".concat(s), true);
      }.bind();
    }
    noeval$1.names = ['noeval',
    'noeval.js', 'silent-noeval.js', 'ubo-noeval.js', 'ubo-silent-noeval.js', 'ubo-noeval', 'ubo-silent-noeval'];
    noeval$1.injections = [hit, logMessage];
    function preventEvalIf$1(source, search) {
      const searchRegexp = toRegExp(search);
      const nativeEval = window.eval;
      window.eval = function (payload) {
        if (!searchRegexp.test(payload.toString())) {
          return nativeEval.call(window, payload);
        }
        hit(source);
        return undefined;
      }.bind(window);
    }
    preventEvalIf$1.names = ['prevent-eval-if',
    'noeval-if.js', 'ubo-noeval-if.js', 'ubo-noeval-if'];
    preventEvalIf$1.injections = [toRegExp, hit];
    function preventFab$1(source) {
      hit(source);
      const Fab = function Fab() {};
      Fab.prototype.check = noopFunc;
      Fab.prototype.clearEvent = noopFunc;
      Fab.prototype.emitEvent = noopFunc;
      Fab.prototype.on = function (a, b) {
        if (!a) {
          b();
        }
        return this;
      };
      Fab.prototype.onDetected = noopThis;
      Fab.prototype.onNotDetected = function (a) {
        a();
        return this;
      };
      Fab.prototype.setOption = noopFunc;
      Fab.prototype.options = {
        set: noopFunc,
        get: noopFunc
      };
      const fab = new Fab();
      const getSetFab = {
        get() {
          return Fab;
        },
        set() {}
      };
      const getsetfab = {
        get() {
          return fab;
        },
        set() {}
      };
      if (Object.prototype.hasOwnProperty.call(window, 'FuckAdBlock')) {
        window.FuckAdBlock = Fab;
      } else {
        Object.defineProperty(window, 'FuckAdBlock', getSetFab);
      }
      if (Object.prototype.hasOwnProperty.call(window, 'BlockAdBlock')) {
        window.BlockAdBlock = Fab;
      } else {
        Object.defineProperty(window, 'BlockAdBlock', getSetFab);
      }
      if (Object.prototype.hasOwnProperty.call(window, 'SniffAdBlock')) {
        window.SniffAdBlock = Fab;
      } else {
        Object.defineProperty(window, 'SniffAdBlock', getSetFab);
      }
      if (Object.prototype.hasOwnProperty.call(window, 'fuckAdBlock')) {
        window.fuckAdBlock = fab;
      } else {
        Object.defineProperty(window, 'fuckAdBlock', getsetfab);
      }
      if (Object.prototype.hasOwnProperty.call(window, 'blockAdBlock')) {
        window.blockAdBlock = fab;
      } else {
        Object.defineProperty(window, 'blockAdBlock', getsetfab);
      }
      if (Object.prototype.hasOwnProperty.call(window, 'sniffAdBlock')) {
        window.sniffAdBlock = fab;
      } else {
        Object.defineProperty(window, 'sniffAdBlock', getsetfab);
      }
    }
    preventFab$1.names = ['prevent-fab-3.2.0',
    'nofab.js', 'ubo-nofab.js', 'fuckadblock.js-3.2.0', 'ubo-fuckadblock.js-3.2.0', 'ubo-nofab'];
    preventFab$1.injections = [hit, noopFunc, noopThis];
    function setPopadsDummy$1(source) {
      delete window.PopAds;
      delete window.popns;
      Object.defineProperties(window, {
        PopAds: {
          get: function get() {
            hit(source);
            return {};
          }
        },
        popns: {
          get: function get() {
            hit(source);
            return {};
          }
        }
      });
    }
    setPopadsDummy$1.names = ['set-popads-dummy',
    'popads-dummy.js', 'ubo-popads-dummy.js', 'ubo-popads-dummy'];
    setPopadsDummy$1.injections = [hit];
    function preventPopadsNet$1(source) {
      const rid = randomId();
      const throwError = function throwError() {
        throw new ReferenceError(rid);
      };
      delete window.PopAds;
      delete window.popns;
      Object.defineProperties(window, {
        PopAds: {
          set: throwError
        },
        popns: {
          set: throwError
        }
      });
      window.onerror = createOnErrorHandler(rid).bind();
      hit(source);
    }
    preventPopadsNet$1.names = ['prevent-popads-net',
    'popads.net.js', 'ubo-popads.net.js', 'ubo-popads.net'];
    preventPopadsNet$1.injections = [createOnErrorHandler, randomId, hit];
    function preventAdfly$1(source) {
      const isDigit = function isDigit(data) {
        return /^\d$/.test(data);
      };
      const handler = function handler(encodedURL) {
        let evenChars = '';
        let oddChars = '';
        for (let i = 0; i < encodedURL.length; i += 1) {
          if (i % 2 === 0) {
            evenChars += encodedURL.charAt(i);
          } else {
            oddChars = encodedURL.charAt(i) + oddChars;
          }
        }
        let data = (evenChars + oddChars).split('');
        for (let i = 0; i < data.length; i += 1) {
          if (isDigit(data[i])) {
            for (let ii = i + 1; ii < data.length; ii += 1) {
              if (isDigit(data[ii])) {
                const temp = parseInt(data[i], 10) ^ parseInt(data[ii], 10);
                if (temp < 10) {
                  data[i] = temp.toString();
                }
                i = ii;
                break;
              }
            }
          }
        }
        data = data.join('');
        const decodedURL = window.atob(data).slice(16, -16);
        if (window.stop) {
          window.stop();
        }
        window.onbeforeunload = null;
        window.location.href = decodedURL;
      };
      let val;
      let applyHandler = true;
      const result = setPropertyAccess(window, 'ysmm', {
        configurable: false,
        set: function set(value) {
          if (applyHandler) {
            applyHandler = false;
            try {
              if (typeof value === 'string') {
                handler(value);
              }
            } catch (err) {}
          }
          val = value;
        },
        get: function get() {
          return val;
        }
      });
      if (result) {
        hit(source);
      } else {
        logMessage(source, 'Failed to set up prevent-adfly scriptlet');
      }
    }
    preventAdfly$1.names = ['prevent-adfly',
    'adfly-defuser.js', 'ubo-adfly-defuser.js', 'ubo-adfly-defuser'];
    preventAdfly$1.injections = [setPropertyAccess, hit, logMessage];
    function debugOnPropertyRead$1(source, property) {
      if (!property) {
        return;
      }
      const rid = randomId();
      const abort = function abort() {
        hit(source);
        debugger;
      };
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        setPropertyAccess(base, prop, {
          get: abort,
          set: noopFunc
        });
      };
      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    debugOnPropertyRead$1.names = ['debug-on-property-read'];
    debugOnPropertyRead$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, noopFunc, isEmptyObject];
    function debugOnPropertyWrite$1(source, property) {
      if (!property) {
        return;
      }
      const rid = randomId();
      const abort = function abort() {
        hit(source);
        debugger;
      };
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        setPropertyAccess(base, prop, {
          set: abort
        });
      };
      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    debugOnPropertyWrite$1.names = ['debug-on-property-write'];
    debugOnPropertyWrite$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, isEmptyObject];
    function debugCurrentInlineScript$1(source, property, search) {
      const searchRegexp = toRegExp(search);
      const rid = randomId();
      const getCurrentScript = function getCurrentScript() {
        if ('currentScript' in document) {
          return document.currentScript;
        }
        const scripts = document.getElementsByTagName('script');
        return scripts[scripts.length - 1];
      };
      const ourScript = getCurrentScript();
      const abort = function abort() {
        const scriptEl = getCurrentScript();
        if (!scriptEl) {
          return;
        }
        let content = scriptEl.textContent;
        try {
          const textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
          content = textContentGetter.call(scriptEl);
        } catch (e) {}
        if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
          hit(source);
          debugger;
        }
      };
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        if (base instanceof Object === false && base === null) {
          const props = property.split('.');
          const propIndex = props.indexOf(prop);
          const baseName = props[propIndex - 1];
          const message = "The scriptlet had been executed before the ".concat(baseName, " was loaded.");
          logMessage(message, source.verbose);
          return;
        }
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        let currentValue = base[prop];
        setPropertyAccess(base, prop, {
          set: function set(value) {
            abort();
            currentValue = value;
          },
          get: function get() {
            abort();
            return currentValue;
          }
        });
      };
      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    debugCurrentInlineScript$1.names = ['debug-current-inline-script'];
    debugCurrentInlineScript$1.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, createOnErrorHandler, hit, logMessage, isEmptyObject];
    function removeAttr$1(source, attrs, selector) {
      let applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'asap stay';
      if (!attrs) {
        return;
      }
      attrs = attrs.split(/\s*\|\s*/);
      if (!selector) {
        selector = "[".concat(attrs.join('],['), "]");
      }
      const rmattr = function rmattr() {
        let nodes = [];
        try {
          nodes = [].slice.call(document.querySelectorAll(selector));
        } catch (e) {
          logMessage(source, "Invalid selector arg: '".concat(selector, "'"));
        }
        let removed = false;
        nodes.forEach(function (node) {
          attrs.forEach(function (attr) {
            node.removeAttribute(attr);
            removed = true;
          });
        });
        if (removed) {
          hit(source);
        }
      };
      const flags = parseFlags(applying);
      const run = function run() {
        rmattr();
        if (!flags.hasFlag(flags.STAY)) {
          return;
        }
        observeDOMChanges(rmattr, true);
      };
      if (flags.hasFlag(flags.ASAP)) {
        if (document.readyState === 'loading') {
          window.addEventListener('DOMContentLoaded', rmattr, {
            once: true
          });
        } else {
          rmattr();
        }
      }
      if (document.readyState !== 'complete' && flags.hasFlag(flags.COMPLETE)) {
        window.addEventListener('load', run, {
          once: true
        });
      } else if (flags.hasFlag(flags.STAY)) {
        if (!applying.indexOf(' ') !== -1) {
          rmattr();
        }
        observeDOMChanges(rmattr, true);
      }
    }
    removeAttr$1.names = ['remove-attr',
    'remove-attr.js', 'ubo-remove-attr.js', 'ra.js', 'ubo-ra.js', 'ubo-remove-attr', 'ubo-ra'];
    removeAttr$1.injections = [hit, observeDOMChanges, parseFlags, logMessage,
    throttle];
    function setAttr$1(source, selector, attr) {
      let value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      if (!selector || !attr) {
        return;
      }
      const allowedValues = ['true', 'false'];
      if (value.length !== 0 && (nativeIsNaN(parseInt(value, 10)) || parseInt(value, 10) < 0 || parseInt(value, 10) > 32767) && !allowedValues.includes(value.toLowerCase())) {
        return;
      }
      const setAttr = function setAttr() {
        const nodes = [].slice.call(document.querySelectorAll(selector));
        let set = false;
        nodes.forEach(function (node) {
          node.setAttribute(attr, value);
          set = true;
        });
        if (set) {
          hit(source);
        }
      };
      setAttr();
      observeDOMChanges(setAttr, true);
    }
    setAttr$1.names = ['set-attr'];
    setAttr$1.injections = [hit, observeDOMChanges, nativeIsNaN,
    throttle];
    function removeClass$1(source, classNames, selector) {
      let applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'asap stay';
      if (!classNames) {
        return;
      }
      classNames = classNames.split(/\s*\|\s*/);
      let selectors = [];
      if (!selector) {
        selectors = classNames.map(function (className) {
          return ".".concat(className);
        });
      }
      const removeClassHandler = function removeClassHandler() {
        const nodes = new Set();
        if (selector) {
          let foundNodes = [];
          try {
            foundNodes = [].slice.call(document.querySelectorAll(selector));
          } catch (e) {
            logMessage(source, "Invalid selector arg: '".concat(selector, "'"));
          }
          foundNodes.forEach(function (n) {
            return nodes.add(n);
          });
        } else if (selectors.length > 0) {
          selectors.forEach(function (s) {
            const elements = document.querySelectorAll(s);
            for (let i = 0; i < elements.length; i += 1) {
              const element = elements[i];
              nodes.add(element);
            }
          });
        }
        let removed = false;
        nodes.forEach(function (node) {
          classNames.forEach(function (className) {
            if (node.classList.contains(className)) {
              node.classList.remove(className);
              removed = true;
            }
          });
        });
        if (removed) {
          hit(source);
        }
      };
      const CLASS_ATTR_NAME = ['class'];
      const flags = parseFlags(applying);
      const run = function run() {
        removeClassHandler();
        if (!flags.hasFlag(flags.STAY)) {
          return;
        }
        observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
      };
      if (flags.hasFlag(flags.ASAP)) {
        if (document.readyState === 'loading') {
          window.addEventListener('DOMContentLoaded', removeClassHandler, {
            once: true
          });
        } else {
          removeClassHandler();
        }
      }
      if (document.readyState !== 'complete' && flags.hasFlag(flags.COMPLETE)) {
        window.addEventListener('load', run, {
          once: true
        });
      } else if (flags.hasFlag(flags.STAY)) {
        if (!applying.indexOf(' ') !== -1) {
          removeClassHandler();
        }
        observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
      }
    }
    removeClass$1.names = ['remove-class',
    'remove-class.js', 'ubo-remove-class.js', 'rc.js', 'ubo-rc.js', 'ubo-remove-class', 'ubo-rc'];
    removeClass$1.injections = [hit, logMessage, observeDOMChanges, parseFlags,
    throttle];
    function disableNewtabLinks$1(source) {
      document.addEventListener('click', function (ev) {
        let target = ev.target;
        while (target !== null) {
          if (target.localName === 'a' && target.hasAttribute('target')) {
            ev.stopPropagation();
            ev.preventDefault();
            hit(source);
            break;
          }
          target = target.parentNode;
        }
      });
    }
    disableNewtabLinks$1.names = ['disable-newtab-links',
    'disable-newtab-links.js', 'ubo-disable-newtab-links.js', 'ubo-disable-newtab-links'];
    disableNewtabLinks$1.injections = [hit];
    function adjustSetInterval$1(source, matchCallback, matchDelay, boost) {
      const nativeSetInterval = window.setInterval;
      const matchRegexp = toRegExp(matchCallback);
      const intervalWrapper = function intervalWrapper(callback, delay) {
        if (!isValidCallback(callback)) {
          const message = "Scriptlet can't be applied because of invalid callback: '".concat(String(callback), "'");
          logMessage(source, message);
        } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
          delay *= getBoostMultiplier(boost);
          hit(source);
        }
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return nativeSetInterval.apply(window, [callback, delay, ...args]);
      };
      window.setInterval = intervalWrapper;
    }
    adjustSetInterval$1.names = ['adjust-setInterval',
    'nano-setInterval-booster.js', 'ubo-nano-setInterval-booster.js', 'nano-sib.js', 'ubo-nano-sib.js', 'ubo-nano-setInterval-booster', 'ubo-nano-sib'];
    adjustSetInterval$1.injections = [hit, isValidCallback, toRegExp, getBoostMultiplier, isDelayMatched, logMessage,
    nativeIsNaN, nativeIsFinite, getMatchDelay, shouldMatchAnyDelay];
    function adjustSetTimeout$1(source, matchCallback, matchDelay, boost) {
      const nativeSetTimeout = window.setTimeout;
      const matchRegexp = toRegExp(matchCallback);
      const timeoutWrapper = function timeoutWrapper(callback, delay) {
        if (!isValidCallback(callback)) {
          const message = "Scriptlet can't be applied because of invalid callback: '".concat(String(callback), "'");
          logMessage(source, message);
        } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
          delay *= getBoostMultiplier(boost);
          hit(source);
        }
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return nativeSetTimeout.apply(window, [callback, delay, ...args]);
      };
      window.setTimeout = timeoutWrapper;
    }
    adjustSetTimeout$1.names = ['adjust-setTimeout',
    'nano-setTimeout-booster.js', 'ubo-nano-setTimeout-booster.js', 'nano-stb.js', 'ubo-nano-stb.js', 'ubo-nano-setTimeout-booster', 'ubo-nano-stb'];
    adjustSetTimeout$1.injections = [hit, isValidCallback, toRegExp, getBoostMultiplier, isDelayMatched, logMessage,
    nativeIsNaN, nativeIsFinite, getMatchDelay, shouldMatchAnyDelay];
    function dirString$1(source, times) {
      const _console = console,
        dir = _console.dir;
      function dirWrapper(object) {
        if (typeof dir === 'function') {
          dir.call(this, object);
        }
        hit(source);
      }
      console.dir = dirWrapper;
    }
    dirString$1.names = ['dir-string', 'abp-dir-string'];
    dirString$1.injections = [hit];
    function jsonPrune$1(source, propsToRemove, requiredInitialProps, stack) {
      if (!!stack && !matchStackTrace(stack, new Error().stack)) {
        return;
      }
      const prunePaths = propsToRemove !== undefined && propsToRemove !== '' ? propsToRemove.split(/ +/) : [];
      const requiredPaths = requiredInitialProps !== undefined && requiredInitialProps !== '' ? requiredInitialProps.split(/ +/) : [];
      function isPruningNeeded(root) {
        if (!root) {
          return false;
        }
        let shouldProcess;
        if (prunePaths.length === 0 && requiredPaths.length > 0) {
          const rootString = JSON.stringify(root);
          const matchRegex = toRegExp(requiredPaths.join(''));
          const shouldLog = matchRegex.test(rootString);
          if (shouldLog) {
            logMessage(source, "".concat(window.location.hostname, "\n").concat(JSON.stringify(root, null, 2)), true);
            if (root && typeof root === 'object') {
              logMessage(source, root, true, false);
            }
            shouldProcess = false;
            return shouldProcess;
          }
        }
        for (let i = 0; i < requiredPaths.length; i += 1) {
          const requiredPath = requiredPaths[i];
          const lastNestedPropName = requiredPath.split('.').pop();
          const hasWildcard = requiredPath.indexOf('.*.') > -1 || requiredPath.indexOf('*.') > -1 || requiredPath.indexOf('.*') > -1 || requiredPath.indexOf('.[].') > -1 || requiredPath.indexOf('[].') > -1 || requiredPath.indexOf('.[]') > -1;
          const details = getWildcardPropertyInChain(root, requiredPath, hasWildcard);
          shouldProcess = !hasWildcard;
          for (let i = 0; i < details.length; i += 1) {
            if (hasWildcard) {
              shouldProcess = !(details[i].base[lastNestedPropName] === undefined) || shouldProcess;
            } else {
              shouldProcess = !(details[i].base[lastNestedPropName] === undefined) && shouldProcess;
            }
          }
        }
        return shouldProcess;
      }
      const jsonPruner = function jsonPruner(root) {
        if (prunePaths.length === 0 && requiredPaths.length === 0) {
          logMessage(source, "".concat(window.location.hostname, "\n").concat(JSON.stringify(root, null, 2)), true);
          if (root && typeof root === 'object') {
            logMessage(source, root, true, false);
          }
          return root;
        }
        try {
          if (isPruningNeeded(root) === false) {
            return root;
          }
          prunePaths.forEach(function (path) {
            const ownerObjArr = getWildcardPropertyInChain(root, path, true);
            ownerObjArr.forEach(function (ownerObj) {
              if (ownerObj !== undefined && ownerObj.base) {
                delete ownerObj.base[ownerObj.prop];
                hit(source);
              }
            });
          });
        } catch (e) {
          logMessage(source, e);
        }
        return root;
      };
      const nativeJSONParse = JSON.parse;
      const jsonParseWrapper = function jsonParseWrapper() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        const root = nativeJSONParse.apply(JSON, args);
        return jsonPruner(root);
      };
      jsonParseWrapper.toString = nativeJSONParse.toString.bind(nativeJSONParse);
      JSON.parse = jsonParseWrapper;
      const nativeResponseJson = Response.prototype.json;
      const responseJsonWrapper = function responseJsonWrapper() {
        const promise = nativeResponseJson.apply(this);
        return promise.then(function (obj) {
          return jsonPruner(obj);
        });
      };
      if (typeof Response === 'undefined') {
        return;
      }
      Response.prototype.json = responseJsonWrapper;
    }
    jsonPrune$1.names = ['json-prune',
    'json-prune.js', 'ubo-json-prune.js', 'ubo-json-prune', 'abp-json-prune'];
    jsonPrune$1.injections = [hit, matchStackTrace, getWildcardPropertyInChain, logMessage,
    toRegExp, getNativeRegexpTest, shouldAbortInlineOrInjectedScript];
    function preventRequestAnimationFrame$1(source, match) {
      const nativeRequestAnimationFrame = window.requestAnimationFrame;
      const shouldLog = typeof match === 'undefined';
      const _parseMatchArg = parseMatchArg(match),
        isInvertedMatch = _parseMatchArg.isInvertedMatch,
        matchRegexp = _parseMatchArg.matchRegexp;
      const rafWrapper = function rafWrapper(callback) {
        let shouldPrevent = false;
        if (shouldLog) {
          hit(source);
          logMessage(source, "requestAnimationFrame(".concat(String(callback), ")"), true);
        } else if (isValidCallback(callback) && isValidStrPattern(match)) {
          shouldPrevent = matchRegexp.test(callback.toString()) !== isInvertedMatch;
        }
        if (shouldPrevent) {
          hit(source);
          return nativeRequestAnimationFrame(noopFunc);
        }
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return nativeRequestAnimationFrame.apply(window, [callback, ...args]);
      };
      window.requestAnimationFrame = rafWrapper;
    }
    preventRequestAnimationFrame$1.names = ['prevent-requestAnimationFrame',
    'no-requestAnimationFrame-if.js', 'ubo-no-requestAnimationFrame-if.js', 'norafif.js', 'ubo-norafif.js', 'ubo-no-requestAnimationFrame-if', 'ubo-norafif'];
    preventRequestAnimationFrame$1.injections = [hit, noopFunc, parseMatchArg, isValidStrPattern, isValidCallback, logMessage,
    escapeRegExp, toRegExp, startsWith$1];
    function setCookie$1(source, name, value) {
      let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';
      const validValue = getLimitedCookieValue(value);
      if (validValue === null) {
        logMessage(source, "Invalid cookie value: '".concat(validValue, "'"));
        return;
      }
      if (!isValidCookiePath(path)) {
        logMessage(source, "Invalid cookie path: '".concat(path, "'"));
        return;
      }
      const cookieToSet = concatCookieNameValuePath(name, validValue, path);
      if (!cookieToSet) {
        return;
      }
      hit(source);
      document.cookie = cookieToSet;
    }
    setCookie$1.names = ['set-cookie'];
    setCookie$1.injections = [hit, logMessage, nativeIsNaN, isCookieSetWithValue, getLimitedCookieValue, concatCookieNameValuePath, isValidCookiePath, getCookiePath];
    function setCookieReload$1(source, name, value) {
      let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';
      if (isCookieSetWithValue(document.cookie, name, value)) {
        return;
      }
      const validValue = getLimitedCookieValue(value);
      if (validValue === null) {
        logMessage(source, "Invalid cookie value: '".concat(value, "'"));
        return;
      }
      if (!isValidCookiePath(path)) {
        logMessage(source, "Invalid cookie path: '".concat(path, "'"));
        return;
      }
      const cookieToSet = concatCookieNameValuePath(name, validValue, path);
      if (!cookieToSet) {
        return;
      }
      document.cookie = cookieToSet;
      hit(source);
      if (isCookieSetWithValue(document.cookie, name, value)) {
        window.location.reload();
      }
    }
    setCookieReload$1.names = ['set-cookie-reload'];
    setCookieReload$1.injections = [hit, logMessage, nativeIsNaN, isCookieSetWithValue, getLimitedCookieValue, concatCookieNameValuePath, isValidCookiePath, getCookiePath];
    function hideInShadowDom$1(source, selector, baseSelector) {
      if (!Element.prototype.attachShadow) {
        return;
      }
      const hideElement = function hideElement(targetElement) {
        const DISPLAY_NONE_CSS = 'display:none!important;';
        targetElement.style.cssText = DISPLAY_NONE_CSS;
      };
      const hideHandler = function hideHandler() {
        let hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
        while (hostElements.length !== 0) {
          let isHidden = false;
          const _pierceShadowDom = pierceShadowDom(selector, hostElements),
            targets = _pierceShadowDom.targets,
            innerHosts = _pierceShadowDom.innerHosts;
          targets.forEach(function (targetEl) {
            hideElement(targetEl);
            isHidden = true;
          });
          if (isHidden) {
            hit(source);
          }
          hostElements = innerHosts;
        }
      };
      hideHandler();
      observeDOMChanges(hideHandler, true);
    }
    hideInShadowDom$1.names = ['hide-in-shadow-dom'];
    hideInShadowDom$1.injections = [hit, observeDOMChanges, findHostElements, pierceShadowDom,
    flatten, throttle];
    function removeInShadowDom$1(source, selector, baseSelector) {
      if (!Element.prototype.attachShadow) {
        return;
      }
      const removeElement = function removeElement(targetElement) {
        targetElement.remove();
      };
      const removeHandler = function removeHandler() {
        let hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
        while (hostElements.length !== 0) {
          let isRemoved = false;
          const _pierceShadowDom = pierceShadowDom(selector, hostElements),
            targets = _pierceShadowDom.targets,
            innerHosts = _pierceShadowDom.innerHosts;
          targets.forEach(function (targetEl) {
            removeElement(targetEl);
            isRemoved = true;
          });
          if (isRemoved) {
            hit(source);
          }
          hostElements = innerHosts;
        }
      };
      removeHandler();
      observeDOMChanges(removeHandler, true);
    }
    removeInShadowDom$1.names = ['remove-in-shadow-dom'];
    removeInShadowDom$1.injections = [hit, observeDOMChanges, findHostElements, pierceShadowDom,
    flatten, throttle];
    function preventFetch$1(source, propsToMatch) {
      let responseBody = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'emptyObj';
      let responseType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'default';
      if (typeof fetch === 'undefined' || typeof Proxy === 'undefined' || typeof Response === 'undefined') {
        return;
      }
      let strResponseBody;
      if (responseBody === '' || responseBody === 'emptyObj') {
        strResponseBody = '{}';
      } else if (responseBody === 'emptyArr') {
        strResponseBody = '[]';
      } else {
        return;
      }
      if (!(responseType === 'default' || responseType === 'opaque')) {
        logMessage(source, "Invalid parameter: ".concat(responseType));
        return;
      }
      const handlerWrapper = function handlerWrapper(target, thisArg, args) {
        let shouldPrevent = false;
        const fetchData = getFetchData(args);
        if (typeof propsToMatch === 'undefined') {
          logMessage(source, "fetch( ".concat(objectToString(fetchData), " )"), true);
          hit(source);
          return Reflect.apply(target, thisArg, args);
        }
        shouldPrevent = matchRequestProps(source, propsToMatch, fetchData);
        if (shouldPrevent) {
          hit(source);
          return noopPromiseResolve(strResponseBody, fetchData.url, responseType);
        }
        return Reflect.apply(target, thisArg, args);
      };
      const fetchHandler = {
        apply: handlerWrapper
      };
      fetch = new Proxy(fetch, fetchHandler);
    }
    preventFetch$1.names = ['prevent-fetch',
    'no-fetch-if.js', 'ubo-no-fetch-if.js', 'ubo-no-fetch-if'];
    preventFetch$1.injections = [hit, getFetchData, objectToString, noopPromiseResolve, matchRequestProps, logMessage, toRegExp, isValidStrPattern, escapeRegExp, isEmptyObject, getRequestData, getRequestProps, getObjectEntries, getObjectFromEntries, parseMatchProps, validateParsedData, getMatchPropsData];
    function setLocalStorageItem$1(source, key, value) {
      if (typeof key === 'undefined') {
        logMessage(source, 'Item key should be specified.');
        return;
      }
      let validValue;
      try {
        validValue = getLimitedStorageItemValue(value);
      } catch (_unused) {
        logMessage(source, "Invalid storage item value: '".concat(value, "'"));
        return;
      }
      const _window = window,
        localStorage = _window.localStorage;
      setStorageItem(source, localStorage, key, validValue);
      hit(source);
    }
    setLocalStorageItem$1.names = ['set-local-storage-item'];
    setLocalStorageItem$1.injections = [hit, logMessage, nativeIsNaN, setStorageItem, getLimitedStorageItemValue];
    function setSessionStorageItem$1(source, key, value) {
      if (typeof key === 'undefined') {
        logMessage(source, 'Item key should be specified.');
        return;
      }
      let validValue;
      try {
        validValue = getLimitedStorageItemValue(value);
      } catch (_unused) {
        logMessage(source, "Invalid storage item value: '".concat(value, "'"));
        return;
      }
      const _window = window,
        sessionStorage = _window.sessionStorage;
      setStorageItem(source, sessionStorage, key, validValue);
      hit(source);
    }
    setSessionStorageItem$1.names = ['set-session-storage-item'];
    setSessionStorageItem$1.injections = [hit, logMessage, nativeIsNaN, setStorageItem, getLimitedStorageItemValue];
    function abortOnStackTrace$1(source, property, stack) {
      if (!property || !stack) {
        return;
      }
      const rid = randomId();
      const abort = function abort() {
        hit(source);
        throw new ReferenceError(rid);
      };
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        if (!stack.match(/^(inlineScript|injectedScript)$/) && !isValidStrPattern(stack)) {
          logMessage(source, "Invalid parameter: ".concat(stack));
          return;
        }
        const descriptorWrapper = Object.assign(getDescriptorAddon(), {
          value: base[prop],
          get() {
            if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
              abort();
            }
            return this.value;
          },
          set(newValue) {
            if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
              abort();
            }
            this.value = newValue;
          }
        });
        setPropertyAccess(base, prop, {
          get() {
            return descriptorWrapper.get.call(descriptorWrapper);
          },
          set(newValue) {
            descriptorWrapper.set.call(descriptorWrapper, newValue);
          }
        });
      };
      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    abortOnStackTrace$1.names = ['abort-on-stack-trace',
    'abort-on-stack-trace.js', 'ubo-abort-on-stack-trace.js', 'aost.js', 'ubo-aost.js', 'ubo-abort-on-stack-trace', 'ubo-aost', 'abp-abort-on-stack-trace'];
    abortOnStackTrace$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, isValidStrPattern, escapeRegExp, matchStackTrace, getDescriptorAddon, logMessage, toRegExp, isEmptyObject, getNativeRegexpTest, startsWith$1, shouldAbortInlineOrInjectedScript];
    function logOnStacktrace$1(source, property) {
      if (!property) {
        return;
      }
      const refineStackTrace = function refineStackTrace(stackString) {
        const stackSteps = stackString.split('\n').slice(2).map(function (line) {
          return line.replace(/ {4}at /, '');
        });
        const logInfoArray = stackSteps.map(function (line) {
          let funcName;
          let funcFullPath;
          const reg = /\(([^\)]+)\)/;
          const regFirefox = /(.*?@)(\S+)(:\d+):\d+\)?$/;
          if (line.match(reg)) {
            funcName = line.split(' ').slice(0, -1).join(' ');
            funcFullPath = line.match(reg)[1];
          } else if (line.match(regFirefox)) {
            funcName = line.split('@').slice(0, -1).join(' ');
            funcFullPath = line.match(regFirefox)[2];
          } else {
            funcName = 'function name is not available';
            funcFullPath = line;
          }
          return [funcName, funcFullPath];
        });
        const logInfoObject = {};
        logInfoArray.forEach(function (pair) {
          logInfoObject[pair[0]] = pair[1];
        });
        return logInfoObject;
      };
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        let base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        if (chain) {
          const setter = function setter(a) {
            base = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };
          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }
        let value = base[prop];
        setPropertyAccess(base, prop, {
          get() {
            hit(source);
            logMessage(source, "Get ".concat(prop), true);
            console.table(refineStackTrace(new Error().stack));
            return value;
          },
          set(newValue) {
            hit(source);
            logMessage(source, "Set ".concat(prop), true);
            console.table(refineStackTrace(new Error().stack));
            value = newValue;
          }
        });
      };
      setChainPropAccess(window, property);
    }
    logOnStacktrace$1.names = ['log-on-stack-trace'];
    logOnStacktrace$1.injections = [getPropertyInChain, setPropertyAccess, hit, logMessage, isEmptyObject];
    function preventXHR$1(source, propsToMatch, customResponseText) {
      if (typeof Proxy === 'undefined') {
        return;
      }
      let response = '';
      let responseText = '';
      let responseUrl;
      const openWrapper = function openWrapper(target, thisArg, args) {
        const xhrData = {
          method: args[0],
          url: args[1]
        };
        responseUrl = xhrData.url;
        if (typeof propsToMatch === 'undefined') {
          logMessage(source, "xhr( ".concat(objectToString(xhrData), " )"), true);
          hit(source);
        } else if (matchRequestProps(source, propsToMatch, xhrData)) {
          thisArg.shouldBePrevented = true;
        }
        return Reflect.apply(target, thisArg, args);
      };
      const sendWrapper = function sendWrapper(target, thisArg, args) {
        if (!thisArg.shouldBePrevented) {
          return Reflect.apply(target, thisArg, args);
        }
        if (thisArg.responseType === 'blob') {
          response = new Blob();
        }
        if (thisArg.responseType === 'arraybuffer') {
          response = new ArrayBuffer();
        }
        if (customResponseText) {
          const randomText = generateRandomResponse(customResponseText);
          if (randomText) {
            responseText = randomText;
          } else {
            logMessage(source, "Invalid range: ".concat(customResponseText));
          }
        }
        Object.defineProperties(thisArg, {
          readyState: {
            value: 4,
            writable: false
          },
          response: {
            value: response,
            writable: false
          },
          responseText: {
            value: responseText,
            writable: false
          },
          responseURL: {
            value: responseUrl,
            writable: false
          },
          responseXML: {
            value: '',
            writable: false
          },
          status: {
            value: 200,
            writable: false
          },
          statusText: {
            value: 'OK',
            writable: false
          }
        });
        setTimeout(function () {
          const stateEvent = new Event('readystatechange');
          thisArg.dispatchEvent(stateEvent);
          const loadEvent = new Event('load');
          thisArg.dispatchEvent(loadEvent);
          const loadEndEvent = new Event('loadend');
          thisArg.dispatchEvent(loadEndEvent);
        }, 1);
        hit(source);
        return undefined;
      };
      const openHandler = {
        apply: openWrapper
      };
      const sendHandler = {
        apply: sendWrapper
      };
      XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
      XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
    }
    preventXHR$1.names = ['prevent-xhr',
    'no-xhr-if.js', 'ubo-no-xhr-if.js', 'ubo-no-xhr-if'];
    preventXHR$1.injections = [hit, logMessage, objectToString, matchRequestProps, generateRandomResponse, toRegExp, isValidStrPattern, escapeRegExp, isEmptyObject, getObjectEntries, getNumberFromString, nativeIsFinite, nativeIsNaN, parseMatchProps, validateParsedData, getMatchPropsData, getRequestProps, getRandomIntInclusive, getRandomStrByLength];
    function forceWindowClose$1(source) {
      let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      if (typeof window.close !== 'function') {
        const message = 'window.close() is not a function so \'close-window\' scriptlet is unavailable';
        logMessage(source, message);
        return;
      }
      const closeImmediately = function closeImmediately() {
        try {
          hit(source);
          window.close();
        } catch (e) {
          logMessage(source, e);
        }
      };
      const closeByExtension = function closeByExtension() {
        const extCall = function extCall() {
          dispatchEvent(new Event('adguard:scriptlet-close-window'));
        };
        window.addEventListener('adguard:subscribed-to-close-window', extCall, {
          once: true
        });
        setTimeout(function () {
          window.removeEventListener('adguard:subscribed-to-close-window', extCall, {
            once: true
          });
        }, 5000);
      };
      const shouldClose = function shouldClose() {
        if (path === '') {
          return true;
        }
        const pathRegexp = toRegExp(path);
        const currentPath = "".concat(window.location.pathname).concat(window.location.search);
        return pathRegexp.test(currentPath);
      };
      if (shouldClose()) {
        closeImmediately();
        if (navigator.userAgent.indexOf('Chrome') > -1) {
          closeByExtension();
        }
      }
    }
    forceWindowClose$1.names = ['close-window', 'window-close-if.js', 'ubo-window-close-if.js', 'ubo-window-close-if'];
    forceWindowClose$1.injections = [hit, toRegExp, logMessage];
    function preventRefresh$1(source, delaySec) {
      const getMetaElements = function getMetaElements() {
        let metaNodes = [];
        try {
          metaNodes = document.querySelectorAll('meta[http-equiv="refresh" i][content]');
        } catch (e) {
          try {
            metaNodes = document.querySelectorAll('meta[http-equiv="refresh"][content]');
          } catch (e) {
            logMessage(source, e);
          }
        }
        return Array.from(metaNodes);
      };
      const getMetaContentDelay = function getMetaContentDelay(metaElements) {
        const delays = metaElements.map(function (meta) {
          const contentString = meta.getAttribute('content');
          if (contentString.length === 0) {
            return null;
          }
          let contentDelay;
          const limiterIndex = contentString.indexOf(';');
          if (limiterIndex !== -1) {
            const delaySubstring = contentString.substring(0, limiterIndex);
            contentDelay = getNumberFromString(delaySubstring);
          } else {
            contentDelay = getNumberFromString(contentString);
          }
          return contentDelay;
        }).filter(function (delay) {
          return delay !== null;
        });
        if (!delays.length) {
          return null;
        }
        const minDelay = delays.reduce(function (a, b) {
          return Math.min(a, b);
        });
        return minDelay;
      };
      const stop = function stop() {
        const metaElements = getMetaElements();
        if (metaElements.length === 0) {
          return;
        }
        let secondsToRun = getNumberFromString(delaySec);
        if (secondsToRun === null) {
          secondsToRun = getMetaContentDelay(metaElements);
        }
        if (secondsToRun === null) {
          return;
        }
        const delayMs = secondsToRun * 1000;
        setTimeout(function () {
          window.stop();
          hit(source);
        }, delayMs);
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', stop, {
          once: true
        });
      } else {
        stop();
      }
    }
    preventRefresh$1.names = ['prevent-refresh',
    'refresh-defuser.js', 'refresh-defuser',
    'ubo-refresh-defuser.js', 'ubo-refresh-defuser'];
    preventRefresh$1.injections = [hit, getNumberFromString, logMessage, nativeIsNaN];
    function preventElementSrcLoading$1(source, tagName, match) {
      if (typeof Proxy === 'undefined' || typeof Reflect === 'undefined') {
        return;
      }
      const srcMockData = {
        script: 'data:text/javascript;base64,KCk9Pnt9',
        img: 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',
        iframe: 'data:text/html;base64, PGRpdj48L2Rpdj4='
      };
      let instance;
      if (tagName === 'script') {
        instance = HTMLScriptElement;
      } else if (tagName === 'img') {
        instance = HTMLImageElement;
      } else if (tagName === 'iframe') {
        instance = HTMLIFrameElement;
      } else {
        return;
      }
      const hasTrustedTypes = window.trustedTypes && typeof window.trustedTypes.createPolicy === 'function';
      let policy;
      if (hasTrustedTypes) {
        policy = window.trustedTypes.createPolicy('AGPolicy', {
          createScriptURL: function createScriptURL(arg) {
            return arg;
          }
        });
      }
      const SOURCE_PROPERTY_NAME = 'src';
      const ONERROR_PROPERTY_NAME = 'onerror';
      const searchRegexp = toRegExp(match);
      const setMatchedAttribute = function setMatchedAttribute(elem) {
        return elem.setAttribute(source.name, 'matched');
      };
      const setAttributeWrapper = function setAttributeWrapper(target, thisArg, args) {
        if (!args[0] || !args[1]) {
          return Reflect.apply(target, thisArg, args);
        }
        const nodeName = thisArg.nodeName.toLowerCase();
        const attrName = args[0].toLowerCase();
        const attrValue = args[1];
        const isMatched = attrName === SOURCE_PROPERTY_NAME && tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(attrValue);
        if (!isMatched) {
          return Reflect.apply(target, thisArg, args);
        }
        hit(source);
        setMatchedAttribute(thisArg);
        return Reflect.apply(target, thisArg, [attrName, srcMockData[nodeName]]);
      };
      const setAttributeHandler = {
        apply: setAttributeWrapper
      };
      instance.prototype.setAttribute = new Proxy(Element.prototype.setAttribute, setAttributeHandler);
      const origSrcDescriptor = safeGetDescriptor(instance.prototype, SOURCE_PROPERTY_NAME);
      if (!origSrcDescriptor) {
        return;
      }
      Object.defineProperty(instance.prototype, SOURCE_PROPERTY_NAME, {
        enumerable: true,
        configurable: true,
        get() {
          return origSrcDescriptor.get.call(this);
        },
        set(urlValue) {
          const nodeName = this.nodeName.toLowerCase();
          const isMatched = tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(urlValue);
          if (!isMatched) {
            origSrcDescriptor.set.call(this, urlValue);
            return true;
          }
          if (policy && urlValue instanceof TrustedScriptURL) {
            const trustedSrc = policy.createScriptURL(urlValue);
            origSrcDescriptor.set.call(this, trustedSrc);
            hit(source);
            return;
          }
          setMatchedAttribute(this);
          origSrcDescriptor.set.call(this, srcMockData[nodeName]);
          hit(source);
        }
      });
      const origOnerrorDescriptor = safeGetDescriptor(HTMLElement.prototype, ONERROR_PROPERTY_NAME);
      if (!origOnerrorDescriptor) {
        return;
      }
      Object.defineProperty(HTMLElement.prototype, ONERROR_PROPERTY_NAME, {
        enumerable: true,
        configurable: true,
        get() {
          return origOnerrorDescriptor.get.call(this);
        },
        set(cb) {
          const isMatched = this.getAttribute(source.name) === 'matched';
          if (!isMatched) {
            origOnerrorDescriptor.set.call(this, cb);
            return true;
          }
          origOnerrorDescriptor.set.call(this, noopFunc);
          return true;
        }
      });
      const addEventListenerWrapper = function addEventListenerWrapper(target, thisArg, args) {
        if (!args[0] || !args[1] || !thisArg) {
          return Reflect.apply(target, thisArg, args);
        }
        const eventName = args[0];
        const isMatched = typeof thisArg.getAttribute === 'function' && thisArg.getAttribute(source.name) === 'matched' && eventName === 'error';
        if (isMatched) {
          return Reflect.apply(target, thisArg, [eventName, noopFunc]);
        }
        return Reflect.apply(target, thisArg, args);
      };
      const addEventListenerHandler = {
        apply: addEventListenerWrapper
      };
      EventTarget.prototype.addEventListener = new Proxy(EventTarget.prototype.addEventListener, addEventListenerHandler);
    }
    preventElementSrcLoading$1.names = ['prevent-element-src-loading'];
    preventElementSrcLoading$1.injections = [hit, toRegExp, safeGetDescriptor, noopFunc];
    function noTopics$1(source) {
      const TOPICS_PROPERTY_NAME = 'browsingTopics';
      if (Document instanceof Object === false) {
        return;
      }
      if (!Object.prototype.hasOwnProperty.call(Document.prototype, TOPICS_PROPERTY_NAME) || Document.prototype[TOPICS_PROPERTY_NAME] instanceof Function === false) {
        return;
      }
      Document.prototype[TOPICS_PROPERTY_NAME] = function () {
        return noopPromiseResolve('[]');
      };
      hit(source);
    }
    noTopics$1.names = ['no-topics'];
    noTopics$1.injections = [hit, noopPromiseResolve];
    function trustedReplaceXhrResponse$1(source) {
      let pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      let replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      let propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      if (typeof Proxy === 'undefined') {
        return;
      }
      if (pattern === '' && replacement !== '') {
        const message = 'Pattern argument should not be empty string.';
        logMessage(source, message);
        return;
      }
      const shouldLog = pattern === '' && replacement === '';
      const nativeOpen = window.XMLHttpRequest.prototype.open;
      const nativeSend = window.XMLHttpRequest.prototype.send;
      let xhrData;
      const openWrapper = function openWrapper(target, thisArg, args) {
        xhrData = getXhrData.apply(null, args);
        if (shouldLog) {
          const message = "xhr( ".concat(objectToString(xhrData), " )");
          logMessage(source, message, true);
          hit(source);
          return Reflect.apply(target, thisArg, args);
        }
        if (matchRequestProps(source, propsToMatch, xhrData)) {
          thisArg.shouldBePrevented = true;
        }
        if (thisArg.shouldBePrevented) {
          thisArg.collectedHeaders = [];
          const setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
            thisArg.collectedHeaders.push(args);
            return Reflect.apply(target, thisArg, args);
          };
          const setRequestHeaderHandler = {
            apply: setRequestHeaderWrapper
          };
          thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
        }
        return Reflect.apply(target, thisArg, args);
      };
      const sendWrapper = function sendWrapper(target, thisArg, args) {
        if (!thisArg.shouldBePrevented) {
          return Reflect.apply(target, thisArg, args);
        }
        const forgedRequest = new XMLHttpRequest();
        forgedRequest.addEventListener('readystatechange', function () {
          if (forgedRequest.readyState !== 4) {
            return;
          }
          const readyState = forgedRequest.readyState,
            response = forgedRequest.response,
            responseText = forgedRequest.responseText,
            responseURL = forgedRequest.responseURL,
            responseXML = forgedRequest.responseXML,
            status = forgedRequest.status,
            statusText = forgedRequest.statusText;
          const content = responseText || response;
          if (typeof content !== 'string') {
            return;
          }
          const patternRegexp = pattern === '*' ? /(\n|.)*/ : toRegExp(pattern);
          const modifiedContent = content.replace(patternRegexp, replacement);
          Object.defineProperties(thisArg, {
            readyState: {
              value: readyState
            },
            response: {
              value: modifiedContent
            },
            responseText: {
              value: modifiedContent
            },
            responseURL: {
              value: responseURL
            },
            responseXML: {
              value: responseXML
            },
            status: {
              value: status
            },
            statusText: {
              value: statusText
            }
          });
          setTimeout(function () {
            const stateEvent = new Event('readystatechange');
            thisArg.dispatchEvent(stateEvent);
            const loadEvent = new Event('load');
            thisArg.dispatchEvent(loadEvent);
            const loadEndEvent = new Event('loadend');
            thisArg.dispatchEvent(loadEndEvent);
          }, 1);
          hit(source);
        });
        nativeOpen.apply(forgedRequest, [xhrData.method, xhrData.url]);
        thisArg.collectedHeaders.forEach(function (header) {
          const name = header[0];
          const value = header[1];
          forgedRequest.setRequestHeader(name, value);
        });
        thisArg.collectedHeaders = [];
        try {
          nativeSend.call(forgedRequest, args);
        } catch (_unused) {
          return Reflect.apply(target, thisArg, args);
        }
        return undefined;
      };
      const openHandler = {
        apply: openWrapper
      };
      const sendHandler = {
        apply: sendWrapper
      };
      XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
      XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
    }
    trustedReplaceXhrResponse$1.names = ['trusted-replace-xhr-response'
    ];
    trustedReplaceXhrResponse$1.injections = [hit, logMessage, toRegExp, objectToString, matchRequestProps, getXhrData, getMatchPropsData, getRequestProps, validateParsedData, parseMatchProps, isValidStrPattern, escapeRegExp, isEmptyObject, getObjectEntries];
    function xmlPrune$1(source, propsToRemove) {
      var _this = this;
      let optionalProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      let urlToMatch = arguments.length > 3 ? arguments[3] : undefined;
      if (typeof Reflect === 'undefined' || typeof fetch === 'undefined' || typeof Proxy === 'undefined' || typeof Response === 'undefined') {
        return;
      }
      let shouldPruneResponse = true;
      if (!propsToRemove) {
        shouldPruneResponse = false;
      }
      const urlMatchRegexp = toRegExp(urlToMatch);
      const isXML = function isXML(text) {
        if (typeof text === 'string') {
          const trimedText = text.trim();
          if (trimedText.startsWith('<') && trimedText.endsWith('>')) {
            return true;
          }
        }
        return false;
      };
      const createXMLDocument = function createXMLDocument(text) {
        const xmlParser = new DOMParser();
        const xmlDocument = xmlParser.parseFromString(text, 'text/xml');
        return xmlDocument;
      };
      const pruneXML = function pruneXML(text) {
        if (!isXML(text)) {
          shouldPruneResponse = false;
          return text;
        }
        const xmlDoc = createXMLDocument(text);
        const errorNode = xmlDoc.querySelector('parsererror');
        if (errorNode) {
          return text;
        }
        if (optionalProp !== '' && xmlDoc.querySelector(optionalProp) === null) {
          shouldPruneResponse = false;
          return text;
        }
        const elems = xmlDoc.querySelectorAll(propsToRemove);
        if (!elems.length) {
          shouldPruneResponse = false;
          return text;
        }
        elems.forEach(function (elem) {
          elem.remove();
        });
        const serializer = new XMLSerializer();
        text = serializer.serializeToString(xmlDoc);
        return text;
      };
      const xhrWrapper = function xhrWrapper(target, thisArg, args) {
        const xhrURL = args[1];
        if (typeof xhrURL !== 'string' || xhrURL.length === 0) {
          return Reflect.apply(target, thisArg, args);
        }
        if (urlMatchRegexp.test(xhrURL)) {
          thisArg.addEventListener('readystatechange', function pruneResponse() {
            if (thisArg.readyState === 4) {
              const response = thisArg.response;
              thisArg.removeEventListener('readystatechange', pruneResponse);
              if (!shouldPruneResponse) {
                if (isXML(response)) {
                  const message = "XMLHttpRequest.open() URL: ".concat(xhrURL, "\nresponse: ").concat(response);
                  logMessage(source, message);
                  logMessage(source, createXMLDocument(response), true, false);
                }
              } else {
                const prunedResponseContent = pruneXML(response);
                if (shouldPruneResponse) {
                  Object.defineProperty(thisArg, 'response', {
                    value: prunedResponseContent
                  });
                  Object.defineProperty(thisArg, 'responseText', {
                    value: prunedResponseContent
                  });
                  hit(source);
                }
                shouldPruneResponse = true;
              }
            }
          });
        }
        return Reflect.apply(target, thisArg, args);
      };
      const xhrHandler = {
        apply: xhrWrapper
      };
      window.XMLHttpRequest.prototype.open = new Proxy(window.XMLHttpRequest.prototype.open, xhrHandler);
      const nativeFetch = window.fetch;
      const fetchWrapper = function fetchWrapper(target, thisArg, args) {
        const fetchURL = args[0] instanceof Request ? args[0].url : args[0];
        if (typeof fetchURL !== 'string' || fetchURL.length === 0) {
          return Reflect.apply(target, thisArg, args);
        }
        if (urlMatchRegexp.test(fetchURL)) {
          return nativeFetch.apply(_this, args).then(function (response) {
            return response.text().then(function (text) {
              if (!shouldPruneResponse) {
                if (isXML(text)) {
                  const message = "fetch URL: ".concat(fetchURL, "\nresponse text: ").concat(text);
                  logMessage(source, message);
                  logMessage(source, createXMLDocument(text), true, false);
                }
                return Reflect.apply(target, thisArg, args);
              }
              const prunedText = pruneXML(text);
              if (shouldPruneResponse) {
                hit(source);
                return new Response(prunedText, {
                  status: response.status,
                  statusText: response.statusText,
                  headers: response.headers
                });
              }
              shouldPruneResponse = true;
              return Reflect.apply(target, thisArg, args);
            });
          });
        }
        return Reflect.apply(target, thisArg, args);
      };
      const fetchHandler = {
        apply: fetchWrapper
      };
      window.fetch = new Proxy(window.fetch, fetchHandler);
    }
    xmlPrune$1.names = ['xml-prune',
    'xml-prune.js', 'ubo-xml-prune.js', 'ubo-xml-prune'];
    xmlPrune$1.injections = [hit, logMessage, toRegExp];
    function m3uPrune$1(source, propsToRemove, urlToMatch) {
      if (typeof Reflect === 'undefined' || typeof fetch === 'undefined' || typeof Proxy === 'undefined' || typeof Response === 'undefined') {
        return;
      }
      let shouldPruneResponse = false;
      const urlMatchRegexp = toRegExp(urlToMatch);
      const SEGMENT_MARKER = '#';
      const AD_MARKER = {
        ASSET: '#EXT-X-ASSET:',
        CUE: '#EXT-X-CUE:',
        CUE_IN: '#EXT-X-CUE-IN',
        DISCONTINUITY: '#EXT-X-DISCONTINUITY',
        EXTINF: '#EXTINF',
        EXTM3U: '#EXTM3U',
        SCTE35: '#EXT-X-SCTE35:'
      };
      const COMCAST_AD_MARKER = {
        AD: '-AD-',
        VAST: '-VAST-',
        VMAP_AD: '-VMAP-AD-',
        VMAP_AD_BREAK: '#EXT-X-VMAP-AD-BREAK:'
      };
      const TAGS_ALLOWLIST = ['#EXT-X-TARGETDURATION', '#EXT-X-MEDIA-SEQUENCE', '#EXT-X-DISCONTINUITY-SEQUENCE', '#EXT-X-ENDLIST', '#EXT-X-PLAYLIST-TYPE', '#EXT-X-I-FRAMES-ONLY', '#EXT-X-MEDIA', '#EXT-X-STREAM-INF', '#EXT-X-I-FRAME-STREAM-INF', '#EXT-X-SESSION-DATA', '#EXT-X-SESSION-KEY', '#EXT-X-INDEPENDENT-SEGMENTS', '#EXT-X-START'];
      const isAllowedTag = function isAllowedTag(str) {
        return TAGS_ALLOWLIST.some(function (el) {
          return str.startsWith(el);
        });
      };
      const pruneExtinfFromVmapBlock = function pruneExtinfFromVmapBlock(lines, i) {
        let array = lines.slice();
        let index = i;
        if (array[index].includes(AD_MARKER.EXTINF)) {
          array[index] = undefined;
          index += 1;
          if (array[index].includes(AD_MARKER.DISCONTINUITY)) {
            array[index] = undefined;
            index += 1;
            const prunedExtinf = pruneExtinfFromVmapBlock(array, index);
            array = prunedExtinf.array;
            index = prunedExtinf.index;
          }
        }
        return {
          array,
          index
        };
      };
      const pruneVmapBlock = function pruneVmapBlock(lines) {
        let array = lines.slice();
        for (let i = 0; i < array.length - 1; i += 1) {
          if (array[i].includes(COMCAST_AD_MARKER.VMAP_AD) || array[i].includes(COMCAST_AD_MARKER.VAST) || array[i].includes(COMCAST_AD_MARKER.AD)) {
            array[i] = undefined;
            if (array[i + 1].includes(AD_MARKER.EXTINF)) {
              i += 1;
              const prunedExtinf = pruneExtinfFromVmapBlock(array, i);
              array = prunedExtinf.array;
              i = prunedExtinf.index - 1;
            }
          }
        }
        return array;
      };
      const pruneSpliceoutBlock = function pruneSpliceoutBlock(line, index, array) {
        if (!line.startsWith(AD_MARKER.CUE)) {
          return line;
        }
        line = undefined;
        index += 1;
        if (array[index].startsWith(AD_MARKER.ASSET)) {
          array[index] = undefined;
          index += 1;
        }
        if (array[index].startsWith(AD_MARKER.SCTE35)) {
          array[index] = undefined;
          index += 1;
        }
        if (array[index].startsWith(AD_MARKER.CUE_IN)) {
          array[index] = undefined;
          index += 1;
        }
        if (array[index].startsWith(AD_MARKER.SCTE35)) {
          array[index] = undefined;
        }
        return line;
      };
      const removeM3ULineRegexp = toRegExp(propsToRemove);
      const pruneInfBlock = function pruneInfBlock(line, index, array) {
        if (!line.startsWith(AD_MARKER.EXTINF)) {
          return line;
        }
        if (!removeM3ULineRegexp.test(array[index + 1])) {
          return line;
        }
        if (!isAllowedTag(array[index])) {
          array[index] = undefined;
        }
        index += 1;
        if (!isAllowedTag(array[index])) {
          array[index] = undefined;
        }
        index += 1;
        if (array[index].startsWith(AD_MARKER.DISCONTINUITY)) {
          array[index] = undefined;
        }
        return line;
      };
      const pruneSegments = function pruneSegments(lines) {
        for (let i = 0; i < lines.length - 1; i += 1) {
          var _lines$i;
          if ((_lines$i = lines[i]) !== null && _lines$i !== void 0 && _lines$i.startsWith(SEGMENT_MARKER) && removeM3ULineRegexp.test(lines[i])) {
            const segmentName = lines[i].substring(0, lines[i].indexOf(':'));
            if (!segmentName) {
              return lines;
            }
            lines[i] = undefined;
            i += 1;
            for (let j = i; j < lines.length; j += 1) {
              if (!lines[j].includes(segmentName) && !isAllowedTag(lines[j])) {
                lines[j] = undefined;
              } else {
                i = j - 1;
                break;
              }
            }
          }
        }
        return lines;
      };
      const isM3U = function isM3U(text) {
        if (typeof text === 'string') {
          const trimmedText = text.trim();
          return trimmedText.startsWith(AD_MARKER.EXTM3U) || trimmedText.startsWith(COMCAST_AD_MARKER.VMAP_AD_BREAK);
        }
        return false;
      };
      const isPruningNeeded = function isPruningNeeded(text, regexp) {
        return isM3U(text) && regexp.test(text);
      };
      const pruneM3U = function pruneM3U(text) {
        let lines = text.split(/\n\r|\n|\r/);
        if (text.includes(COMCAST_AD_MARKER.VMAP_AD_BREAK)) {
          lines = pruneVmapBlock(lines);
          return lines.filter(function (l) {
            return !!l;
          }).join('\n');
        }
        lines = pruneSegments(lines);
        return lines.map(function (line, index, array) {
          if (typeof line === 'undefined') {
            return line;
          }
          line = pruneSpliceoutBlock(line, index, array);
          if (typeof line !== 'undefined') {
            line = pruneInfBlock(line, index, array);
          }
          return line;
        }).filter(function (l) {
          return !!l;
        }).join('\n');
      };
      const xhrWrapper = function xhrWrapper(target, thisArg, args) {
        const xhrURL = args[1];
        if (typeof xhrURL !== 'string' || xhrURL.length === 0) {
          return Reflect.apply(target, thisArg, args);
        }
        if (urlMatchRegexp.test(xhrURL)) {
          thisArg.addEventListener('readystatechange', function pruneResponse() {
            if (thisArg.readyState === 4) {
              const response = thisArg.response;
              thisArg.removeEventListener('readystatechange', pruneResponse);
              if (!propsToRemove) {
                if (isM3U(response)) {
                  const message = "XMLHttpRequest.open() URL: ".concat(xhrURL, "\nresponse: ").concat(response);
                  logMessage(source, message);
                }
              } else {
                shouldPruneResponse = isPruningNeeded(response, removeM3ULineRegexp);
              }
              if (shouldPruneResponse) {
                const prunedResponseContent = pruneM3U(response);
                Object.defineProperty(thisArg, 'response', {
                  value: prunedResponseContent
                });
                Object.defineProperty(thisArg, 'responseText', {
                  value: prunedResponseContent
                });
                hit(source);
              }
            }
          });
        }
        return Reflect.apply(target, thisArg, args);
      };
      const xhrHandler = {
        apply: xhrWrapper
      };
      window.XMLHttpRequest.prototype.open = new Proxy(window.XMLHttpRequest.prototype.open, xhrHandler);
      const nativeFetch = window.fetch;
      const fetchWrapper = async function fetchWrapper(target, thisArg, args) {
        const fetchURL = args[0] instanceof Request ? args[0].url : args[0];
        if (typeof fetchURL !== 'string' || fetchURL.length === 0) {
          return Reflect.apply(target, thisArg, args);
        }
        if (urlMatchRegexp.test(fetchURL)) {
          const response = await nativeFetch(...args);
          const responseText = await response.text();
          if (!propsToRemove && isM3U(responseText)) {
            const message = "fetch URL: ".concat(fetchURL, "\nresponse text: ").concat(responseText);
            logMessage(source, message);
            return Reflect.apply(target, thisArg, args);
          }
          if (isPruningNeeded(responseText, removeM3ULineRegexp)) {
            const prunedText = pruneM3U(responseText);
            hit(source);
            return new Response(prunedText, {
              status: response.status,
              statusText: response.statusText,
              headers: response.headers
            });
          }
          return Reflect.apply(target, thisArg, args);
        }
        return Reflect.apply(target, thisArg, args);
      };
      const fetchHandler = {
        apply: fetchWrapper
      };
      window.fetch = new Proxy(window.fetch, fetchHandler);
    }
    m3uPrune$1.names = ['m3u-prune',
    'm3u-prune.js', 'ubo-m3u-prune.js', 'ubo-m3u-prune'];
    m3uPrune$1.injections = [hit, toRegExp, logMessage];
    function trustedSetCookie$1(source, name, value) {
      let offsetExpiresSec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      let path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '/';
      if (typeof name === 'undefined') {
        logMessage(source, 'Cookie name should be specified');
        return;
      }
      if (typeof value === 'undefined') {
        logMessage(source, 'Cookie value should be specified');
        return;
      }
      const parsedValue = parseKeywordValue(value);
      if (!isValidCookiePath(path)) {
        logMessage(source, "Invalid cookie path: '".concat(path, "'"));
        return;
      }
      let cookieToSet = concatCookieNameValuePath(name, parsedValue, path);
      if (!cookieToSet) {
        return;
      }
      if (offsetExpiresSec) {
        const parsedOffsetMs = getTrustedCookieOffsetMs(offsetExpiresSec);
        if (!parsedOffsetMs) {
          logMessage(source, "Invalid offsetExpiresSec value: ".concat(offsetExpiresSec));
          return;
        }
        const expires = Date.now() + parsedOffsetMs;
        cookieToSet += " expires=".concat(new Date(expires).toUTCString(), ";");
      }
      document.cookie = cookieToSet;
      hit(source);
    }
    trustedSetCookie$1.names = ['trusted-set-cookie'
    ];
    trustedSetCookie$1.injections = [hit, logMessage, nativeIsNaN, isCookieSetWithValue, concatCookieNameValuePath, isValidCookiePath, getTrustedCookieOffsetMs, parseKeywordValue, getCookiePath];
    function trustedSetCookieReload$1(source, name, value) {
      let offsetExpiresSec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      let path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '/';
      if (typeof name === 'undefined') {
        logMessage(source, 'Cookie name should be specified');
        return;
      }
      if (typeof value === 'undefined') {
        logMessage(source, 'Cookie value should be specified');
        return;
      }
      if (isCookieSetWithValue(document.cookie, name, value)) {
        return;
      }
      const parsedValue = parseKeywordValue(value);
      if (!isValidCookiePath(path)) {
        logMessage(source, "Invalid cookie path: '".concat(path, "'"));
        return;
      }
      let cookieToSet = concatCookieNameValuePath(name, parsedValue, path);
      if (!cookieToSet) {
        return;
      }
      if (offsetExpiresSec) {
        const parsedOffsetMs = getTrustedCookieOffsetMs(offsetExpiresSec);
        if (!parsedOffsetMs) {
          logMessage(source, "Invalid offsetExpiresSec value: ".concat(offsetExpiresSec));
          return;
        }
        const expires = Date.now() + parsedOffsetMs;
        cookieToSet += " expires=".concat(new Date(expires).toUTCString(), ";");
      }
      document.cookie = cookieToSet;
      hit(source);
      if (isCookieSetWithValue(document.cookie, name, value)) {
        window.location.reload();
      }
    }
    trustedSetCookieReload$1.names = ['trusted-set-cookie-reload'
    ];
    trustedSetCookieReload$1.injections = [hit, logMessage, nativeIsNaN, isCookieSetWithValue, concatCookieNameValuePath, isValidCookiePath, getTrustedCookieOffsetMs, parseKeywordValue, getCookiePath];
    function trustedReplaceFetchResponse$1(source) {
      let pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      let replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      let propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      if (typeof fetch === 'undefined' || typeof Proxy === 'undefined' || typeof Response === 'undefined') {
        return;
      }
      if (pattern === '' && replacement !== '') {
        logMessage(source, 'Pattern argument should not be empty string');
        return;
      }
      const shouldLog = pattern === '' && replacement === '';
      const nativeFetch = fetch;
      let shouldReplace = false;
      let fetchData;
      const handlerWrapper = function handlerWrapper(target, thisArg, args) {
        fetchData = getFetchData(args);
        if (shouldLog) {
          logMessage(source, "fetch( ".concat(objectToString(fetchData), " )"), true);
          hit(source);
          return Reflect.apply(target, thisArg, args);
        }
        shouldReplace = matchRequestProps(source, propsToMatch, fetchData);
        if (!shouldReplace) {
          return Reflect.apply(target, thisArg, args);
        }
        const forgeResponse = function forgeResponse(response, textContent) {
          const bodyUsed = response.bodyUsed,
            headers = response.headers,
            ok = response.ok,
            redirected = response.redirected,
            status = response.status,
            statusText = response.statusText,
            type = response.type,
            url = response.url;
          const forgedResponse = new Response(textContent, {
            status,
            statusText,
            headers
          });
          Object.defineProperties(forgedResponse, {
            url: {
              value: url
            },
            type: {
              value: type
            },
            ok: {
              value: ok
            },
            bodyUsed: {
              value: bodyUsed
            },
            redirected: {
              value: redirected
            }
          });
          return forgedResponse;
        };
        return nativeFetch.apply(null, args).then(function (response) {
          return response.text().then(function (bodyText) {
            const patternRegexp = pattern === '*' ? /(\n|.)*/ : toRegExp(pattern);
            const modifiedTextContent = bodyText.replace(patternRegexp, replacement);
            const forgedResponse = forgeResponse(response, modifiedTextContent);
            hit(source);
            return forgedResponse;
          }).catch(function () {
            const fetchDataStr = objectToString(fetchData);
            const message = "Response body can't be converted to text: ".concat(fetchDataStr);
            logMessage(source, message);
            return Reflect.apply(target, thisArg, args);
          });
        }).catch(function () {
          return Reflect.apply(target, thisArg, args);
        });
      };
      const fetchHandler = {
        apply: handlerWrapper
      };
      fetch = new Proxy(fetch, fetchHandler);
    }
    trustedReplaceFetchResponse$1.names = ['trusted-replace-fetch-response'];
    trustedReplaceFetchResponse$1.injections = [hit, logMessage, getFetchData, objectToString, matchRequestProps, toRegExp, isValidStrPattern, escapeRegExp, isEmptyObject, getRequestData, getRequestProps, getObjectEntries, getObjectFromEntries, parseMatchProps, validateParsedData, getMatchPropsData];
    function trustedSetLocalStorageItem$1(source, key, value) {
      if (typeof key === 'undefined') {
        logMessage(source, 'Item key should be specified');
        return;
      }
      if (typeof value === 'undefined') {
        logMessage(source, 'Item value should be specified');
        return;
      }
      const parsedValue = parseKeywordValue(value);
      const _window = window,
        localStorage = _window.localStorage;
      setStorageItem(source, localStorage, key, parsedValue);
      hit(source);
    }
    trustedSetLocalStorageItem$1.names = ['trusted-set-local-storage-item'
    ];
    trustedSetLocalStorageItem$1.injections = [hit, logMessage, nativeIsNaN, setStorageItem, parseKeywordValue];
    function trustedSetConstant$1(source, property, value, stack) {
      if (!property || !matchStackTrace(stack, new Error().stack)) {
        return;
      }
      let constantValue;
      try {
        constantValue = inferValue(value);
      } catch (e) {
        logMessage(source, e);
        return;
      }
      let canceled = false;
      const mustCancel = function mustCancel(value) {
        if (canceled) {
          return canceled;
        }
        canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue && value !== null;
        return canceled;
      };
      const trapProp = function trapProp(base, prop, configurable, handler) {
        if (!handler.init(base[prop])) {
          return false;
        }
        const origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
        let prevSetter;
        if (origDescriptor instanceof Object) {
          if (!origDescriptor.configurable) {
            const message = "Property '".concat(prop, "' is not configurable");
            logMessage(source, message);
            return false;
          }
          base[prop] = constantValue;
          if (origDescriptor.set instanceof Function) {
            prevSetter = origDescriptor.set;
          }
        }
        Object.defineProperty(base, prop, {
          configurable,
          get() {
            return handler.get();
          },
          set(a) {
            if (prevSetter !== undefined) {
              prevSetter(a);
            }
            handler.set(a);
          }
        });
        return true;
      };
      const setChainPropAccess = function setChainPropAccess(owner, property) {
        const chainInfo = getPropertyInChain(owner, property);
        const base = chainInfo.base;
        const prop = chainInfo.prop,
          chain = chainInfo.chain;
        const inChainPropHandler = {
          factValue: undefined,
          init(a) {
            this.factValue = a;
            return true;
          },
          get() {
            return this.factValue;
          },
          set(a) {
            if (this.factValue === a) {
              return;
            }
            this.factValue = a;
            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          }
        };
        const endPropHandler = {
          init(a) {
            if (mustCancel(a)) {
              return false;
            }
            return true;
          },
          get() {
            return constantValue;
          },
          set(a) {
            if (!mustCancel(a)) {
              return;
            }
            constantValue = a;
          }
        };
        if (!chain) {
          const isTrapped = trapProp(base, prop, false, endPropHandler);
          if (isTrapped) {
            hit(source);
          }
          return;
        }
        if (base !== undefined && base[prop] === null) {
          trapProp(base, prop, true, inChainPropHandler);
          return;
        }
        if ((base instanceof Object || typeof base === 'object') && isEmptyObject(base)) {
          trapProp(base, prop, true, inChainPropHandler);
        }
        const propValue = owner[prop];
        if (propValue instanceof Object || typeof propValue === 'object' && propValue !== null) {
          setChainPropAccess(propValue, chain);
        }
        trapProp(base, prop, true, inChainPropHandler);
      };
      setChainPropAccess(window, property);
    }
    trustedSetConstant$1.names = ['trusted-set-constant'
    ];
    trustedSetConstant$1.injections = [hit, inferValue, logMessage, noopArray, noopObject, noopFunc, noopCallbackFunc, trueFunc, falseFunc, throwFunc, noopPromiseReject, noopPromiseResolve, getPropertyInChain, setPropertyAccess, toRegExp, matchStackTrace, nativeIsNaN, isEmptyObject, getNativeRegexpTest,
    shouldAbortInlineOrInjectedScript];
    function injectCssInShadowDom$1(source, cssRule) {
      let hostSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      if (!Element.prototype.attachShadow || typeof Proxy === 'undefined' || typeof Reflect === 'undefined') {
        return;
      }
      if (cssRule.match(/(url|image-set)\(.*\)/i)) {
        logMessage(source, '"url()" function is not allowed for css rules');
        return;
      }
      const callback = function callback(shadowRoot) {
        try {
          const stylesheet = new CSSStyleSheet();
          try {
            stylesheet.insertRule(cssRule);
          } catch (e) {
            logMessage(source, "Unable to apply the rule '".concat(cssRule, "' due to: \n'").concat(e.message, "'"));
            return;
          }
          shadowRoot.adoptedStyleSheets = [...shadowRoot.adoptedStyleSheets, stylesheet];
        } catch (_unused) {
          const styleTag = document.createElement('style');
          styleTag.innerText = cssRule;
          shadowRoot.appendChild(styleTag);
        }
        hit(source);
      };
      hijackAttachShadow(window, hostSelector, callback);
    }
    injectCssInShadowDom$1.names = ['inject-css-in-shadow-dom'];
    injectCssInShadowDom$1.injections = [hit, logMessage, hijackAttachShadow];
    var scriptletList = Object.freeze({
        __proto__: null,
        trustedClickElement: trustedClickElement$1,
        abortOnPropertyRead: abortOnPropertyRead$1,
        abortOnPropertyWrite: abortOnPropertyWrite$1,
        preventSetTimeout: preventSetTimeout$1,
        preventSetInterval: preventSetInterval$1,
        preventWindowOpen: preventWindowOpen$1,
        abortCurrentInlineScript: abortCurrentInlineScript$1,
        setConstant: setConstant$1,
        removeCookie: removeCookie$1,
        preventAddEventListener: preventAddEventListener$1,
        preventBab: preventBab$2,
        nowebrtc: nowebrtc$1,
        logAddEventListener: logAddEventListener$1,
        logEval: logEval$1,
        log: log$1,
        noeval: noeval$1,
        preventEvalIf: preventEvalIf$1,
        preventFab: preventFab$1,
        setPopadsDummy: setPopadsDummy$1,
        preventPopadsNet: preventPopadsNet$1,
        preventAdfly: preventAdfly$1,
        debugOnPropertyRead: debugOnPropertyRead$1,
        debugOnPropertyWrite: debugOnPropertyWrite$1,
        debugCurrentInlineScript: debugCurrentInlineScript$1,
        removeAttr: removeAttr$1,
        setAttr: setAttr$1,
        removeClass: removeClass$1,
        disableNewtabLinks: disableNewtabLinks$1,
        adjustSetInterval: adjustSetInterval$1,
        adjustSetTimeout: adjustSetTimeout$1,
        dirString: dirString$1,
        jsonPrune: jsonPrune$1,
        preventRequestAnimationFrame: preventRequestAnimationFrame$1,
        setCookie: setCookie$1,
        setCookieReload: setCookieReload$1,
        hideInShadowDom: hideInShadowDom$1,
        removeInShadowDom: removeInShadowDom$1,
        preventFetch: preventFetch$1,
        setLocalStorageItem: setLocalStorageItem$1,
        setSessionStorageItem: setSessionStorageItem$1,
        abortOnStackTrace: abortOnStackTrace$1,
        logOnStacktrace: logOnStacktrace$1,
        preventXHR: preventXHR$1,
        forceWindowClose: forceWindowClose$1,
        preventRefresh: preventRefresh$1,
        preventElementSrcLoading: preventElementSrcLoading$1,
        noTopics: noTopics$1,
        trustedReplaceXhrResponse: trustedReplaceXhrResponse$1,
        xmlPrune: xmlPrune$1,
        m3uPrune: m3uPrune$1,
        trustedSetCookie: trustedSetCookie$1,
        trustedSetCookieReload: trustedSetCookieReload$1,
        trustedReplaceFetchResponse: trustedReplaceFetchResponse$1,
        trustedSetLocalStorageItem: trustedSetLocalStorageItem$1,
        trustedSetConstant: trustedSetConstant$1,
        injectCssInShadowDom: injectCssInShadowDom$1
    });
    const redirects$1 = [{
      adg: '1x1-transparent.gif',
      ubo: '1x1.gif',
      abp: '1x1-transparent-gif'
    }, {
      adg: '2x2-transparent.png',
      ubo: '2x2.png',
      abp: '2x2-transparent-png'
    }, {
      adg: '3x2-transparent.png',
      ubo: '3x2.png',
      abp: '3x2-transparent-png'
    }, {
      adg: '32x32-transparent.png',
      ubo: '32x32.png',
      abp: '32x32-transparent-png'
    }, {
      adg: 'amazon-apstag',
      ubo: 'amazon_apstag.js'
    }, {
      adg: 'ati-smarttag'
    }, {
      adg: 'didomi-loader'
    }, {
      adg: 'click2load.html',
      ubo: 'click2load.html'
    }, {
      adg: 'fingerprintjs2',
      ubo: 'fingerprint2.js'
    }, {
      adg: 'fingerprintjs3',
      ubo: 'fingerprint3.js'
    }, {
      adg: 'google-analytics',
      ubo: 'google-analytics_analytics.js'
    }, {
      adg: 'google-analytics-ga',
      ubo: 'google-analytics_ga.js'
    }, {
      adg: 'googlesyndication-adsbygoogle',
      ubo: 'googlesyndication_adsbygoogle.js'
    }, {
      adg: 'googlesyndication-adsbygoogle',
      ubo: 'googlesyndication.com/adsbygoogle.js'
    }, {
      adg: 'googletagmanager-gtm',
      ubo: 'google-analytics_ga.js'
    }, {
      adg: 'googletagmanager-gtm',
      ubo: 'googletagmanager_gtm.js'
    }, {
      adg: 'googletagservices-gpt',
      ubo: 'googletagservices_gpt.js'
    }, {
      adg: 'google-ima3',
      ubo: 'google-ima.js'
    }, {
      adg: 'gemius'
    }, {
      adg: 'matomo'
    }, {
      adg: 'metrika-yandex-watch'
    }, {
      adg: 'metrika-yandex-tag'
    }, {
      adg: 'naver-wcslog'
    }, {
      adg: 'noeval',
      ubo: 'noeval-silent.js'
    }, {
      adg: 'noopcss',
      ubo: 'noop.css',
      abp: 'blank-css'
    }, {
      adg: 'noopframe',
      ubo: 'noop.html',
      abp: 'blank-html'
    }, {
      adg: 'noopjs',
      ubo: 'noop.js',
      abp: 'blank-js'
    }, {
      adg: 'noopjson'
    }, {
      adg: 'nooptext',
      ubo: 'noop.txt',
      abp: 'blank-text'
    }, {
      adg: 'noopmp3-0.1s',
      ubo: 'noop-0.1s.mp3',
      abp: 'blank-mp3'
    }, {
      adg: 'noopmp4-1s',
      ubo: 'noop-1s.mp4',
      abp: 'blank-mp4'
    }, {
      adg: 'noopvmap-1.0',
      ubo: 'noop-vmap1.0.xml'
    }, {
      adg: 'noopvast-2.0'
    }, {
      adg: 'noopvast-3.0'
    }, {
      adg: 'noopvast-4.0'
    }, {
      adg: 'prebid'
    }, {
      adg: 'pardot-1.0'
    }, {
      adg: 'prevent-bab',
      ubo: 'nobab.js'
    }, {
      adg: 'prevent-bab2',
      ubo: 'nobab2.js'
    }, {
      adg: 'prevent-fab-3.2.0',
      ubo: 'nofab.js'
    }, {
      adg: 'prevent-fab-3.2.0',
      ubo: 'fuckadblock.js-3.2.0'
    }, {
      adg: 'prevent-popads-net',
      ubo: 'popads.js'
    }, {
      adg: 'scorecardresearch-beacon',
      ubo: 'scorecardresearch_beacon.js'
    }, {
      adg: 'set-popads-dummy',
      ubo: 'popads-dummy.js'
    }, {
      adg: 'empty',
      ubo: 'empty'
    }, {
      adg: 'prebid-ads',
      ubo: 'prebid-ads.js'
    }];
    const JS_RULE_MARKER = '#%#';
    const COMMENT_MARKER = '!';
    const isComment = function isComment(rule) {
      return startsWith$1(rule, COMMENT_MARKER);
    };
    const UBO_SCRIPTLET_MASK_REG = /#@?#script:inject|#@?#\s*\+js/;
    const UBO_SCRIPTLET_MASK_1 = '##+js';
    const UBO_SCRIPTLET_MASK_2 = '##script:inject';
    const UBO_SCRIPTLET_EXCEPTION_MASK_1 = '#@#+js';
    const UBO_SCRIPTLET_EXCEPTION_MASK_2 = '#@#script:inject';
    const ABP_SCRIPTLET_MASK = '#$#';
    const ABP_SCRIPTLET_EXCEPTION_MASK = '#@$#';
    const ADG_CSS_MASK_REG = /#@?\$#.+?\s*\{.*\}\s*$/g;
    const isAdgScriptletRule = function isAdgScriptletRule(rule) {
      return !isComment(rule) && rule.indexOf(ADG_SCRIPTLET_MASK) > -1;
    };
    const isUboScriptletRule = function isUboScriptletRule(rule) {
      return (rule.indexOf(UBO_SCRIPTLET_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_MASK_2) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_2) > -1) && UBO_SCRIPTLET_MASK_REG.test(rule) && !isComment(rule);
    };
    const isAbpSnippetRule = function isAbpSnippetRule(rule) {
      return (rule.indexOf(ABP_SCRIPTLET_MASK) > -1 || rule.indexOf(ABP_SCRIPTLET_EXCEPTION_MASK) > -1) && rule.search(ADG_CSS_MASK_REG) === -1 && !isComment(rule);
    };
    const getScriptletsObjList = function getScriptletsObjList() {
      return Object.values(scriptletList);
    };
    const getScriptletByName = function getScriptletByName(name, scriptlets) {
      if (!scriptlets) {
        scriptlets = getScriptletsObjList();
      }
      return scriptlets.find(function (s) {
        return s.names
        && (s.names.indexOf(name) > -1
        || !endsWith(name, '.js') && s.names.indexOf("".concat(name, ".js")) > -1);
      });
    };
    const scriptletObjects = getScriptletsObjList();
    const isValidScriptletNameNotCached = function isValidScriptletNameNotCached(name) {
      if (!name) {
        return false;
      }
      const scriptlet = getScriptletByName(name, scriptletObjects);
      if (!scriptlet) {
        return false;
      }
      return true;
    };
    const scriptletNameValidationCache = new Map();
    const isValidScriptletName = function isValidScriptletName(name) {
      if (!name) {
        return false;
      }
      if (!scriptletNameValidationCache.has(name)) {
        const isValid = isValidScriptletNameNotCached(name);
        scriptletNameValidationCache.set(name, isValid);
        return isValid;
      }
      return scriptletNameValidationCache.get(name);
    };
    const ADG_UBO_REDIRECT_MARKER = 'redirect=';
    const ADG_UBO_REDIRECT_RULE_MARKER = 'redirect-rule=';
    const ABP_REDIRECT_MARKER = 'rewrite=abp-resource:';
    const EMPTY_REDIRECT_MARKER = 'empty';
    const VALID_SOURCE_TYPES = ['image', 'media', 'subdocument', 'stylesheet', 'script', 'xmlhttprequest', 'other'];
    const ABSENT_SOURCE_TYPE_REPLACEMENT = [{
      NAME: 'nooptext',
      TYPES: VALID_SOURCE_TYPES
    }, {
      NAME: 'noopcss',
      TYPES: ['stylesheet']
    }, {
      NAME: 'noopjs',
      TYPES: ['script']
    }, {
      NAME: 'noopframe',
      TYPES: ['subdocument']
    }, {
      NAME: '1x1-transparent.gif',
      TYPES: ['image']
    }, {
      NAME: 'noopmp3-0.1s',
      TYPES: ['media']
    }, {
      NAME: 'noopmp4-1s',
      TYPES: ['media']
    }, {
      NAME: 'googlesyndication-adsbygoogle',
      TYPES: ['xmlhttprequest', 'script']
    }, {
      NAME: 'google-analytics',
      TYPES: ['script']
    }, {
      NAME: 'googletagservices-gpt',
      TYPES: ['script']
    }];
    const validAdgRedirects = redirects$1.filter(function (el) {
      return el.adg;
    });
    const uboToAdgCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {
      return el.ubo;
    }).map(function (el) {
      return [el.ubo, el.adg];
    }));
    const abpToAdgCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {
      return el.abp;
    }).map(function (el) {
      return [el.abp, el.adg];
    }));
    const adgToUboCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {
      return el.ubo;
    }).map(function (el) {
      return [el.adg, el.ubo];
    }));
    const validAdgCompatibility = getObjectFromEntries(validAdgRedirects.map(function (el) {
      return [el.adg, 'valid adg redirect'];
    }));
    const REDIRECT_RULE_TYPES = {
      VALID_ADG: {
        redirectMarker: ADG_UBO_REDIRECT_MARKER,
        redirectRuleMarker: ADG_UBO_REDIRECT_RULE_MARKER,
        compatibility: validAdgCompatibility
      },
      ADG: {
        redirectMarker: ADG_UBO_REDIRECT_MARKER,
        redirectRuleMarker: ADG_UBO_REDIRECT_RULE_MARKER,
        compatibility: adgToUboCompatibility
      },
      UBO: {
        redirectMarker: ADG_UBO_REDIRECT_MARKER,
        redirectRuleMarker: ADG_UBO_REDIRECT_RULE_MARKER,
        compatibility: uboToAdgCompatibility
      },
      ABP: {
        redirectMarker: ABP_REDIRECT_MARKER,
        compatibility: abpToAdgCompatibility
      }
    };
    const parseModifiers = function parseModifiers(rule) {
      return substringAfter$1(rule, '$').split(',');
    };
    const getRedirectName = function getRedirectName(rule, marker) {
      const ruleModifiers = parseModifiers(rule);
      const redirectNamePart = ruleModifiers.find(function (el) {
        return el.includes(marker);
      });
      return substringAfter$1(redirectNamePart, marker);
    };
    const isAdgRedirectRule = function isAdgRedirectRule(rule) {
      const MARKER_IN_BASE_PART_MASK = '/((?!\\$|\\,).{1})redirect((-rule)?)=(.{0,}?)\\$(popup)?/';
      return !isComment(rule) && (rule.includes(REDIRECT_RULE_TYPES.ADG.redirectMarker) || rule.includes(REDIRECT_RULE_TYPES.ADG.redirectRuleMarker))
      && !rule.includes(JS_RULE_MARKER)
      && !toRegExp(MARKER_IN_BASE_PART_MASK).test(rule);
    };
    const isRedirectRuleByType = function isRedirectRuleByType(rule, type) {
      const _REDIRECT_RULE_TYPES$ = REDIRECT_RULE_TYPES[type],
        redirectMarker = _REDIRECT_RULE_TYPES$.redirectMarker,
        redirectRuleMarker = _REDIRECT_RULE_TYPES$.redirectRuleMarker,
        compatibility = _REDIRECT_RULE_TYPES$.compatibility;
      if (rule && !isComment(rule)) {
        let marker;
        let markerIndex = redirectRuleMarker ? rule.indexOf(redirectRuleMarker) : -1;
        if (markerIndex > -1) {
          marker = redirectRuleMarker;
        } else {
          markerIndex = rule.indexOf(redirectMarker);
          if (markerIndex > -1) {
            marker = redirectMarker;
          } else {
            return false;
          }
        }
        const redirectName = getRedirectName(rule, marker);
        if (!redirectName) {
          return false;
        }
        return redirectName === Object.keys(compatibility).find(function (el) {
          return el === redirectName;
        });
      }
      return false;
    };
    const isValidAdgRedirectRule = function isValidAdgRedirectRule(rule) {
      return isRedirectRuleByType(rule, 'VALID_ADG');
    };
    const isAdgRedirectCompatibleWithUbo = function isAdgRedirectCompatibleWithUbo(rule) {
      return isAdgRedirectRule(rule) && isRedirectRuleByType(rule, 'ADG');
    };
    const isUboRedirectCompatibleWithAdg = function isUboRedirectCompatibleWithAdg(rule) {
      return isRedirectRuleByType(rule, 'UBO');
    };
    const isAbpRedirectCompatibleWithAdg = function isAbpRedirectCompatibleWithAdg(rule) {
      return isRedirectRuleByType(rule, 'ABP');
    };
    const hasValidContentType = function hasValidContentType(rule) {
      const ruleModifiers = parseModifiers(rule);
      const sourceTypes = ruleModifiers.filter(function (el) {
        return VALID_SOURCE_TYPES.includes(el);
      });
      const isSourceTypeSpecified = sourceTypes.length > 0;
      const isEmptyRedirect = ruleModifiers.includes("".concat(ADG_UBO_REDIRECT_MARKER).concat(EMPTY_REDIRECT_MARKER)) || ruleModifiers.includes("".concat(ADG_UBO_REDIRECT_RULE_MARKER).concat(EMPTY_REDIRECT_MARKER));
      if (isEmptyRedirect) {
        return true;
      }
      return isSourceTypeSpecified;
    };
    const validator = {
      UBO_SCRIPTLET_MASK_REG,
      ABP_SCRIPTLET_MASK,
      ABP_SCRIPTLET_EXCEPTION_MASK,
      isComment,
      isAdgScriptletRule,
      isUboScriptletRule,
      isAbpSnippetRule,
      getScriptletByName,
      isValidScriptletName,
      ADG_UBO_REDIRECT_RULE_MARKER,
      REDIRECT_RULE_TYPES,
      ABSENT_SOURCE_TYPE_REPLACEMENT,
      isAdgRedirectRule,
      isValidAdgRedirectRule,
      isAdgRedirectCompatibleWithUbo,
      isUboRedirectCompatibleWithAdg,
      isAbpRedirectCompatibleWithAdg,
      parseModifiers,
      getRedirectName,
      hasValidContentType
    };
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    var arrayWithHoles = _arrayWithHoles;
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
    }
    var iterableToArray = _iterableToArray;
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var arrayLikeToArray = _arrayLikeToArray;
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
    }
    var unsupportedIterableToArray = _unsupportedIterableToArray;
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var nonIterableRest = _nonIterableRest;
    function _toArray(arr) {
      return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
    }
    var toArray$1 = _toArray;
    const ADGUARD_SCRIPTLET_MASK_REG = /#@?%#\/\/scriptlet\(.+\)/;
    const ADGUARD_SCRIPTLET_TEMPLATE = '${domains}#%#//scriptlet(${args})';
    const ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@%#//scriptlet(${args})';
    const UBO_SCRIPTLET_TEMPLATE = '${domains}##+js(${args})';
    const UBO_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@#+js(${args})';
    const UBO_ALIAS_NAME_MARKER = 'ubo-';
    const UBO_SCRIPTLET_JS_ENDING = '.js';
    const UBO_XHR_TYPE = 'xhr';
    const ADG_XHR_TYPE = 'xmlhttprequest';
    const ADG_SET_CONSTANT_NAME = 'set-constant';
    const ADG_SET_CONSTANT_EMPTY_STRING = '';
    const ADG_SET_CONSTANT_EMPTY_ARRAY = 'emptyArr';
    const ADG_SET_CONSTANT_EMPTY_OBJECT = 'emptyObj';
    const UBO_SET_CONSTANT_EMPTY_STRING = '\'\'';
    const UBO_SET_CONSTANT_EMPTY_ARRAY = '[]';
    const UBO_SET_CONSTANT_EMPTY_OBJECT = '{}';
    const ADG_PREVENT_FETCH_NAME = 'prevent-fetch';
    const ADG_PREVENT_FETCH_EMPTY_STRING = '';
    const ADG_PREVENT_FETCH_WILDCARD = '*';
    const UBO_NO_FETCH_IF_WILDCARD = '/^/';
    const ESCAPED_COMMA_SEPARATOR = '\\,';
    const COMMA_SEPARATOR = ',';
    const REMOVE_ATTR_METHOD = 'removeAttr';
    const REMOVE_CLASS_METHOD = 'removeClass';
    const REMOVE_ATTR_ALIASES = scriptletList[REMOVE_ATTR_METHOD].names;
    const REMOVE_CLASS_ALIASES = scriptletList[REMOVE_CLASS_METHOD].names;
    const ADG_REMOVE_ATTR_NAME = REMOVE_ATTR_ALIASES[0];
    const ADG_REMOVE_CLASS_NAME = REMOVE_CLASS_ALIASES[0];
    const REMOVE_ATTR_CLASS_APPLYING = ['asap', 'stay', 'complete'];
    const getSentences = function getSentences(str) {
      const reg = /'.*?'|".*?"|\S+/g;
      return str.match(reg);
    };
    const replacePlaceholders = function replacePlaceholders(str, data) {
      return Object.keys(data).reduce(function (acc, key) {
        const reg = new RegExp("\\$\\{".concat(key, "\\}"), 'g');
        acc = acc.replace(reg, data[key]);
        return acc;
      }, str);
    };
    const splitArgs = function splitArgs(str) {
      const args = [];
      let prevArgStart = 0;
      for (let i = 0; i < str.length; i += 1) {
        if (str[i] === COMMA_SEPARATOR && str[i - 1] !== '\\') {
          args.push(str.slice(prevArgStart, i).trim());
          prevArgStart = i + 1;
        }
      }
      args.push(str.slice(prevArgStart, str.length).trim());
      return args;
    };
    const validateRemoveAttrClassArgs = function validateRemoveAttrClassArgs(parsedArgs) {
      const _parsedArgs = toArray$1(parsedArgs),
        name = _parsedArgs[0],
        value = _parsedArgs[1],
        restArgs = _parsedArgs.slice(2);
      if (restArgs.length === 0) {
        return [name, value];
      }
      const lastArg = restArgs.pop();
      let applying;
      if (REMOVE_ATTR_CLASS_APPLYING.some(function (el) {
        return lastArg.indexOf(el) > -1;
      })) {
        applying = lastArg;
      } else {
        restArgs.push(lastArg);
      }
      const selector = replaceAll(restArgs.join(', '), ESCAPED_COMMA_SEPARATOR, COMMA_SEPARATOR);
      if (selector.length > 0 && typeof document !== 'undefined') {
        document.querySelectorAll(selector);
      }
      const validArgs = applying ? [name, value, selector, applying] : [name, value, selector];
      return validArgs;
    };
    const convertUboScriptletToAdg = function convertUboScriptletToAdg(rule) {
      const domains = getBeforeRegExp(rule, validator.UBO_SCRIPTLET_MASK_REG);
      const mask = rule.match(validator.UBO_SCRIPTLET_MASK_REG)[0];
      let template;
      if (mask.indexOf('@') > -1) {
        template = ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;
      } else {
        template = ADGUARD_SCRIPTLET_TEMPLATE;
      }
      const argsStr = getStringInBraces(rule);
      let parsedArgs = splitArgs(argsStr);
      const scriptletName = parsedArgs[0].indexOf(UBO_SCRIPTLET_JS_ENDING) > -1 ? "ubo-".concat(parsedArgs[0]) : "ubo-".concat(parsedArgs[0]).concat(UBO_SCRIPTLET_JS_ENDING);
      if (REMOVE_ATTR_ALIASES.indexOf(scriptletName) > -1 || REMOVE_CLASS_ALIASES.indexOf(scriptletName) > -1) {
        parsedArgs = validateRemoveAttrClassArgs(parsedArgs);
      }
      const args = parsedArgs.map(function (arg, index) {
        let outputArg = arg;
        if (index === 0) {
          outputArg = scriptletName;
        }
        if (arg === '$') {
          outputArg = '$$';
        }
        return outputArg;
      }).map(function (arg) {
        return wrapInSingleQuotes(arg);
      }).join("".concat(COMMA_SEPARATOR, " "));
      const adgRule = replacePlaceholders(template, {
        domains,
        args
      });
      return [adgRule];
    };
    const convertAbpSnippetToAdg = function convertAbpSnippetToAdg(rule) {
      const SEMICOLON_DIVIDER = /;(?=(?:(?:[^"]*"){2})*[^"]*$)/g;
      const mask = rule.indexOf(validator.ABP_SCRIPTLET_MASK) > -1 ? validator.ABP_SCRIPTLET_MASK : validator.ABP_SCRIPTLET_EXCEPTION_MASK;
      const template = mask === validator.ABP_SCRIPTLET_MASK ? ADGUARD_SCRIPTLET_TEMPLATE : ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;
      const domains = substringBefore(rule, mask);
      const args = substringAfter$1(rule, mask);
      return args.split(SEMICOLON_DIVIDER)
      .filter(isExisting).map(function (args) {
        return getSentences(args).map(function (arg, index) {
          return index === 0 ? "abp-".concat(arg) : arg;
        }).map(function (arg) {
          return wrapInSingleQuotes(arg);
        }).join("".concat(COMMA_SEPARATOR, " "));
      }).map(function (args) {
        return replacePlaceholders(template, {
          domains,
          args
        });
      });
    };
    const isValidAdgScriptletRuleSyntax = function isValidAdgScriptletRuleSyntax(adgRuleText) {
      if (!adgRuleText) {
        return false;
      }
      if (!validator.isAdgScriptletRule(adgRuleText)) {
        return false;
      }
      let parsedRule;
      try {
        parsedRule = parseRule(adgRuleText);
        return validator.isValidScriptletName(parsedRule.name);
      } catch (e) {
        return false;
      }
    };
    const convertScriptletToAdg = function convertScriptletToAdg(rule) {
      let result;
      if (validator.isUboScriptletRule(rule)) {
        result = convertUboScriptletToAdg(rule);
      } else if (validator.isAbpSnippetRule(rule)) {
        result = convertAbpSnippetToAdg(rule);
      } else if (validator.isAdgScriptletRule(rule)) {
        if (isValidAdgScriptletRuleSyntax(rule)) {
          result = [rule];
        } else {
          console.log("Invalid AdGuard scriptlet rule: ".concat(rule));
          result = [];
        }
      } else if (validator.isComment(rule)) {
        result = [rule];
      }
      return result;
    };
    const convertAdgScriptletToUbo = function convertAdgScriptletToUbo(rule) {
      let res;
      if (validator.isAdgScriptletRule(rule)) {
        const _parseRule = parseRule(rule),
          parsedName = _parseRule.name,
          parsedParams = _parseRule.args;
        let preparedParams;
        if (parsedName === ADG_SET_CONSTANT_NAME
        && parsedParams[1] === ADG_SET_CONSTANT_EMPTY_STRING) {
          preparedParams = [parsedParams[0], UBO_SET_CONSTANT_EMPTY_STRING];
        } else if (parsedName === ADG_SET_CONSTANT_NAME
        && parsedParams[1] === ADG_SET_CONSTANT_EMPTY_ARRAY) {
          preparedParams = [parsedParams[0], UBO_SET_CONSTANT_EMPTY_ARRAY];
        } else if (parsedName === ADG_SET_CONSTANT_NAME && parsedParams[1] === ADG_SET_CONSTANT_EMPTY_OBJECT) {
          preparedParams = [parsedParams[0], UBO_SET_CONSTANT_EMPTY_OBJECT];
        } else if (parsedName === ADG_PREVENT_FETCH_NAME
        && (parsedParams[0] === ADG_PREVENT_FETCH_WILDCARD || parsedParams[0] === ADG_PREVENT_FETCH_EMPTY_STRING)) {
          preparedParams = [UBO_NO_FETCH_IF_WILDCARD];
        } else if ((parsedName === ADG_REMOVE_ATTR_NAME || parsedName === ADG_REMOVE_CLASS_NAME) && parsedParams[1] && parsedParams[1].indexOf(COMMA_SEPARATOR) > -1) {
          preparedParams = [parsedParams[0], replaceAll(parsedParams[1], COMMA_SEPARATOR, ESCAPED_COMMA_SEPARATOR)];
        } else {
          preparedParams = parsedParams;
        }
        const adgScriptletObject = Object.keys(scriptletList).map(function (el) {
          return scriptletList[el];
        }).map(function (s) {
          const _s$names = toArray$1(s.names),
            name = _s$names[0],
            aliases = _s$names.slice(1);
          return {
            name,
            aliases
          };
        }).find(function (el) {
          return el.name === parsedName || el.aliases.indexOf(parsedName) >= 0;
        });
        const aliases = adgScriptletObject.aliases;
        if (aliases.length > 0) {
          const uboAlias = adgScriptletObject.aliases
          .find(function (alias) {
            return alias.includes(UBO_ALIAS_NAME_MARKER);
          });
          if (uboAlias) {
            const mask = rule.match(ADGUARD_SCRIPTLET_MASK_REG)[0];
            let template;
            if (mask.indexOf('@') > -1) {
              template = UBO_SCRIPTLET_EXCEPTION_TEMPLATE;
            } else {
              template = UBO_SCRIPTLET_TEMPLATE;
            }
            const domains = getBeforeRegExp(rule, ADGUARD_SCRIPTLET_MASK_REG);
            const uboName = uboAlias.replace(UBO_ALIAS_NAME_MARKER, '')
            .replace(UBO_SCRIPTLET_JS_ENDING, '');
            const args = preparedParams.length > 0 ? "".concat(uboName, ", ").concat(preparedParams.join("".concat(COMMA_SEPARATOR, " "))) : uboName;
            const uboRule = replacePlaceholders(template, {
              domains,
              args
            });
            res = uboRule;
          }
        }
      }
      return res;
    };
    const getAdgScriptletName = function getAdgScriptletName(rule) {
      let buffer = substringAfter$1(rule, "".concat(ADG_SCRIPTLET_MASK, "("));
      if (!buffer) {
        return null;
      }
      const nameQuote = buffer[0];
      buffer = buffer.slice(1);
      if (!buffer) {
        return null;
      }
      const name = substringBefore(buffer, nameQuote);
      return name === buffer ? null : name;
    };
    const isValidScriptletRule = function isValidScriptletRule(ruleText) {
      if (!ruleText) {
        return false;
      }
      const rulesArray = convertScriptletToAdg(ruleText);
      if (rulesArray.length === 0) {
        return false;
      }
      const isValid = rulesArray.every(function (rule) {
        const name = getAdgScriptletName(rule);
        return validator.isValidScriptletName(name);
      });
      return isValid;
    };
    const getMarkerData = function getMarkerData(modifiers, redirectsData, rule) {
      let marker;
      let index = modifiers.findIndex(function (m) {
        return m.indexOf(redirectsData.redirectRuleMarker) > -1;
      });
      if (index > -1) {
        marker = redirectsData.redirectRuleMarker;
      } else {
        index = modifiers.findIndex(function (m) {
          return m.indexOf(redirectsData.redirectMarker) > -1;
        });
        if (index > -1) {
          marker = redirectsData.redirectMarker;
        } else {
          throw new Error("No redirect resource modifier found in rule: ".concat(rule));
        }
      }
      return {
        index,
        marker
      };
    };
    const convertUboRedirectToAdg = function convertUboRedirectToAdg(rule) {
      const firstPartOfRule = substringBefore(rule, '$');
      const uboModifiers = validator.parseModifiers(rule);
      const uboMarkerData = getMarkerData(uboModifiers, validator.REDIRECT_RULE_TYPES.UBO, rule);
      const adgModifiers = uboModifiers.map(function (modifier, index) {
        if (index === uboMarkerData.index) {
          const uboName = substringAfter$1(modifier, uboMarkerData.marker);
          const adgName = validator.REDIRECT_RULE_TYPES.UBO.compatibility[uboName];
          const adgMarker = uboMarkerData.marker === validator.ADG_UBO_REDIRECT_RULE_MARKER ? validator.REDIRECT_RULE_TYPES.ADG.redirectRuleMarker : validator.REDIRECT_RULE_TYPES.ADG.redirectMarker;
          return "".concat(adgMarker).concat(adgName);
        }
        if (modifier === UBO_XHR_TYPE) {
          return ADG_XHR_TYPE;
        }
        return modifier;
      }).join(COMMA_SEPARATOR);
      return "".concat(firstPartOfRule, "$").concat(adgModifiers);
    };
    const convertAbpRedirectToAdg = function convertAbpRedirectToAdg(rule) {
      const firstPartOfRule = substringBefore(rule, '$');
      const abpModifiers = validator.parseModifiers(rule);
      const adgModifiers = abpModifiers.map(function (modifier) {
        if (modifier.indexOf(validator.REDIRECT_RULE_TYPES.ABP.redirectMarker) > -1) {
          const abpName = substringAfter$1(modifier, validator.REDIRECT_RULE_TYPES.ABP.redirectMarker);
          const adgName = validator.REDIRECT_RULE_TYPES.ABP.compatibility[abpName];
          return "".concat(validator.REDIRECT_RULE_TYPES.ADG.redirectMarker).concat(adgName);
        }
        return modifier;
      }).join(COMMA_SEPARATOR);
      return "".concat(firstPartOfRule, "$").concat(adgModifiers);
    };
    const convertRedirectToAdg = function convertRedirectToAdg(rule) {
      let result;
      if (validator.isUboRedirectCompatibleWithAdg(rule)) {
        result = convertUboRedirectToAdg(rule);
      } else if (validator.isAbpRedirectCompatibleWithAdg(rule)) {
        result = convertAbpRedirectToAdg(rule);
      } else if (validator.isValidAdgRedirectRule(rule)) {
        result = rule;
      }
      return result;
    };
    const convertAdgRedirectToUbo = function convertAdgRedirectToUbo(rule) {
      if (!validator.isAdgRedirectCompatibleWithUbo(rule)) {
        throw new Error("Unable to convert for uBO - unsupported redirect in rule: ".concat(rule));
      }
      const basePart = substringBefore(rule, '$');
      const adgModifiers = validator.parseModifiers(rule);
      const adgMarkerData = getMarkerData(adgModifiers, validator.REDIRECT_RULE_TYPES.ADG, rule);
      const adgRedirectName = adgModifiers[adgMarkerData.index].slice(adgMarkerData.marker.length);
      if (!validator.hasValidContentType(rule)) {
        const sourceTypesData = validator.ABSENT_SOURCE_TYPE_REPLACEMENT.find(function (el) {
          return el.NAME === adgRedirectName;
        });
        if (typeof sourceTypesData === 'undefined') {
          throw new Error("Unable to convert for uBO - no types to add for specific redirect in rule: ".concat(rule));
        }
        const additionModifiers = sourceTypesData.TYPES;
        adgModifiers.push(...additionModifiers);
      }
      const uboModifiers = adgModifiers.map(function (el, index) {
        if (index === adgMarkerData.index) {
          const uboMarker = adgMarkerData.marker === validator.ADG_UBO_REDIRECT_RULE_MARKER ? validator.REDIRECT_RULE_TYPES.UBO.redirectRuleMarker : validator.REDIRECT_RULE_TYPES.UBO.redirectMarker;
          const uboRedirectName = validator.REDIRECT_RULE_TYPES.ADG.compatibility[adgRedirectName];
          return "".concat(uboMarker).concat(uboRedirectName);
        }
        return el;
      }).join(COMMA_SEPARATOR);
      return "".concat(basePart, "$").concat(uboModifiers);
    };
    function GoogleAnalytics(source) {
      const Tracker = function Tracker() {};
      const proto = Tracker.prototype;
      proto.get = noopFunc;
      proto.set = noopFunc;
      proto.send = noopFunc;
      const googleAnalyticsName = window.GoogleAnalyticsObject || 'ga';
      function ga(a) {
        const len = arguments.length;
        if (len === 0) {
          return;
        }
        const lastArg = arguments[len - 1];
        let replacer;
        if (lastArg instanceof Object && lastArg !== null && typeof lastArg.hitCallback === 'function') {
          replacer = lastArg.hitCallback;
        } else if (typeof lastArg === 'function') {
          replacer = function replacer() {
            lastArg(ga.create());
          };
        }
        try {
          setTimeout(replacer, 1);
        } catch (ex) {}
      }
      ga.create = function () {
        return new Tracker();
      };
      ga.getByName = function () {
        return new Tracker();
      };
      ga.getAll = function () {
        return [new Tracker()];
      };
      ga.remove = noopFunc;
      ga.loaded = true;
      window[googleAnalyticsName] = ga;
      const _window = window,
        dataLayer = _window.dataLayer,
        google_optimize = _window.google_optimize;
      if (dataLayer instanceof Object === false) {
        return;
      }
      if (dataLayer.hide instanceof Object && typeof dataLayer.hide.end === 'function') {
        dataLayer.hide.end();
      }
      const handleCallback = function handleCallback(dataObj, funcName) {
        if (dataObj && typeof dataObj[funcName] === 'function') {
          setTimeout(dataObj[funcName]);
        }
      };
      if (typeof dataLayer.push === 'function') {
        dataLayer.push = function (data) {
          if (data instanceof Object) {
            handleCallback(data, 'eventCallback');
            for (const key in data) {
              handleCallback(data[key], 'event_callback');
            }
            if (!data.hasOwnProperty('eventCallback') && !data.hasOwnProperty('eventCallback')) {
              [].push.call(window.dataLayer, data);
            }
          }
          if (Array.isArray(data)) {
            data.forEach(function (arg) {
              handleCallback(arg, 'callback');
            });
          }
          return noopFunc;
        };
      }
      if (google_optimize instanceof Object && typeof google_optimize.get === 'function') {
        const googleOptimizeWrapper = {
          get: noopFunc
        };
        window.google_optimize = googleOptimizeWrapper;
      }
      hit(source);
    }
    GoogleAnalytics.names = ['google-analytics', 'ubo-google-analytics_analytics.js', 'google-analytics_analytics.js',
    'googletagmanager-gtm', 'ubo-googletagmanager_gtm.js', 'googletagmanager_gtm.js'];
    GoogleAnalytics.injections = [hit, noopFunc, noopNull, noopArray];
    function GoogleAnalyticsGa(source) {
      function Gaq() {}
      Gaq.prototype.Na = noopFunc;
      Gaq.prototype.O = noopFunc;
      Gaq.prototype.Sa = noopFunc;
      Gaq.prototype.Ta = noopFunc;
      Gaq.prototype.Va = noopFunc;
      Gaq.prototype._createAsyncTracker = noopFunc;
      Gaq.prototype._getAsyncTracker = noopFunc;
      Gaq.prototype._getPlugin = noopFunc;
      Gaq.prototype.push = function (data) {
        if (typeof data === 'function') {
          data();
          return;
        }
        if (Array.isArray(data) === false) {
          return;
        }
        if (typeof data[0] === 'string' && /(^|\.)_link$/.test(data[0]) && typeof data[1] === 'string') {
          window.location.assign(data[1]);
        }
        if (data[0] === '_set' && data[1] === 'hitCallback' && typeof data[2] === 'function') {
          data[2]();
        }
      };
      const gaq = new Gaq();
      const asyncTrackers = window._gaq || [];
      if (Array.isArray(asyncTrackers)) {
        while (asyncTrackers[0]) {
          gaq.push(asyncTrackers.shift());
        }
      }
      window._gaq = gaq.qf = gaq;
      function Gat() {}
      const api = ['_addIgnoredOrganic', '_addIgnoredRef', '_addItem', '_addOrganic', '_addTrans', '_clearIgnoredOrganic', '_clearIgnoredRef', '_clearOrganic', '_cookiePathCopy', '_deleteCustomVar', '_getName', '_setAccount', '_getAccount', '_getClientInfo', '_getDetectFlash', '_getDetectTitle', '_getLinkerUrl', '_getLocalGifPath', '_getServiceMode', '_getVersion', '_getVisitorCustomVar', '_initData', '_link', '_linkByPost', '_setAllowAnchor', '_setAllowHash', '_setAllowLinker', '_setCampContentKey', '_setCampMediumKey', '_setCampNameKey', '_setCampNOKey', '_setCampSourceKey', '_setCampTermKey', '_setCampaignCookieTimeout', '_setCampaignTrack', '_setClientInfo', '_setCookiePath', '_setCookiePersistence', '_setCookieTimeout', '_setCustomVar', '_setDetectFlash', '_setDetectTitle', '_setDomainName', '_setLocalGifPath', '_setLocalRemoteServerMode', '_setLocalServerMode', '_setReferrerOverride', '_setRemoteServerMode', '_setSampleRate', '_setSessionTimeout', '_setSiteSpeedSampleRate', '_setSessionCookieTimeout', '_setVar', '_setVisitorCookieTimeout', '_trackEvent', '_trackPageLoadTime', '_trackPageview', '_trackSocial', '_trackTiming', '_trackTrans', '_visitCode'];
      const tracker = api.reduce(function (res, funcName) {
        res[funcName] = noopFunc;
        return res;
      }, {});
      tracker._getLinkerUrl = function (a) {
        return a;
      };
      tracker._link = function (url) {
        if (typeof url !== 'string') {
          return;
        }
        try {
          window.location.assign(url);
        } catch (e) {
          logMessage(source, e);
        }
      };
      Gat.prototype._anonymizeIP = noopFunc;
      Gat.prototype._createTracker = noopFunc;
      Gat.prototype._forceSSL = noopFunc;
      Gat.prototype._getPlugin = noopFunc;
      Gat.prototype._getTracker = function () {
        return tracker;
      };
      Gat.prototype._getTrackerByName = function () {
        return tracker;
      };
      Gat.prototype._getTrackers = noopFunc;
      Gat.prototype.aa = noopFunc;
      Gat.prototype.ab = noopFunc;
      Gat.prototype.hb = noopFunc;
      Gat.prototype.la = noopFunc;
      Gat.prototype.oa = noopFunc;
      Gat.prototype.pa = noopFunc;
      Gat.prototype.u = noopFunc;
      const gat = new Gat();
      window._gat = gat;
      hit(source);
    }
    GoogleAnalyticsGa.names = ['google-analytics-ga', 'ubo-google-analytics_ga.js', 'google-analytics_ga.js'];
    GoogleAnalyticsGa.injections = [hit, noopFunc, logMessage];
    function GoogleSyndicationAdsByGoogle(source) {
      window.adsbygoogle = {
        loaded: true,
        push(arg) {
          if (typeof this.length === 'undefined') {
            this.length = 0;
            this.length += 1;
          }
          if (arg !== null && arg instanceof Object && arg.constructor.name === 'Object') {
            for (var _i = 0, _Object$keys = Object.keys(arg); _i < _Object$keys.length; _i++) {
              const key = _Object$keys[_i];
              if (typeof arg[key] === 'function') {
                try {
                  arg[key].call(this, {});
                } catch (_unused) {
                }
              }
            }
          }
        }
      };
      const adElems = document.querySelectorAll('.adsbygoogle');
      const css = 'height:1px!important;max-height:1px!important;max-width:1px!important;width:1px!important;';
      const statusAttrName = 'data-adsbygoogle-status';
      const ASWIFT_IFRAME_MARKER = 'aswift_';
      const GOOGLE_ADS_IFRAME_MARKER = 'google_ads_iframe_';
      let executed = false;
      for (let i = 0; i < adElems.length; i += 1) {
        const adElemChildNodes = adElems[i].childNodes;
        const childNodesQuantity = adElemChildNodes.length;
        let areIframesDefined = false;
        if (childNodesQuantity > 0) {
          areIframesDefined = childNodesQuantity === 2
          && adElemChildNodes[0].nodeName.toLowerCase() === 'iframe' && adElemChildNodes[0].id.indexOf(ASWIFT_IFRAME_MARKER) > -1
          && adElemChildNodes[1].nodeName.toLowerCase() === 'iframe' && adElemChildNodes[1].id.indexOf(GOOGLE_ADS_IFRAME_MARKER) > -1;
        }
        if (!areIframesDefined) {
          adElems[i].setAttribute(statusAttrName, 'done');
          const aswiftIframe = document.createElement('iframe');
          aswiftIframe.id = "".concat(ASWIFT_IFRAME_MARKER).concat(i);
          aswiftIframe.style = css;
          adElems[i].appendChild(aswiftIframe);
          const innerAswiftIframe = document.createElement('iframe');
          aswiftIframe.contentWindow.document.body.appendChild(innerAswiftIframe);
          const googleadsIframe = document.createElement('iframe');
          googleadsIframe.id = "".concat(GOOGLE_ADS_IFRAME_MARKER).concat(i);
          googleadsIframe.style = css;
          adElems[i].appendChild(googleadsIframe);
          const innerGoogleadsIframe = document.createElement('iframe');
          googleadsIframe.contentWindow.document.body.appendChild(innerGoogleadsIframe);
          executed = true;
        }
      }
      if (executed) {
        hit(source);
      }
    }
    GoogleSyndicationAdsByGoogle.names = ['googlesyndication-adsbygoogle', 'ubo-googlesyndication_adsbygoogle.js', 'googlesyndication_adsbygoogle.js'];
    GoogleSyndicationAdsByGoogle.injections = [hit];
    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    var iterableToArrayLimit = _iterableToArrayLimit;
    function _slicedToArray(arr, i) {
      return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
    }
    var slicedToArray = _slicedToArray;
    function GoogleTagServicesGpt(source) {
      const slots = new Map();
      const slotsById = new Map();
      const slotsPerPath = new Map();
      const slotCreatives = new Map();
      const eventCallbacks = new Map();
      const gTargeting = new Map();
      const addEventListener = function addEventListener(name, listener) {
        if (!eventCallbacks.has(name)) {
          eventCallbacks.set(name, new Set());
        }
        eventCallbacks.get(name).add(listener);
        return this;
      };
      const removeEventListener = function removeEventListener(name, listener) {
        if (eventCallbacks.has(name)) {
          return eventCallbacks.get(name).delete(listener);
        }
        return false;
      };
      const fireSlotEvent = function fireSlotEvent(name, slot) {
        return new Promise(function (resolve) {
          requestAnimationFrame(function () {
            const size = [0, 0];
            const callbacksSet = eventCallbacks.get(name) || [];
            const callbackArray = Array.from(callbacksSet);
            for (let i = 0; i < callbackArray.length; i += 1) {
              callbackArray[i]({
                isEmpty: true,
                size,
                slot
              });
            }
            resolve();
          });
        });
      };
      const emptySlotElement = function emptySlotElement(slot) {
        const node = document.getElementById(slot.getSlotElementId());
        while (node !== null && node !== void 0 && node.lastChild) {
          node.lastChild.remove();
        }
      };
      const recreateIframeForSlot = function recreateIframeForSlot(slot) {
        var _document$getElementB;
        const eid = "google_ads_iframe_".concat(slot.getId());
        (_document$getElementB = document.getElementById(eid)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.remove();
        const node = document.getElementById(slot.getSlotElementId());
        if (node) {
          const f = document.createElement('iframe');
          f.id = eid;
          f.srcdoc = '<body></body>';
          f.style = 'position:absolute; width:0; height:0; left:0; right:0; z-index:-1; border:0';
          f.setAttribute('width', 0);
          f.setAttribute('height', 0);
          f.setAttribute('data-load-complete', true);
          f.setAttribute('data-google-container-id', true);
          f.setAttribute('sandbox', true);
          node.appendChild(f);
        }
      };
      const displaySlot = function displaySlot(slot) {
        if (!slot) {
          return;
        }
        const id = slot.getSlotElementId();
        if (!document.getElementById(id)) {
          return;
        }
        const parent = document.getElementById(id);
        if (parent) {
          parent.appendChild(document.createElement('div'));
        }
        emptySlotElement(slot);
        recreateIframeForSlot(slot);
        fireSlotEvent('slotRenderEnded', slot);
        fireSlotEvent('slotRequested', slot);
        fireSlotEvent('slotResponseReceived', slot);
        fireSlotEvent('slotOnload', slot);
        fireSlotEvent('impressionViewable', slot);
      };
      const companionAdsService = {
        addEventListener,
        removeEventListener,
        enableSyncLoading: noopFunc,
        setRefreshUnfilledSlots: noopFunc,
        getSlots: noopArray
      };
      const contentService = {
        addEventListener,
        removeEventListener,
        setContent: noopFunc
      };
      function PassbackSlot() {}
      PassbackSlot.prototype.display = noopFunc;
      PassbackSlot.prototype.get = noopNull;
      PassbackSlot.prototype.set = noopThis;
      PassbackSlot.prototype.setClickUrl = noopThis;
      PassbackSlot.prototype.setTagForChildDirectedTreatment = noopThis;
      PassbackSlot.prototype.setTargeting = noopThis;
      PassbackSlot.prototype.updateTargetingFromMap = noopThis;
      function SizeMappingBuilder() {}
      SizeMappingBuilder.prototype.addSize = noopThis;
      SizeMappingBuilder.prototype.build = noopNull;
      const getTargetingValue = function getTargetingValue(v) {
        if (typeof v === 'string') {
          return [v];
        }
        try {
          return [Array.prototype.flat.call(v)[0]];
        } catch (_unused) {
        }
        return [];
      };
      const updateTargeting = function updateTargeting(targeting, map) {
        if (typeof map === 'object') {
          const entries = Object.entries(map || {});
          for (var _i = 0, _entries = entries; _i < _entries.length; _i++) {
            const _entries$_i = slicedToArray(_entries[_i], 2),
              k = _entries$_i[0],
              v = _entries$_i[1];
            targeting.set(k, getTargetingValue(v));
          }
        }
      };
      const defineSlot = function defineSlot(adUnitPath, creatives, optDiv) {
        if (slotsById.has(optDiv)) {
          var _document$getElementB2;
          (_document$getElementB2 = document.getElementById(optDiv)) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.remove();
          return slotsById.get(optDiv);
        }
        const attributes = new Map();
        const targeting = new Map();
        const exclusions = new Set();
        const response = {
          advertiserId: undefined,
          campaignId: undefined,
          creativeId: undefined,
          creativeTemplateId: undefined,
          lineItemId: undefined
        };
        const sizes = [{
          getHeight: function getHeight() {
            return 2;
          },
          getWidth: function getWidth() {
            return 2;
          }
        }];
        const num = (slotsPerPath.get(adUnitPath) || 0) + 1;
        slotsPerPath.set(adUnitPath, num);
        const id = "".concat(adUnitPath, "_").concat(num);
        let clickUrl = '';
        let collapseEmptyDiv = null;
        const services = new Set();
        const slot = {
          addService(e) {
            services.add(e);
            return slot;
          },
          clearCategoryExclusions: noopThis,
          clearTargeting(k) {
            if (k === undefined) {
              targeting.clear();
            } else {
              targeting.delete(k);
            }
          },
          defineSizeMapping(mapping) {
            slotCreatives.set(optDiv, mapping);
            return this;
          },
          get: function get(k) {
            return attributes.get(k);
          },
          getAdUnitPath: function getAdUnitPath() {
            return adUnitPath;
          },
          getAttributeKeys: function getAttributeKeys() {
            return Array.from(attributes.keys());
          },
          getCategoryExclusions: function getCategoryExclusions() {
            return Array.from(exclusions);
          },
          getClickUrl: function getClickUrl() {
            return clickUrl;
          },
          getCollapseEmptyDiv: function getCollapseEmptyDiv() {
            return collapseEmptyDiv;
          },
          getContentUrl: function getContentUrl() {
            return '';
          },
          getDivStartsCollapsed: function getDivStartsCollapsed() {
            return null;
          },
          getDomId: function getDomId() {
            return optDiv;
          },
          getEscapedQemQueryId: function getEscapedQemQueryId() {
            return '';
          },
          getFirstLook: function getFirstLook() {
            return 0;
          },
          getId: function getId() {
            return id;
          },
          getHtml: function getHtml() {
            return '';
          },
          getName: function getName() {
            return id;
          },
          getOutOfPage: function getOutOfPage() {
            return false;
          },
          getResponseInformation: function getResponseInformation() {
            return response;
          },
          getServices: function getServices() {
            return Array.from(services);
          },
          getSizes: function getSizes() {
            return sizes;
          },
          getSlotElementId: function getSlotElementId() {
            return optDiv;
          },
          getSlotId: function getSlotId() {
            return slot;
          },
          getTargeting: function getTargeting(k) {
            return targeting.get(k) || gTargeting.get(k) || [];
          },
          getTargetingKeys: function getTargetingKeys() {
            return Array.from(new Set(Array.of(...gTargeting.keys(), ...targeting.keys())));
          },
          getTargetingMap: function getTargetingMap() {
            return Object.assign(Object.fromEntries(gTargeting.entries()), Object.fromEntries(targeting.entries()));
          },
          set(k, v) {
            attributes.set(k, v);
            return slot;
          },
          setCategoryExclusion(e) {
            exclusions.add(e);
            return slot;
          },
          setClickUrl(u) {
            clickUrl = u;
            return slot;
          },
          setCollapseEmptyDiv(v) {
            collapseEmptyDiv = !!v;
            return slot;
          },
          setSafeFrameConfig: noopThis,
          setTagForChildDirectedTreatment: noopThis,
          setTargeting(k, v) {
            targeting.set(k, getTargetingValue(v));
            return slot;
          },
          toString: function toString() {
            return id;
          },
          updateTargetingFromMap(map) {
            updateTargeting(targeting, map);
            return slot;
          }
        };
        slots.set(adUnitPath, slot);
        slotsById.set(optDiv, slot);
        slotCreatives.set(optDiv, creatives);
        return slot;
      };
      const pubAdsService = {
        addEventListener,
        removeEventListener,
        clear: noopFunc,
        clearCategoryExclusions: noopThis,
        clearTagForChildDirectedTreatment: noopThis,
        clearTargeting(k) {
          if (k === undefined) {
            gTargeting.clear();
          } else {
            gTargeting.delete(k);
          }
        },
        collapseEmptyDivs: noopFunc,
        defineOutOfPagePassback() {
          return new PassbackSlot();
        },
        definePassback() {
          return new PassbackSlot();
        },
        disableInitialLoad: noopFunc,
        display: noopFunc,
        enableAsyncRendering: noopFunc,
        enableLazyLoad: noopFunc,
        enableSingleRequest: noopFunc,
        enableSyncRendering: noopFunc,
        enableVideoAds: noopFunc,
        get: noopNull,
        getAttributeKeys: noopArray,
        getTargeting: noopArray,
        getTargetingKeys: noopArray,
        getSlots: noopArray,
        isInitialLoadDisabled: trueFunc,
        refresh: noopFunc,
        set: noopThis,
        setCategoryExclusion: noopThis,
        setCentering: noopFunc,
        setCookieOptions: noopThis,
        setForceSafeFrame: noopThis,
        setLocation: noopThis,
        setPublisherProvidedId: noopThis,
        setRequestNonPersonalizedAds: noopThis,
        setSafeFrameConfig: noopThis,
        setTagForChildDirectedTreatment: noopThis,
        setTargeting: noopThis,
        setVideoContent: noopThis,
        updateCorrelator: noopFunc
      };
      const _window = window,
        _window$googletag = _window.googletag,
        googletag = _window$googletag === void 0 ? {} : _window$googletag;
      const _googletag$cmd = googletag.cmd,
        cmd = _googletag$cmd === void 0 ? [] : _googletag$cmd;
      googletag.apiReady = true;
      googletag.cmd = [];
      googletag.cmd.push = function (a) {
        try {
          a();
        } catch (ex) {}
        return 1;
      };
      googletag.companionAds = function () {
        return companionAdsService;
      };
      googletag.content = function () {
        return contentService;
      };
      googletag.defineOutOfPageSlot = defineSlot;
      googletag.defineSlot = defineSlot;
      googletag.destroySlots = function () {
        slots.clear();
        slotsById.clear();
      };
      googletag.disablePublisherConsole = noopFunc;
      googletag.display = function (arg) {
        let id;
        if (arg !== null && arg !== void 0 && arg.getSlotElementId) {
          id = arg.getSlotElementId();
        } else if (arg !== null && arg !== void 0 && arg.nodeType) {
          id = arg.id;
        } else {
          id = String(arg);
        }
        displaySlot(slotsById.get(id));
      };
      googletag.enableServices = noopFunc;
      googletag.getVersion = noopStr;
      googletag.pubads = function () {
        return pubAdsService;
      };
      googletag.pubadsReady = true;
      googletag.setAdIframeTitle = noopFunc;
      googletag.sizeMapping = function () {
        return new SizeMappingBuilder();
      };
      window.googletag = googletag;
      while (cmd.length !== 0) {
        googletag.cmd.push(cmd.shift());
      }
      hit(source);
    }
    GoogleTagServicesGpt.names = ['googletagservices-gpt', 'ubo-googletagservices_gpt.js', 'googletagservices_gpt.js'];
    GoogleTagServicesGpt.injections = [hit, noopFunc, noopThis, noopNull, noopArray, noopStr, trueFunc];
    function ScoreCardResearchBeacon(source) {
      window.COMSCORE = {
        purge() {
          window._comscore = [];
        },
        beacon() {}
      };
      hit(source);
    }
    ScoreCardResearchBeacon.names = ['scorecardresearch-beacon', 'ubo-scorecardresearch_beacon.js', 'scorecardresearch_beacon.js'];
    ScoreCardResearchBeacon.injections = [hit];
    function metrikaYandexTag(source) {
      const asyncCallbackFromOptions = function asyncCallbackFromOptions(id, param) {
        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        let callback = options.callback;
        const ctx = options.ctx;
        if (typeof callback === 'function') {
          callback = ctx !== undefined ? callback.bind(ctx) : callback;
          setTimeout(function () {
            return callback();
          });
        }
      };
      const addFileExtension = noopFunc;
      const extLink = asyncCallbackFromOptions;
      const file = asyncCallbackFromOptions;
      const getClientID = function getClientID(id, cb) {
        if (!cb) {
          return;
        }
        setTimeout(cb(null));
      };
      const hitFunc = asyncCallbackFromOptions;
      const notBounce = asyncCallbackFromOptions;
      const params = noopFunc;
      const reachGoal = function reachGoal(id, target, params, callback, ctx) {
        asyncCallbackFromOptions(null, null, {
          callback,
          ctx
        });
      };
      const setUserID = noopFunc;
      const userParams = noopFunc;
      const destruct = noopFunc;
      const api = {
        addFileExtension,
        extLink,
        file,
        getClientID,
        hit: hitFunc,
        notBounce,
        params,
        reachGoal,
        setUserID,
        userParams,
        destruct
      };
      function ym(id, funcName) {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return api[funcName] && api[funcName](id, ...args);
      }
      function init(id) {
        window["yaCounter".concat(id)] = api;
        document.dispatchEvent(new Event("yacounter".concat(id, "inited")));
      }
      if (typeof window.ym === 'undefined') {
        window.ym = ym;
        ym.a = [];
      } else if (window.ym && window.ym.a) {
        ym.a = window.ym.a;
        window.ym = ym;
        window.ym.a.forEach(function (params) {
          const id = params[0];
          init(id);
        });
      }
      hit(source);
    }
    metrikaYandexTag.names = ['metrika-yandex-tag'];
    metrikaYandexTag.injections = [hit, noopFunc];
    function metrikaYandexWatch(source) {
      const cbName = 'yandex_metrika_callbacks';
      const asyncCallbackFromOptions = function asyncCallbackFromOptions() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        let callback = options.callback;
        const ctx = options.ctx;
        if (typeof callback === 'function') {
          callback = ctx !== undefined ? callback.bind(ctx) : callback;
          setTimeout(function () {
            return callback();
          });
        }
      };
      function Metrika() {}
      Metrika.counters = noopArray;
      Metrika.prototype.addFileExtension = noopFunc;
      Metrika.prototype.getClientID = noopFunc;
      Metrika.prototype.setUserID = noopFunc;
      Metrika.prototype.userParams = noopFunc;
      Metrika.prototype.params = noopFunc;
      Metrika.prototype.counters = noopArray;
      Metrika.prototype.extLink = function (url, options) {
        asyncCallbackFromOptions(options);
      };
      Metrika.prototype.file = function (url, options) {
        asyncCallbackFromOptions(options);
      };
      Metrika.prototype.hit = function (url, options) {
        asyncCallbackFromOptions(options);
      };
      Metrika.prototype.reachGoal = function (target, params, cb, ctx) {
        asyncCallbackFromOptions({
          callback: cb,
          ctx
        });
      };
      Metrika.prototype.notBounce = asyncCallbackFromOptions;
      if (window.Ya) {
        window.Ya.Metrika = Metrika;
      } else {
        window.Ya = {
          Metrika
        };
      }
      if (window[cbName] && Array.isArray(window[cbName])) {
        window[cbName].forEach(function (func) {
          if (typeof func === 'function') {
            func();
          }
        });
      }
      hit(source);
    }
    metrikaYandexWatch.names = ['metrika-yandex-watch'];
    metrikaYandexWatch.injections = [hit, noopFunc, noopArray];
    function Pardot(source) {
      window.piVersion = '1.0.2';
      window.piScriptNum = 0;
      window.piScriptObj = [];
      window.checkNamespace = noopFunc;
      window.getPardotUrl = noopStr;
      window.piGetParameter = noopNull;
      window.piSetCookie = noopFunc;
      window.piGetCookie = noopStr;
      function piTracker() {
        window.pi = {
          tracker: {
            visitor_id: '',
            visitor_id_sign: '',
            pi_opt_in: '',
            campaign_id: ''
          }
        };
        window.piScriptNum += 1;
      }
      window.piResponse = noopFunc;
      window.piTracker = piTracker;
      piTracker();
      hit(source);
    }
    Pardot.names = ['pardot-1.0'];
    Pardot.injections = [hit, noopFunc, noopStr, noopNull];
    const preventBab$1 = preventBab$2;
    preventBab$1.names = ['prevent-bab',
    'nobab.js', 'ubo-nobab.js', 'bab-defuser.js', 'ubo-bab-defuser.js', 'ubo-nobab', 'ubo-bab-defuser'];
    function AmazonApstag(source) {
      const apstagWrapper = {
        fetchBids(a, b) {
          if (typeof b === 'function') {
            b([]);
          }
        },
        init: noopFunc,
        setDisplayBids: noopFunc,
        targetingKeys: noopFunc
      };
      window.apstag = apstagWrapper;
      hit(source);
    }
    AmazonApstag.names = ['amazon-apstag', 'ubo-amazon_apstag.js', 'amazon_apstag.js'];
    AmazonApstag.injections = [hit, noopFunc];
    function Matomo(source) {
      const Tracker = function Tracker() {};
      Tracker.prototype.setDoNotTrack = noopFunc;
      Tracker.prototype.setDomains = noopFunc;
      Tracker.prototype.setCustomDimension = noopFunc;
      Tracker.prototype.trackPageView = noopFunc;
      const AsyncTracker = function AsyncTracker() {};
      AsyncTracker.prototype.addListener = noopFunc;
      const matomoWrapper = {
        getTracker: Tracker,
        getAsyncTracker: AsyncTracker
      };
      window.Piwik = matomoWrapper;
      hit(source);
    }
    Matomo.names = ['matomo'];
    Matomo.injections = [hit, noopFunc];
    function Fingerprintjs2(source) {
      let browserId = '';
      for (let i = 0; i < 8; i += 1) {
        browserId += (Math.random() * 0x10000 + 0x1000).toString(16).slice(-4);
      }
      const Fingerprint2 = function Fingerprint2() {};
      Fingerprint2.get = function (options, callback) {
        if (!callback) {
          callback = options;
        }
        setTimeout(function () {
          if (callback) {
            callback(browserId, []);
          }
        }, 1);
      };
      Fingerprint2.prototype = {
        get: Fingerprint2.get
      };
      window.Fingerprint2 = Fingerprint2;
      hit(source);
    }
    Fingerprintjs2.names = ['fingerprintjs2',
    'ubo-fingerprint2.js',
    'fingerprint2.js'];
    Fingerprintjs2.injections = [hit];
    function Fingerprintjs3(source) {
      const visitorId = function () {
        let id = '';
        for (let i = 0; i < 8; i += 1) {
          id += (Math.random() * 0x10000 + 0x1000).toString(16).slice(-4);
        }
        return id;
      }();
      const FingerprintJS = function FingerprintJS() {};
      FingerprintJS.prototype = {
        load() {
          return Promise.resolve(new FingerprintJS());
        },
        get() {
          return Promise.resolve({
            visitorId
          });
        },
        hashComponents: noopStr
      };
      window.FingerprintJS = new FingerprintJS();
      hit(source);
    }
    Fingerprintjs3.names = ['fingerprintjs3',
    'ubo-fingerprint3.js',
    'fingerprint3.js'];
    Fingerprintjs3.injections = [hit, noopStr];
    function Gemius(source) {
      const GemiusPlayer = function GemiusPlayer() {};
      GemiusPlayer.prototype = {
        setVideoObject: noopFunc,
        newProgram: noopFunc,
        programEvent: noopFunc,
        newAd: noopFunc,
        adEvent: noopFunc
      };
      window.GemiusPlayer = GemiusPlayer;
      hit(source);
    }
    Gemius.names = ['gemius'];
    Gemius.injections = [hit, noopFunc];
    function ATInternetSmartTag(source) {
      const setNoopFuncWrapper = {
        set: noopFunc
      };
      const sendNoopFuncWrapper = {
        send: noopFunc
      };
      const ecommerceWrapper = {
        displayCart: {
          products: setNoopFuncWrapper,
          cart: setNoopFuncWrapper
        },
        updateCart: {
          cart: setNoopFuncWrapper
        },
        displayProduct: {
          products: setNoopFuncWrapper
        },
        displayPageProduct: {
          products: setNoopFuncWrapper
        },
        addProduct: {
          products: setNoopFuncWrapper
        },
        removeProduct: {
          products: setNoopFuncWrapper
        }
      };
      const tag = function tag() {};
      tag.prototype = {
        setConfig: noopFunc,
        setParam: noopFunc,
        dispatch: noopFunc,
        customVars: setNoopFuncWrapper,
        publisher: setNoopFuncWrapper,
        order: setNoopFuncWrapper,
        click: sendNoopFuncWrapper,
        clickListener: sendNoopFuncWrapper,
        internalSearch: {
          set: noopFunc,
          send: noopFunc
        },
        ecommerce: ecommerceWrapper,
        identifiedVisitor: {
          unset: noopFunc
        },
        page: {
          set: noopFunc,
          send: noopFunc
        },
        selfPromotion: {
          add: noopFunc,
          send: noopFunc
        },
        privacy: {
          setVisitorMode: noopFunc,
          getVisitorMode: noopFunc,
          hit: noopFunc
        },
        richMedia: {
          add: noopFunc,
          send: noopFunc,
          remove: noopFunc,
          removeAll: noopFunc
        }
      };
      const smartTagWrapper = {
        Tracker: {
          Tag: tag
        }
      };
      window.ATInternet = smartTagWrapper;
      hit(source);
    }
    ATInternetSmartTag.names = ['ati-smarttag'];
    ATInternetSmartTag.injections = [hit, noopFunc];
    function preventBab2(source) {
      const script = document.currentScript;
      if (script === null) {
        return;
      }
      const url = script.src;
      if (typeof url !== 'string') {
        return;
      }
      const domainsStr = ['adclixx\\.net', 'adnetasia\\.com', 'adtrackers\\.net', 'bannertrack\\.net'].join('|');
      const matchStr = "^https?://[\\w-]+\\.(".concat(domainsStr, ")/.");
      const domainsRegex = new RegExp(matchStr);
      if (domainsRegex.test(url) === false) {
        return;
      }
      window.nH7eXzOsG = 858;
      hit(source);
    }
    preventBab2.names = ['prevent-bab2',
    'nobab2.js'];
    preventBab2.injections = [hit];
    function GoogleIma3(source) {
      const VERSION = '3.453.0';
      const ima = {};
      const AdDisplayContainer = function AdDisplayContainer() {};
      AdDisplayContainer.prototype.destroy = noopFunc;
      AdDisplayContainer.prototype.initialize = noopFunc;
      const ImaSdkSettings = function ImaSdkSettings() {};
      ImaSdkSettings.CompanionBackfillMode = {
        ALWAYS: 'always',
        ON_MASTER_AD: 'on_master_ad'
      };
      ImaSdkSettings.VpaidMode = {
        DISABLED: 0,
        ENABLED: 1,
        INSECURE: 2
      };
      ImaSdkSettings.prototype = {
        c: true,
        f: {},
        i: false,
        l: '',
        p: '',
        r: 0,
        t: '',
        v: '',
        getCompanionBackfill: noopFunc,
        getDisableCustomPlaybackForIOS10Plus() {
          return this.i;
        },
        getDisabledFlashAds: function getDisabledFlashAds() {
          return true;
        },
        getFeatureFlags() {
          return this.f;
        },
        getLocale() {
          return this.l;
        },
        getNumRedirects() {
          return this.r;
        },
        getPlayerType() {
          return this.t;
        },
        getPlayerVersion() {
          return this.v;
        },
        getPpid() {
          return this.p;
        },
        getVpaidMode() {
          return this.C;
        },
        isCookiesEnabled() {
          return this.c;
        },
        isVpaidAdapter() {
          return this.M;
        },
        setCompanionBackfill: noopFunc,
        setAutoPlayAdBreaks(a) {
          this.K = a;
        },
        setCookiesEnabled(c) {
          this.c = !!c;
        },
        setDisableCustomPlaybackForIOS10Plus(i) {
          this.i = !!i;
        },
        setDisableFlashAds: noopFunc,
        setFeatureFlags(f) {
          this.f = !!f;
        },
        setIsVpaidAdapter(a) {
          this.M = a;
        },
        setLocale(l) {
          this.l = !!l;
        },
        setNumRedirects(r) {
          this.r = !!r;
        },
        setPageCorrelator(a) {
          this.R = a;
        },
        setPlayerType(t) {
          this.t = !!t;
        },
        setPlayerVersion(v) {
          this.v = !!v;
        },
        setPpid(p) {
          this.p = !!p;
        },
        setVpaidMode(a) {
          this.C = a;
        },
        setSessionId: noopFunc,
        setStreamCorrelator: noopFunc,
        setVpaidAllowed: noopFunc,
        CompanionBackfillMode: {
          ALWAYS: 'always',
          ON_MASTER_AD: 'on_master_ad'
        },
        VpaidMode: {
          DISABLED: 0,
          ENABLED: 1,
          INSECURE: 2
        }
      };
      const EventHandler = function EventHandler() {
        this.listeners = new Map();
        this._dispatch = function (e) {
          const listeners = this.listeners.get(e.type) || [];
          for (var _i = 0, _Array$from = Array.from(listeners); _i < _Array$from.length; _i++) {
            const listener = _Array$from[_i];
            try {
              listener(e);
            } catch (r) {
              logMessage(source, r);
            }
          }
        };
        this.addEventListener = function (t, c) {
          if (!this.listeners.has(t)) {
            this.listeners.set(t, new Set());
          }
          this.listeners.get(t).add(c);
        };
        this.removeEventListener = function (t, c) {
          var _this$listeners$get;
          (_this$listeners$get = this.listeners.get(t)) === null || _this$listeners$get === void 0 ? void 0 : _this$listeners$get.delete(c);
        };
      };
      const AdsManager = new EventHandler();
      AdsManager.volume = 1;
      AdsManager.collapse = noopFunc;
      AdsManager.configureAdsManager = noopFunc;
      AdsManager.destroy = noopFunc;
      AdsManager.discardAdBreak = noopFunc;
      AdsManager.expand = noopFunc;
      AdsManager.focus = noopFunc;
      AdsManager.getAdSkippableState = function () {
        return false;
      };
      AdsManager.getCuePoints = function () {
        return [0];
      };
      AdsManager.getCurrentAd = function () {
        return currentAd;
      };
      AdsManager.getCurrentAdCuePoints = function () {
        return [];
      };
      AdsManager.getRemainingTime = function () {
        return 0;
      };
      AdsManager.getVolume = function () {
        return this.volume;
      };
      AdsManager.init = noopFunc;
      AdsManager.isCustomClickTrackingUsed = function () {
        return false;
      };
      AdsManager.isCustomPlaybackUsed = function () {
        return false;
      };
      AdsManager.pause = noopFunc;
      AdsManager.requestNextAdBreak = noopFunc;
      AdsManager.resize = noopFunc;
      AdsManager.resume = noopFunc;
      AdsManager.setVolume = function (v) {
        this.volume = v;
      };
      AdsManager.skip = noopFunc;
      AdsManager.start = function () {
        for (var _i2 = 0, _arr = [AdEvent.Type.ALL_ADS_COMPLETED, AdEvent.Type.CONTENT_RESUME_REQUESTED]; _i2 < _arr.length; _i2++) {
          const type = _arr[_i2];
          try {
            this._dispatch(new ima.AdEvent(type));
          } catch (e) {
            logMessage(source, e);
          }
        }
      };
      AdsManager.stop = noopFunc;
      AdsManager.updateAdsRenderingSettings = noopFunc;
      const manager = Object.create(AdsManager);
      const AdsManagerLoadedEvent = function AdsManagerLoadedEvent(type, adsRequest, userRequestContext) {
        this.type = type;
        this.adsRequest = adsRequest;
        this.userRequestContext = userRequestContext;
      };
      AdsManagerLoadedEvent.prototype = {
        getAdsManager: function getAdsManager() {
          return manager;
        },
        getUserRequestContext() {
          if (this.userRequestContext) {
            return this.userRequestContext;
          }
          return {};
        }
      };
      AdsManagerLoadedEvent.Type = {
        ADS_MANAGER_LOADED: 'adsManagerLoaded'
      };
      const AdsLoader = EventHandler;
      AdsLoader.prototype.settings = new ImaSdkSettings();
      AdsLoader.prototype.contentComplete = noopFunc;
      AdsLoader.prototype.destroy = noopFunc;
      AdsLoader.prototype.getSettings = function () {
        return this.settings;
      };
      AdsLoader.prototype.getVersion = function () {
        return VERSION;
      };
      AdsLoader.prototype.requestAds = function (adsRequest, userRequestContext) {
        var _this = this;
        requestAnimationFrame(function () {
          const ADS_MANAGER_LOADED = AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED;
          const event = new ima.AdsManagerLoadedEvent(ADS_MANAGER_LOADED, adsRequest, userRequestContext);
          _this._dispatch(event);
        });
        const e = new ima.AdError('adPlayError', 1205, 1205, 'The browser prevented playback initiated without user interaction.', adsRequest, userRequestContext);
        requestAnimationFrame(function () {
          _this._dispatch(new ima.AdErrorEvent(e));
        });
      };
      const AdsRenderingSettings = noopFunc;
      const AdsRequest = function AdsRequest() {};
      AdsRequest.prototype = {
        setAdWillAutoPlay: noopFunc,
        setAdWillPlayMuted: noopFunc,
        setContinuousPlayback: noopFunc
      };
      const AdPodInfo = function AdPodInfo() {};
      AdPodInfo.prototype = {
        getAdPosition: function getAdPosition() {
          return 1;
        },
        getIsBumper: function getIsBumper() {
          return false;
        },
        getMaxDuration: function getMaxDuration() {
          return -1;
        },
        getPodIndex: function getPodIndex() {
          return 1;
        },
        getTimeOffset: function getTimeOffset() {
          return 0;
        },
        getTotalAds: function getTotalAds() {
          return 1;
        }
      };
      const Ad = function Ad() {};
      Ad.prototype = {
        pi: new AdPodInfo(),
        getAdId: function getAdId() {
          return '';
        },
        getAdPodInfo() {
          return this.pi;
        },
        getAdSystem: function getAdSystem() {
          return '';
        },
        getAdvertiserName: function getAdvertiserName() {
          return '';
        },
        getApiFramework: function getApiFramework() {
          return null;
        },
        getCompanionAds: function getCompanionAds() {
          return [];
        },
        getContentType: function getContentType() {
          return '';
        },
        getCreativeAdId: function getCreativeAdId() {
          return '';
        },
        getDealId: function getDealId() {
          return '';
        },
        getDescription: function getDescription() {
          return '';
        },
        getDuration: function getDuration() {
          return 8.5;
        },
        getHeight: function getHeight() {
          return 0;
        },
        getMediaUrl: function getMediaUrl() {
          return null;
        },
        getMinSuggestedDuration: function getMinSuggestedDuration() {
          return -2;
        },
        getSkipTimeOffset: function getSkipTimeOffset() {
          return -1;
        },
        getSurveyUrl: function getSurveyUrl() {
          return null;
        },
        getTitle: function getTitle() {
          return '';
        },
        getTraffickingParametersString: function getTraffickingParametersString() {
          return '';
        },
        getUiElements: function getUiElements() {
          return [''];
        },
        getUniversalAdIdRegistry: function getUniversalAdIdRegistry() {
          return 'unknown';
        },
        getUniversalAdIds: function getUniversalAdIds() {
          return [''];
        },
        getUniversalAdIdValue: function getUniversalAdIdValue() {
          return 'unknown';
        },
        getVastMediaBitrate: function getVastMediaBitrate() {
          return 0;
        },
        getVastMediaHeight: function getVastMediaHeight() {
          return 0;
        },
        getVastMediaWidth: function getVastMediaWidth() {
          return 0;
        },
        getWidth: function getWidth() {
          return 0;
        },
        getWrapperAdIds: function getWrapperAdIds() {
          return [''];
        },
        getWrapperAdSystems: function getWrapperAdSystems() {
          return [''];
        },
        getWrapperCreativeIds: function getWrapperCreativeIds() {
          return [''];
        },
        isLinear: function isLinear() {
          return true;
        },
        isSkippable() {
          return true;
        }
      };
      const CompanionAd = function CompanionAd() {};
      CompanionAd.prototype = {
        getAdSlotId: function getAdSlotId() {
          return '';
        },
        getContent: function getContent() {
          return '';
        },
        getContentType: function getContentType() {
          return '';
        },
        getHeight: function getHeight() {
          return 1;
        },
        getWidth: function getWidth() {
          return 1;
        }
      };
      const AdError = function AdError(type, code, vast, message, adsRequest, userRequestContext) {
        this.errorCode = code;
        this.message = message;
        this.type = type;
        this.adsRequest = adsRequest;
        this.userRequestContext = userRequestContext;
        this.getErrorCode = function () {
          return this.errorCode;
        };
        this.getInnerError = function () {};
        this.getMessage = function () {
          return this.message;
        };
        this.getType = function () {
          return this.type;
        };
        this.getVastErrorCode = function () {
          return this.vastErrorCode;
        };
        this.toString = function () {
          return "AdError ".concat(this.errorCode, ": ").concat(this.message);
        };
      };
      AdError.ErrorCode = {};
      AdError.Type = {};
      const isEngadget = function isEngadget() {
        try {
          for (var _i3 = 0, _Object$values = Object.values(window.vidible._getContexts()); _i3 < _Object$values.length; _i3++) {
            var _ctx$getPlayer, _ctx$getPlayer$div;
            const ctx = _Object$values[_i3];
            if ((_ctx$getPlayer = ctx.getPlayer()) !== null && _ctx$getPlayer !== void 0 && (_ctx$getPlayer$div = _ctx$getPlayer.div) !== null && _ctx$getPlayer$div !== void 0 && _ctx$getPlayer$div.innerHTML.includes('www.engadget.com')) {
              return true;
            }
          }
        } catch (e) {}
        return false;
      };
      const currentAd = isEngadget() ? undefined : new Ad();
      const AdEvent = function AdEvent(type) {
        this.type = type;
      };
      AdEvent.prototype = {
        getAd: function getAd() {
          return currentAd;
        },
        getAdData: function getAdData() {}
      };
      AdEvent.Type = {
        AD_BREAK_READY: 'adBreakReady',
        AD_BUFFERING: 'adBuffering',
        AD_CAN_PLAY: 'adCanPlay',
        AD_METADATA: 'adMetadata',
        AD_PROGRESS: 'adProgress',
        ALL_ADS_COMPLETED: 'allAdsCompleted',
        CLICK: 'click',
        COMPLETE: 'complete',
        CONTENT_PAUSE_REQUESTED: 'contentPauseRequested',
        CONTENT_RESUME_REQUESTED: 'contentResumeRequested',
        DURATION_CHANGE: 'durationChange',
        EXPANDED_CHANGED: 'expandedChanged',
        FIRST_QUARTILE: 'firstQuartile',
        IMPRESSION: 'impression',
        INTERACTION: 'interaction',
        LINEAR_CHANGE: 'linearChange',
        LINEAR_CHANGED: 'linearChanged',
        LOADED: 'loaded',
        LOG: 'log',
        MIDPOINT: 'midpoint',
        PAUSED: 'pause',
        RESUMED: 'resume',
        SKIPPABLE_STATE_CHANGED: 'skippableStateChanged',
        SKIPPED: 'skip',
        STARTED: 'start',
        THIRD_QUARTILE: 'thirdQuartile',
        USER_CLOSE: 'userClose',
        VIDEO_CLICKED: 'videoClicked',
        VIDEO_ICON_CLICKED: 'videoIconClicked',
        VIEWABLE_IMPRESSION: 'viewable_impression',
        VOLUME_CHANGED: 'volumeChange',
        VOLUME_MUTED: 'mute'
      };
      const AdErrorEvent = function AdErrorEvent(error) {
        this.error = error;
        this.type = 'adError';
        this.getError = function () {
          return this.error;
        };
        this.getUserRequestContext = function () {
          var _this$error;
          if ((_this$error = this.error) !== null && _this$error !== void 0 && _this$error.userRequestContext) {
            return this.error.userRequestContext;
          }
          return {};
        };
      };
      AdErrorEvent.Type = {
        AD_ERROR: 'adError'
      };
      const CustomContentLoadedEvent = function CustomContentLoadedEvent() {};
      CustomContentLoadedEvent.Type = {
        CUSTOM_CONTENT_LOADED: 'deprecated-event'
      };
      const CompanionAdSelectionSettings = function CompanionAdSelectionSettings() {};
      CompanionAdSelectionSettings.CreativeType = {
        ALL: 'All',
        FLASH: 'Flash',
        IMAGE: 'Image'
      };
      CompanionAdSelectionSettings.ResourceType = {
        ALL: 'All',
        HTML: 'Html',
        IFRAME: 'IFrame',
        STATIC: 'Static'
      };
      CompanionAdSelectionSettings.SizeCriteria = {
        IGNORE: 'IgnoreSize',
        SELECT_EXACT_MATCH: 'SelectExactMatch',
        SELECT_NEAR_MATCH: 'SelectNearMatch'
      };
      const AdCuePoints = function AdCuePoints() {};
      AdCuePoints.prototype = {
        getCuePoints: function getCuePoints() {
          return [];
        },
        getAdIdRegistry: function getAdIdRegistry() {
          return '';
        },
        getAdIsValue: function getAdIsValue() {
          return '';
        }
      };
      const AdProgressData = noopFunc;
      const UniversalAdIdInfo = function UniversalAdIdInfo() {};
      Object.assign(ima, {
        AdCuePoints,
        AdDisplayContainer,
        AdError,
        AdErrorEvent,
        AdEvent,
        AdPodInfo,
        AdProgressData,
        AdsLoader,
        AdsManager: manager,
        AdsManagerLoadedEvent,
        AdsRenderingSettings,
        AdsRequest,
        CompanionAd,
        CompanionAdSelectionSettings,
        CustomContentLoadedEvent,
        gptProxyInstance: {},
        ImaSdkSettings,
        OmidAccessMode: {
          DOMAIN: 'domain',
          FULL: 'full',
          LIMITED: 'limited'
        },
        settings: new ImaSdkSettings(),
        UiElements: {
          AD_ATTRIBUTION: 'adAttribution',
          COUNTDOWN: 'countdown'
        },
        UniversalAdIdInfo,
        VERSION,
        ViewMode: {
          FULLSCREEN: 'fullscreen',
          NORMAL: 'normal'
        }
      });
      if (!window.google) {
        window.google = {};
      }
      window.google.ima = ima;
      hit(source);
    }
    GoogleIma3.names = ['google-ima3',
    'ubo-google-ima.js',
    'google-ima.js'];
    GoogleIma3.injections = [hit, noopFunc, logMessage];
    function DidomiLoader(source) {
      function UserConsentStatusForVendorSubscribe() {}
      UserConsentStatusForVendorSubscribe.prototype.filter = function () {
        return new UserConsentStatusForVendorSubscribe();
      };
      UserConsentStatusForVendorSubscribe.prototype.subscribe = noopFunc;
      function UserConsentStatusForVendor() {}
      UserConsentStatusForVendor.prototype.first = function () {
        return new UserConsentStatusForVendorSubscribe();
      };
      UserConsentStatusForVendor.prototype.filter = function () {
        return new UserConsentStatusForVendorSubscribe();
      };
      UserConsentStatusForVendor.prototype.subscribe = noopFunc;
      const DidomiWrapper = {
        isConsentRequired: falseFunc,
        getUserConsentStatusForPurpose: trueFunc,
        getUserConsentStatus: trueFunc,
        getUserStatus: noopFunc,
        getRequiredPurposes: noopArray,
        getUserConsentStatusForVendor: trueFunc,
        Purposes: {
          Cookies: 'cookies'
        },
        notice: {
          configure: noopFunc,
          hide: noopFunc,
          isVisible: falseFunc,
          show: noopFunc,
          showDataProcessing: trueFunc
        },
        isUserConsentStatusPartial: falseFunc,
        on() {
          return {
            actions: {},
            emitter: {},
            services: {},
            store: {}
          };
        },
        shouldConsentBeCollected: falseFunc,
        getUserConsentStatusForAll: noopFunc,
        getObservableOnUserConsentStatusForVendor() {
          return new UserConsentStatusForVendor();
        }
      };
      window.Didomi = DidomiWrapper;
      const didomiStateWrapper = {
        didomiExperimentId: '',
        didomiExperimentUserGroup: '',
        didomiGDPRApplies: 1,
        didomiIABConsent: '',
        didomiPurposesConsent: '',
        didomiPurposesConsentDenied: '',
        didomiPurposesConsentUnknown: '',
        didomiVendorsConsent: '',
        didomiVendorsConsentDenied: '',
        didomiVendorsConsentUnknown: '',
        didomiVendorsRawConsent: '',
        didomiVendorsRawConsentDenied: '',
        didomiVendorsRawConsentUnknown: ''
      };
      window.didomiState = didomiStateWrapper;
      const tcData = {
        eventStatus: 'tcloaded',
        gdprApplies: false,
        listenerId: noopFunc,
        vendor: {
          consents: []
        },
        purpose: {
          consents: []
        }
      };
      const __tcfapiWrapper = function __tcfapiWrapper(command, version, callback) {
        if (typeof callback !== 'function' || command === 'removeEventListener') {
          return;
        }
        callback(tcData, true);
      };
      window.__tcfapi = __tcfapiWrapper;
      const didomiEventListenersWrapper = {
        stub: true,
        push: noopFunc
      };
      window.didomiEventListeners = didomiEventListenersWrapper;
      const didomiOnReadyWrapper = {
        stub: true,
        push(arg) {
          if (typeof arg !== 'function') {
            return;
          }
          if (document.readyState !== 'complete') {
            window.addEventListener('load', function () {
              setTimeout(arg(window.Didomi));
            });
          } else {
            setTimeout(arg(window.Didomi));
          }
        }
      };
      window.didomiOnReady = window.didomiOnReady || didomiOnReadyWrapper;
      if (Array.isArray(window.didomiOnReady)) {
        window.didomiOnReady.forEach(function (arg) {
          if (typeof arg === 'function') {
            try {
              setTimeout(arg(window.Didomi));
            } catch (e) {
            }
          }
        });
      }
      hit(source);
    }
    DidomiLoader.names = ['didomi-loader'];
    DidomiLoader.injections = [hit, noopFunc, noopArray, trueFunc, falseFunc];
    function Prebid(source) {
      const pushFunction = function pushFunction(arg) {
        if (typeof arg === 'function') {
          try {
            arg.call();
          } catch (ex) {
          }
        }
      };
      const pbjsWrapper = {
        addAdUnits() {},
        adServers: {
          dfp: {
            buildVideoUrl: noopStr
          }
        },
        adUnits: [],
        aliasBidder() {},
        cmd: [],
        enableAnalytics() {},
        getHighestCpmBids: noopArray,
        libLoaded: true,
        que: [],
        requestBids(arg) {
          if (arg instanceof Object && arg.bidsBackHandler) {
            try {
              arg.bidsBackHandler.call();
            } catch (ex) {
            }
          }
        },
        removeAdUnit() {},
        setBidderConfig() {},
        setConfig() {},
        setTargetingForGPTAsync() {}
      };
      pbjsWrapper.cmd.push = pushFunction;
      pbjsWrapper.que.push = pushFunction;
      window.pbjs = pbjsWrapper;
      hit(source);
    }
    Prebid.names = ['prebid'];
    Prebid.injections = [hit, noopFunc, noopStr, noopArray];
    function prebidAds(source) {
      window.canRunAds = true;
      window.isAdBlockActive = false;
      hit(source);
    }
    prebidAds.names = ['prebid-ads', 'ubo-prebid-ads.js', 'prebid-ads.js'];
    prebidAds.injections = [hit];
    function NaverWcslog(source) {
      window.wcs_add = {};
      window.wcs_do = noopFunc;
      window.wcs = {
        inflow: noopFunc
      };
      hit(source);
    }
    NaverWcslog.names = ['naver-wcslog'];
    NaverWcslog.injections = [hit, noopFunc];
    var redirectsList = Object.freeze({
        __proto__: null,
        noeval: noeval$1,
        GoogleAnalytics: GoogleAnalytics,
        GoogleAnalyticsGa: GoogleAnalyticsGa,
        GoogleSyndicationAdsByGoogle: GoogleSyndicationAdsByGoogle,
        GoogleTagServicesGpt: GoogleTagServicesGpt,
        ScoreCardResearchBeacon: ScoreCardResearchBeacon,
        metrikaYandexTag: metrikaYandexTag,
        metrikaYandexWatch: metrikaYandexWatch,
        Pardot: Pardot,
        preventFab: preventFab$1,
        preventBab: preventBab$1,
        setPopadsDummy: setPopadsDummy$1,
        preventPopadsNet: preventPopadsNet$1,
        AmazonApstag: AmazonApstag,
        Matomo: Matomo,
        Fingerprintjs2: Fingerprintjs2,
        Fingerprintjs3: Fingerprintjs3,
        Gemius: Gemius,
        ATInternetSmartTag: ATInternetSmartTag,
        preventBab2: preventBab2,
        GoogleIma3: GoogleIma3,
        DidomiLoader: DidomiLoader,
        Prebid: Prebid,
        prebidAds: prebidAds,
        NaverWcslog: NaverWcslog
    });
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var defineProperty = _defineProperty;
    function isNothing(subject) {
      return typeof subject === 'undefined' || subject === null;
    }
    function isObject(subject) {
      return typeof subject === 'object' && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];
      return [sequence];
    }
    function extend(target, source) {
      var index, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key = sourceKeys[index];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = '',
        cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    var isNothing_1 = isNothing;
    var isObject_1 = isObject;
    var toArray_1 = toArray;
    var repeat_1 = repeat;
    var isNegativeZero_1 = isNegativeZero;
    var extend_1 = extend;
    var common = {
      isNothing: isNothing_1,
      isObject: isObject_1,
      toArray: toArray_1,
      repeat: repeat_1,
      isNegativeZero: isNegativeZero_1,
      extend: extend_1
    };
    function YAMLException$1(reason, mark) {
      Error.call(this);
      this.name = 'YAMLException';
      this.reason = reason;
      this.mark = mark;
      this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || '';
      }
    }
    YAMLException$1.prototype = Object.create(Error.prototype);
    YAMLException$1.prototype.constructor = YAMLException$1;
    YAMLException$1.prototype.toString = function toString(compact) {
      var result = this.name + ': ';
      result += this.reason || '(unknown reason)';
      if (!compact && this.mark) {
        result += ' ' + this.mark.toString();
      }
      return result;
    };
    var exception = YAMLException$1;
    function Mark(name, buffer, position, line, column) {
      this.name = name;
      this.buffer = buffer;
      this.position = position;
      this.line = line;
      this.column = column;
    }
    Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
      var head, start, tail, end, snippet;
      if (!this.buffer) return null;
      indent = indent || 4;
      maxLength = maxLength || 75;
      head = '';
      start = this.position;
      while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
        start -= 1;
        if (this.position - start > maxLength / 2 - 1) {
          head = ' ... ';
          start += 5;
          break;
        }
      }
      tail = '';
      end = this.position;
      while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
        end += 1;
        if (end - this.position > maxLength / 2 - 1) {
          tail = ' ... ';
          end -= 5;
          break;
        }
      }
      snippet = this.buffer.slice(start, end);
      return common.repeat(' ', indent) + head + snippet + tail + '\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';
    };
    Mark.prototype.toString = function toString(compact) {
      var snippet,
        where = '';
      if (this.name) {
        where += 'in "' + this.name + '" ';
      }
      where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);
      if (!compact) {
        snippet = this.getSnippet();
        if (snippet) {
          where += ':\n' + snippet;
        }
      }
      return where;
    };
    var mark = Mark;
    var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];
    var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function (style) {
          map[style].forEach(function (alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type$1(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function (name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.tag = tag;
      this.kind = options['kind'] || null;
      this.resolve = options['resolve'] || function () {
        return true;
      };
      this.construct = options['construct'] || function (data) {
        return data;
      };
      this.instanceOf = options['instanceOf'] || null;
      this.predicate = options['predicate'] || null;
      this.represent = options['represent'] || null;
      this.defaultStyle = options['defaultStyle'] || null;
      this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    var type = Type$1;
    function compileList(schema, name, result) {
      var exclude = [];
      schema.include.forEach(function (includedSchema) {
        result = compileList(includedSchema, name, result);
      });
      schema[name].forEach(function (currentType) {
        result.forEach(function (previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
            exclude.push(previousIndex);
          }
        });
        result.push(currentType);
      });
      return result.filter(function (type, index) {
        return exclude.indexOf(index) === -1;
      });
    }
    function compileMap(
    ) {
      var result = {
          scalar: {},
          sequence: {},
          mapping: {},
          fallback: {}
        },
        index,
        length;
      function collectType(type) {
        result[type.kind][type.tag] = result['fallback'][type.tag] = type;
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema$1(definition) {
      this.include = definition.include || [];
      this.implicit = definition.implicit || [];
      this.explicit = definition.explicit || [];
      this.implicit.forEach(function (type) {
        if (type.loadKind && type.loadKind !== 'scalar') {
          throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
        }
      });
      this.compiledImplicit = compileList(this, 'implicit', []);
      this.compiledExplicit = compileList(this, 'explicit', []);
      this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
    }
    Schema$1.DEFAULT = null;
    Schema$1.create = function createSchema() {
      var schemas, types;
      switch (arguments.length) {
        case 1:
          schemas = Schema$1.DEFAULT;
          types = arguments[0];
          break;
        case 2:
          schemas = arguments[0];
          types = arguments[1];
          break;
        default:
          throw new exception('Wrong number of arguments for Schema.create function');
      }
      schemas = common.toArray(schemas);
      types = common.toArray(types);
      if (!schemas.every(function (schema) {
        return schema instanceof Schema$1;
      })) {
        throw new exception('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
      }
      if (!types.every(function (type$1) {
        return type$1 instanceof type;
      })) {
        throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
      }
      return new Schema$1({
        include: schemas,
        explicit: types
      });
    };
    var schema = Schema$1;
    var str = new type('tag:yaml.org,2002:str', {
      kind: 'scalar',
      construct: function construct(data) {
        return data !== null ? data : '';
      }
    });
    var seq = new type('tag:yaml.org,2002:seq', {
      kind: 'sequence',
      construct: function construct(data) {
        return data !== null ? data : [];
      }
    });
    var map = new type('tag:yaml.org,2002:map', {
      kind: 'mapping',
      construct: function construct(data) {
        return data !== null ? data : {};
      }
    });
    var failsafe = new schema({
      explicit: [str, seq, map]
    });
    function resolveYamlNull(data) {
      if (data === null) return true;
      var max = data.length;
      return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    var _null = new type('tag:yaml.org,2002:null', {
      kind: 'scalar',
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function canonical() {
          return '~';
        },
        lowercase: function lowercase() {
          return 'null';
        },
        uppercase: function uppercase() {
          return 'NULL';
        },
        camelcase: function camelcase() {
          return 'Null';
        }
      },
      defaultStyle: 'lowercase'
    });
    function resolveYamlBoolean(data) {
      if (data === null) return false;
      var max = data.length;
      return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
    }
    function constructYamlBoolean(data) {
      return data === 'true' || data === 'True' || data === 'TRUE';
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === '[object Boolean]';
    }
    var bool = new type('tag:yaml.org,2002:bool', {
      kind: 'scalar',
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function lowercase(object) {
          return object ? 'true' : 'false';
        },
        uppercase: function uppercase(object) {
          return object ? 'TRUE' : 'FALSE';
        },
        camelcase: function camelcase(object) {
          return object ? 'True' : 'False';
        }
      },
      defaultStyle: 'lowercase'
    });
    function isHexCode(c) {
      return 0x30  <= c && c <= 0x39  || 0x41  <= c && c <= 0x46  || 0x61  <= c && c <= 0x66 ;
    }
    function isOctCode(c) {
      return 0x30  <= c && c <= 0x37 ;
    }
    function isDecCode(c) {
      return 0x30  <= c && c <= 0x39 ;
    }
    function resolveYamlInteger(data) {
      if (data === null) return false;
      var max = data.length,
        index = 0,
        hasDigits = false,
        ch;
      if (!max) return false;
      ch = data[index];
      if (ch === '-' || ch === '+') {
        ch = data[++index];
      }
      if (ch === '0') {
        if (index + 1 === max) return true;
        ch = data[++index];
        if (ch === 'b') {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === '_') continue;
            if (ch !== '0' && ch !== '1') return false;
            hasDigits = true;
          }
          return hasDigits && ch !== '_';
        }
        if (ch === 'x') {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === '_') continue;
            if (!isHexCode(data.charCodeAt(index))) return false;
            hasDigits = true;
          }
          return hasDigits && ch !== '_';
        }
        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (!isOctCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }
      if (ch === '_') return false;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch === ':') break;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === '_') return false;
      if (ch !== ':') return true;
      return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
    }
    function constructYamlInteger(data) {
      var value = data,
        sign = 1,
        ch,
        base,
        digits = [];
      if (value.indexOf('_') !== -1) {
        value = value.replace(/_/g, '');
      }
      ch = value[0];
      if (ch === '-' || ch === '+') {
        if (ch === '-') sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === '0') return 0;
      if (ch === '0') {
        if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
        if (value[1] === 'x') return sign * parseInt(value, 16);
        return sign * parseInt(value, 8);
      }
      if (value.indexOf(':') !== -1) {
        value.split(':').forEach(function (v) {
          digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function (d) {
          value += d * base;
          base *= 60;
        });
        return sign * value;
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);
    }
    var int = new type('tag:yaml.org,2002:int', {
      kind: 'scalar',
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function binary(obj) {
          return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);
        },
        octal: function octal(obj) {
          return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1);
        },
        decimal: function decimal(obj) {
          return obj.toString(10);
        },
        hexadecimal: function hexadecimal(obj) {
          return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: 'decimal',
      styleAliases: {
        binary: [2, 'bin'],
        octal: [8, 'oct'],
        decimal: [10, 'dec'],
        hexadecimal: [16, 'hex']
      }
    });
    var YAML_FLOAT_PATTERN = new RegExp(
    '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
    '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
    '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
    '|[-+]?\\.(?:inf|Inf|INF)' +
    '|\\.(?:nan|NaN|NAN))$');
    function resolveYamlFloat(data) {
      if (data === null) return false;
      if (!YAML_FLOAT_PATTERN.test(data) ||
      data[data.length - 1] === '_') {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign, base, digits;
      value = data.replace(/_/g, '').toLowerCase();
      sign = value[0] === '-' ? -1 : 1;
      digits = [];
      if ('+-'.indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === '.inf') {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === '.nan') {
        return NaN;
      } else if (value.indexOf(':') >= 0) {
        value.split(':').forEach(function (v) {
          digits.unshift(parseFloat(v, 10));
        });
        value = 0.0;
        base = 1;
        digits.forEach(function (d) {
          value += d * base;
          base *= 60;
        });
        return sign * value;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case 'lowercase':
            return '.nan';
          case 'uppercase':
            return '.NAN';
          case 'camelcase':
            return '.NaN';
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case 'lowercase':
            return '.inf';
          case 'uppercase':
            return '.INF';
          case 'camelcase':
            return '.Inf';
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case 'lowercase':
            return '-.inf';
          case 'uppercase':
            return '-.INF';
          case 'camelcase':
            return '-.Inf';
        }
      } else if (common.isNegativeZero(object)) {
        return '-0.0';
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    var float = new type('tag:yaml.org,2002:float', {
      kind: 'scalar',
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: 'lowercase'
    });
    var json = new schema({
      include: [failsafe],
      implicit: [_null, bool, int, float]
    });
    var core = new schema({
      include: [json]
    });
    var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +
    '-([0-9][0-9])' +
    '-([0-9][0-9])$');
    var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +
    '-([0-9][0-9]?)' +
    '-([0-9][0-9]?)' +
    '(?:[Tt]|[ \\t]+)' +
    '([0-9][0-9]?)' +
    ':([0-9][0-9])' +
    ':([0-9][0-9])' +
    '(?:\\.([0-9]*))?' +
    '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' +
    '(?::([0-9][0-9]))?))?$');
    function resolveYamlTimestamp(data) {
      if (data === null) return false;
      if (YAML_DATE_REGEXP.exec(data) !== null) return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match,
        year,
        month,
        day,
        hour,
        minute,
        second,
        fraction = 0,
        delta = null,
        tz_hour,
        tz_minute,
        date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null) throw new Error('Date resolve error');
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += '0';
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 60000;
        if (match[9] === '-') delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta) date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object ) {
      return object.toISOString();
    }
    var timestamp = new type('tag:yaml.org,2002:timestamp', {
      kind: 'scalar',
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
    function resolveYamlMerge(data) {
      return data === '<<' || data === null;
    }
    var merge = new type('tag:yaml.org,2002:merge', {
      kind: 'scalar',
      resolve: resolveYamlMerge
    });
    function commonjsRequire (target) {
    	throw new Error('Could not dynamically require "' + target + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
    }
    var NodeBuffer;
    try {
      var _require$1 = commonjsRequire;
      NodeBuffer = _require$1('buffer').Buffer;
    } catch (__) {}
    var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
    function resolveYamlBinary(data) {
      if (data === null) return false;
      var code,
        idx,
        bitlen = 0,
        max = data.length,
        map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64) continue;
        if (code < 0) return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx,
        tailbits,
        input = data.replace(/[\r\n=]/g, ''),
        max = input.length,
        map = BASE64_MAP,
        bits = 0,
        result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 0xFF);
          result.push(bits >> 8 & 0xFF);
          result.push(bits & 0xFF);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 0xFF);
        result.push(bits >> 8 & 0xFF);
        result.push(bits & 0xFF);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 0xFF);
        result.push(bits >> 2 & 0xFF);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 0xFF);
      }
      if (NodeBuffer) {
        return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
      }
      return result;
    }
    function representYamlBinary(object ) {
      var result = '',
        bits = 0,
        idx,
        tail,
        max = object.length,
        map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 0x3F];
          result += map[bits >> 12 & 0x3F];
          result += map[bits >> 6 & 0x3F];
          result += map[bits & 0x3F];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 0x3F];
        result += map[bits >> 12 & 0x3F];
        result += map[bits >> 6 & 0x3F];
        result += map[bits & 0x3F];
      } else if (tail === 2) {
        result += map[bits >> 10 & 0x3F];
        result += map[bits >> 4 & 0x3F];
        result += map[bits << 2 & 0x3F];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 0x3F];
        result += map[bits << 4 & 0x3F];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(object) {
      return NodeBuffer && NodeBuffer.isBuffer(object);
    }
    var binary = new type('tag:yaml.org,2002:binary', {
      kind: 'scalar',
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
    var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    var _toString$2 = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null) return true;
      var objectKeys = [],
        index,
        length,
        pair,
        pairKey,
        pairHasKey,
        object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString$2.call(pair) !== '[object Object]') return false;
        for (pairKey in pair) {
          if (_hasOwnProperty$3.call(pair, pairKey)) {
            if (!pairHasKey) pairHasKey = true;else return false;
          }
        }
        if (!pairHasKey) return false;
        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    var omap = new type('tag:yaml.org,2002:omap', {
      kind: 'sequence',
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
    var _toString$1 = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null) return true;
      var index,
        length,
        pair,
        keys,
        result,
        object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString$1.call(pair) !== '[object Object]') return false;
        keys = Object.keys(pair);
        if (keys.length !== 1) return false;
        result[index] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null) return [];
      var index,
        length,
        pair,
        keys,
        result,
        object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    var pairs = new type('tag:yaml.org,2002:pairs', {
      kind: 'sequence',
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
    var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null) return true;
      var key,
        object = data;
      for (key in object) {
        if (_hasOwnProperty$2.call(object, key)) {
          if (object[key] !== null) return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    var set = new type('tag:yaml.org,2002:set', {
      kind: 'mapping',
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
    var default_safe = new schema({
      include: [core],
      implicit: [timestamp, merge],
      explicit: [binary, omap, pairs, set]
    });
    function resolveJavascriptUndefined() {
      return true;
    }
    function constructJavascriptUndefined() {
      return undefined;
    }
    function representJavascriptUndefined() {
      return '';
    }
    function isUndefined(object) {
      return typeof object === 'undefined';
    }
    var _undefined = new type('tag:yaml.org,2002:js/undefined', {
      kind: 'scalar',
      resolve: resolveJavascriptUndefined,
      construct: constructJavascriptUndefined,
      predicate: isUndefined,
      represent: representJavascriptUndefined
    });
    function resolveJavascriptRegExp(data) {
      if (data === null) return false;
      if (data.length === 0) return false;
      var regexp = data,
        tail = /\/([gim]*)$/.exec(data),
        modifiers = '';
      if (regexp[0] === '/') {
        if (tail) modifiers = tail[1];
        if (modifiers.length > 3) return false;
        if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
      }
      return true;
    }
    function constructJavascriptRegExp(data) {
      var regexp = data,
        tail = /\/([gim]*)$/.exec(data),
        modifiers = '';
      if (regexp[0] === '/') {
        if (tail) modifiers = tail[1];
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
      }
      return new RegExp(regexp, modifiers);
    }
    function representJavascriptRegExp(object ) {
      var result = '/' + object.source + '/';
      if (object.global) result += 'g';
      if (object.multiline) result += 'm';
      if (object.ignoreCase) result += 'i';
      return result;
    }
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === '[object RegExp]';
    }
    var regexp = new type('tag:yaml.org,2002:js/regexp', {
      kind: 'scalar',
      resolve: resolveJavascriptRegExp,
      construct: constructJavascriptRegExp,
      predicate: isRegExp,
      represent: representJavascriptRegExp
    });
    var esprima;
    try {
      var _require = commonjsRequire;
      esprima = _require('esprima');
    } catch (_) {
      if (typeof window !== 'undefined') esprima = window.esprima;
    }
    function resolveJavascriptFunction(data) {
      if (data === null) return false;
      try {
        var source = '(' + data + ')',
          ast = esprima.parse(source, {
            range: true
          });
        if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    function constructJavascriptFunction(data) {
      var source = '(' + data + ')',
        ast = esprima.parse(source, {
          range: true
        }),
        params = [],
        body;
      if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
        throw new Error('Failed to resolve function');
      }
      ast.body[0].expression.params.forEach(function (param) {
        params.push(param.name);
      });
      body = ast.body[0].expression.body.range;
      if (ast.body[0].expression.body.type === 'BlockStatement') {
        return new Function(params, source.slice(body[0] + 1, body[1] - 1));
      }
      return new Function(params, 'return ' + source.slice(body[0], body[1]));
    }
    function representJavascriptFunction(object ) {
      return object.toString();
    }
    function isFunction(object) {
      return Object.prototype.toString.call(object) === '[object Function]';
    }
    var _function = new type('tag:yaml.org,2002:js/function', {
      kind: 'scalar',
      resolve: resolveJavascriptFunction,
      construct: constructJavascriptFunction,
      predicate: isFunction,
      represent: representJavascriptFunction
    });
    var default_full = schema.DEFAULT = new schema({
      include: [default_safe],
      explicit: [_undefined, regexp, _function]
    });
    var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 0x0A  || c === 0x0D ;
    }
    function is_WHITE_SPACE(c) {
      return c === 0x09  || c === 0x20 ;
    }
    function is_WS_OR_EOL(c) {
      return c === 0x09  || c === 0x20  || c === 0x0A  || c === 0x0D ;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 0x2C  || c === 0x5B  || c === 0x5D  || c === 0x7B  || c === 0x7D ;
    }
    function fromHexCode(c) {
      var lc;
      if (0x30  <= c && c <= 0x39 ) {
        return c - 0x30;
      }
      lc = c | 0x20;
      if (0x61  <= lc && lc <= 0x66 ) {
        return lc - 0x61 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 0x78 ) {
        return 2;
      }
      if (c === 0x75 ) {
        return 4;
      }
      if (c === 0x55 ) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (0x30  <= c && c <= 0x39 ) {
        return c - 0x30;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 0x30  ? '\x00' : c === 0x61  ? '\x07' : c === 0x62  ? '\x08' : c === 0x74  ? '\x09' : c === 0x09  ? '\x09' : c === 0x6E  ? '\x0A' : c === 0x76  ? '\x0B' : c === 0x66  ? '\x0C' : c === 0x72  ? '\x0D' : c === 0x65  ? '\x1B' : c === 0x20  ? ' ' : c === 0x22  ? '\x22' : c === 0x2F  ? '/' : c === 0x5C  ? '\x5C' : c === 0x4E  ? '\x85' : c === 0x5F  ? '\xA0' : c === 0x4C  ? "\u2028" : c === 0x50  ? "\u2029" : '';
    }
    function charFromCodepoint(c) {
      if (c <= 0xFFFF) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (var i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    function State$1(input, options) {
      this.input = input;
      this.filename = options['filename'] || null;
      this.schema = options['schema'] || default_full;
      this.onWarning = options['onWarning'] || null;
      this.legacy = options['legacy'] || false;
      this.json = options['json'] || false;
      this.listener = options['listener'] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.documents = [];
    }
    function generateError(state, message) {
      return new exception(message, new mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, 'duplication of %YAML directive');
        }
        if (args.length !== 1) {
          throwError(state, 'YAML directive accepts exactly one argument');
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, 'ill-formed argument of the YAML directive');
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, 'unacceptable YAML version of the document');
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, 'unsupported YAML version of the document');
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, 'TAG directive accepts exactly two arguments');
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
        }
        if (_hasOwnProperty$1.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
              throwError(state, 'expected valid JSON character');
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, 'the stream contains non-printable characters');
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common.isObject(source)) {
        throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty$1.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, 'nested arrays are not supported inside keys');
          }
          if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
            keyNode[index] = '[object Object]';
          }
        }
      }
      if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
        keyNode = '[object Object]';
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === 'tag:yaml.org,2002:merge') {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.position = startPos || state.position;
          throwError(state, 'duplicated mapping key');
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 0x0A ) {
        state.position++;
      } else if (ch === 0x0D ) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 0x0A ) {
          state.position++;
        }
      } else {
        throwError(state, 'a line break is expected');
      }
      state.line += 1;
      state.lineStart = state.position;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0,
        ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 0x23 ) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0x0A  && ch !== 0x0D  && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 0x20 ) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, 'deficient indentation');
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position,
        ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 0x2D  || ch === 0x2E ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += ' ';
      } else if (count > 1) {
        state.result += common.repeat('\n', count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding,
        following,
        captureStart,
        captureEnd,
        hasPendingContent,
        _line,
        _lineStart,
        _lineIndent,
        _kind = state.kind,
        _result = state.result,
        ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23  || ch === 0x26  || ch === 0x2A  || ch === 0x21  || ch === 0x7C  || ch === 0x3E  || ch === 0x27  || ch === 0x22  || ch === 0x25  || ch === 0x40  || ch === 0x60 ) {
        return false;
      }
      if (ch === 0x3F  || ch === 0x2D ) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = 'scalar';
      state.result = '';
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 0x3A ) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 0x23 ) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 0x27 ) {
        return false;
      }
      state.kind = 'scalar';
      state.result = '';
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 0x27 ) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 0x27 ) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, 'unexpected end of the document within a single quoted scalar');
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, 'unexpected end of the stream within a single quoted scalar');
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 0x22 ) {
        return false;
      }
      state.kind = 'scalar';
      state.result = '';
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 0x22 ) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 0x5C ) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, 'expected hexadecimal character');
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, 'unknown escape sequence');
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, 'unexpected end of the document within a double quoted scalar');
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, 'unexpected end of the stream within a double quoted scalar');
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true,
        _line,
        _tag = state.tag,
        _result,
        _anchor = state.anchor,
        following,
        terminator,
        isPair,
        isExplicitPair,
        isMapping,
        overridableKeys = {},
        keyNode,
        keyTag,
        valueNode,
        ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 0x5B ) {
        terminator = 0x5D;
        isMapping = false;
        _result = [];
      } else if (ch === 0x7B ) {
        terminator = 0x7D;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? 'mapping' : 'sequence';
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, 'missed comma between flow collection entries');
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 0x3F ) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 0x3A ) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 0x2C ) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, 'unexpected end of the stream within a flow collection');
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart,
        folding,
        chomping = CHOMPING_CLIP,
        didReadContent = false,
        detectedIndent = false,
        textIndent = nodeIndent,
        emptyLines = 0,
        atMoreIndented = false,
        tmp,
        ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 0x7C ) {
        folding = false;
      } else if (ch === 0x3E ) {
        folding = true;
      } else {
        return false;
      }
      state.kind = 'scalar';
      state.result = '';
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 0x2B  || ch === 0x2D ) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 0x2B  ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, 'repeat of a chomping mode identifier');
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, 'repeat of an indentation width identifier');
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 0x23 ) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 ) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += '\n';
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat('\n', emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += ' ';
            }
          } else {
            state.result += common.repeat('\n', emptyLines);
          }
        } else {
          state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line,
        _tag = state.tag,
        _anchor = state.anchor,
        _result = [],
        following,
        detected = false,
        ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (ch !== 0x2D ) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, 'bad indentation of a sequence entry');
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = 'sequence';
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following,
        allowCompact,
        _line,
        _pos,
        _tag = state.tag,
        _anchor = state.anchor,
        _result = {},
        overridableKeys = {},
        keyTag = null,
        keyNode = null,
        valueNode = null,
        atExplicitKey = false,
        detected = false,
        ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        _pos = state.position;
        if ((ch === 0x3F  || ch === 0x3A ) && is_WS_OR_EOL(following)) {
          if (ch === 0x3F ) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
          }
          state.position += 1;
          ch = following;
        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 0x3A ) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, 'can not read an implicit mapping pair; a colon is missed');
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else {
          break;
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) {
          throwError(state, 'bad indentation of a mapping entry');
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = 'mapping';
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position,
        isVerbatim = false,
        isNamed = false,
        tagHandle,
        tagName,
        ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 0x21 ) return false;
      if (state.tag !== null) {
        throwError(state, 'duplication of a tag property');
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 0x3C ) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 0x21 ) {
        isNamed = true;
        tagHandle = '!!';
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = '!';
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 0x3E );
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, 'unexpected end of the stream within a verbatim tag');
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 0x21 ) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, 'named tag handle cannot contain such characters');
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, 'tag suffix cannot contain exclamation marks');
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, 'tag suffix cannot contain flow indicator characters');
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, 'tag name cannot contain such characters: ' + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === '!') {
        state.tag = '!' + tagName;
      } else if (tagHandle === '!!') {
        state.tag = 'tag:yaml.org,2002:' + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 0x26 ) return false;
      if (state.anchor !== null) {
        throwError(state, 'duplication of an anchor property');
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, 'name of an anchor node must contain at least one character');
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 0x2A ) return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, 'name of an alias node must contain at least one character');
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles,
        allowBlockScalars,
        allowBlockCollections,
        indentStatus = 1,
        atNewLine = false,
        hasContent = false,
        typeIndex,
        typeQuantity,
        type,
        flowIndent,
        blockIndent;
      if (state.listener !== null) {
        state.listener('open', state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, 'alias node should not have any properties');
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = '?';
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag !== null && state.tag !== '!') {
        if (state.tag === '?') {
          if (state.result !== null && state.kind !== 'scalar') {
            throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
          }
          for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
            type = state.implicitTypes[typeIndex];
            if (type.resolve(state.result)) {
              state.result = type.construct(state.result);
              state.tag = type.tag;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
              break;
            }
          }
        } else if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
          type = state.typeMap[state.kind || 'fallback'][state.tag];
          if (state.result !== null && type.kind !== state.kind) {
            throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
          }
          if (!type.resolve(state.result)) {
            throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
          } else {
            state.result = type.construct(state.result);
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else {
          throwError(state, 'unknown tag !<' + state.tag + '>');
        }
      }
      if (state.listener !== null) {
        state.listener('close', state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position,
        _position,
        directiveName,
        directiveArgs,
        hasDirectives = false,
        ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = {};
      state.anchorMap = {};
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 0x25 ) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, 'directive name must not be less than one character in length');
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 0x23 ) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch)) break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0) readLineBreak(state);
        if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D  && state.input.charCodeAt(state.position + 1) === 0x2D  && state.input.charCodeAt(state.position + 2) === 0x2D ) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, 'directives end mark is expected');
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, 'non-ASCII line breaks are interpreted as content');
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 0x2E ) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, 'end of the stream or a document separator is expected');
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 0x0A  && input.charCodeAt(input.length - 1) !== 0x0D ) {
          input += '\n';
        }
        if (input.charCodeAt(0) === 0xFEFF) {
          input = input.slice(1);
        }
      }
      var state = new State$1(input, options);
      var nullpos = input.indexOf('\0');
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, 'null byte is not allowed in input');
      }
      state.input += '\0';
      while (state.input.charCodeAt(state.position) === 0x20 ) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll$1(input, iterator, options) {
      if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
        options = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options);
      if (typeof iterator !== 'function') {
        return documents;
      }
      for (var index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load$1(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        return undefined;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new exception('expected a single document in the stream, but found more');
    }
    function safeLoadAll$1(input, iterator, options) {
      if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
        options = iterator;
        iterator = null;
      }
      return loadAll$1(input, iterator, common.extend({
        schema: default_safe
      }, options));
    }
    function safeLoad$1(input, options) {
      return load$1(input, common.extend({
        schema: default_safe
      }, options));
    }
    var loadAll_1 = loadAll$1;
    var load_1 = load$1;
    var safeLoadAll_1 = safeLoadAll$1;
    var safeLoad_1 = safeLoad$1;
    var loader = {
      loadAll: loadAll_1,
      load: load_1,
      safeLoadAll: safeLoadAll_1,
      safeLoad: safeLoad_1
    };
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_TAB = 0x09;
    var CHAR_LINE_FEED = 0x0A;
    var CHAR_CARRIAGE_RETURN = 0x0D;
    var CHAR_SPACE = 0x20;
    var CHAR_EXCLAMATION = 0x21;
    var CHAR_DOUBLE_QUOTE = 0x22;
    var CHAR_SHARP = 0x23;
    var CHAR_PERCENT = 0x25;
    var CHAR_AMPERSAND = 0x26;
    var CHAR_SINGLE_QUOTE = 0x27;
    var CHAR_ASTERISK = 0x2A;
    var CHAR_COMMA = 0x2C;
    var CHAR_MINUS = 0x2D;
    var CHAR_COLON = 0x3A;
    var CHAR_EQUALS = 0x3D;
    var CHAR_GREATER_THAN = 0x3E;
    var CHAR_QUESTION = 0x3F;
    var CHAR_COMMERCIAL_AT = 0x40;
    var CHAR_LEFT_SQUARE_BRACKET = 0x5B;
    var CHAR_RIGHT_SQUARE_BRACKET = 0x5D;
    var CHAR_GRAVE_ACCENT = 0x60;
    var CHAR_LEFT_CURLY_BRACKET = 0x7B;
    var CHAR_VERTICAL_LINE = 0x7C;
    var CHAR_RIGHT_CURLY_BRACKET = 0x7D;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0x00] = '\\0';
    ESCAPE_SEQUENCES[0x07] = '\\a';
    ESCAPE_SEQUENCES[0x08] = '\\b';
    ESCAPE_SEQUENCES[0x09] = '\\t';
    ESCAPE_SEQUENCES[0x0A] = '\\n';
    ESCAPE_SEQUENCES[0x0B] = '\\v';
    ESCAPE_SEQUENCES[0x0C] = '\\f';
    ESCAPE_SEQUENCES[0x0D] = '\\r';
    ESCAPE_SEQUENCES[0x1B] = '\\e';
    ESCAPE_SEQUENCES[0x22] = '\\"';
    ESCAPE_SEQUENCES[0x5C] = '\\\\';
    ESCAPE_SEQUENCES[0x85] = '\\N';
    ESCAPE_SEQUENCES[0xA0] = '\\_';
    ESCAPE_SEQUENCES[0x2028] = '\\L';
    ESCAPE_SEQUENCES[0x2029] = '\\P';
    var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];
    function compileStyleMap(schema, map) {
      var result, keys, index, length, tag, style, type;
      if (map === null) return {};
      result = {};
      keys = Object.keys(map);
      for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === '!!') {
          tag = 'tag:yaml.org,2002:' + tag.slice(2);
        }
        type = schema.compiledTypeMap['fallback'][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 0xFF) {
        handle = 'x';
        length = 2;
      } else if (character <= 0xFFFF) {
        handle = 'u';
        length = 4;
      } else if (character <= 0xFFFFFFFF) {
        handle = 'U';
        length = 8;
      } else {
        throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
      }
      return '\\' + handle + common.repeat('0', length - string.length) + string;
    }
    function State(options) {
      this.schema = options['schema'] || default_full;
      this.indent = Math.max(1, options['indent'] || 2);
      this.noArrayIndent = options['noArrayIndent'] || false;
      this.skipInvalid = options['skipInvalid'] || false;
      this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
      this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
      this.sortKeys = options['sortKeys'] || false;
      this.lineWidth = options['lineWidth'] || 80;
      this.noRefs = options['noRefs'] || false;
      this.noCompatMode = options['noCompatMode'] || false;
      this.condenseFlow = options['condenseFlow'] || false;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = '';
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(' ', spaces),
        position = 0,
        next = -1,
        result = '',
        line,
        length = string.length;
      while (position < length) {
        next = string.indexOf('\n', position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== '\n') result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return '\n' + common.repeat(' ', state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF  || 0x10000 <= c && c <= 0x10FFFF;
    }
    function isNsChar(c) {
      return isPrintable(c) && !isWhitespace(c)
      && c !== 0xFEFF
      && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev) {
      return isPrintable(c) && c !== 0xFEFF
      && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
      && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c)
      && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
      && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE
      && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1,
      STYLE_SINGLE = 2,
      STYLE_LITERAL = 3,
      STYLE_FOLDED = 4,
      STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
      var i;
      var char, prev_char;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
      if (singleLineOnly) {
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
      } else {
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine ||
              i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
              previousLineBreak = i;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
      }
      if (!hasLineBreak && !hasFoldableLine) {
        return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    function writeScalar(state, string, level, iskey) {
      state.dump = function () {
        if (string.length === 0) {
          return "''";
        }
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
          return "'" + string + "'";
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey
        || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string) {
          return testImplicitResolving(state, string);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string) + '"';
          default:
            throw new exception('impossible error: invalid scalar style');
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';
      var clip = string[string.length - 1] === '\n';
      var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
      var chomp = keep ? '+' : clip ? '' : '-';
      return indentIndicator + chomp + '\n';
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function () {
        var nextLF = string.indexOf('\n');
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1],
          line = match[2];
        moreIndented = line[0] === ' ';
        result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === '' || line[0] === ' ') return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0,
        end,
        curr = 0,
        next = 0;
      var result = '';
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += '\n' + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += '\n';
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = '';
      var char, nextChar;
      var escapeSeq;
      for (var i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (char >= 0xD800 && char <= 0xDBFF ) {
          nextChar = string.charCodeAt(i + 1);
          if (nextChar >= 0xDC00 && nextChar <= 0xDFFF ) {
            result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
            i++;
            continue;
          }
        }
        escapeSeq = ESCAPE_SEQUENCES[char];
        result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = '',
        _tag = state.tag,
        index,
        length;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (writeNode(state, level, object[index], false, false)) {
          if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = '[' + _result + ']';
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = '',
        _tag = state.tag,
        index,
        length;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (writeNode(state, level + 1, object[index], true, true)) {
          if (!compact || index !== 0) {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += '-';
          } else {
            _result += '- ';
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || '[]';
    }
    function writeFlowMapping(state, level, object) {
      var _result = '',
        _tag = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = '';
        if (index !== 0) pairBuffer += ', ';
        if (state.condenseFlow) pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024) pairBuffer += '? ';
        pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = '{' + _result + '}';
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = '',
        _tag = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        explicitPair,
        pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === 'function') {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new exception('sortKeys must be a boolean or a function');
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = '';
        if (!compact || index !== 0) {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += '?';
          } else {
            pairBuffer += '? ';
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ':';
        } else {
          pairBuffer += ': ';
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || '{}';
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          state.tag = explicit ? type.tag : '?';
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === '[object Function]') {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === '[object Object]' || type === '[object Array]',
        duplicateIndex,
        duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = '*ref_' + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === '[object Object]') {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = '&ref_' + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
            }
          }
        } else if (type === '[object Array]') {
          var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
          if (block && state.dump.length !== 0) {
            writeBlockSequence(state, arrayLevel, state.dump, compact);
            if (duplicate) {
              state.dump = '&ref_' + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, arrayLevel, state.dump);
            if (duplicate) {
              state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
            }
          }
        } else if (type === '[object String]') {
          if (state.tag !== '?') {
            writeScalar(state, state.dump, level, iskey);
          }
        } else {
          if (state.skipInvalid) return false;
          throw new exception('unacceptable kind of an object to dump ' + type);
        }
        if (state.tag !== null && state.tag !== '?') {
          state.dump = '!<' + state.tag + '> ' + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [],
        duplicatesIndexes = [],
        index,
        length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === 'object') {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump$1(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs) getDuplicateReferences(input, state);
      if (writeNode(state, 0, input, true, true)) return state.dump + '\n';
      return '';
    }
    function safeDump$1(input, options) {
      return dump$1(input, common.extend({
        schema: default_safe
      }, options));
    }
    var dump_1 = dump$1;
    var safeDump_1 = safeDump$1;
    var dumper = {
      dump: dump_1,
      safeDump: safeDump_1
    };
    function deprecated(name) {
      return function () {
        throw new Error('Function ' + name + ' is deprecated and cannot be used.');
      };
    }
    var Type = type;
    var Schema = schema;
    var FAILSAFE_SCHEMA = failsafe;
    var JSON_SCHEMA = json;
    var CORE_SCHEMA = core;
    var DEFAULT_SAFE_SCHEMA = default_safe;
    var DEFAULT_FULL_SCHEMA = default_full;
    var load = loader.load;
    var loadAll = loader.loadAll;
    var safeLoad = loader.safeLoad;
    var safeLoadAll = loader.safeLoadAll;
    var dump = dumper.dump;
    var safeDump = dumper.safeDump;
    var YAMLException = exception;
    var MINIMAL_SCHEMA = failsafe;
    var SAFE_SCHEMA = default_safe;
    var DEFAULT_SCHEMA = default_full;
    var scan = deprecated('scan');
    var parse = deprecated('parse');
    var compose = deprecated('compose');
    var addConstructor = deprecated('addConstructor');
    var jsYaml$1 = {
      Type: Type,
      Schema: Schema,
      FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
      JSON_SCHEMA: JSON_SCHEMA,
      CORE_SCHEMA: CORE_SCHEMA,
      DEFAULT_SAFE_SCHEMA: DEFAULT_SAFE_SCHEMA,
      DEFAULT_FULL_SCHEMA: DEFAULT_FULL_SCHEMA,
      load: load,
      loadAll: loadAll,
      safeLoad: safeLoad,
      safeLoadAll: safeLoadAll,
      dump: dump,
      safeDump: safeDump,
      YAMLException: YAMLException,
      MINIMAL_SCHEMA: MINIMAL_SCHEMA,
      SAFE_SCHEMA: SAFE_SCHEMA,
      DEFAULT_SCHEMA: DEFAULT_SCHEMA,
      scan: scan,
      parse: parse,
      compose: compose,
      addConstructor: addConstructor
    };
    var jsYaml = jsYaml$1;
    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
    class Redirects {
      constructor(rawYaml) {
        try {
          const arrOfRedirects = jsYaml.safeLoad(rawYaml);
          this.redirects = arrOfRedirects.reduce(function (acc, redirect) {
            return _objectSpread(_objectSpread({}, acc), {}, {
              [redirect.title]: redirect
            });
          }, {});
        } catch (e) {
          console.log("Was unable to load YAML into JS due to: ".concat(e.message));
          throw e;
        }
      }
      getRedirect(title) {
        var _this = this;
        if (Object.prototype.hasOwnProperty.call(this.redirects, title)) {
          return this.redirects[title];
        }
        const values = Object.keys(this.redirects).map(function (key) {
          return _this.redirects[key];
        });
        return values.find(function (redirect) {
          const aliases = redirect.aliases;
          if (!aliases) {
            return false;
          }
          return aliases.indexOf(title) > -1;
        });
      }
      isBlocking(title) {
        const redirect = this.redirects[title];
        if (redirect) {
          return !!redirect.isBlocking;
        }
        return false;
      }
    }
    const redirectsMap = {
      "1x1-transparent.gif": "1x1-transparent.gif",
      "1x1.gif": "1x1-transparent.gif",
      "1x1-transparent-gif": "1x1-transparent.gif",
      "2x2-transparent.png": "2x2-transparent.png",
      "2x2.png": "2x2-transparent.png",
      "2x2-transparent-png": "2x2-transparent.png",
      "3x2-transparent.png": "3x2-transparent.png",
      "3x2.png": "3x2-transparent.png",
      "3x2-transparent-png": "3x2-transparent.png",
      "32x32-transparent.png": "32x32-transparent.png",
      "32x32.png": "32x32-transparent.png",
      "32x32-transparent-png": "32x32-transparent.png",
      noopframe: "noopframe.html",
      "noop.html": "noopframe.html",
      "blank-html": "noopframe.html",
      noopcss: "noopcss.css",
      "noop.css": "noopcss.css",
      "blank-css": "noopcss.css",
      noopjs: "noopjs.js",
      "noop.js": "noopjs.js",
      "blank-js": "noopjs.js",
      noopjson: "noopjson.json",
      nooptext: "nooptext.js",
      "noop.txt": "nooptext.js",
      "blank-text": "nooptext.js",
      empty: "nooptext.js",
      "noopvmap-1.0": "noopvmap01.xml",
      "noop-vmap1.0.xml": "noopvmap01.xml",
      "noopvast-2.0": "noopvast02.xml",
      "noopvast-3.0": "noopvast03.xml",
      "noopvast-4.0": "noopvast04.xml",
      "noopmp3-0.1s": "noopmp3.mp3",
      "blank-mp3": "noopmp3.mp3",
      "noopmp4-1s": "noopmp4.mp4",
      "noop-1s.mp4": "noopmp4.mp4",
      "blank-mp4": "noopmp4.mp4",
      "click2load.html": "click2load.html",
      "ubo-click2load.html": "click2load.html",
      "amazon-apstag": "amazon-apstag.js",
      "ubo-amazon_apstag.js": "amazon-apstag.js",
      "amazon_apstag.js": "amazon-apstag.js",
      "ati-smarttag": "ati-smarttag.js",
      "didomi-loader": "didomi-loader.js",
      fingerprintjs2: "fingerprintjs2.js",
      "ubo-fingerprint2.js": "fingerprintjs2.js",
      "fingerprint2.js": "fingerprintjs2.js",
      fingerprintjs3: "fingerprintjs3.js",
      "ubo-fingerprint3.js": "fingerprintjs3.js",
      "fingerprint3.js": "fingerprintjs3.js",
      gemius: "gemius.js",
      "google-analytics-ga": "google-analytics-ga.js",
      "ubo-google-analytics_ga.js": "google-analytics-ga.js",
      "google-analytics_ga.js": "google-analytics-ga.js",
      "google-analytics": "google-analytics.js",
      "ubo-google-analytics_analytics.js": "google-analytics.js",
      "google-analytics_analytics.js": "google-analytics.js",
      "googletagmanager-gtm": "google-analytics.js",
      "ubo-googletagmanager_gtm.js": "google-analytics.js",
      "googletagmanager_gtm.js": "google-analytics.js",
      "google-ima3": "google-ima3.js",
      "ubo-google-ima.js": "google-ima3.js",
      "google-ima.js": "google-ima3.js",
      "googlesyndication-adsbygoogle": "googlesyndication-adsbygoogle.js",
      "ubo-googlesyndication_adsbygoogle.js": "googlesyndication-adsbygoogle.js",
      "googlesyndication_adsbygoogle.js": "googlesyndication-adsbygoogle.js",
      "googletagservices-gpt": "googletagservices-gpt.js",
      "ubo-googletagservices_gpt.js": "googletagservices-gpt.js",
      "googletagservices_gpt.js": "googletagservices-gpt.js",
      matomo: "matomo.js",
      "metrika-yandex-tag": "metrika-yandex-tag.js",
      "metrika-yandex-watch": "metrika-yandex-watch.js",
      "naver-wcslog": "naver-wcslog.js",
      noeval: "noeval.js",
      "noeval.js": "noeval.js",
      "silent-noeval.js": "noeval.js",
      "ubo-noeval.js": "noeval.js",
      "ubo-silent-noeval.js": "noeval.js",
      "ubo-noeval": "noeval.js",
      "ubo-silent-noeval": "noeval.js",
      "pardot-1.0": "pardot-1.0.js",
      "prebid-ads": "prebid-ads.js",
      "ubo-prebid-ads.js": "prebid-ads.js",
      "prebid-ads.js": "prebid-ads.js",
      prebid: "prebid.js",
      "prevent-bab": "prevent-bab.js",
      "nobab.js": "prevent-bab.js",
      "ubo-nobab.js": "prevent-bab.js",
      "bab-defuser.js": "prevent-bab.js",
      "ubo-bab-defuser.js": "prevent-bab.js",
      "ubo-nobab": "prevent-bab.js",
      "ubo-bab-defuser": "prevent-bab.js",
      "prevent-bab2": "prevent-bab2.js",
      "nobab2.js": "prevent-bab2.js",
      "prevent-fab-3.2.0": "prevent-fab-3.2.0.js",
      "nofab.js": "prevent-fab-3.2.0.js",
      "ubo-nofab.js": "prevent-fab-3.2.0.js",
      "fuckadblock.js-3.2.0": "prevent-fab-3.2.0.js",
      "ubo-fuckadblock.js-3.2.0": "prevent-fab-3.2.0.js",
      "ubo-nofab": "prevent-fab-3.2.0.js",
      "prevent-popads-net": "prevent-popads-net.js",
      "popads.net.js": "prevent-popads-net.js",
      "ubo-popads.net.js": "prevent-popads-net.js",
      "ubo-popads.net": "prevent-popads-net.js",
      "scorecardresearch-beacon": "scorecardresearch-beacon.js",
      "ubo-scorecardresearch_beacon.js": "scorecardresearch-beacon.js",
      "scorecardresearch_beacon.js": "scorecardresearch-beacon.js",
      "set-popads-dummy": "set-popads-dummy.js",
      "popads-dummy.js": "set-popads-dummy.js",
      "ubo-popads-dummy.js": "set-popads-dummy.js",
      "ubo-popads-dummy": "set-popads-dummy.js"
    };
    const getRedirectByName = function getRedirectByName(name) {
      const redirects = Object.keys(redirectsList).map(function (key) {
        return redirectsList[key];
      });
      return redirects.find(function (r) {
        return r.names && r.names.indexOf(name) > -1;
      });
    };
    const getRedirectCode = function getRedirectCode(source) {
      const redirect = getRedirectByName(source.name);
      let result = attachDependencies(redirect);
      result = addCall(redirect, result);
      result = source.engine === 'test' ? wrapInNonameFunc(result) : passSourceAndProps(source, result, true);
      return result;
    };
    const getRedirectFilename = function getRedirectFilename(name) {
      return redirectsMap[name];
    };
    const redirects = {
      Redirects,
      getRedirectFilename,
      getCode: getRedirectCode,
      isAdgRedirectRule: validator.isAdgRedirectRule,
      isValidAdgRedirectRule: validator.isValidAdgRedirectRule,
      isAdgRedirectCompatibleWithUbo: validator.isAdgRedirectCompatibleWithUbo,
      isUboRedirectCompatibleWithAdg: validator.isUboRedirectCompatibleWithAdg,
      isAbpRedirectCompatibleWithAdg: validator.isAbpRedirectCompatibleWithAdg,
      convertUboRedirectToAdg,
      convertAbpRedirectToAdg,
      convertRedirectToAdg,
      convertAdgRedirectToUbo
    };
    function abortCurrentInlineScript(source, args) {
      function abortCurrentInlineScript(source, property, search) {
        const searchRegexp = toRegExp(search);
        const rid = randomId();
        const SRC_DATA_MARKER = "data:text/javascript;base64,";
        const getCurrentScript = function getCurrentScript() {
          if ("currentScript" in document) {
            return document.currentScript;
          }
          const scripts = document.getElementsByTagName("script");
          return scripts[scripts.length - 1];
        };
        const ourScript = getCurrentScript();
        const abort = function abort() {
          const scriptEl = getCurrentScript();
          if (!scriptEl) {
            return;
          }
          let content = scriptEl.textContent;
          try {
            const textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, "textContent").get;
            content = textContentGetter.call(scriptEl);
          } catch (e) {}
          if (content.length === 0 && typeof scriptEl.src !== "undefined" && startsWith(scriptEl.src, SRC_DATA_MARKER)) {
            const encodedContent = scriptEl.src.slice(SRC_DATA_MARKER.length);
            content = window.atob(encodedContent);
          }
          if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
            hit(source);
            throw new ReferenceError(rid);
          }
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (base instanceof Object === false && base === null) {
            const props = property.split(".");
            const propIndex = props.indexOf(prop);
            const baseName = props[propIndex - 1];
            const message = "The scriptlet had been executed before the ".concat(baseName, " was loaded.");
            logMessage(source, message);
            return;
          }
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          let currentValue = base[prop];
          let origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
          if (origDescriptor instanceof Object === false || origDescriptor.get instanceof Function === false) {
            currentValue = base[prop];
            origDescriptor = undefined;
          }
          const descriptorWrapper = Object.assign(getDescriptorAddon(), {
            currentValue: currentValue,
            get() {
              if (!this.isAbortingSuspended) {
                this.isolateCallback(abort);
              }
              if (origDescriptor instanceof Object) {
                return origDescriptor.get.call(base);
              }
              return this.currentValue;
            },
            set(newValue) {
              if (!this.isAbortingSuspended) {
                this.isolateCallback(abort);
              }
              if (origDescriptor instanceof Object) {
                origDescriptor.set.call(base, newValue);
              } else {
                this.currentValue = newValue;
              }
            }
          });
          setPropertyAccess(base, prop, {
            get() {
              return descriptorWrapper.get.call(descriptorWrapper);
            },
            set(newValue) {
              descriptorWrapper.set.call(descriptorWrapper, newValue);
            }
          });
        };
        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function startsWith(str, prefix) {
        return !!str && str.indexOf(prefix) === 0;
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getDescriptorAddon() {
        return {
          isAbortingSuspended: false,
          isolateCallback(cb) {
            this.isAbortingSuspended = true;
            try {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              const result = cb(...args);
              this.isAbortingSuspended = false;
              return result;
            } catch (_unused) {
              const rid = randomId();
              this.isAbortingSuspended = false;
              throw new ReferenceError(rid);
            }
          }
        };
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        abortCurrentInlineScript.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function abortOnPropertyRead(source, args) {
      function abortOnPropertyRead(source, property) {
        if (!property) {
          return;
        }
        const rid = randomId();
        const abort = function abort() {
          hit(source);
          throw new ReferenceError(rid);
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          setPropertyAccess(base, prop, {
            get: abort,
            set: function set() {}
          });
        };
        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        abortOnPropertyRead.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function abortOnPropertyWrite(source, args) {
      function abortOnPropertyWrite(source, property) {
        if (!property) {
          return;
        }
        const rid = randomId();
        const abort = function abort() {
          hit(source);
          throw new ReferenceError(rid);
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          setPropertyAccess(base, prop, {
            set: abort
          });
        };
        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        abortOnPropertyWrite.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function abortOnStackTrace(source, args) {
      function abortOnStackTrace(source, property, stack) {
        if (!property || !stack) {
          return;
        }
        const rid = randomId();
        const abort = function abort() {
          hit(source);
          throw new ReferenceError(rid);
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          if (!stack.match(/^(inlineScript|injectedScript)$/) && !isValidStrPattern(stack)) {
            logMessage(source, "Invalid parameter: ".concat(stack));
            return;
          }
          const descriptorWrapper = Object.assign(getDescriptorAddon(), {
            value: base[prop],
            get() {
              if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
                abort();
              }
              return this.value;
            },
            set(newValue) {
              if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
                abort();
              }
              this.value = newValue;
            }
          });
          setPropertyAccess(base, prop, {
            get() {
              return descriptorWrapper.get.call(descriptorWrapper);
            },
            set(newValue) {
              descriptorWrapper.set.call(descriptorWrapper, newValue);
            }
          });
        };
        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
          return true;
        }
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
          return true;
        }
        const stackRegexp = toRegExp(stackMatch);
        const refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        }).join("\n");
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
      }
      function getDescriptorAddon() {
        return {
          isAbortingSuspended: false,
          isolateCallback(cb) {
            this.isAbortingSuspended = true;
            try {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              const result = cb(...args);
              this.isAbortingSuspended = false;
              return result;
            } catch (_unused) {
              const rid = randomId();
              this.isAbortingSuspended = false;
              throw new ReferenceError(rid);
            }
          }
        };
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getNativeRegexpTest() {
        return Object.getOwnPropertyDescriptor(RegExp.prototype, "test").value;
      }
      function startsWith(str, prefix) {
        return !!str && str.indexOf(prefix) === 0;
      }
      function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        const INLINE_SCRIPT_STRING = "inlineScript";
        const INJECTED_SCRIPT_STRING = "injectedScript";
        const INJECTED_SCRIPT_MARKER = "<anonymous>";
        const isInlineScript = function isInlineScript(stackMatch) {
          return stackMatch.indexOf(INLINE_SCRIPT_STRING) > -1;
        };
        const isInjectedScript = function isInjectedScript(stackMatch) {
          return stackMatch.indexOf(INJECTED_SCRIPT_STRING) > -1;
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
          return false;
        }
        let documentURL = window.location.href;
        const pos = documentURL.indexOf("#");
        if (pos !== -1) {
          documentURL = documentURL.slice(0, pos);
        }
        const stackSteps = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        });
        const stackLines = stackSteps.map(function (line) {
          let stack;
          const getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
          if (getStackTraceURL) {
            let stackURL = getStackTraceURL[2];
            if (startsWith(stackURL, "(")) {
              stackURL = stackURL.slice(1);
            }
            if (startsWith(stackURL, INJECTED_SCRIPT_MARKER)) {
              stackURL = INJECTED_SCRIPT_STRING;
              let stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
              if (startsWith(stackFunction, "at")) {
                stackFunction = stackFunction.slice(2).trim();
              }
              stack = "".concat(stackFunction, " ").concat(stackURL).trim();
            } else {
              stack = stackURL;
            }
          } else {
            stack = line;
          }
          return stack;
        });
        if (stackLines) {
          for (let index = 0; index < stackLines.length; index += 1) {
            if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
              return true;
            }
            if (isInjectedScript(stackMatch) && startsWith(stackLines[index], INJECTED_SCRIPT_STRING)) {
              return true;
            }
          }
        }
        return false;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        abortOnStackTrace.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function adjustSetInterval(source, args) {
      function adjustSetInterval(source, matchCallback, matchDelay, boost) {
        const nativeSetInterval = window.setInterval;
        const matchRegexp = toRegExp(matchCallback);
        const intervalWrapper = function intervalWrapper(callback, delay) {
          if (!isValidCallback(callback)) {
            const message = "Scriptlet can't be applied because of invalid callback: '".concat(String(callback), "'");
            logMessage(source, message);
          } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
            delay *= getBoostMultiplier(boost);
            hit(source);
          }
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }
          return nativeSetInterval.apply(window, [callback, delay, ...args]);
        };
        window.setInterval = intervalWrapper;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function isValidCallback(callback) {
        return callback instanceof Function || typeof callback === "string";
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function getBoostMultiplier(boost) {
        const DEFAULT_MULTIPLIER = .05;
        const MIN_MULTIPLIER = .001;
        const MAX_MULTIPLIER = 50;
        const parsedBoost = parseFloat(boost);
        let boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER : parsedBoost;
        if (boostMultiplier < MIN_MULTIPLIER) {
          boostMultiplier = MIN_MULTIPLIER;
        }
        if (boostMultiplier > MAX_MULTIPLIER) {
          boostMultiplier = MAX_MULTIPLIER;
        }
        return boostMultiplier;
      }
      function isDelayMatched(inputDelay, realDelay) {
        return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function nativeIsFinite(num) {
        const native = Number.isFinite || window.isFinite;
        return native(num);
      }
      function getMatchDelay(delay) {
        const DEFAULT_DELAY = 1e3;
        const parsedDelay = parseInt(delay, 10);
        const delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY : parsedDelay;
        return delayMatch;
      }
      function shouldMatchAnyDelay(delay) {
        return delay === "*";
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        adjustSetInterval.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function adjustSetTimeout(source, args) {
      function adjustSetTimeout(source, matchCallback, matchDelay, boost) {
        const nativeSetTimeout = window.setTimeout;
        const matchRegexp = toRegExp(matchCallback);
        const timeoutWrapper = function timeoutWrapper(callback, delay) {
          if (!isValidCallback(callback)) {
            const message = "Scriptlet can't be applied because of invalid callback: '".concat(String(callback), "'");
            logMessage(source, message);
          } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
            delay *= getBoostMultiplier(boost);
            hit(source);
          }
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }
          return nativeSetTimeout.apply(window, [callback, delay, ...args]);
        };
        window.setTimeout = timeoutWrapper;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function isValidCallback(callback) {
        return callback instanceof Function || typeof callback === "string";
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function getBoostMultiplier(boost) {
        const DEFAULT_MULTIPLIER = .05;
        const MIN_MULTIPLIER = .001;
        const MAX_MULTIPLIER = 50;
        const parsedBoost = parseFloat(boost);
        let boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER : parsedBoost;
        if (boostMultiplier < MIN_MULTIPLIER) {
          boostMultiplier = MIN_MULTIPLIER;
        }
        if (boostMultiplier > MAX_MULTIPLIER) {
          boostMultiplier = MAX_MULTIPLIER;
        }
        return boostMultiplier;
      }
      function isDelayMatched(inputDelay, realDelay) {
        return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function nativeIsFinite(num) {
        const native = Number.isFinite || window.isFinite;
        return native(num);
      }
      function getMatchDelay(delay) {
        const DEFAULT_DELAY = 1e3;
        const parsedDelay = parseInt(delay, 10);
        const delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY : parsedDelay;
        return delayMatch;
      }
      function shouldMatchAnyDelay(delay) {
        return delay === "*";
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        adjustSetTimeout.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function debugCurrentInlineScript(source, args) {
      function debugCurrentInlineScript(source, property, search) {
        const searchRegexp = toRegExp(search);
        const rid = randomId();
        const getCurrentScript = function getCurrentScript() {
          if ("currentScript" in document) {
            return document.currentScript;
          }
          const scripts = document.getElementsByTagName("script");
          return scripts[scripts.length - 1];
        };
        const ourScript = getCurrentScript();
        const abort = function abort() {
          const scriptEl = getCurrentScript();
          if (!scriptEl) {
            return;
          }
          let content = scriptEl.textContent;
          try {
            const textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, "textContent").get;
            content = textContentGetter.call(scriptEl);
          } catch (e) {}
          if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
            hit(source);
            debugger;
          }
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (base instanceof Object === false && base === null) {
            const props = property.split(".");
            const propIndex = props.indexOf(prop);
            const baseName = props[propIndex - 1];
            const message = "The scriptlet had been executed before the ".concat(baseName, " was loaded.");
            logMessage(message, source.verbose);
            return;
          }
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          let currentValue = base[prop];
          setPropertyAccess(base, prop, {
            set: function set(value) {
              abort();
              currentValue = value;
            },
            get: function get() {
              abort();
              return currentValue;
            }
          });
        };
        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        debugCurrentInlineScript.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function debugOnPropertyRead(source, args) {
      function debugOnPropertyRead(source, property) {
        if (!property) {
          return;
        }
        const rid = randomId();
        const abort = function abort() {
          hit(source);
          debugger;
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          setPropertyAccess(base, prop, {
            get: abort,
            set: noopFunc
          });
        };
        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function noopFunc() {}
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        debugOnPropertyRead.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function debugOnPropertyWrite(source, args) {
      function debugOnPropertyWrite(source, property) {
        if (!property) {
          return;
        }
        const rid = randomId();
        const abort = function abort() {
          hit(source);
          debugger;
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          setPropertyAccess(base, prop, {
            set: abort
          });
        };
        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        debugOnPropertyWrite.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function dirString(source, args) {
      function dirString(source, times) {
        const _console = console,
          dir = _console.dir;
        function dirWrapper(object) {
          if (typeof dir === "function") {
            dir.call(this, object);
          }
          hit(source);
        }
        console.dir = dirWrapper;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        dirString.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function disableNewtabLinks(source, args) {
      function disableNewtabLinks(source) {
        document.addEventListener("click", function (ev) {
          let target = ev.target;
          while (target !== null) {
            if (target.localName === "a" && target.hasAttribute("target")) {
              ev.stopPropagation();
              ev.preventDefault();
              hit(source);
              break;
            }
            target = target.parentNode;
          }
        });
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        disableNewtabLinks.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function forceWindowClose(source, args) {
      function forceWindowClose(source) {
        let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        if (typeof window.close !== "function") {
          const message = "window.close() is not a function so 'close-window' scriptlet is unavailable";
          logMessage(source, message);
          return;
        }
        const closeImmediately = function closeImmediately() {
          try {
            hit(source);
            window.close();
          } catch (e) {
            logMessage(source, e);
          }
        };
        const closeByExtension = function closeByExtension() {
          const extCall = function extCall() {
            dispatchEvent(new Event("adguard:scriptlet-close-window"));
          };
          window.addEventListener("adguard:subscribed-to-close-window", extCall, {
            once: true
          });
          setTimeout(function () {
            window.removeEventListener("adguard:subscribed-to-close-window", extCall, {
              once: true
            });
          }, 5e3);
        };
        const shouldClose = function shouldClose() {
          if (path === "") {
            return true;
          }
          const pathRegexp = toRegExp(path);
          const currentPath = "".concat(window.location.pathname).concat(window.location.search);
          return pathRegexp.test(currentPath);
        };
        if (shouldClose()) {
          closeImmediately();
          if (navigator.userAgent.indexOf("Chrome") > -1) {
            closeByExtension();
          }
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        forceWindowClose.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function hideInShadowDom(source, args) {
      function hideInShadowDom(source, selector, baseSelector) {
        if (!Element.prototype.attachShadow) {
          return;
        }
        const hideElement = function hideElement(targetElement) {
          const DISPLAY_NONE_CSS = "display:none!important;";
          targetElement.style.cssText = DISPLAY_NONE_CSS;
        };
        const hideHandler = function hideHandler() {
          let hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
          while (hostElements.length !== 0) {
            let isHidden = false;
            const _pierceShadowDom = pierceShadowDom(selector, hostElements),
              targets = _pierceShadowDom.targets,
              innerHosts = _pierceShadowDom.innerHosts;
            targets.forEach(function (targetEl) {
              hideElement(targetEl);
              isHidden = true;
            });
            if (isHidden) {
              hit(source);
            }
            hostElements = innerHosts;
          }
        };
        hideHandler();
        observeDOMChanges(hideHandler, true);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function observeDOMChanges(callback) {
        let observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        const THROTTLE_DELAY_MS = 20;
        const observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        const connect = function connect() {
          if (attrsToObserve.length > 0) {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs,
              attributeFilter: attrsToObserve
            });
          } else {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs
            });
          }
        };
        const disconnect = function disconnect() {
          observer.disconnect();
        };
        function callbackWrapper() {
          disconnect();
          callback();
          connect();
        }
        connect();
      }
      function findHostElements(rootElement) {
        const hosts = [];
        const domElems = rootElement.querySelectorAll("*");
        domElems.forEach(function (el) {
          if (el.shadowRoot) {
            hosts.push(el);
          }
        });
        return hosts;
      }
      function pierceShadowDom(selector, hostElements) {
        let targets = [];
        const innerHostsAcc = [];
        hostElements.forEach(function (host) {
          const simpleElems = host.querySelectorAll(selector);
          targets = targets.concat([].slice.call(simpleElems));
          const shadowRootElem = host.shadowRoot;
          const shadowChildren = shadowRootElem.querySelectorAll(selector);
          targets = targets.concat([].slice.call(shadowChildren));
          innerHostsAcc.push(findHostElements(shadowRootElem));
        });
        const innerHosts = flatten(innerHostsAcc);
        return {
          targets: targets,
          innerHosts: innerHosts
        };
      }
      function flatten(input) {
        const stack = [];
        input.forEach(function (el) {
          return stack.push(el);
        });
        const res = [];
        while (stack.length) {
          const next = stack.pop();
          if (Array.isArray(next)) {
            next.forEach(function (el) {
              return stack.push(el);
            });
          } else {
            res.push(next);
          }
        }
        return res.reverse();
      }
      function throttle(cb, delay) {
        let wait = false;
        let savedArgs;
        const wrapper = function wrapper() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (wait) {
            savedArgs = args;
            return;
          }
          cb(...args);
          wait = true;
          setTimeout(function () {
            wait = false;
            if (savedArgs) {
              wrapper(...savedArgs);
              savedArgs = null;
            }
          }, delay);
        };
        return wrapper;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        hideInShadowDom.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function injectCssInShadowDom(source, args) {
      function injectCssInShadowDom(source, cssRule) {
        let hostSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        if (!Element.prototype.attachShadow || typeof Proxy === "undefined" || typeof Reflect === "undefined") {
          return;
        }
        if (cssRule.match(/(url|image-set)\(.*\)/i)) {
          logMessage(source, '"url()" function is not allowed for css rules');
          return;
        }
        const callback = function callback(shadowRoot) {
          try {
            const stylesheet = new CSSStyleSheet();
            try {
              stylesheet.insertRule(cssRule);
            } catch (e) {
              logMessage(source, "Unable to apply the rule '".concat(cssRule, "' due to: \n'").concat(e.message, "'"));
              return;
            }
            shadowRoot.adoptedStyleSheets = [...shadowRoot.adoptedStyleSheets, stylesheet];
          } catch (_unused) {
            const styleTag = document.createElement("style");
            styleTag.innerText = cssRule;
            shadowRoot.appendChild(styleTag);
          }
          hit(source);
        };
        hijackAttachShadow(window, hostSelector, callback);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function hijackAttachShadow(context, hostSelector, callback) {
        const handlerWrapper = function handlerWrapper(target, thisArg, args) {
          const shadowRoot = Reflect.apply(target, thisArg, args);
          if (thisArg && thisArg.matches(hostSelector || "*")) {
            callback(shadowRoot);
          }
          return shadowRoot;
        };
        const attachShadowHandler = {
          apply: handlerWrapper
        };
        context.Element.prototype.attachShadow = new Proxy(context.Element.prototype.attachShadow, attachShadowHandler);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        injectCssInShadowDom.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function jsonPrune(source, args) {
      function jsonPrune(source, propsToRemove, requiredInitialProps, stack) {
        if (!!stack && !matchStackTrace(stack, new Error().stack)) {
          return;
        }
        const prunePaths = propsToRemove !== undefined && propsToRemove !== "" ? propsToRemove.split(/ +/) : [];
        const requiredPaths = requiredInitialProps !== undefined && requiredInitialProps !== "" ? requiredInitialProps.split(/ +/) : [];
        function isPruningNeeded(root) {
          if (!root) {
            return false;
          }
          let shouldProcess;
          if (prunePaths.length === 0 && requiredPaths.length > 0) {
            const rootString = JSON.stringify(root);
            const matchRegex = toRegExp(requiredPaths.join(""));
            const shouldLog = matchRegex.test(rootString);
            if (shouldLog) {
              logMessage(source, "".concat(window.location.hostname, "\n").concat(JSON.stringify(root, null, 2)), true);
              if (root && typeof root === "object") {
                logMessage(source, root, true, false);
              }
              shouldProcess = false;
              return shouldProcess;
            }
          }
          for (let i = 0; i < requiredPaths.length; i += 1) {
            const requiredPath = requiredPaths[i];
            const lastNestedPropName = requiredPath.split(".").pop();
            const hasWildcard = requiredPath.indexOf(".*.") > -1 || requiredPath.indexOf("*.") > -1 || requiredPath.indexOf(".*") > -1 || requiredPath.indexOf(".[].") > -1 || requiredPath.indexOf("[].") > -1 || requiredPath.indexOf(".[]") > -1;
            const details = getWildcardPropertyInChain(root, requiredPath, hasWildcard);
            shouldProcess = !hasWildcard;
            for (let i = 0; i < details.length; i += 1) {
              if (hasWildcard) {
                shouldProcess = !(details[i].base[lastNestedPropName] === undefined) || shouldProcess;
              } else {
                shouldProcess = !(details[i].base[lastNestedPropName] === undefined) && shouldProcess;
              }
            }
          }
          return shouldProcess;
        }
        const jsonPruner = function jsonPruner(root) {
          if (prunePaths.length === 0 && requiredPaths.length === 0) {
            logMessage(source, "".concat(window.location.hostname, "\n").concat(JSON.stringify(root, null, 2)), true);
            if (root && typeof root === "object") {
              logMessage(source, root, true, false);
            }
            return root;
          }
          try {
            if (isPruningNeeded(root) === false) {
              return root;
            }
            prunePaths.forEach(function (path) {
              const ownerObjArr = getWildcardPropertyInChain(root, path, true);
              ownerObjArr.forEach(function (ownerObj) {
                if (ownerObj !== undefined && ownerObj.base) {
                  delete ownerObj.base[ownerObj.prop];
                  hit(source);
                }
              });
            });
          } catch (e) {
            logMessage(source, e);
          }
          return root;
        };
        const nativeJSONParse = JSON.parse;
        const jsonParseWrapper = function jsonParseWrapper() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          const root = nativeJSONParse.apply(JSON, args);
          return jsonPruner(root);
        };
        jsonParseWrapper.toString = nativeJSONParse.toString.bind(nativeJSONParse);
        JSON.parse = jsonParseWrapper;
        const nativeResponseJson = Response.prototype.json;
        const responseJsonWrapper = function responseJsonWrapper() {
          const promise = nativeResponseJson.apply(this);
          return promise.then(function (obj) {
            return jsonPruner(obj);
          });
        };
        if (typeof Response === "undefined") {
          return;
        }
        Response.prototype.json = responseJsonWrapper;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
          return true;
        }
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
          return true;
        }
        const stackRegexp = toRegExp(stackMatch);
        const refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        }).join("\n");
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
      }
      function getWildcardPropertyInChain(base, chain) {
        let lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
        const pos = chain.indexOf(".");
        if (pos === -1) {
          if (chain === "*" || chain === "[]") {
            for (const key in base) {
              if (Object.prototype.hasOwnProperty.call(base, key)) {
                output.push({
                  base: base,
                  prop: key
                });
              }
            }
          } else {
            output.push({
              base: base,
              prop: chain
            });
          }
          return output;
        }
        const prop = chain.slice(0, pos);
        const shouldLookThrough = prop === "[]" && Array.isArray(base) || prop === "*" && base instanceof Object;
        if (shouldLookThrough) {
          const nextProp = chain.slice(pos + 1);
          const baseKeys = Object.keys(base);
          baseKeys.forEach(function (key) {
            const item = base[key];
            getWildcardPropertyInChain(item, nextProp, lookThrough, output);
          });
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if (nextBase !== undefined) {
          getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
        }
        return output;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function getNativeRegexpTest() {
        return Object.getOwnPropertyDescriptor(RegExp.prototype, "test").value;
      }
      function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        const INLINE_SCRIPT_STRING = "inlineScript";
        const INJECTED_SCRIPT_STRING = "injectedScript";
        const INJECTED_SCRIPT_MARKER = "<anonymous>";
        const isInlineScript = function isInlineScript(stackMatch) {
          return stackMatch.indexOf(INLINE_SCRIPT_STRING) > -1;
        };
        const isInjectedScript = function isInjectedScript(stackMatch) {
          return stackMatch.indexOf(INJECTED_SCRIPT_STRING) > -1;
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
          return false;
        }
        let documentURL = window.location.href;
        const pos = documentURL.indexOf("#");
        if (pos !== -1) {
          documentURL = documentURL.slice(0, pos);
        }
        const stackSteps = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        });
        const stackLines = stackSteps.map(function (line) {
          let stack;
          const getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
          if (getStackTraceURL) {
            let stackURL = getStackTraceURL[2];
            if (startsWith(stackURL, "(")) {
              stackURL = stackURL.slice(1);
            }
            if (startsWith(stackURL, INJECTED_SCRIPT_MARKER)) {
              stackURL = INJECTED_SCRIPT_STRING;
              let stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
              if (startsWith(stackFunction, "at")) {
                stackFunction = stackFunction.slice(2).trim();
              }
              stack = "".concat(stackFunction, " ").concat(stackURL).trim();
            } else {
              stack = stackURL;
            }
          } else {
            stack = line;
          }
          return stack;
        });
        if (stackLines) {
          for (let index = 0; index < stackLines.length; index += 1) {
            if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
              return true;
            }
            if (isInjectedScript(stackMatch) && startsWith(stackLines[index], INJECTED_SCRIPT_STRING)) {
              return true;
            }
          }
        }
        return false;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        jsonPrune.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function log(source, args) {
      function log() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        console.log(args);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        log.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function logAddEventListener(source, args) {
      function logAddEventListener(source) {
        const nativeAddEventListener = window.EventTarget.prototype.addEventListener;
        function addEventListenerWrapper(type, listener) {
          var _this$constructor;
          if (validateType(type) && validateListener(listener)) {
            const message = 'addEventListener("'.concat(type, '", ').concat(listenerToString(listener), ")");
            logMessage(source, message, true);
            hit(source);
          }
          const message = "Invalid event type or listener passed to addEventListener:\ntype: ".concat(convertTypeToString(type), "\nlistener: ").concat(convertTypeToString(listener));
          logMessage(source, message, true);
          let context = this;
          if (this && ((_this$constructor = this.constructor) === null || _this$constructor === void 0 ? void 0 : _this$constructor.name) === "Window" && this !== window) {
            context = window;
          }
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }
          return nativeAddEventListener.apply(context, [type, listener, ...args]);
        }
        const descriptor = {
          configurable: true,
          set: function set() {},
          get: function get() {
            return addEventListenerWrapper;
          }
        };
        Object.defineProperty(window.EventTarget.prototype, "addEventListener", descriptor);
        Object.defineProperty(window, "addEventListener", descriptor);
        Object.defineProperty(document, "addEventListener", descriptor);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function validateType(type) {
        return typeof type !== "undefined";
      }
      function validateListener(listener) {
        return typeof listener !== "undefined" && (typeof listener === "function" || typeof listener === "object" && listener !== null && typeof listener.handleEvent === "function");
      }
      function listenerToString(listener) {
        return typeof listener === "function" ? listener.toString() : listener.handleEvent.toString();
      }
      function convertTypeToString(value) {
        let output;
        if (typeof value === "undefined") {
          output = "undefined";
        } else if (typeof value === "object") {
          if (value === null) {
            output = "null";
          } else {
            output = objectToString(value);
          }
        } else {
          output = value.toString();
        }
        return output;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
          return String(obj);
        }
        return isEmptyObject(obj) ? "{}" : getObjectEntries(obj).map(function (pair) {
          const key = pair[0];
          const value = pair[1];
          let recordValueStr = value;
          if (value instanceof Object) {
            recordValueStr = "{ ".concat(objectToString(value), " }");
          }
          return "".concat(key, ':"').concat(recordValueStr, '"');
        }).join(" ");
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getObjectEntries(object) {
        const keys = Object.keys(object);
        const entries = [];
        keys.forEach(function (key) {
          return entries.push([key, object[key]]);
        });
        return entries;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        logAddEventListener.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function logEval(source, args) {
      function logEval(source) {
        const nativeEval = window.eval;
        function evalWrapper(str) {
          hit(source);
          logMessage(source, 'eval("'.concat(str, '")'), true);
          return nativeEval(str);
        }
        window.eval = evalWrapper;
        const nativeFunction = window.Function;
        function FunctionWrapper() {
          hit(source);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          logMessage(source, "new Function(".concat(args.join(", "), ")"), true);
          return nativeFunction.apply(this, [...args]);
        }
        FunctionWrapper.prototype = Object.create(nativeFunction.prototype);
        FunctionWrapper.prototype.constructor = FunctionWrapper;
        window.Function = FunctionWrapper;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        logEval.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function logOnStacktrace(source, args) {
      function logOnStacktrace(source, property) {
        if (!property) {
          return;
        }
        const refineStackTrace = function refineStackTrace(stackString) {
          const stackSteps = stackString.split("\n").slice(2).map(function (line) {
            return line.replace(/ {4}at /, "");
          });
          const logInfoArray = stackSteps.map(function (line) {
            let funcName;
            let funcFullPath;
            const reg = /\(([^\)]+)\)/;
            const regFirefox = /(.*?@)(\S+)(:\d+):\d+\)?$/;
            if (line.match(reg)) {
              funcName = line.split(" ").slice(0, -1).join(" ");
              funcFullPath = line.match(reg)[1];
            } else if (line.match(regFirefox)) {
              funcName = line.split("@").slice(0, -1).join(" ");
              funcFullPath = line.match(regFirefox)[2];
            } else {
              funcName = "function name is not available";
              funcFullPath = line;
            }
            return [funcName, funcFullPath];
          });
          const logInfoObject = {};
          logInfoArray.forEach(function (pair) {
            logInfoObject[pair[0]] = pair[1];
          });
          return logInfoObject;
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          let base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          if (chain) {
            const setter = function setter(a) {
              base = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            };
            Object.defineProperty(owner, prop, {
              get: function get() {
                return base;
              },
              set: setter
            });
            return;
          }
          let value = base[prop];
          setPropertyAccess(base, prop, {
            get() {
              hit(source);
              logMessage(source, "Get ".concat(prop), true);
              console.table(refineStackTrace(new Error().stack));
              return value;
            },
            set(newValue) {
              hit(source);
              logMessage(source, "Set ".concat(prop), true);
              console.table(refineStackTrace(new Error().stack));
              value = newValue;
            }
          });
        };
        setChainPropAccess(window, property);
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        logOnStacktrace.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function m3uPrune(source, args) {
      function m3uPrune(source, propsToRemove, urlToMatch) {
        if (typeof Reflect === "undefined" || typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
          return;
        }
        let shouldPruneResponse = false;
        const urlMatchRegexp = toRegExp(urlToMatch);
        const SEGMENT_MARKER = "#";
        const AD_MARKER = {
          ASSET: "#EXT-X-ASSET:",
          CUE: "#EXT-X-CUE:",
          CUE_IN: "#EXT-X-CUE-IN",
          DISCONTINUITY: "#EXT-X-DISCONTINUITY",
          EXTINF: "#EXTINF",
          EXTM3U: "#EXTM3U",
          SCTE35: "#EXT-X-SCTE35:"
        };
        const COMCAST_AD_MARKER = {
          AD: "-AD-",
          VAST: "-VAST-",
          VMAP_AD: "-VMAP-AD-",
          VMAP_AD_BREAK: "#EXT-X-VMAP-AD-BREAK:"
        };
        const TAGS_ALLOWLIST = ["#EXT-X-TARGETDURATION", "#EXT-X-MEDIA-SEQUENCE", "#EXT-X-DISCONTINUITY-SEQUENCE", "#EXT-X-ENDLIST", "#EXT-X-PLAYLIST-TYPE", "#EXT-X-I-FRAMES-ONLY", "#EXT-X-MEDIA", "#EXT-X-STREAM-INF", "#EXT-X-I-FRAME-STREAM-INF", "#EXT-X-SESSION-DATA", "#EXT-X-SESSION-KEY", "#EXT-X-INDEPENDENT-SEGMENTS", "#EXT-X-START"];
        const isAllowedTag = function isAllowedTag(str) {
          return TAGS_ALLOWLIST.some(function (el) {
            return str.startsWith(el);
          });
        };
        const pruneExtinfFromVmapBlock = function pruneExtinfFromVmapBlock(lines, i) {
          let array = lines.slice();
          let index = i;
          if (array[index].includes(AD_MARKER.EXTINF)) {
            array[index] = undefined;
            index += 1;
            if (array[index].includes(AD_MARKER.DISCONTINUITY)) {
              array[index] = undefined;
              index += 1;
              const prunedExtinf = pruneExtinfFromVmapBlock(array, index);
              array = prunedExtinf.array;
              index = prunedExtinf.index;
            }
          }
          return {
            array: array,
            index: index
          };
        };
        const pruneVmapBlock = function pruneVmapBlock(lines) {
          let array = lines.slice();
          for (let i = 0; i < array.length - 1; i += 1) {
            if (array[i].includes(COMCAST_AD_MARKER.VMAP_AD) || array[i].includes(COMCAST_AD_MARKER.VAST) || array[i].includes(COMCAST_AD_MARKER.AD)) {
              array[i] = undefined;
              if (array[i + 1].includes(AD_MARKER.EXTINF)) {
                i += 1;
                const prunedExtinf = pruneExtinfFromVmapBlock(array, i);
                array = prunedExtinf.array;
                i = prunedExtinf.index - 1;
              }
            }
          }
          return array;
        };
        const pruneSpliceoutBlock = function pruneSpliceoutBlock(line, index, array) {
          if (!line.startsWith(AD_MARKER.CUE)) {
            return line;
          }
          line = undefined;
          index += 1;
          if (array[index].startsWith(AD_MARKER.ASSET)) {
            array[index] = undefined;
            index += 1;
          }
          if (array[index].startsWith(AD_MARKER.SCTE35)) {
            array[index] = undefined;
            index += 1;
          }
          if (array[index].startsWith(AD_MARKER.CUE_IN)) {
            array[index] = undefined;
            index += 1;
          }
          if (array[index].startsWith(AD_MARKER.SCTE35)) {
            array[index] = undefined;
          }
          return line;
        };
        const removeM3ULineRegexp = toRegExp(propsToRemove);
        const pruneInfBlock = function pruneInfBlock(line, index, array) {
          if (!line.startsWith(AD_MARKER.EXTINF)) {
            return line;
          }
          if (!removeM3ULineRegexp.test(array[index + 1])) {
            return line;
          }
          if (!isAllowedTag(array[index])) {
            array[index] = undefined;
          }
          index += 1;
          if (!isAllowedTag(array[index])) {
            array[index] = undefined;
          }
          index += 1;
          if (array[index].startsWith(AD_MARKER.DISCONTINUITY)) {
            array[index] = undefined;
          }
          return line;
        };
        const pruneSegments = function pruneSegments(lines) {
          for (let i = 0; i < lines.length - 1; i += 1) {
            var _lines$i;
            if ((_lines$i = lines[i]) !== null && _lines$i !== void 0 && _lines$i.startsWith(SEGMENT_MARKER) && removeM3ULineRegexp.test(lines[i])) {
              const segmentName = lines[i].substring(0, lines[i].indexOf(":"));
              if (!segmentName) {
                return lines;
              }
              lines[i] = undefined;
              i += 1;
              for (let j = i; j < lines.length; j += 1) {
                if (!lines[j].includes(segmentName) && !isAllowedTag(lines[j])) {
                  lines[j] = undefined;
                } else {
                  i = j - 1;
                  break;
                }
              }
            }
          }
          return lines;
        };
        const isM3U = function isM3U(text) {
          if (typeof text === "string") {
            const trimmedText = text.trim();
            return trimmedText.startsWith(AD_MARKER.EXTM3U) || trimmedText.startsWith(COMCAST_AD_MARKER.VMAP_AD_BREAK);
          }
          return false;
        };
        const isPruningNeeded = function isPruningNeeded(text, regexp) {
          return isM3U(text) && regexp.test(text);
        };
        const pruneM3U = function pruneM3U(text) {
          let lines = text.split(/\n\r|\n|\r/);
          if (text.includes(COMCAST_AD_MARKER.VMAP_AD_BREAK)) {
            lines = pruneVmapBlock(lines);
            return lines.filter(function (l) {
              return !!l;
            }).join("\n");
          }
          lines = pruneSegments(lines);
          return lines.map(function (line, index, array) {
            if (typeof line === "undefined") {
              return line;
            }
            line = pruneSpliceoutBlock(line, index, array);
            if (typeof line !== "undefined") {
              line = pruneInfBlock(line, index, array);
            }
            return line;
          }).filter(function (l) {
            return !!l;
          }).join("\n");
        };
        const xhrWrapper = function xhrWrapper(target, thisArg, args) {
          const xhrURL = args[1];
          if (typeof xhrURL !== "string" || xhrURL.length === 0) {
            return Reflect.apply(target, thisArg, args);
          }
          if (urlMatchRegexp.test(xhrURL)) {
            thisArg.addEventListener("readystatechange", function pruneResponse() {
              if (thisArg.readyState === 4) {
                const response = thisArg.response;
                thisArg.removeEventListener("readystatechange", pruneResponse);
                if (!propsToRemove) {
                  if (isM3U(response)) {
                    const message = "XMLHttpRequest.open() URL: ".concat(xhrURL, "\nresponse: ").concat(response);
                    logMessage(source, message);
                  }
                } else {
                  shouldPruneResponse = isPruningNeeded(response, removeM3ULineRegexp);
                }
                if (shouldPruneResponse) {
                  const prunedResponseContent = pruneM3U(response);
                  Object.defineProperty(thisArg, "response", {
                    value: prunedResponseContent
                  });
                  Object.defineProperty(thisArg, "responseText", {
                    value: prunedResponseContent
                  });
                  hit(source);
                }
              }
            });
          }
          return Reflect.apply(target, thisArg, args);
        };
        const xhrHandler = {
          apply: xhrWrapper
        };
        window.XMLHttpRequest.prototype.open = new Proxy(window.XMLHttpRequest.prototype.open, xhrHandler);
        const nativeFetch = window.fetch;
        const fetchWrapper = async function fetchWrapper(target, thisArg, args) {
          const fetchURL = args[0] instanceof Request ? args[0].url : args[0];
          if (typeof fetchURL !== "string" || fetchURL.length === 0) {
            return Reflect.apply(target, thisArg, args);
          }
          if (urlMatchRegexp.test(fetchURL)) {
            const response = await nativeFetch(...args);
            const responseText = await response.text();
            if (!propsToRemove && isM3U(responseText)) {
              const message = "fetch URL: ".concat(fetchURL, "\nresponse text: ").concat(responseText);
              logMessage(source, message);
              return Reflect.apply(target, thisArg, args);
            }
            if (isPruningNeeded(responseText, removeM3ULineRegexp)) {
              const prunedText = pruneM3U(responseText);
              hit(source);
              return new Response(prunedText, {
                status: response.status,
                statusText: response.statusText,
                headers: response.headers
              });
            }
            return Reflect.apply(target, thisArg, args);
          }
          return Reflect.apply(target, thisArg, args);
        };
        const fetchHandler = {
          apply: fetchWrapper
        };
        window.fetch = new Proxy(window.fetch, fetchHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        m3uPrune.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function noTopics(source, args) {
      function noTopics(source) {
        const TOPICS_PROPERTY_NAME = "browsingTopics";
        if (Document instanceof Object === false) {
          return;
        }
        if (!Object.prototype.hasOwnProperty.call(Document.prototype, TOPICS_PROPERTY_NAME) || Document.prototype[TOPICS_PROPERTY_NAME] instanceof Function === false) {
          return;
        }
        Document.prototype[TOPICS_PROPERTY_NAME] = function () {
          return noopPromiseResolve("[]");
        };
        hit(source);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function noopPromiseResolve() {
        let responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "{}";
        let responseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        let responseType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "default";
        if (typeof Response === "undefined") {
          return;
        }
        const response = new Response(responseBody, {
          status: 200,
          statusText: "OK"
        });
        Object.defineProperties(response, {
          url: {
            value: responseUrl
          },
          type: {
            value: responseType
          }
        });
        return Promise.resolve(response);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        noTopics.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function noeval(source, args) {
      function noeval(source) {
        window.eval = function evalWrapper(s) {
          hit(source);
          logMessage(source, "AdGuard has prevented eval:\n".concat(s), true);
        }.bind();
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        noeval.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function nowebrtc(source, args) {
      function nowebrtc(source) {
        let propertyName = "";
        if (window.RTCPeerConnection) {
          propertyName = "RTCPeerConnection";
        } else if (window.webkitRTCPeerConnection) {
          propertyName = "webkitRTCPeerConnection";
        }
        if (propertyName === "") {
          return;
        }
        const rtcReplacement = function rtcReplacement(config) {
          const message = "Document tried to create an RTCPeerConnection: ".concat(convertRtcConfigToString(config));
          logMessage(source, message);
          hit(source);
        };
        rtcReplacement.prototype = {
          close: noopFunc,
          createDataChannel: noopFunc,
          createOffer: noopFunc,
          setRemoteDescription: noopFunc
        };
        const rtc = window[propertyName];
        window[propertyName] = rtcReplacement;
        if (rtc.prototype) {
          rtc.prototype.createDataChannel = function (a, b) {
            return {
              close: noopFunc,
              send: noopFunc
            };
          }.bind(null);
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function noopFunc() {}
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function convertRtcConfigToString(config) {
        const UNDEF_STR = "undefined";
        let str = UNDEF_STR;
        if (config === null) {
          str = "null";
        } else if (config instanceof Object) {
          const SERVERS_PROP_NAME = "iceServers";
          const URLS_PROP_NAME = "urls";
          if (Object.prototype.hasOwnProperty.call(config, SERVERS_PROP_NAME) && Object.prototype.hasOwnProperty.call(config[SERVERS_PROP_NAME][0], URLS_PROP_NAME) && !!config[SERVERS_PROP_NAME][0][URLS_PROP_NAME]) {
            str = config[SERVERS_PROP_NAME][0][URLS_PROP_NAME].toString();
          }
        }
        return str;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        nowebrtc.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventAddEventListener(source, args) {
      function preventAddEventListener(source, typeSearch, listenerSearch) {
        const typeSearchRegexp = toRegExp(typeSearch);
        const listenerSearchRegexp = toRegExp(listenerSearch);
        const nativeAddEventListener = window.EventTarget.prototype.addEventListener;
        function addEventListenerWrapper(type, listener) {
          var _this$constructor;
          let shouldPrevent = false;
          if (validateType(type) && validateListener(listener)) {
            shouldPrevent = typeSearchRegexp.test(type.toString()) && listenerSearchRegexp.test(listenerToString(listener));
          }
          if (shouldPrevent) {
            hit(source);
            return undefined;
          }
          let context = this;
          if (this && ((_this$constructor = this.constructor) === null || _this$constructor === void 0 ? void 0 : _this$constructor.name) === "Window" && this !== window) {
            context = window;
          }
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }
          return nativeAddEventListener.apply(context, [type, listener, ...args]);
        }
        const descriptor = {
          configurable: true,
          set: function set() {},
          get: function get() {
            return addEventListenerWrapper;
          }
        };
        Object.defineProperty(window.EventTarget.prototype, "addEventListener", descriptor);
        Object.defineProperty(window, "addEventListener", descriptor);
        Object.defineProperty(document, "addEventListener", descriptor);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function validateType(type) {
        return typeof type !== "undefined";
      }
      function validateListener(listener) {
        return typeof listener !== "undefined" && (typeof listener === "function" || typeof listener === "object" && listener !== null && typeof listener.handleEvent === "function");
      }
      function listenerToString(listener) {
        return typeof listener === "function" ? listener.toString() : listener.handleEvent.toString();
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventAddEventListener.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventAdfly(source, args) {
      function preventAdfly(source) {
        const isDigit = function isDigit(data) {
          return /^\d$/.test(data);
        };
        const handler = function handler(encodedURL) {
          let evenChars = "";
          let oddChars = "";
          for (let i = 0; i < encodedURL.length; i += 1) {
            if (i % 2 === 0) {
              evenChars += encodedURL.charAt(i);
            } else {
              oddChars = encodedURL.charAt(i) + oddChars;
            }
          }
          let data = (evenChars + oddChars).split("");
          for (let i = 0; i < data.length; i += 1) {
            if (isDigit(data[i])) {
              for (let ii = i + 1; ii < data.length; ii += 1) {
                if (isDigit(data[ii])) {
                  const temp = parseInt(data[i], 10) ^ parseInt(data[ii], 10);
                  if (temp < 10) {
                    data[i] = temp.toString();
                  }
                  i = ii;
                  break;
                }
              }
            }
          }
          data = data.join("");
          const decodedURL = window.atob(data).slice(16, -16);
          if (window.stop) {
            window.stop();
          }
          window.onbeforeunload = null;
          window.location.href = decodedURL;
        };
        let val;
        let applyHandler = true;
        const result = setPropertyAccess(window, "ysmm", {
          configurable: false,
          set: function set(value) {
            if (applyHandler) {
              applyHandler = false;
              try {
                if (typeof value === "string") {
                  handler(value);
                }
              } catch (err) {}
            }
            val = value;
          },
          get: function get() {
            return val;
          }
        });
        if (result) {
          hit(source);
        } else {
          logMessage(source, "Failed to set up prevent-adfly scriptlet");
        }
      }
      function setPropertyAccess(object, property, descriptor) {
        const currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
          return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventAdfly.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventBab(source, args) {
      function preventBab(source) {
        const nativeSetTimeout = window.setTimeout;
        const babRegex = /\.bab_elementid.$/;
        const timeoutWrapper = function timeoutWrapper(callback) {
          if (typeof callback !== "string" || !babRegex.test(callback)) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeSetTimeout.apply(window, [callback, ...args]);
          }
          hit(source);
        };
        window.setTimeout = timeoutWrapper;
        const signatures = [["blockadblock"], ["babasbm"], [/getItem\('babn'\)/], ["getElementById", "String.fromCharCode", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", "charAt", "DOMContentLoaded", "AdBlock", "addEventListener", "doScroll", "fromCharCode", "<<2|r>>4", "sessionStorage", "clientWidth", "localStorage", "Math", "random"]];
        const check = function check(str) {
          if (typeof str !== "string") {
            return false;
          }
          for (let i = 0; i < signatures.length; i += 1) {
            const tokens = signatures[i];
            let match = 0;
            for (let j = 0; j < tokens.length; j += 1) {
              const token = tokens[j];
              const found = token instanceof RegExp ? token.test(str) : str.indexOf(token) > -1;
              if (found) {
                match += 1;
              }
            }
            if (match / tokens.length >= .8) {
              return true;
            }
          }
          return false;
        };
        const nativeEval = window.eval;
        const evalWrapper = function evalWrapper(str) {
          if (!check(str)) {
            return nativeEval(str);
          }
          hit(source);
          const bodyEl = document.body;
          if (bodyEl) {
            bodyEl.style.removeProperty("visibility");
          }
          const el = document.getElementById("babasbmsgx");
          if (el) {
            el.parentNode.removeChild(el);
          }
        };
        window.eval = evalWrapper.bind(window);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventBab.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventElementSrcLoading(source, args) {
      function preventElementSrcLoading(source, tagName, match) {
        if (typeof Proxy === "undefined" || typeof Reflect === "undefined") {
          return;
        }
        const srcMockData = {
          script: "data:text/javascript;base64,KCk9Pnt9",
          img: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
          iframe: "data:text/html;base64, PGRpdj48L2Rpdj4="
        };
        let instance;
        if (tagName === "script") {
          instance = HTMLScriptElement;
        } else if (tagName === "img") {
          instance = HTMLImageElement;
        } else if (tagName === "iframe") {
          instance = HTMLIFrameElement;
        } else {
          return;
        }
        const hasTrustedTypes = window.trustedTypes && typeof window.trustedTypes.createPolicy === "function";
        let policy;
        if (hasTrustedTypes) {
          policy = window.trustedTypes.createPolicy("AGPolicy", {
            createScriptURL: function createScriptURL(arg) {
              return arg;
            }
          });
        }
        const SOURCE_PROPERTY_NAME = "src";
        const ONERROR_PROPERTY_NAME = "onerror";
        const searchRegexp = toRegExp(match);
        const setMatchedAttribute = function setMatchedAttribute(elem) {
          return elem.setAttribute(source.name, "matched");
        };
        const setAttributeWrapper = function setAttributeWrapper(target, thisArg, args) {
          if (!args[0] || !args[1]) {
            return Reflect.apply(target, thisArg, args);
          }
          const nodeName = thisArg.nodeName.toLowerCase();
          const attrName = args[0].toLowerCase();
          const attrValue = args[1];
          const isMatched = attrName === SOURCE_PROPERTY_NAME && tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(attrValue);
          if (!isMatched) {
            return Reflect.apply(target, thisArg, args);
          }
          hit(source);
          setMatchedAttribute(thisArg);
          return Reflect.apply(target, thisArg, [attrName, srcMockData[nodeName]]);
        };
        const setAttributeHandler = {
          apply: setAttributeWrapper
        };
        instance.prototype.setAttribute = new Proxy(Element.prototype.setAttribute, setAttributeHandler);
        const origSrcDescriptor = safeGetDescriptor(instance.prototype, SOURCE_PROPERTY_NAME);
        if (!origSrcDescriptor) {
          return;
        }
        Object.defineProperty(instance.prototype, SOURCE_PROPERTY_NAME, {
          enumerable: true,
          configurable: true,
          get() {
            return origSrcDescriptor.get.call(this);
          },
          set(urlValue) {
            const nodeName = this.nodeName.toLowerCase();
            const isMatched = tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(urlValue);
            if (!isMatched) {
              origSrcDescriptor.set.call(this, urlValue);
              return true;
            }
            if (policy && urlValue instanceof TrustedScriptURL) {
              const trustedSrc = policy.createScriptURL(urlValue);
              origSrcDescriptor.set.call(this, trustedSrc);
              hit(source);
              return;
            }
            setMatchedAttribute(this);
            origSrcDescriptor.set.call(this, srcMockData[nodeName]);
            hit(source);
          }
        });
        const origOnerrorDescriptor = safeGetDescriptor(HTMLElement.prototype, ONERROR_PROPERTY_NAME);
        if (!origOnerrorDescriptor) {
          return;
        }
        Object.defineProperty(HTMLElement.prototype, ONERROR_PROPERTY_NAME, {
          enumerable: true,
          configurable: true,
          get() {
            return origOnerrorDescriptor.get.call(this);
          },
          set(cb) {
            const isMatched = this.getAttribute(source.name) === "matched";
            if (!isMatched) {
              origOnerrorDescriptor.set.call(this, cb);
              return true;
            }
            origOnerrorDescriptor.set.call(this, noopFunc);
            return true;
          }
        });
        const addEventListenerWrapper = function addEventListenerWrapper(target, thisArg, args) {
          if (!args[0] || !args[1] || !thisArg) {
            return Reflect.apply(target, thisArg, args);
          }
          const eventName = args[0];
          const isMatched = typeof thisArg.getAttribute === "function" && thisArg.getAttribute(source.name) === "matched" && eventName === "error";
          if (isMatched) {
            return Reflect.apply(target, thisArg, [eventName, noopFunc]);
          }
          return Reflect.apply(target, thisArg, args);
        };
        const addEventListenerHandler = {
          apply: addEventListenerWrapper
        };
        EventTarget.prototype.addEventListener = new Proxy(EventTarget.prototype.addEventListener, addEventListenerHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function safeGetDescriptor(obj, prop) {
        const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        if (descriptor && descriptor.configurable) {
          return descriptor;
        }
        return null;
      }
      function noopFunc() {}
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventElementSrcLoading.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventEvalIf(source, args) {
      function preventEvalIf(source, search) {
        const searchRegexp = toRegExp(search);
        const nativeEval = window.eval;
        window.eval = function (payload) {
          if (!searchRegexp.test(payload.toString())) {
            return nativeEval.call(window, payload);
          }
          hit(source);
          return undefined;
        }.bind(window);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventEvalIf.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventFab(source, args) {
      function preventFab(source) {
        hit(source);
        const Fab = function Fab() {};
        Fab.prototype.check = noopFunc;
        Fab.prototype.clearEvent = noopFunc;
        Fab.prototype.emitEvent = noopFunc;
        Fab.prototype.on = function (a, b) {
          if (!a) {
            b();
          }
          return this;
        };
        Fab.prototype.onDetected = noopThis;
        Fab.prototype.onNotDetected = function (a) {
          a();
          return this;
        };
        Fab.prototype.setOption = noopFunc;
        Fab.prototype.options = {
          set: noopFunc,
          get: noopFunc
        };
        const fab = new Fab();
        const getSetFab = {
          get() {
            return Fab;
          },
          set() {}
        };
        const getsetfab = {
          get() {
            return fab;
          },
          set() {}
        };
        if (Object.prototype.hasOwnProperty.call(window, "FuckAdBlock")) {
          window.FuckAdBlock = Fab;
        } else {
          Object.defineProperty(window, "FuckAdBlock", getSetFab);
        }
        if (Object.prototype.hasOwnProperty.call(window, "BlockAdBlock")) {
          window.BlockAdBlock = Fab;
        } else {
          Object.defineProperty(window, "BlockAdBlock", getSetFab);
        }
        if (Object.prototype.hasOwnProperty.call(window, "SniffAdBlock")) {
          window.SniffAdBlock = Fab;
        } else {
          Object.defineProperty(window, "SniffAdBlock", getSetFab);
        }
        if (Object.prototype.hasOwnProperty.call(window, "fuckAdBlock")) {
          window.fuckAdBlock = fab;
        } else {
          Object.defineProperty(window, "fuckAdBlock", getsetfab);
        }
        if (Object.prototype.hasOwnProperty.call(window, "blockAdBlock")) {
          window.blockAdBlock = fab;
        } else {
          Object.defineProperty(window, "blockAdBlock", getsetfab);
        }
        if (Object.prototype.hasOwnProperty.call(window, "sniffAdBlock")) {
          window.sniffAdBlock = fab;
        } else {
          Object.defineProperty(window, "sniffAdBlock", getsetfab);
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function noopFunc() {}
      function noopThis() {
        return this;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventFab.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventFetch(source, args) {
      function preventFetch(source, propsToMatch) {
        let responseBody = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "emptyObj";
        let responseType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "default";
        if (typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
          return;
        }
        let strResponseBody;
        if (responseBody === "" || responseBody === "emptyObj") {
          strResponseBody = "{}";
        } else if (responseBody === "emptyArr") {
          strResponseBody = "[]";
        } else {
          return;
        }
        if (!(responseType === "default" || responseType === "opaque")) {
          logMessage(source, "Invalid parameter: ".concat(responseType));
          return;
        }
        const handlerWrapper = function handlerWrapper(target, thisArg, args) {
          let shouldPrevent = false;
          const fetchData = getFetchData(args);
          if (typeof propsToMatch === "undefined") {
            logMessage(source, "fetch( ".concat(objectToString(fetchData), " )"), true);
            hit(source);
            return Reflect.apply(target, thisArg, args);
          }
          shouldPrevent = matchRequestProps(source, propsToMatch, fetchData);
          if (shouldPrevent) {
            hit(source);
            return noopPromiseResolve(strResponseBody, fetchData.url, responseType);
          }
          return Reflect.apply(target, thisArg, args);
        };
        const fetchHandler = {
          apply: handlerWrapper
        };
        fetch = new Proxy(fetch, fetchHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function getFetchData(args) {
        const fetchPropsObj = {};
        let fetchUrl;
        let fetchInit;
        if (args[0] instanceof Request) {
          const requestData = getRequestData(args[0]);
          fetchUrl = requestData.url;
          fetchInit = requestData;
        } else {
          fetchUrl = args[0];
          fetchInit = args[1];
        }
        fetchPropsObj.url = fetchUrl;
        if (fetchInit instanceof Object) {
          Object.keys(fetchInit).forEach(function (prop) {
            fetchPropsObj[prop] = fetchInit[prop];
          });
        }
        return fetchPropsObj;
      }
      function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
          return String(obj);
        }
        return isEmptyObject(obj) ? "{}" : getObjectEntries(obj).map(function (pair) {
          const key = pair[0];
          const value = pair[1];
          let recordValueStr = value;
          if (value instanceof Object) {
            recordValueStr = "{ ".concat(objectToString(value), " }");
          }
          return "".concat(key, ':"').concat(recordValueStr, '"');
        }).join(" ");
      }
      function noopPromiseResolve() {
        let responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "{}";
        let responseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        let responseType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "default";
        if (typeof Response === "undefined") {
          return;
        }
        const response = new Response(responseBody, {
          status: 200,
          statusText: "OK"
        });
        Object.defineProperties(response, {
          url: {
            value: responseUrl
          },
          type: {
            value: responseType
          }
        });
        return Promise.resolve(response);
      }
      function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
          return true;
        }
        let isMatched;
        const parsedData = parseMatchProps(propsToMatch);
        if (!validateParsedData(parsedData)) {
          logMessage(source, "Invalid parameter: ".concat(propsToMatch));
          isMatched = false;
        } else {
          const matchData = getMatchPropsData(parsedData);
          isMatched = Object.keys(matchData).every(function (matchKey) {
            const matchValue = matchData[matchKey];
            return Object.prototype.hasOwnProperty.call(requestData, matchKey) && matchValue.test(requestData[matchKey]);
          });
        }
        return isMatched;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getRequestData(request) {
        const requestInitOptions = getRequestProps();
        const entries = requestInitOptions.map(function (key) {
          const value = request[key];
          return [key, value];
        });
        return getObjectFromEntries(entries);
      }
      function getRequestProps() {
        return ["url", "method", "headers", "body", "mode", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal"];
      }
      function getObjectEntries(object) {
        const keys = Object.keys(object);
        const entries = [];
        keys.forEach(function (key) {
          return entries.push([key, object[key]]);
        });
        return entries;
      }
      function getObjectFromEntries(entries) {
        const output = entries.reduce(function (acc, el) {
          const key = el[0];
          const value = el[1];
          acc[key] = value;
          return acc;
        }, {});
        return output;
      }
      function parseMatchProps(propsToMatchStr) {
        const PROPS_DIVIDER = " ";
        const PAIRS_MARKER = ":";
        const LEGAL_MATCH_PROPS = getRequestProps();
        const propsObj = {};
        const props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach(function (prop) {
          const dividerInd = prop.indexOf(PAIRS_MARKER);
          const key = prop.slice(0, dividerInd);
          const hasLegalMatchProp = LEGAL_MATCH_PROPS.indexOf(key) !== -1;
          if (hasLegalMatchProp) {
            const value = prop.slice(dividerInd + 1);
            propsObj[key] = value;
          } else {
            propsObj.url = prop;
          }
        });
        return propsObj;
      }
      function validateParsedData(data) {
        return Object.values(data).every(function (value) {
          return isValidStrPattern(value);
        });
      }
      function getMatchPropsData(data) {
        const matchData = {};
        Object.keys(data).forEach(function (key) {
          matchData[key] = toRegExp(data[key]);
        });
        return matchData;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventFetch.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventPopadsNet(source, args) {
      function preventPopadsNet(source) {
        const rid = randomId();
        const throwError = function throwError() {
          throw new ReferenceError(rid);
        };
        delete window.PopAds;
        delete window.popns;
        Object.defineProperties(window, {
          PopAds: {
            set: throwError
          },
          popns: {
            set: throwError
          }
        });
        window.onerror = createOnErrorHandler(rid).bind();
        hit(source);
      }
      function createOnErrorHandler(rid) {
        const nativeOnError = window.onerror;
        return function onError(error) {
          if (typeof error === "string" && error.indexOf(rid) !== -1) {
            return true;
          }
          if (nativeOnError instanceof Function) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeOnError.apply(this, [error, ...args]);
          }
          return false;
        };
      }
      function randomId() {
        return Math.random().toString(36).slice(2, 9);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventPopadsNet.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventRefresh(source, args) {
      function preventRefresh(source, delaySec) {
        const getMetaElements = function getMetaElements() {
          let metaNodes = [];
          try {
            metaNodes = document.querySelectorAll('meta[http-equiv="refresh" i][content]');
          } catch (e) {
            try {
              metaNodes = document.querySelectorAll('meta[http-equiv="refresh"][content]');
            } catch (e) {
              logMessage(source, e);
            }
          }
          return Array.from(metaNodes);
        };
        const getMetaContentDelay = function getMetaContentDelay(metaElements) {
          const delays = metaElements.map(function (meta) {
            const contentString = meta.getAttribute("content");
            if (contentString.length === 0) {
              return null;
            }
            let contentDelay;
            const limiterIndex = contentString.indexOf(";");
            if (limiterIndex !== -1) {
              const delaySubstring = contentString.substring(0, limiterIndex);
              contentDelay = getNumberFromString(delaySubstring);
            } else {
              contentDelay = getNumberFromString(contentString);
            }
            return contentDelay;
          }).filter(function (delay) {
            return delay !== null;
          });
          if (!delays.length) {
            return null;
          }
          const minDelay = delays.reduce(function (a, b) {
            return Math.min(a, b);
          });
          return minDelay;
        };
        const stop = function stop() {
          const metaElements = getMetaElements();
          if (metaElements.length === 0) {
            return;
          }
          let secondsToRun = getNumberFromString(delaySec);
          if (secondsToRun === null) {
            secondsToRun = getMetaContentDelay(metaElements);
          }
          if (secondsToRun === null) {
            return;
          }
          const delayMs = secondsToRun * 1e3;
          setTimeout(function () {
            window.stop();
            hit(source);
          }, delayMs);
        };
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", stop, {
            once: true
          });
        } else {
          stop();
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function getNumberFromString(rawString) {
        const parsedDelay = parseInt(rawString, 10);
        const validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
        return validDelay;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventRefresh.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventRequestAnimationFrame(source, args) {
      function preventRequestAnimationFrame(source, match) {
        const nativeRequestAnimationFrame = window.requestAnimationFrame;
        const shouldLog = typeof match === "undefined";
        const _parseMatchArg = parseMatchArg(match),
          isInvertedMatch = _parseMatchArg.isInvertedMatch,
          matchRegexp = _parseMatchArg.matchRegexp;
        const rafWrapper = function rafWrapper(callback) {
          let shouldPrevent = false;
          if (shouldLog) {
            hit(source);
            logMessage(source, "requestAnimationFrame(".concat(String(callback), ")"), true);
          } else if (isValidCallback(callback) && isValidStrPattern(match)) {
            shouldPrevent = matchRegexp.test(callback.toString()) !== isInvertedMatch;
          }
          if (shouldPrevent) {
            hit(source);
            return nativeRequestAnimationFrame(noopFunc);
          }
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          return nativeRequestAnimationFrame.apply(window, [callback, ...args]);
        };
        window.requestAnimationFrame = rafWrapper;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function noopFunc() {}
      function parseMatchArg(match) {
        const INVERT_MARKER = "!";
        const isInvertedMatch = match ? match.startsWith(INVERT_MARKER) : false;
        const matchValue = isInvertedMatch ? match.slice(1) : match;
        const matchRegexp = toRegExp(matchValue);
        return {
          isInvertedMatch: isInvertedMatch,
          matchRegexp: matchRegexp,
          matchValue: matchValue
        };
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function isValidCallback(callback) {
        return callback instanceof Function || typeof callback === "string";
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventRequestAnimationFrame.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventSetInterval(source, args) {
      function preventSetInterval(source, matchCallback, matchDelay) {
        const shouldLog = typeof matchCallback === "undefined" && typeof matchDelay === "undefined";
        const handlerWrapper = function handlerWrapper(target, thisArg, args) {
          const callback = args[0];
          const delay = args[1];
          let shouldPrevent = false;
          if (shouldLog) {
            hit(source);
            logMessage(source, "setInterval(".concat(String(callback), ", ").concat(delay, ")"), true);
          } else {
            shouldPrevent = isPreventionNeeded({
              callback: callback,
              delay: delay,
              matchCallback: matchCallback,
              matchDelay: matchDelay
            });
          }
          if (shouldPrevent) {
            hit(source);
            args[0] = noopFunc;
          }
          return target.apply(thisArg, args);
        };
        const setIntervalHandler = {
          apply: handlerWrapper
        };
        window.setInterval = new Proxy(window.setInterval, setIntervalHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function noopFunc() {}
      function isPreventionNeeded(_ref) {
        let callback = _ref.callback,
          delay = _ref.delay,
          matchCallback = _ref.matchCallback,
          matchDelay = _ref.matchDelay;
        if (!isValidCallback(callback)) {
          return false;
        }
        if (!isValidMatchStr(matchCallback) || matchDelay && !isValidMatchNumber(matchDelay)) {
          return false;
        }
        const _parseMatchArg = parseMatchArg(matchCallback),
          isInvertedMatch = _parseMatchArg.isInvertedMatch,
          matchRegexp = _parseMatchArg.matchRegexp;
        const _parseDelayArg = parseDelayArg(matchDelay),
          isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,
          delayMatch = _parseDelayArg.delayMatch;
        const parsedDelay = parseRawDelay(delay);
        let shouldPrevent = false;
        const callbackStr = String(callback);
        if (delayMatch === null) {
          shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch;
        } else if (!matchCallback) {
          shouldPrevent = parsedDelay === delayMatch !== isInvertedDelayMatch;
        } else {
          shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch && parsedDelay === delayMatch !== isInvertedDelayMatch;
        }
        return shouldPrevent;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function startsWith(str, prefix) {
        return !!str && str.indexOf(prefix) === 0;
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function parseMatchArg(match) {
        const INVERT_MARKER = "!";
        const isInvertedMatch = match ? match.startsWith(INVERT_MARKER) : false;
        const matchValue = isInvertedMatch ? match.slice(1) : match;
        const matchRegexp = toRegExp(matchValue);
        return {
          isInvertedMatch: isInvertedMatch,
          matchRegexp: matchRegexp,
          matchValue: matchValue
        };
      }
      function parseDelayArg(delay) {
        const INVERT_MARKER = "!";
        const isInvertedDelayMatch = startsWith(delay, INVERT_MARKER);
        let delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;
        delayValue = parseInt(delayValue, 10);
        const delayMatch = nativeIsNaN(delayValue) ? null : delayValue;
        return {
          isInvertedDelayMatch: isInvertedDelayMatch,
          delayMatch: delayMatch
        };
      }
      function isValidCallback(callback) {
        return callback instanceof Function || typeof callback === "string";
      }
      function isValidMatchStr(match) {
        const INVERT_MARKER = "!";
        let str = match;
        if (startsWith(match, INVERT_MARKER)) {
          str = match.slice(1);
        }
        return isValidStrPattern(str);
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function nativeIsFinite(num) {
        const native = Number.isFinite || window.isFinite;
        return native(num);
      }
      function isValidMatchNumber(match) {
        const INVERT_MARKER = "!";
        let str = match;
        if (startsWith(match, INVERT_MARKER)) {
          str = match.slice(1);
        }
        const num = parseFloat(str);
        return !nativeIsNaN(num) && nativeIsFinite(num);
      }
      function parseRawDelay(delay) {
        const parsedDelay = Math.floor(parseInt(delay, 10));
        return typeof parsedDelay === "number" && !nativeIsNaN(parsedDelay) ? parsedDelay : delay;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventSetInterval.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventSetTimeout(source, args) {
      function preventSetTimeout(source, matchCallback, matchDelay) {
        const shouldLog = typeof matchCallback === "undefined" && typeof matchDelay === "undefined";
        const handlerWrapper = function handlerWrapper(target, thisArg, args) {
          const callback = args[0];
          const delay = args[1];
          let shouldPrevent = false;
          if (shouldLog) {
            hit(source);
            logMessage(source, "setTimeout(".concat(String(callback), ", ").concat(delay, ")"), true);
          } else {
            shouldPrevent = isPreventionNeeded({
              callback: callback,
              delay: delay,
              matchCallback: matchCallback,
              matchDelay: matchDelay
            });
          }
          if (shouldPrevent) {
            hit(source);
            args[0] = noopFunc;
          }
          return target.apply(thisArg, args);
        };
        const setTimeoutHandler = {
          apply: handlerWrapper
        };
        window.setTimeout = new Proxy(window.setTimeout, setTimeoutHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function noopFunc() {}
      function isPreventionNeeded(_ref) {
        let callback = _ref.callback,
          delay = _ref.delay,
          matchCallback = _ref.matchCallback,
          matchDelay = _ref.matchDelay;
        if (!isValidCallback(callback)) {
          return false;
        }
        if (!isValidMatchStr(matchCallback) || matchDelay && !isValidMatchNumber(matchDelay)) {
          return false;
        }
        const _parseMatchArg = parseMatchArg(matchCallback),
          isInvertedMatch = _parseMatchArg.isInvertedMatch,
          matchRegexp = _parseMatchArg.matchRegexp;
        const _parseDelayArg = parseDelayArg(matchDelay),
          isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,
          delayMatch = _parseDelayArg.delayMatch;
        const parsedDelay = parseRawDelay(delay);
        let shouldPrevent = false;
        const callbackStr = String(callback);
        if (delayMatch === null) {
          shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch;
        } else if (!matchCallback) {
          shouldPrevent = parsedDelay === delayMatch !== isInvertedDelayMatch;
        } else {
          shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch && parsedDelay === delayMatch !== isInvertedDelayMatch;
        }
        return shouldPrevent;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function parseMatchArg(match) {
        const INVERT_MARKER = "!";
        const isInvertedMatch = match ? match.startsWith(INVERT_MARKER) : false;
        const matchValue = isInvertedMatch ? match.slice(1) : match;
        const matchRegexp = toRegExp(matchValue);
        return {
          isInvertedMatch: isInvertedMatch,
          matchRegexp: matchRegexp,
          matchValue: matchValue
        };
      }
      function parseDelayArg(delay) {
        const INVERT_MARKER = "!";
        const isInvertedDelayMatch = startsWith(delay, INVERT_MARKER);
        let delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;
        delayValue = parseInt(delayValue, 10);
        const delayMatch = nativeIsNaN(delayValue) ? null : delayValue;
        return {
          isInvertedDelayMatch: isInvertedDelayMatch,
          delayMatch: delayMatch
        };
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function startsWith(str, prefix) {
        return !!str && str.indexOf(prefix) === 0;
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function isValidCallback(callback) {
        return callback instanceof Function || typeof callback === "string";
      }
      function isValidMatchStr(match) {
        const INVERT_MARKER = "!";
        let str = match;
        if (startsWith(match, INVERT_MARKER)) {
          str = match.slice(1);
        }
        return isValidStrPattern(str);
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function nativeIsFinite(num) {
        const native = Number.isFinite || window.isFinite;
        return native(num);
      }
      function isValidMatchNumber(match) {
        const INVERT_MARKER = "!";
        let str = match;
        if (startsWith(match, INVERT_MARKER)) {
          str = match.slice(1);
        }
        const num = parseFloat(str);
        return !nativeIsNaN(num) && nativeIsFinite(num);
      }
      function parseRawDelay(delay) {
        const parsedDelay = Math.floor(parseInt(delay, 10));
        return typeof parsedDelay === "number" && !nativeIsNaN(parsedDelay) ? parsedDelay : delay;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventSetTimeout.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventWindowOpen(source, args) {
      function preventWindowOpen(source) {
        let match = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "*";
        let delay = arguments.length > 2 ? arguments[2] : undefined;
        let replacement = arguments.length > 3 ? arguments[3] : undefined;
        const nativeOpen = window.open;
        const isNewSyntax = match !== "0" && match !== "1";
        const oldOpenWrapper = function oldOpenWrapper(str) {
          match = Number(match) > 0;
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          if (!isValidStrPattern(delay)) {
            logMessage(source, "Invalid parameter: ".concat(delay));
            return nativeOpen.apply(window, [str, ...args]);
          }
          const searchRegexp = toRegExp(delay);
          if (match !== searchRegexp.test(str)) {
            return nativeOpen.apply(window, [str, ...args]);
          }
          hit(source);
          return handleOldReplacement(replacement);
        };
        const newOpenWrapper = function newOpenWrapper(url) {
          const shouldLog = replacement && replacement.indexOf("log") > -1;
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          if (shouldLog) {
            const argsStr = args && args.length > 0 ? ", ".concat(args.join(", ")) : "";
            const message = "".concat(url).concat(argsStr);
            logMessage(source, message, true);
            hit(source);
          }
          let shouldPrevent = false;
          if (match === "*") {
            shouldPrevent = true;
          } else if (isValidMatchStr(match)) {
            const _parseMatchArg = parseMatchArg(match),
              isInvertedMatch = _parseMatchArg.isInvertedMatch,
              matchRegexp = _parseMatchArg.matchRegexp;
            shouldPrevent = matchRegexp.test(url) !== isInvertedMatch;
          } else {
            logMessage(source, "Invalid parameter: ".concat(match));
            shouldPrevent = false;
          }
          if (shouldPrevent) {
            const parsedDelay = parseInt(delay, 10);
            let result;
            if (nativeIsNaN(parsedDelay)) {
              result = noopNull();
            } else {
              const decoyArgs = {
                replacement: replacement,
                url: url,
                delay: parsedDelay
              };
              const decoy = createDecoy(decoyArgs);
              let popup = decoy.contentWindow;
              if (typeof popup === "object" && popup !== null) {
                Object.defineProperty(popup, "closed", {
                  value: false
                });
                Object.defineProperty(popup, "opener", {
                  value: window
                });
                Object.defineProperty(popup, "frameElement", {
                  value: null
                });
              } else {
                const nativeGetter = decoy.contentWindow && decoy.contentWindow.get;
                Object.defineProperty(decoy, "contentWindow", {
                  get: getPreventGetter(nativeGetter)
                });
                popup = decoy.contentWindow;
              }
              result = popup;
            }
            hit(source);
            return result;
          }
          return nativeOpen.apply(window, [url, ...args]);
        };
        window.open = isNewSyntax ? newOpenWrapper : oldOpenWrapper;
        window.open.toString = nativeOpen.toString.bind(nativeOpen);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function isValidMatchStr(match) {
        const INVERT_MARKER = "!";
        let str = match;
        if (startsWith(match, INVERT_MARKER)) {
          str = match.slice(1);
        }
        return isValidStrPattern(str);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function parseMatchArg(match) {
        const INVERT_MARKER = "!";
        const isInvertedMatch = match ? match.startsWith(INVERT_MARKER) : false;
        const matchValue = isInvertedMatch ? match.slice(1) : match;
        const matchRegexp = toRegExp(matchValue);
        return {
          isInvertedMatch: isInvertedMatch,
          matchRegexp: matchRegexp,
          matchValue: matchValue
        };
      }
      function handleOldReplacement(replacement) {
        let result;
        if (!replacement) {
          result = noopFunc;
        } else if (replacement === "trueFunc") {
          result = trueFunc;
        } else if (replacement.indexOf("=") > -1) {
          const isProp = startsWith(replacement, "{") && endsWith(replacement, "}");
          if (isProp) {
            const propertyPart = replacement.slice(1, -1);
            const propertyName = substringBefore(propertyPart, "=");
            const propertyValue = substringAfter(propertyPart, "=");
            if (propertyValue === "noopFunc") {
              result = {};
              result[propertyName] = noopFunc;
            }
          }
        }
        return result;
      }
      function createDecoy(args) {
        const OBJECT_TAG_NAME = "object";
        const OBJECT_URL_PROP_NAME = "data";
        const IFRAME_TAG_NAME = "iframe";
        const IFRAME_URL_PROP_NAME = "src";
        const replacement = args.replacement,
          url = args.url,
          delay = args.delay;
        let tag;
        let urlProp;
        if (replacement === "obj") {
          tag = OBJECT_TAG_NAME;
          urlProp = OBJECT_URL_PROP_NAME;
        } else {
          tag = IFRAME_TAG_NAME;
          urlProp = IFRAME_URL_PROP_NAME;
        }
        const decoy = document.createElement(tag);
        decoy[urlProp] = url;
        decoy.style.setProperty("height", "1px", "important");
        decoy.style.setProperty("position", "fixed", "important");
        decoy.style.setProperty("top", "-1px", "important");
        decoy.style.setProperty("width", "1px", "important");
        document.body.appendChild(decoy);
        setTimeout(function () {
          return decoy.remove();
        }, delay * 1e3);
        return decoy;
      }
      function getPreventGetter(nativeGetter) {
        const preventGetter = function preventGetter(target, prop) {
          if (prop && prop === "closed") {
            return false;
          }
          if (typeof nativeGetter === "function") {
            return noopFunc;
          }
          return prop && target[prop];
        };
        return preventGetter;
      }
      function noopNull() {
        return null;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function noopFunc() {}
      function trueFunc() {
        return true;
      }
      function startsWith(str, prefix) {
        return !!str && str.indexOf(prefix) === 0;
      }
      function endsWith(str, ending) {
        return !!str && str.lastIndexOf(ending) === str.length - ending.length;
      }
      function substringBefore(str, separator) {
        if (!str || !separator) {
          return str;
        }
        const index = str.indexOf(separator);
        return index < 0 ? str : str.substring(0, index);
      }
      function substringAfter(str, separator) {
        if (!str) {
          return str;
        }
        const index = str.indexOf(separator);
        return index < 0 ? "" : str.substring(index + separator.length);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventWindowOpen.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function preventXHR(source, args) {
      function preventXHR(source, propsToMatch, customResponseText) {
        if (typeof Proxy === "undefined") {
          return;
        }
        let response = "";
        let responseText = "";
        let responseUrl;
        const openWrapper = function openWrapper(target, thisArg, args) {
          const xhrData = {
            method: args[0],
            url: args[1]
          };
          responseUrl = xhrData.url;
          if (typeof propsToMatch === "undefined") {
            logMessage(source, "xhr( ".concat(objectToString(xhrData), " )"), true);
            hit(source);
          } else if (matchRequestProps(source, propsToMatch, xhrData)) {
            thisArg.shouldBePrevented = true;
          }
          return Reflect.apply(target, thisArg, args);
        };
        const sendWrapper = function sendWrapper(target, thisArg, args) {
          if (!thisArg.shouldBePrevented) {
            return Reflect.apply(target, thisArg, args);
          }
          if (thisArg.responseType === "blob") {
            response = new Blob();
          }
          if (thisArg.responseType === "arraybuffer") {
            response = new ArrayBuffer();
          }
          if (customResponseText) {
            const randomText = generateRandomResponse(customResponseText);
            if (randomText) {
              responseText = randomText;
            } else {
              logMessage(source, "Invalid range: ".concat(customResponseText));
            }
          }
          Object.defineProperties(thisArg, {
            readyState: {
              value: 4,
              writable: false
            },
            response: {
              value: response,
              writable: false
            },
            responseText: {
              value: responseText,
              writable: false
            },
            responseURL: {
              value: responseUrl,
              writable: false
            },
            responseXML: {
              value: "",
              writable: false
            },
            status: {
              value: 200,
              writable: false
            },
            statusText: {
              value: "OK",
              writable: false
            }
          });
          setTimeout(function () {
            const stateEvent = new Event("readystatechange");
            thisArg.dispatchEvent(stateEvent);
            const loadEvent = new Event("load");
            thisArg.dispatchEvent(loadEvent);
            const loadEndEvent = new Event("loadend");
            thisArg.dispatchEvent(loadEndEvent);
          }, 1);
          hit(source);
          return undefined;
        };
        const openHandler = {
          apply: openWrapper
        };
        const sendHandler = {
          apply: sendWrapper
        };
        XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
        XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
          return String(obj);
        }
        return isEmptyObject(obj) ? "{}" : getObjectEntries(obj).map(function (pair) {
          const key = pair[0];
          const value = pair[1];
          let recordValueStr = value;
          if (value instanceof Object) {
            recordValueStr = "{ ".concat(objectToString(value), " }");
          }
          return "".concat(key, ':"').concat(recordValueStr, '"');
        }).join(" ");
      }
      function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
          return true;
        }
        let isMatched;
        const parsedData = parseMatchProps(propsToMatch);
        if (!validateParsedData(parsedData)) {
          logMessage(source, "Invalid parameter: ".concat(propsToMatch));
          isMatched = false;
        } else {
          const matchData = getMatchPropsData(parsedData);
          isMatched = Object.keys(matchData).every(function (matchKey) {
            const matchValue = matchData[matchKey];
            return Object.prototype.hasOwnProperty.call(requestData, matchKey) && matchValue.test(requestData[matchKey]);
          });
        }
        return isMatched;
      }
      function generateRandomResponse(customResponseText) {
        let customResponse = customResponseText;
        if (customResponse === "true") {
          customResponse = Math.random().toString(36).slice(-10);
          return customResponse;
        }
        customResponse = customResponse.replace("length:", "");
        const rangeRegex = /^\d+-\d+$/;
        if (!rangeRegex.test(customResponse)) {
          return null;
        }
        let rangeMin = getNumberFromString(customResponse.split("-")[0]);
        let rangeMax = getNumberFromString(customResponse.split("-")[1]);
        if (!nativeIsFinite(rangeMin) || !nativeIsFinite(rangeMax)) {
          return null;
        }
        if (rangeMin > rangeMax) {
          const temp = rangeMin;
          rangeMin = rangeMax;
          rangeMax = temp;
        }
        const LENGTH_RANGE_LIMIT = 500 * 1e3;
        if (rangeMax > LENGTH_RANGE_LIMIT) {
          return null;
        }
        const length = getRandomIntInclusive(rangeMin, rangeMax);
        customResponse = getRandomStrByLength(length);
        return customResponse;
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getObjectEntries(object) {
        const keys = Object.keys(object);
        const entries = [];
        keys.forEach(function (key) {
          return entries.push([key, object[key]]);
        });
        return entries;
      }
      function getNumberFromString(rawString) {
        const parsedDelay = parseInt(rawString, 10);
        const validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
        return validDelay;
      }
      function nativeIsFinite(num) {
        const native = Number.isFinite || window.isFinite;
        return native(num);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function parseMatchProps(propsToMatchStr) {
        const PROPS_DIVIDER = " ";
        const PAIRS_MARKER = ":";
        const LEGAL_MATCH_PROPS = getRequestProps();
        const propsObj = {};
        const props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach(function (prop) {
          const dividerInd = prop.indexOf(PAIRS_MARKER);
          const key = prop.slice(0, dividerInd);
          const hasLegalMatchProp = LEGAL_MATCH_PROPS.indexOf(key) !== -1;
          if (hasLegalMatchProp) {
            const value = prop.slice(dividerInd + 1);
            propsObj[key] = value;
          } else {
            propsObj.url = prop;
          }
        });
        return propsObj;
      }
      function validateParsedData(data) {
        return Object.values(data).every(function (value) {
          return isValidStrPattern(value);
        });
      }
      function getMatchPropsData(data) {
        const matchData = {};
        Object.keys(data).forEach(function (key) {
          matchData[key] = toRegExp(data[key]);
        });
        return matchData;
      }
      function getRequestProps() {
        return ["url", "method", "headers", "body", "mode", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal"];
      }
      function getRandomIntInclusive(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1) + min);
      }
      function getRandomStrByLength(length) {
        let result = "";
        const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+=~";
        const charactersLength = characters.length;
        for (let i = 0; i < length; i += 1) {
          result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return result;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        preventXHR.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function removeAttr(source, args) {
      function removeAttr(source, attrs, selector) {
        let applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "asap stay";
        if (!attrs) {
          return;
        }
        attrs = attrs.split(/\s*\|\s*/);
        if (!selector) {
          selector = "[".concat(attrs.join("],["), "]");
        }
        const rmattr = function rmattr() {
          let nodes = [];
          try {
            nodes = [].slice.call(document.querySelectorAll(selector));
          } catch (e) {
            logMessage(source, "Invalid selector arg: '".concat(selector, "'"));
          }
          let removed = false;
          nodes.forEach(function (node) {
            attrs.forEach(function (attr) {
              node.removeAttribute(attr);
              removed = true;
            });
          });
          if (removed) {
            hit(source);
          }
        };
        const flags = parseFlags(applying);
        const run = function run() {
          rmattr();
          if (!flags.hasFlag(flags.STAY)) {
            return;
          }
          observeDOMChanges(rmattr, true);
        };
        if (flags.hasFlag(flags.ASAP)) {
          if (document.readyState === "loading") {
            window.addEventListener("DOMContentLoaded", rmattr, {
              once: true
            });
          } else {
            rmattr();
          }
        }
        if (document.readyState !== "complete" && flags.hasFlag(flags.COMPLETE)) {
          window.addEventListener("load", run, {
            once: true
          });
        } else if (flags.hasFlag(flags.STAY)) {
          if (!applying.indexOf(" ") !== -1) {
            rmattr();
          }
          observeDOMChanges(rmattr, true);
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function observeDOMChanges(callback) {
        let observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        const THROTTLE_DELAY_MS = 20;
        const observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        const connect = function connect() {
          if (attrsToObserve.length > 0) {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs,
              attributeFilter: attrsToObserve
            });
          } else {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs
            });
          }
        };
        const disconnect = function disconnect() {
          observer.disconnect();
        };
        function callbackWrapper() {
          disconnect();
          callback();
          connect();
        }
        connect();
      }
      function parseFlags(flags) {
        const FLAGS_DIVIDER = " ";
        const ASAP_FLAG = "asap";
        const COMPLETE_FLAG = "complete";
        const STAY_FLAG = "stay";
        const VALID_FLAGS = [STAY_FLAG, ASAP_FLAG, COMPLETE_FLAG];
        const passedFlags = flags.trim().split(FLAGS_DIVIDER).filter(function (f) {
          return VALID_FLAGS.indexOf(f) !== -1;
        });
        return {
          ASAP: ASAP_FLAG,
          COMPLETE: COMPLETE_FLAG,
          STAY: STAY_FLAG,
          hasFlag(flag) {
            return passedFlags.indexOf(flag) !== -1;
          }
        };
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function throttle(cb, delay) {
        let wait = false;
        let savedArgs;
        const wrapper = function wrapper() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (wait) {
            savedArgs = args;
            return;
          }
          cb(...args);
          wait = true;
          setTimeout(function () {
            wait = false;
            if (savedArgs) {
              wrapper(...savedArgs);
              savedArgs = null;
            }
          }, delay);
        };
        return wrapper;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        removeAttr.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function removeClass(source, args) {
      function removeClass(source, classNames, selector) {
        let applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "asap stay";
        if (!classNames) {
          return;
        }
        classNames = classNames.split(/\s*\|\s*/);
        let selectors = [];
        if (!selector) {
          selectors = classNames.map(function (className) {
            return ".".concat(className);
          });
        }
        const removeClassHandler = function removeClassHandler() {
          const nodes = new Set();
          if (selector) {
            let foundNodes = [];
            try {
              foundNodes = [].slice.call(document.querySelectorAll(selector));
            } catch (e) {
              logMessage(source, "Invalid selector arg: '".concat(selector, "'"));
            }
            foundNodes.forEach(function (n) {
              return nodes.add(n);
            });
          } else if (selectors.length > 0) {
            selectors.forEach(function (s) {
              const elements = document.querySelectorAll(s);
              for (let i = 0; i < elements.length; i += 1) {
                const element = elements[i];
                nodes.add(element);
              }
            });
          }
          let removed = false;
          nodes.forEach(function (node) {
            classNames.forEach(function (className) {
              if (node.classList.contains(className)) {
                node.classList.remove(className);
                removed = true;
              }
            });
          });
          if (removed) {
            hit(source);
          }
        };
        const CLASS_ATTR_NAME = ["class"];
        const flags = parseFlags(applying);
        const run = function run() {
          removeClassHandler();
          if (!flags.hasFlag(flags.STAY)) {
            return;
          }
          observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
        };
        if (flags.hasFlag(flags.ASAP)) {
          if (document.readyState === "loading") {
            window.addEventListener("DOMContentLoaded", removeClassHandler, {
              once: true
            });
          } else {
            removeClassHandler();
          }
        }
        if (document.readyState !== "complete" && flags.hasFlag(flags.COMPLETE)) {
          window.addEventListener("load", run, {
            once: true
          });
        } else if (flags.hasFlag(flags.STAY)) {
          if (!applying.indexOf(" ") !== -1) {
            removeClassHandler();
          }
          observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function observeDOMChanges(callback) {
        let observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        const THROTTLE_DELAY_MS = 20;
        const observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        const connect = function connect() {
          if (attrsToObserve.length > 0) {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs,
              attributeFilter: attrsToObserve
            });
          } else {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs
            });
          }
        };
        const disconnect = function disconnect() {
          observer.disconnect();
        };
        function callbackWrapper() {
          disconnect();
          callback();
          connect();
        }
        connect();
      }
      function parseFlags(flags) {
        const FLAGS_DIVIDER = " ";
        const ASAP_FLAG = "asap";
        const COMPLETE_FLAG = "complete";
        const STAY_FLAG = "stay";
        const VALID_FLAGS = [STAY_FLAG, ASAP_FLAG, COMPLETE_FLAG];
        const passedFlags = flags.trim().split(FLAGS_DIVIDER).filter(function (f) {
          return VALID_FLAGS.indexOf(f) !== -1;
        });
        return {
          ASAP: ASAP_FLAG,
          COMPLETE: COMPLETE_FLAG,
          STAY: STAY_FLAG,
          hasFlag(flag) {
            return passedFlags.indexOf(flag) !== -1;
          }
        };
      }
      function throttle(cb, delay) {
        let wait = false;
        let savedArgs;
        const wrapper = function wrapper() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (wait) {
            savedArgs = args;
            return;
          }
          cb(...args);
          wait = true;
          setTimeout(function () {
            wait = false;
            if (savedArgs) {
              wrapper(...savedArgs);
              savedArgs = null;
            }
          }, delay);
        };
        return wrapper;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        removeClass.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function removeCookie(source, args) {
      function removeCookie(source, match) {
        const matchRegexp = toRegExp(match);
        const removeCookieFromHost = function removeCookieFromHost(cookieName, hostName) {
          const cookieSpec = "".concat(cookieName, "=");
          const domain1 = "; domain=".concat(hostName);
          const domain2 = "; domain=.".concat(hostName);
          const path = "; path=/";
          const expiration = "; expires=Thu, 01 Jan 1970 00:00:00 GMT";
          document.cookie = cookieSpec + expiration;
          document.cookie = cookieSpec + domain1 + expiration;
          document.cookie = cookieSpec + domain2 + expiration;
          document.cookie = cookieSpec + path + expiration;
          document.cookie = cookieSpec + domain1 + path + expiration;
          document.cookie = cookieSpec + domain2 + path + expiration;
          hit(source);
        };
        const rmCookie = function rmCookie() {
          document.cookie.split(";").forEach(function (cookieStr) {
            const pos = cookieStr.indexOf("=");
            if (pos === -1) {
              return;
            }
            const cookieName = cookieStr.slice(0, pos).trim();
            if (!matchRegexp.test(cookieName)) {
              return;
            }
            const hostParts = document.location.hostname.split(".");
            for (let i = 0; i <= hostParts.length - 1; i += 1) {
              const hostName = hostParts.slice(i).join(".");
              if (hostName) {
                removeCookieFromHost(cookieName, hostName);
              }
            }
          });
        };
        rmCookie();
        window.addEventListener("beforeunload", rmCookie);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        removeCookie.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function removeInShadowDom(source, args) {
      function removeInShadowDom(source, selector, baseSelector) {
        if (!Element.prototype.attachShadow) {
          return;
        }
        const removeElement = function removeElement(targetElement) {
          targetElement.remove();
        };
        const removeHandler = function removeHandler() {
          let hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
          while (hostElements.length !== 0) {
            let isRemoved = false;
            const _pierceShadowDom = pierceShadowDom(selector, hostElements),
              targets = _pierceShadowDom.targets,
              innerHosts = _pierceShadowDom.innerHosts;
            targets.forEach(function (targetEl) {
              removeElement(targetEl);
              isRemoved = true;
            });
            if (isRemoved) {
              hit(source);
            }
            hostElements = innerHosts;
          }
        };
        removeHandler();
        observeDOMChanges(removeHandler, true);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function observeDOMChanges(callback) {
        let observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        const THROTTLE_DELAY_MS = 20;
        const observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        const connect = function connect() {
          if (attrsToObserve.length > 0) {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs,
              attributeFilter: attrsToObserve
            });
          } else {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs
            });
          }
        };
        const disconnect = function disconnect() {
          observer.disconnect();
        };
        function callbackWrapper() {
          disconnect();
          callback();
          connect();
        }
        connect();
      }
      function findHostElements(rootElement) {
        const hosts = [];
        const domElems = rootElement.querySelectorAll("*");
        domElems.forEach(function (el) {
          if (el.shadowRoot) {
            hosts.push(el);
          }
        });
        return hosts;
      }
      function pierceShadowDom(selector, hostElements) {
        let targets = [];
        const innerHostsAcc = [];
        hostElements.forEach(function (host) {
          const simpleElems = host.querySelectorAll(selector);
          targets = targets.concat([].slice.call(simpleElems));
          const shadowRootElem = host.shadowRoot;
          const shadowChildren = shadowRootElem.querySelectorAll(selector);
          targets = targets.concat([].slice.call(shadowChildren));
          innerHostsAcc.push(findHostElements(shadowRootElem));
        });
        const innerHosts = flatten(innerHostsAcc);
        return {
          targets: targets,
          innerHosts: innerHosts
        };
      }
      function flatten(input) {
        const stack = [];
        input.forEach(function (el) {
          return stack.push(el);
        });
        const res = [];
        while (stack.length) {
          const next = stack.pop();
          if (Array.isArray(next)) {
            next.forEach(function (el) {
              return stack.push(el);
            });
          } else {
            res.push(next);
          }
        }
        return res.reverse();
      }
      function throttle(cb, delay) {
        let wait = false;
        let savedArgs;
        const wrapper = function wrapper() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (wait) {
            savedArgs = args;
            return;
          }
          cb(...args);
          wait = true;
          setTimeout(function () {
            wait = false;
            if (savedArgs) {
              wrapper(...savedArgs);
              savedArgs = null;
            }
          }, delay);
        };
        return wrapper;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        removeInShadowDom.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function setAttr(source, args) {
      function setAttr(source, selector, attr) {
        let value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        if (!selector || !attr) {
          return;
        }
        const allowedValues = ["true", "false"];
        if (value.length !== 0 && (nativeIsNaN(parseInt(value, 10)) || parseInt(value, 10) < 0 || parseInt(value, 10) > 32767) && !allowedValues.includes(value.toLowerCase())) {
          return;
        }
        const setAttr = function setAttr() {
          const nodes = [].slice.call(document.querySelectorAll(selector));
          let set = false;
          nodes.forEach(function (node) {
            node.setAttribute(attr, value);
            set = true;
          });
          if (set) {
            hit(source);
          }
        };
        setAttr();
        observeDOMChanges(setAttr, true);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function observeDOMChanges(callback) {
        let observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        const THROTTLE_DELAY_MS = 20;
        const observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        const connect = function connect() {
          if (attrsToObserve.length > 0) {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs,
              attributeFilter: attrsToObserve
            });
          } else {
            observer.observe(document.documentElement, {
              childList: true,
              subtree: true,
              attributes: observeAttrs
            });
          }
        };
        const disconnect = function disconnect() {
          observer.disconnect();
        };
        function callbackWrapper() {
          disconnect();
          callback();
          connect();
        }
        connect();
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function throttle(cb, delay) {
        let wait = false;
        let savedArgs;
        const wrapper = function wrapper() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (wait) {
            savedArgs = args;
            return;
          }
          cb(...args);
          wait = true;
          setTimeout(function () {
            wait = false;
            if (savedArgs) {
              wrapper(...savedArgs);
              savedArgs = null;
            }
          }, delay);
        };
        return wrapper;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        setAttr.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function setConstant(source, args) {
      function setConstant(source, property, value, stack) {
        if (!property || !matchStackTrace(stack, new Error().stack)) {
          return;
        }
        const emptyArr = noopArray();
        const emptyObj = noopObject();
        let constantValue;
        if (value === "undefined") {
          constantValue = undefined;
        } else if (value === "false") {
          constantValue = false;
        } else if (value === "true") {
          constantValue = true;
        } else if (value === "null") {
          constantValue = null;
        } else if (value === "emptyArr") {
          constantValue = emptyArr;
        } else if (value === "emptyObj") {
          constantValue = emptyObj;
        } else if (value === "noopFunc") {
          constantValue = noopFunc;
        } else if (value === "noopCallbackFunc") {
          constantValue = noopCallbackFunc;
        } else if (value === "trueFunc") {
          constantValue = trueFunc;
        } else if (value === "falseFunc") {
          constantValue = falseFunc;
        } else if (value === "throwFunc") {
          constantValue = throwFunc;
        } else if (value === "noopPromiseResolve") {
          constantValue = noopPromiseResolve;
        } else if (value === "noopPromiseReject") {
          constantValue = noopPromiseReject;
        } else if (/^\d+$/.test(value)) {
          constantValue = parseFloat(value);
          if (nativeIsNaN(constantValue)) {
            return;
          }
          if (Math.abs(constantValue) > 32767) {
            return;
          }
        } else if (value === "-1") {
          constantValue = -1;
        } else if (value === "") {
          constantValue = "";
        } else if (value === "yes") {
          constantValue = "yes";
        } else if (value === "no") {
          constantValue = "no";
        } else {
          return;
        }
        let canceled = false;
        const mustCancel = function mustCancel(value) {
          if (canceled) {
            return canceled;
          }
          canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue && value !== null;
          return canceled;
        };
        const trapProp = function trapProp(base, prop, configurable, handler) {
          if (!handler.init(base[prop])) {
            return false;
          }
          const origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
          let prevSetter;
          if (origDescriptor instanceof Object) {
            if (!origDescriptor.configurable) {
              const message = "Property '".concat(prop, "' is not configurable");
              logMessage(source, message);
              return false;
            }
            base[prop] = constantValue;
            if (origDescriptor.set instanceof Function) {
              prevSetter = origDescriptor.set;
            }
          }
          Object.defineProperty(base, prop, {
            configurable: configurable,
            get() {
              return handler.get();
            },
            set(a) {
              if (prevSetter !== undefined) {
                prevSetter(a);
              }
              handler.set(a);
            }
          });
          return true;
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          const base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          const inChainPropHandler = {
            factValue: undefined,
            init(a) {
              this.factValue = a;
              return true;
            },
            get() {
              return this.factValue;
            },
            set(a) {
              if (this.factValue === a) {
                return;
              }
              this.factValue = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            }
          };
          const endPropHandler = {
            init(a) {
              if (mustCancel(a)) {
                return false;
              }
              return true;
            },
            get() {
              return constantValue;
            },
            set(a) {
              if (!mustCancel(a)) {
                return;
              }
              constantValue = a;
            }
          };
          if (!chain) {
            const isTrapped = trapProp(base, prop, false, endPropHandler);
            if (isTrapped) {
              hit(source);
            }
            return;
          }
          if (base !== undefined && base[prop] === null) {
            trapProp(base, prop, true, inChainPropHandler);
            return;
          }
          if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            trapProp(base, prop, true, inChainPropHandler);
          }
          const propValue = owner[prop];
          if (propValue instanceof Object || typeof propValue === "object" && propValue !== null) {
            setChainPropAccess(propValue, chain);
          }
          trapProp(base, prop, true, inChainPropHandler);
        };
        setChainPropAccess(window, property);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function noopArray() {
        return [];
      }
      function noopObject() {
        return {};
      }
      function noopFunc() {}
      function noopCallbackFunc() {
        return noopFunc;
      }
      function trueFunc() {
        return true;
      }
      function falseFunc() {
        return false;
      }
      function throwFunc() {
        throw new Error();
      }
      function noopPromiseReject() {
        return Promise.reject();
      }
      function noopPromiseResolve() {
        let responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "{}";
        let responseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        let responseType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "default";
        if (typeof Response === "undefined") {
          return;
        }
        const response = new Response(responseBody, {
          status: 200,
          statusText: "OK"
        });
        Object.defineProperties(response, {
          url: {
            value: responseUrl
          },
          type: {
            value: responseType
          }
        });
        return Promise.resolve(response);
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
          return true;
        }
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
          return true;
        }
        const stackRegexp = toRegExp(stackMatch);
        const refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        }).join("\n");
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getNativeRegexpTest() {
        return Object.getOwnPropertyDescriptor(RegExp.prototype, "test").value;
      }
      function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        const INLINE_SCRIPT_STRING = "inlineScript";
        const INJECTED_SCRIPT_STRING = "injectedScript";
        const INJECTED_SCRIPT_MARKER = "<anonymous>";
        const isInlineScript = function isInlineScript(stackMatch) {
          return stackMatch.indexOf(INLINE_SCRIPT_STRING) > -1;
        };
        const isInjectedScript = function isInjectedScript(stackMatch) {
          return stackMatch.indexOf(INJECTED_SCRIPT_STRING) > -1;
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
          return false;
        }
        let documentURL = window.location.href;
        const pos = documentURL.indexOf("#");
        if (pos !== -1) {
          documentURL = documentURL.slice(0, pos);
        }
        const stackSteps = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        });
        const stackLines = stackSteps.map(function (line) {
          let stack;
          const getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
          if (getStackTraceURL) {
            let stackURL = getStackTraceURL[2];
            if (startsWith(stackURL, "(")) {
              stackURL = stackURL.slice(1);
            }
            if (startsWith(stackURL, INJECTED_SCRIPT_MARKER)) {
              stackURL = INJECTED_SCRIPT_STRING;
              let stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
              if (startsWith(stackFunction, "at")) {
                stackFunction = stackFunction.slice(2).trim();
              }
              stack = "".concat(stackFunction, " ").concat(stackURL).trim();
            } else {
              stack = stackURL;
            }
          } else {
            stack = line;
          }
          return stack;
        });
        if (stackLines) {
          for (let index = 0; index < stackLines.length; index += 1) {
            if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
              return true;
            }
            if (isInjectedScript(stackMatch) && startsWith(stackLines[index], INJECTED_SCRIPT_STRING)) {
              return true;
            }
          }
        }
        return false;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        setConstant.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function setCookie(source, args) {
      function setCookie(source, name, value) {
        let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "/";
        const validValue = getLimitedCookieValue(value);
        if (validValue === null) {
          logMessage(source, "Invalid cookie value: '".concat(validValue, "'"));
          return;
        }
        if (!isValidCookiePath(path)) {
          logMessage(source, "Invalid cookie path: '".concat(path, "'"));
          return;
        }
        const cookieToSet = concatCookieNameValuePath(name, validValue, path);
        if (!cookieToSet) {
          return;
        }
        hit(source);
        document.cookie = cookieToSet;
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function getLimitedCookieValue(value) {
        if (!value) {
          return null;
        }
        let validValue;
        if (value === "true") {
          validValue = "true";
        } else if (value === "True") {
          validValue = "True";
        } else if (value === "false") {
          validValue = "false";
        } else if (value === "False") {
          validValue = "False";
        } else if (value === "yes") {
          validValue = "yes";
        } else if (value === "Yes") {
          validValue = "Yes";
        } else if (value === "Y") {
          validValue = "Y";
        } else if (value === "no") {
          validValue = "no";
        } else if (value === "ok") {
          validValue = "ok";
        } else if (value === "OK") {
          validValue = "OK";
        } else if (/^\d+$/.test(value)) {
          validValue = parseFloat(value);
          if (nativeIsNaN(validValue)) {
            return null;
          }
          if (Math.abs(validValue) < 0 || Math.abs(validValue) > 15) {
            return null;
          }
        } else {
          return null;
        }
        return validValue;
      }
      function concatCookieNameValuePath(rawName, rawValue, rawPath) {
        return "".concat(encodeURIComponent(rawName), "=").concat(encodeURIComponent(rawValue), "; ").concat(getCookiePath(rawPath), ";");
      }
      function isValidCookiePath(rawPath) {
        return rawPath === "/" || rawPath === "none";
      }
      function getCookiePath(rawPath) {
        if (rawPath === "/") {
          return "path=/";
        }
        return "";
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        setCookie.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function setCookieReload(source, args) {
      function setCookieReload(source, name, value) {
        let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "/";
        if (isCookieSetWithValue(document.cookie, name, value)) {
          return;
        }
        const validValue = getLimitedCookieValue(value);
        if (validValue === null) {
          logMessage(source, "Invalid cookie value: '".concat(value, "'"));
          return;
        }
        if (!isValidCookiePath(path)) {
          logMessage(source, "Invalid cookie path: '".concat(path, "'"));
          return;
        }
        const cookieToSet = concatCookieNameValuePath(name, validValue, path);
        if (!cookieToSet) {
          return;
        }
        document.cookie = cookieToSet;
        hit(source);
        if (isCookieSetWithValue(document.cookie, name, value)) {
          window.location.reload();
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function isCookieSetWithValue(cookieString, name, value) {
        return cookieString.split(";").some(function (cookieStr) {
          const pos = cookieStr.indexOf("=");
          if (pos === -1) {
            return false;
          }
          const cookieName = cookieStr.slice(0, pos).trim();
          const cookieValue = cookieStr.slice(pos + 1).trim();
          return name === cookieName && value === cookieValue;
        });
      }
      function getLimitedCookieValue(value) {
        if (!value) {
          return null;
        }
        let validValue;
        if (value === "true") {
          validValue = "true";
        } else if (value === "True") {
          validValue = "True";
        } else if (value === "false") {
          validValue = "false";
        } else if (value === "False") {
          validValue = "False";
        } else if (value === "yes") {
          validValue = "yes";
        } else if (value === "Yes") {
          validValue = "Yes";
        } else if (value === "Y") {
          validValue = "Y";
        } else if (value === "no") {
          validValue = "no";
        } else if (value === "ok") {
          validValue = "ok";
        } else if (value === "OK") {
          validValue = "OK";
        } else if (/^\d+$/.test(value)) {
          validValue = parseFloat(value);
          if (nativeIsNaN(validValue)) {
            return null;
          }
          if (Math.abs(validValue) < 0 || Math.abs(validValue) > 15) {
            return null;
          }
        } else {
          return null;
        }
        return validValue;
      }
      function concatCookieNameValuePath(rawName, rawValue, rawPath) {
        return "".concat(encodeURIComponent(rawName), "=").concat(encodeURIComponent(rawValue), "; ").concat(getCookiePath(rawPath), ";");
      }
      function isValidCookiePath(rawPath) {
        return rawPath === "/" || rawPath === "none";
      }
      function getCookiePath(rawPath) {
        if (rawPath === "/") {
          return "path=/";
        }
        return "";
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        setCookieReload.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function setLocalStorageItem(source, args) {
      function setLocalStorageItem(source, key, value) {
        if (typeof key === "undefined") {
          logMessage(source, "Item key should be specified.");
          return;
        }
        let validValue;
        try {
          validValue = getLimitedStorageItemValue(value);
        } catch (_unused) {
          logMessage(source, "Invalid storage item value: '".concat(value, "'"));
          return;
        }
        const _window = window,
          localStorage = _window.localStorage;
        setStorageItem(source, localStorage, key, validValue);
        hit(source);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function setStorageItem(source, storage, key, value) {
        try {
          storage.setItem(key, value);
        } catch (e) {
          const message = "Unable to set sessionStorage item due to: ".concat(e.message);
          logMessage(source, message);
        }
      }
      function getLimitedStorageItemValue(value) {
        if (typeof value !== "string") {
          throw new Error("Invalid value");
        }
        let validValue;
        if (value === "undefined") {
          validValue = undefined;
        } else if (value === "false") {
          validValue = false;
        } else if (value === "true") {
          validValue = true;
        } else if (value === "null") {
          validValue = null;
        } else if (value === "emptyArr") {
          validValue = "[]";
        } else if (value === "emptyObj") {
          validValue = "{}";
        } else if (value === "") {
          validValue = "";
        } else if (/^\d+$/.test(value)) {
          validValue = parseFloat(value);
          if (nativeIsNaN(validValue)) {
            throw new Error("Invalid value");
          }
          if (Math.abs(validValue) > 32767) {
            throw new Error("Invalid value");
          }
        } else if (value === "yes") {
          validValue = "yes";
        } else if (value === "no") {
          validValue = "no";
        } else {
          throw new Error("Invalid value");
        }
        return validValue;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        setLocalStorageItem.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function setPopadsDummy(source, args) {
      function setPopadsDummy(source) {
        delete window.PopAds;
        delete window.popns;
        Object.defineProperties(window, {
          PopAds: {
            get: function get() {
              hit(source);
              return {};
            }
          },
          popns: {
            get: function get() {
              hit(source);
              return {};
            }
          }
        });
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        setPopadsDummy.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function setSessionStorageItem(source, args) {
      function setSessionStorageItem(source, key, value) {
        if (typeof key === "undefined") {
          logMessage(source, "Item key should be specified.");
          return;
        }
        let validValue;
        try {
          validValue = getLimitedStorageItemValue(value);
        } catch (_unused) {
          logMessage(source, "Invalid storage item value: '".concat(value, "'"));
          return;
        }
        const _window = window,
          sessionStorage = _window.sessionStorage;
        setStorageItem(source, sessionStorage, key, validValue);
        hit(source);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function setStorageItem(source, storage, key, value) {
        try {
          storage.setItem(key, value);
        } catch (e) {
          const message = "Unable to set sessionStorage item due to: ".concat(e.message);
          logMessage(source, message);
        }
      }
      function getLimitedStorageItemValue(value) {
        if (typeof value !== "string") {
          throw new Error("Invalid value");
        }
        let validValue;
        if (value === "undefined") {
          validValue = undefined;
        } else if (value === "false") {
          validValue = false;
        } else if (value === "true") {
          validValue = true;
        } else if (value === "null") {
          validValue = null;
        } else if (value === "emptyArr") {
          validValue = "[]";
        } else if (value === "emptyObj") {
          validValue = "{}";
        } else if (value === "") {
          validValue = "";
        } else if (/^\d+$/.test(value)) {
          validValue = parseFloat(value);
          if (nativeIsNaN(validValue)) {
            throw new Error("Invalid value");
          }
          if (Math.abs(validValue) > 32767) {
            throw new Error("Invalid value");
          }
        } else if (value === "yes") {
          validValue = "yes";
        } else if (value === "no") {
          validValue = "no";
        } else {
          throw new Error("Invalid value");
        }
        return validValue;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        setSessionStorageItem.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function trustedClickElement(source, args) {
      function trustedClickElement(source, selectors) {
        let extraMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        let delay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NaN;
        if (!selectors) {
          return;
        }
        const OBSERVER_TIMEOUT_MS = 1e4;
        const THROTTLE_DELAY_MS = 20;
        const STATIC_CLICK_DELAY_MS = 150;
        const COOKIE_MATCH_MARKER = "cookie:";
        const LOCAL_STORAGE_MATCH_MARKER = "localStorage:";
        const SELECTORS_DELIMITER = ",";
        const COOKIE_STRING_DELIMITER = ";";
        const EXTRA_MATCH_DELIMITER = /(,\s*){1}(?=!?cookie:|!?localStorage:)/;
        const sleep = function sleep(delayMs) {
          return new Promise(function (resolve) {
            return setTimeout(resolve, delayMs);
          });
        };
        let parsedDelay;
        if (delay) {
          parsedDelay = parseInt(delay, 10);
          const isValidDelay = !Number.isNaN(parsedDelay) || parsedDelay < OBSERVER_TIMEOUT_MS;
          if (!isValidDelay) {
            const message = "Passed delay '".concat(delay, "' is invalid or bigger than ").concat(OBSERVER_TIMEOUT_MS, " ms");
            logMessage(source, message);
            return;
          }
        }
        let canClick = !parsedDelay;
        const cookieMatches = [];
        const localStorageMatches = [];
        let isInvertedMatchCookie = false;
        let isInvertedMatchLocalStorage = false;
        if (extraMatch) {
          const parsedExtraMatch = extraMatch.split(EXTRA_MATCH_DELIMITER).map(function (matchStr) {
            return matchStr.trim();
          });
          parsedExtraMatch.forEach(function (matchStr) {
            if (matchStr.indexOf(COOKIE_MATCH_MARKER) > -1) {
              const _parseMatchArg = parseMatchArg(matchStr),
                isInvertedMatch = _parseMatchArg.isInvertedMatch,
                matchValue = _parseMatchArg.matchValue;
              isInvertedMatchCookie = isInvertedMatch;
              const cookieMatch = matchValue.replace(COOKIE_MATCH_MARKER, "");
              cookieMatches.push(cookieMatch);
            }
            if (matchStr.indexOf(LOCAL_STORAGE_MATCH_MARKER) > -1) {
              const _parseMatchArg2 = parseMatchArg(matchStr),
                isInvertedMatch = _parseMatchArg2.isInvertedMatch,
                matchValue = _parseMatchArg2.matchValue;
              isInvertedMatchLocalStorage = isInvertedMatch;
              const localStorageMatch = matchValue.replace(LOCAL_STORAGE_MATCH_MARKER, "");
              localStorageMatches.push(localStorageMatch);
            }
          });
        }
        if (cookieMatches.length > 0) {
          const parsedCookieMatches = parseCookieString(cookieMatches.join(COOKIE_STRING_DELIMITER));
          const parsedCookies = parseCookieString(document.cookie);
          const cookieKeys = Object.keys(parsedCookies);
          if (cookieKeys.length === 0) {
            return;
          }
          const cookiesMatched = Object.keys(parsedCookieMatches).every(function (key) {
            const valueMatch = parsedCookieMatches[key] ? toRegExp(parsedCookieMatches[key]) : null;
            const keyMatch = toRegExp(key);
            return cookieKeys.some(function (key) {
              const keysMatched = keyMatch.test(key);
              if (!keysMatched) {
                return false;
              }
              if (!valueMatch) {
                return true;
              }
              return valueMatch.test(parsedCookies[key]);
            });
          });
          const shouldRun = cookiesMatched !== isInvertedMatchCookie;
          if (!shouldRun) {
            return;
          }
        }
        if (localStorageMatches.length > 0) {
          const localStorageMatched = localStorageMatches.every(function (str) {
            const itemValue = window.localStorage.getItem(str);
            return itemValue || itemValue === "";
          });
          const shouldRun = localStorageMatched !== isInvertedMatchLocalStorage;
          if (!shouldRun) {
            return;
          }
        }
        let selectorsSequence = selectors.split(SELECTORS_DELIMITER).map(function (selector) {
          return selector.trim();
        });
        const createElementObj = function createElementObj(element) {
          return {
            element: element || null,
            clicked: false
          };
        };
        const elementsSequence = Array(selectorsSequence.length).fill(createElementObj());
        const clickElementsBySequence = async function clickElementsBySequence() {
          for (let i = 0; i < elementsSequence.length; i += 1) {
            const elementObj = elementsSequence[i];
            if (i >= 1) {
              await sleep(STATIC_CLICK_DELAY_MS);
            }
            if (!elementObj.element) {
              break;
            }
            if (!elementObj.clicked) {
              elementObj.element.click();
              elementObj.clicked = true;
            }
          }
          const allElementsClicked = elementsSequence.every(function (elementObj) {
            return elementObj.clicked === true;
          });
          if (allElementsClicked) {
            hit(source);
          }
        };
        const handleElement = function handleElement(element, i) {
          const elementObj = createElementObj(element);
          elementsSequence[i] = elementObj;
          if (canClick) {
            clickElementsBySequence();
          }
        };
        const findElements = function findElements(mutations, observer) {
          const fulfilledSelectors = [];
          selectorsSequence.forEach(function (selector, i) {
            if (!selector) {
              return;
            }
            const element = document.querySelector(selector);
            if (!element) {
              return;
            }
            handleElement(element, i);
            fulfilledSelectors.push(selector);
          });
          selectorsSequence = selectorsSequence.map(function (selector) {
            return fulfilledSelectors.indexOf(selector) === -1 ? selector : null;
          });
          const allSelectorsFulfilled = selectorsSequence.every(function (selector) {
            return selector === null;
          });
          if (allSelectorsFulfilled) {
            observer.disconnect();
          }
        };
        const observer = new MutationObserver(throttle(findElements, THROTTLE_DELAY_MS));
        observer.observe(document.documentElement, {
          attributes: true,
          childList: true,
          subtree: true
        });
        if (parsedDelay) {
          setTimeout(function () {
            clickElementsBySequence();
            canClick = true;
          }, parsedDelay);
        }
        setTimeout(function () {
          return observer.disconnect();
        }, OBSERVER_TIMEOUT_MS);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function parseCookieString(cookieString) {
        const COOKIE_DELIMITER = "=";
        const COOKIE_PAIRS_DELIMITER = ";";
        const cookieChunks = cookieString.split(COOKIE_PAIRS_DELIMITER);
        const cookieData = {};
        cookieChunks.forEach(function (singleCookie) {
          let cookieKey;
          let cookieValue;
          const delimiterIndex = singleCookie.indexOf(COOKIE_DELIMITER);
          if (delimiterIndex === -1) {
            cookieKey = singleCookie.trim();
          } else {
            cookieKey = singleCookie.slice(0, delimiterIndex).trim();
            cookieValue = singleCookie.slice(delimiterIndex + 1);
          }
          cookieData[cookieKey] = cookieValue || null;
        });
        return cookieData;
      }
      function throttle(cb, delay) {
        let wait = false;
        let savedArgs;
        const wrapper = function wrapper() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (wait) {
            savedArgs = args;
            return;
          }
          cb(...args);
          wait = true;
          setTimeout(function () {
            wait = false;
            if (savedArgs) {
              wrapper(...savedArgs);
              savedArgs = null;
            }
          }, delay);
        };
        return wrapper;
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function parseMatchArg(match) {
        const INVERT_MARKER = "!";
        const isInvertedMatch = match ? match.startsWith(INVERT_MARKER) : false;
        const matchValue = isInvertedMatch ? match.slice(1) : match;
        const matchRegexp = toRegExp(matchValue);
        return {
          isInvertedMatch: isInvertedMatch,
          matchRegexp: matchRegexp,
          matchValue: matchValue
        };
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        trustedClickElement.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function trustedReplaceFetchResponse(source, args) {
      function trustedReplaceFetchResponse(source) {
        let pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        let replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        let propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        if (typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
          return;
        }
        if (pattern === "" && replacement !== "") {
          logMessage(source, "Pattern argument should not be empty string");
          return;
        }
        const shouldLog = pattern === "" && replacement === "";
        const nativeFetch = fetch;
        let shouldReplace = false;
        let fetchData;
        const handlerWrapper = function handlerWrapper(target, thisArg, args) {
          fetchData = getFetchData(args);
          if (shouldLog) {
            logMessage(source, "fetch( ".concat(objectToString(fetchData), " )"), true);
            hit(source);
            return Reflect.apply(target, thisArg, args);
          }
          shouldReplace = matchRequestProps(source, propsToMatch, fetchData);
          if (!shouldReplace) {
            return Reflect.apply(target, thisArg, args);
          }
          const forgeResponse = function forgeResponse(response, textContent) {
            const bodyUsed = response.bodyUsed,
              headers = response.headers,
              ok = response.ok,
              redirected = response.redirected,
              status = response.status,
              statusText = response.statusText,
              type = response.type,
              url = response.url;
            const forgedResponse = new Response(textContent, {
              status: status,
              statusText: statusText,
              headers: headers
            });
            Object.defineProperties(forgedResponse, {
              url: {
                value: url
              },
              type: {
                value: type
              },
              ok: {
                value: ok
              },
              bodyUsed: {
                value: bodyUsed
              },
              redirected: {
                value: redirected
              }
            });
            return forgedResponse;
          };
          return nativeFetch.apply(null, args).then(function (response) {
            return response.text().then(function (bodyText) {
              const patternRegexp = pattern === "*" ? /(\n|.)*/ : toRegExp(pattern);
              const modifiedTextContent = bodyText.replace(patternRegexp, replacement);
              const forgedResponse = forgeResponse(response, modifiedTextContent);
              hit(source);
              return forgedResponse;
            }).catch(function () {
              const fetchDataStr = objectToString(fetchData);
              const message = "Response body can't be converted to text: ".concat(fetchDataStr);
              logMessage(source, message);
              return Reflect.apply(target, thisArg, args);
            });
          }).catch(function () {
            return Reflect.apply(target, thisArg, args);
          });
        };
        const fetchHandler = {
          apply: handlerWrapper
        };
        fetch = new Proxy(fetch, fetchHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function getFetchData(args) {
        const fetchPropsObj = {};
        let fetchUrl;
        let fetchInit;
        if (args[0] instanceof Request) {
          const requestData = getRequestData(args[0]);
          fetchUrl = requestData.url;
          fetchInit = requestData;
        } else {
          fetchUrl = args[0];
          fetchInit = args[1];
        }
        fetchPropsObj.url = fetchUrl;
        if (fetchInit instanceof Object) {
          Object.keys(fetchInit).forEach(function (prop) {
            fetchPropsObj[prop] = fetchInit[prop];
          });
        }
        return fetchPropsObj;
      }
      function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
          return String(obj);
        }
        return isEmptyObject(obj) ? "{}" : getObjectEntries(obj).map(function (pair) {
          const key = pair[0];
          const value = pair[1];
          let recordValueStr = value;
          if (value instanceof Object) {
            recordValueStr = "{ ".concat(objectToString(value), " }");
          }
          return "".concat(key, ':"').concat(recordValueStr, '"');
        }).join(" ");
      }
      function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
          return true;
        }
        let isMatched;
        const parsedData = parseMatchProps(propsToMatch);
        if (!validateParsedData(parsedData)) {
          logMessage(source, "Invalid parameter: ".concat(propsToMatch));
          isMatched = false;
        } else {
          const matchData = getMatchPropsData(parsedData);
          isMatched = Object.keys(matchData).every(function (matchKey) {
            const matchValue = matchData[matchKey];
            return Object.prototype.hasOwnProperty.call(requestData, matchKey) && matchValue.test(requestData[matchKey]);
          });
        }
        return isMatched;
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getRequestData(request) {
        const requestInitOptions = getRequestProps();
        const entries = requestInitOptions.map(function (key) {
          const value = request[key];
          return [key, value];
        });
        return getObjectFromEntries(entries);
      }
      function getRequestProps() {
        return ["url", "method", "headers", "body", "mode", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal"];
      }
      function getObjectEntries(object) {
        const keys = Object.keys(object);
        const entries = [];
        keys.forEach(function (key) {
          return entries.push([key, object[key]]);
        });
        return entries;
      }
      function getObjectFromEntries(entries) {
        const output = entries.reduce(function (acc, el) {
          const key = el[0];
          const value = el[1];
          acc[key] = value;
          return acc;
        }, {});
        return output;
      }
      function parseMatchProps(propsToMatchStr) {
        const PROPS_DIVIDER = " ";
        const PAIRS_MARKER = ":";
        const LEGAL_MATCH_PROPS = getRequestProps();
        const propsObj = {};
        const props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach(function (prop) {
          const dividerInd = prop.indexOf(PAIRS_MARKER);
          const key = prop.slice(0, dividerInd);
          const hasLegalMatchProp = LEGAL_MATCH_PROPS.indexOf(key) !== -1;
          if (hasLegalMatchProp) {
            const value = prop.slice(dividerInd + 1);
            propsObj[key] = value;
          } else {
            propsObj.url = prop;
          }
        });
        return propsObj;
      }
      function validateParsedData(data) {
        return Object.values(data).every(function (value) {
          return isValidStrPattern(value);
        });
      }
      function getMatchPropsData(data) {
        const matchData = {};
        Object.keys(data).forEach(function (key) {
          matchData[key] = toRegExp(data[key]);
        });
        return matchData;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        trustedReplaceFetchResponse.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function trustedReplaceXhrResponse(source, args) {
      function trustedReplaceXhrResponse(source) {
        let pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        let replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        let propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        if (typeof Proxy === "undefined") {
          return;
        }
        if (pattern === "" && replacement !== "") {
          const message = "Pattern argument should not be empty string.";
          logMessage(source, message);
          return;
        }
        const shouldLog = pattern === "" && replacement === "";
        const nativeOpen = window.XMLHttpRequest.prototype.open;
        const nativeSend = window.XMLHttpRequest.prototype.send;
        let xhrData;
        const openWrapper = function openWrapper(target, thisArg, args) {
          xhrData = getXhrData.apply(null, args);
          if (shouldLog) {
            const message = "xhr( ".concat(objectToString(xhrData), " )");
            logMessage(source, message, true);
            hit(source);
            return Reflect.apply(target, thisArg, args);
          }
          if (matchRequestProps(source, propsToMatch, xhrData)) {
            thisArg.shouldBePrevented = true;
          }
          if (thisArg.shouldBePrevented) {
            thisArg.collectedHeaders = [];
            const setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
              thisArg.collectedHeaders.push(args);
              return Reflect.apply(target, thisArg, args);
            };
            const setRequestHeaderHandler = {
              apply: setRequestHeaderWrapper
            };
            thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
          }
          return Reflect.apply(target, thisArg, args);
        };
        const sendWrapper = function sendWrapper(target, thisArg, args) {
          if (!thisArg.shouldBePrevented) {
            return Reflect.apply(target, thisArg, args);
          }
          const forgedRequest = new XMLHttpRequest();
          forgedRequest.addEventListener("readystatechange", function () {
            if (forgedRequest.readyState !== 4) {
              return;
            }
            const readyState = forgedRequest.readyState,
              response = forgedRequest.response,
              responseText = forgedRequest.responseText,
              responseURL = forgedRequest.responseURL,
              responseXML = forgedRequest.responseXML,
              status = forgedRequest.status,
              statusText = forgedRequest.statusText;
            const content = responseText || response;
            if (typeof content !== "string") {
              return;
            }
            const patternRegexp = pattern === "*" ? /(\n|.)*/ : toRegExp(pattern);
            const modifiedContent = content.replace(patternRegexp, replacement);
            Object.defineProperties(thisArg, {
              readyState: {
                value: readyState
              },
              response: {
                value: modifiedContent
              },
              responseText: {
                value: modifiedContent
              },
              responseURL: {
                value: responseURL
              },
              responseXML: {
                value: responseXML
              },
              status: {
                value: status
              },
              statusText: {
                value: statusText
              }
            });
            setTimeout(function () {
              const stateEvent = new Event("readystatechange");
              thisArg.dispatchEvent(stateEvent);
              const loadEvent = new Event("load");
              thisArg.dispatchEvent(loadEvent);
              const loadEndEvent = new Event("loadend");
              thisArg.dispatchEvent(loadEndEvent);
            }, 1);
            hit(source);
          });
          nativeOpen.apply(forgedRequest, [xhrData.method, xhrData.url]);
          thisArg.collectedHeaders.forEach(function (header) {
            const name = header[0];
            const value = header[1];
            forgedRequest.setRequestHeader(name, value);
          });
          thisArg.collectedHeaders = [];
          try {
            nativeSend.call(forgedRequest, args);
          } catch (_unused) {
            return Reflect.apply(target, thisArg, args);
          }
          return undefined;
        };
        const openHandler = {
          apply: openWrapper
        };
        const sendHandler = {
          apply: sendWrapper
        };
        XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
        XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
          return String(obj);
        }
        return isEmptyObject(obj) ? "{}" : getObjectEntries(obj).map(function (pair) {
          const key = pair[0];
          const value = pair[1];
          let recordValueStr = value;
          if (value instanceof Object) {
            recordValueStr = "{ ".concat(objectToString(value), " }");
          }
          return "".concat(key, ':"').concat(recordValueStr, '"');
        }).join(" ");
      }
      function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
          return true;
        }
        let isMatched;
        const parsedData = parseMatchProps(propsToMatch);
        if (!validateParsedData(parsedData)) {
          logMessage(source, "Invalid parameter: ".concat(propsToMatch));
          isMatched = false;
        } else {
          const matchData = getMatchPropsData(parsedData);
          isMatched = Object.keys(matchData).every(function (matchKey) {
            const matchValue = matchData[matchKey];
            return Object.prototype.hasOwnProperty.call(requestData, matchKey) && matchValue.test(requestData[matchKey]);
          });
        }
        return isMatched;
      }
      function getXhrData(method, url, async, user, password) {
        return {
          method: method,
          url: url,
          async: async,
          user: user,
          password: password
        };
      }
      function getMatchPropsData(data) {
        const matchData = {};
        Object.keys(data).forEach(function (key) {
          matchData[key] = toRegExp(data[key]);
        });
        return matchData;
      }
      function getRequestProps() {
        return ["url", "method", "headers", "body", "mode", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal"];
      }
      function validateParsedData(data) {
        return Object.values(data).every(function (value) {
          return isValidStrPattern(value);
        });
      }
      function parseMatchProps(propsToMatchStr) {
        const PROPS_DIVIDER = " ";
        const PAIRS_MARKER = ":";
        const LEGAL_MATCH_PROPS = getRequestProps();
        const propsObj = {};
        const props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach(function (prop) {
          const dividerInd = prop.indexOf(PAIRS_MARKER);
          const key = prop.slice(0, dividerInd);
          const hasLegalMatchProp = LEGAL_MATCH_PROPS.indexOf(key) !== -1;
          if (hasLegalMatchProp) {
            const value = prop.slice(dividerInd + 1);
            propsObj[key] = value;
          } else {
            propsObj.url = prop;
          }
        });
        return propsObj;
      }
      function isValidStrPattern(input) {
        const FORWARD_SLASH = "/";
        let str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          str = input.slice(1, -1);
        }
        let isValid;
        try {
          isValid = new RegExp(str);
          isValid = true;
        } catch (e) {
          isValid = false;
        }
        return isValid;
      }
      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getObjectEntries(object) {
        const keys = Object.keys(object);
        const entries = [];
        keys.forEach(function (key) {
          return entries.push([key, object[key]]);
        });
        return entries;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        trustedReplaceXhrResponse.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function trustedSetConstant(source, args) {
      function trustedSetConstant(source, property, value, stack) {
        if (!property || !matchStackTrace(stack, new Error().stack)) {
          return;
        }
        let constantValue;
        try {
          constantValue = inferValue(value);
        } catch (e) {
          logMessage(source, e);
          return;
        }
        let canceled = false;
        const mustCancel = function mustCancel(value) {
          if (canceled) {
            return canceled;
          }
          canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue && value !== null;
          return canceled;
        };
        const trapProp = function trapProp(base, prop, configurable, handler) {
          if (!handler.init(base[prop])) {
            return false;
          }
          const origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
          let prevSetter;
          if (origDescriptor instanceof Object) {
            if (!origDescriptor.configurable) {
              const message = "Property '".concat(prop, "' is not configurable");
              logMessage(source, message);
              return false;
            }
            base[prop] = constantValue;
            if (origDescriptor.set instanceof Function) {
              prevSetter = origDescriptor.set;
            }
          }
          Object.defineProperty(base, prop, {
            configurable: configurable,
            get() {
              return handler.get();
            },
            set(a) {
              if (prevSetter !== undefined) {
                prevSetter(a);
              }
              handler.set(a);
            }
          });
          return true;
        };
        const setChainPropAccess = function setChainPropAccess(owner, property) {
          const chainInfo = getPropertyInChain(owner, property);
          const base = chainInfo.base;
          const prop = chainInfo.prop,
            chain = chainInfo.chain;
          const inChainPropHandler = {
            factValue: undefined,
            init(a) {
              this.factValue = a;
              return true;
            },
            get() {
              return this.factValue;
            },
            set(a) {
              if (this.factValue === a) {
                return;
              }
              this.factValue = a;
              if (a instanceof Object) {
                setChainPropAccess(a, chain);
              }
            }
          };
          const endPropHandler = {
            init(a) {
              if (mustCancel(a)) {
                return false;
              }
              return true;
            },
            get() {
              return constantValue;
            },
            set(a) {
              if (!mustCancel(a)) {
                return;
              }
              constantValue = a;
            }
          };
          if (!chain) {
            const isTrapped = trapProp(base, prop, false, endPropHandler);
            if (isTrapped) {
              hit(source);
            }
            return;
          }
          if (base !== undefined && base[prop] === null) {
            trapProp(base, prop, true, inChainPropHandler);
            return;
          }
          if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            trapProp(base, prop, true, inChainPropHandler);
          }
          const propValue = owner[prop];
          if (propValue instanceof Object || typeof propValue === "object" && propValue !== null) {
            setChainPropAccess(propValue, chain);
          }
          trapProp(base, prop, true, inChainPropHandler);
        };
        setChainPropAccess(window, property);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function inferValue(value) {
        if (value === "undefined") {
          return undefined;
        }
        if (value === "false") {
          return false;
        }
        if (value === "true") {
          return true;
        }
        if (value === "null") {
          return null;
        }
        if (value === "NaN") {
          return NaN;
        }
        const MAX_ALLOWED_NUM = 32767;
        const numVal = Number(value);
        if (!nativeIsNaN(numVal)) {
          if (Math.abs(numVal) > MAX_ALLOWED_NUM) {
            throw new Error("number values bigger than 32767 are not allowed");
          }
          return numVal;
        }
        let errorMessage = "'".concat(value, "' value type can't be inferred");
        try {
          const parsableVal = JSON.parse(value);
          if (parsableVal instanceof Object || typeof parsableVal === "string") {
            return parsableVal;
          }
        } catch (e) {
          errorMessage += ": ".concat(e);
        }
        throw new TypeError(errorMessage);
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function getPropertyInChain(base, chain) {
        const pos = chain.indexOf(".");
        if (pos === -1) {
          return {
            base: base,
            prop: chain
          };
        }
        const prop = chain.slice(0, pos);
        if (base === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        const nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase === null) {
          return {
            base: base,
            prop: prop,
            chain: chain
          };
        }
        if (nextBase !== undefined) {
          return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
          configurable: true
        });
        return {
          base: base,
          prop: prop,
          chain: chain
        };
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
          return true;
        }
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
          return true;
        }
        const stackRegexp = toRegExp(stackMatch);
        const refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        }).join("\n");
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
      }
      function nativeIsNaN(num) {
        const native = Number.isNaN || window.isNaN;
        return native(num);
      }
      function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
      }
      function getNativeRegexpTest() {
        return Object.getOwnPropertyDescriptor(RegExp.prototype, "test").value;
      }
      function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        const INLINE_SCRIPT_STRING = "inlineScript";
        const INJECTED_SCRIPT_STRING = "injectedScript";
        const INJECTED_SCRIPT_MARKER = "<anonymous>";
        const isInlineScript = function isInlineScript(stackMatch) {
          return stackMatch.indexOf(INLINE_SCRIPT_STRING) > -1;
        };
        const isInjectedScript = function isInjectedScript(stackMatch) {
          return stackMatch.indexOf(INJECTED_SCRIPT_STRING) > -1;
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
          return false;
        }
        let documentURL = window.location.href;
        const pos = documentURL.indexOf("#");
        if (pos !== -1) {
          documentURL = documentURL.slice(0, pos);
        }
        const stackSteps = stackTrace.split("\n").slice(2).map(function (line) {
          return line.trim();
        });
        const stackLines = stackSteps.map(function (line) {
          let stack;
          const getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
          if (getStackTraceURL) {
            let stackURL = getStackTraceURL[2];
            if (startsWith(stackURL, "(")) {
              stackURL = stackURL.slice(1);
            }
            if (startsWith(stackURL, INJECTED_SCRIPT_MARKER)) {
              stackURL = INJECTED_SCRIPT_STRING;
              let stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
              if (startsWith(stackFunction, "at")) {
                stackFunction = stackFunction.slice(2).trim();
              }
              stack = "".concat(stackFunction, " ").concat(stackURL).trim();
            } else {
              stack = stackURL;
            }
          } else {
            stack = line;
          }
          return stack;
        });
        if (stackLines) {
          for (let index = 0; index < stackLines.length; index += 1) {
            if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
              return true;
            }
            if (isInjectedScript(stackMatch) && startsWith(stackLines[index], INJECTED_SCRIPT_STRING)) {
              return true;
            }
          }
        }
        return false;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        trustedSetConstant.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function trustedSetCookie(source, args) {
      function trustedSetCookie(source, name, value) {
        let offsetExpiresSec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        let path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "/";
        if (typeof name === "undefined") {
          logMessage(source, "Cookie name should be specified");
          return;
        }
        if (typeof value === "undefined") {
          logMessage(source, "Cookie value should be specified");
          return;
        }
        const parsedValue = parseKeywordValue(value);
        if (!isValidCookiePath(path)) {
          logMessage(source, "Invalid cookie path: '".concat(path, "'"));
          return;
        }
        let cookieToSet = concatCookieNameValuePath(name, parsedValue, path);
        if (!cookieToSet) {
          return;
        }
        if (offsetExpiresSec) {
          const parsedOffsetMs = getTrustedCookieOffsetMs(offsetExpiresSec);
          if (!parsedOffsetMs) {
            logMessage(source, "Invalid offsetExpiresSec value: ".concat(offsetExpiresSec));
            return;
          }
          const expires = Date.now() + parsedOffsetMs;
          cookieToSet += " expires=".concat(new Date(expires).toUTCString(), ";");
        }
        document.cookie = cookieToSet;
        hit(source);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function concatCookieNameValuePath(rawName, rawValue, rawPath) {
        return "".concat(encodeURIComponent(rawName), "=").concat(encodeURIComponent(rawValue), "; ").concat(getCookiePath(rawPath), ";");
      }
      function isValidCookiePath(rawPath) {
        return rawPath === "/" || rawPath === "none";
      }
      function getTrustedCookieOffsetMs(offsetExpiresSec) {
        const ONE_YEAR_EXPIRATION_KEYWORD = "1year";
        const ONE_DAY_EXPIRATION_KEYWORD = "1day";
        const MS_IN_SEC = 1e3;
        const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
        const SECONDS_IN_DAY = 24 * 60 * 60;
        let parsedSec;
        if (offsetExpiresSec === ONE_YEAR_EXPIRATION_KEYWORD) {
          parsedSec = SECONDS_IN_YEAR;
        } else if (offsetExpiresSec === ONE_DAY_EXPIRATION_KEYWORD) {
          parsedSec = SECONDS_IN_DAY;
        } else {
          parsedSec = Number.parseInt(offsetExpiresSec, 10);
          if (Number.isNaN(parsedSec)) {
            return null;
          }
        }
        return parsedSec * MS_IN_SEC;
      }
      function parseKeywordValue(rawValue) {
        const NOW_VALUE_KEYWORD = "$now$";
        const CURRENT_DATE_KEYWORD = "$currentDate$";
        let parsedValue = rawValue;
        if (rawValue === NOW_VALUE_KEYWORD) {
          parsedValue = Date.now().toString();
        } else if (rawValue === CURRENT_DATE_KEYWORD) {
          parsedValue = Date();
        }
        return parsedValue;
      }
      function getCookiePath(rawPath) {
        if (rawPath === "/") {
          return "path=/";
        }
        return "";
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        trustedSetCookie.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function trustedSetCookieReload(source, args) {
      function trustedSetCookieReload(source, name, value) {
        let offsetExpiresSec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        let path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "/";
        if (typeof name === "undefined") {
          logMessage(source, "Cookie name should be specified");
          return;
        }
        if (typeof value === "undefined") {
          logMessage(source, "Cookie value should be specified");
          return;
        }
        if (isCookieSetWithValue(document.cookie, name, value)) {
          return;
        }
        const parsedValue = parseKeywordValue(value);
        if (!isValidCookiePath(path)) {
          logMessage(source, "Invalid cookie path: '".concat(path, "'"));
          return;
        }
        let cookieToSet = concatCookieNameValuePath(name, parsedValue, path);
        if (!cookieToSet) {
          return;
        }
        if (offsetExpiresSec) {
          const parsedOffsetMs = getTrustedCookieOffsetMs(offsetExpiresSec);
          if (!parsedOffsetMs) {
            logMessage(source, "Invalid offsetExpiresSec value: ".concat(offsetExpiresSec));
            return;
          }
          const expires = Date.now() + parsedOffsetMs;
          cookieToSet += " expires=".concat(new Date(expires).toUTCString(), ";");
        }
        document.cookie = cookieToSet;
        hit(source);
        if (isCookieSetWithValue(document.cookie, name, value)) {
          window.location.reload();
        }
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function isCookieSetWithValue(cookieString, name, value) {
        return cookieString.split(";").some(function (cookieStr) {
          const pos = cookieStr.indexOf("=");
          if (pos === -1) {
            return false;
          }
          const cookieName = cookieStr.slice(0, pos).trim();
          const cookieValue = cookieStr.slice(pos + 1).trim();
          return name === cookieName && value === cookieValue;
        });
      }
      function concatCookieNameValuePath(rawName, rawValue, rawPath) {
        return "".concat(encodeURIComponent(rawName), "=").concat(encodeURIComponent(rawValue), "; ").concat(getCookiePath(rawPath), ";");
      }
      function isValidCookiePath(rawPath) {
        return rawPath === "/" || rawPath === "none";
      }
      function getTrustedCookieOffsetMs(offsetExpiresSec) {
        const ONE_YEAR_EXPIRATION_KEYWORD = "1year";
        const ONE_DAY_EXPIRATION_KEYWORD = "1day";
        const MS_IN_SEC = 1e3;
        const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
        const SECONDS_IN_DAY = 24 * 60 * 60;
        let parsedSec;
        if (offsetExpiresSec === ONE_YEAR_EXPIRATION_KEYWORD) {
          parsedSec = SECONDS_IN_YEAR;
        } else if (offsetExpiresSec === ONE_DAY_EXPIRATION_KEYWORD) {
          parsedSec = SECONDS_IN_DAY;
        } else {
          parsedSec = Number.parseInt(offsetExpiresSec, 10);
          if (Number.isNaN(parsedSec)) {
            return null;
          }
        }
        return parsedSec * MS_IN_SEC;
      }
      function parseKeywordValue(rawValue) {
        const NOW_VALUE_KEYWORD = "$now$";
        const CURRENT_DATE_KEYWORD = "$currentDate$";
        let parsedValue = rawValue;
        if (rawValue === NOW_VALUE_KEYWORD) {
          parsedValue = Date.now().toString();
        } else if (rawValue === CURRENT_DATE_KEYWORD) {
          parsedValue = Date();
        }
        return parsedValue;
      }
      function getCookiePath(rawPath) {
        if (rawPath === "/") {
          return "path=/";
        }
        return "";
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        trustedSetCookieReload.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function trustedSetLocalStorageItem(source, args) {
      function trustedSetLocalStorageItem(source, key, value) {
        if (typeof key === "undefined") {
          logMessage(source, "Item key should be specified");
          return;
        }
        if (typeof value === "undefined") {
          logMessage(source, "Item value should be specified");
          return;
        }
        const parsedValue = parseKeywordValue(value);
        const _window = window,
          localStorage = _window.localStorage;
        setStorageItem(source, localStorage, key, parsedValue);
        hit(source);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function setStorageItem(source, storage, key, value) {
        try {
          storage.setItem(key, value);
        } catch (e) {
          const message = "Unable to set sessionStorage item due to: ".concat(e.message);
          logMessage(source, message);
        }
      }
      function parseKeywordValue(rawValue) {
        const NOW_VALUE_KEYWORD = "$now$";
        const CURRENT_DATE_KEYWORD = "$currentDate$";
        let parsedValue = rawValue;
        if (rawValue === NOW_VALUE_KEYWORD) {
          parsedValue = Date.now().toString();
        } else if (rawValue === CURRENT_DATE_KEYWORD) {
          parsedValue = Date();
        }
        return parsedValue;
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        trustedSetLocalStorageItem.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    function xmlPrune(source, args) {
      function xmlPrune(source, propsToRemove) {
        var _this = this;
        let optionalProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        let urlToMatch = arguments.length > 3 ? arguments[3] : undefined;
        if (typeof Reflect === "undefined" || typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
          return;
        }
        let shouldPruneResponse = true;
        if (!propsToRemove) {
          shouldPruneResponse = false;
        }
        const urlMatchRegexp = toRegExp(urlToMatch);
        const isXML = function isXML(text) {
          if (typeof text === "string") {
            const trimedText = text.trim();
            if (trimedText.startsWith("<") && trimedText.endsWith(">")) {
              return true;
            }
          }
          return false;
        };
        const createXMLDocument = function createXMLDocument(text) {
          const xmlParser = new DOMParser();
          const xmlDocument = xmlParser.parseFromString(text, "text/xml");
          return xmlDocument;
        };
        const pruneXML = function pruneXML(text) {
          if (!isXML(text)) {
            shouldPruneResponse = false;
            return text;
          }
          const xmlDoc = createXMLDocument(text);
          const errorNode = xmlDoc.querySelector("parsererror");
          if (errorNode) {
            return text;
          }
          if (optionalProp !== "" && xmlDoc.querySelector(optionalProp) === null) {
            shouldPruneResponse = false;
            return text;
          }
          const elems = xmlDoc.querySelectorAll(propsToRemove);
          if (!elems.length) {
            shouldPruneResponse = false;
            return text;
          }
          elems.forEach(function (elem) {
            elem.remove();
          });
          const serializer = new XMLSerializer();
          text = serializer.serializeToString(xmlDoc);
          return text;
        };
        const xhrWrapper = function xhrWrapper(target, thisArg, args) {
          const xhrURL = args[1];
          if (typeof xhrURL !== "string" || xhrURL.length === 0) {
            return Reflect.apply(target, thisArg, args);
          }
          if (urlMatchRegexp.test(xhrURL)) {
            thisArg.addEventListener("readystatechange", function pruneResponse() {
              if (thisArg.readyState === 4) {
                const response = thisArg.response;
                thisArg.removeEventListener("readystatechange", pruneResponse);
                if (!shouldPruneResponse) {
                  if (isXML(response)) {
                    const message = "XMLHttpRequest.open() URL: ".concat(xhrURL, "\nresponse: ").concat(response);
                    logMessage(source, message);
                    logMessage(source, createXMLDocument(response), true, false);
                  }
                } else {
                  const prunedResponseContent = pruneXML(response);
                  if (shouldPruneResponse) {
                    Object.defineProperty(thisArg, "response", {
                      value: prunedResponseContent
                    });
                    Object.defineProperty(thisArg, "responseText", {
                      value: prunedResponseContent
                    });
                    hit(source);
                  }
                  shouldPruneResponse = true;
                }
              }
            });
          }
          return Reflect.apply(target, thisArg, args);
        };
        const xhrHandler = {
          apply: xhrWrapper
        };
        window.XMLHttpRequest.prototype.open = new Proxy(window.XMLHttpRequest.prototype.open, xhrHandler);
        const nativeFetch = window.fetch;
        const fetchWrapper = function fetchWrapper(target, thisArg, args) {
          const fetchURL = args[0] instanceof Request ? args[0].url : args[0];
          if (typeof fetchURL !== "string" || fetchURL.length === 0) {
            return Reflect.apply(target, thisArg, args);
          }
          if (urlMatchRegexp.test(fetchURL)) {
            return nativeFetch.apply(_this, args).then(function (response) {
              return response.text().then(function (text) {
                if (!shouldPruneResponse) {
                  if (isXML(text)) {
                    const message = "fetch URL: ".concat(fetchURL, "\nresponse text: ").concat(text);
                    logMessage(source, message);
                    logMessage(source, createXMLDocument(text), true, false);
                  }
                  return Reflect.apply(target, thisArg, args);
                }
                const prunedText = pruneXML(text);
                if (shouldPruneResponse) {
                  hit(source);
                  return new Response(prunedText, {
                    status: response.status,
                    statusText: response.statusText,
                    headers: response.headers
                  });
                }
                shouldPruneResponse = true;
                return Reflect.apply(target, thisArg, args);
              });
            });
          }
          return Reflect.apply(target, thisArg, args);
        };
        const fetchHandler = {
          apply: fetchWrapper
        };
        window.fetch = new Proxy(window.fetch, fetchHandler);
      }
      function hit(source) {
        if (source.verbose !== true) {
          return;
        }
        try {
          const log = console.log.bind(console);
          const trace = console.trace.bind(console);
          let prefix = source.ruleText || "";
          if (source.domainName) {
            const AG_SCRIPTLET_MARKER = "#%#//";
            const UBO_SCRIPTLET_MARKER = "##+js";
            let ruleStartIndex;
            if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
            } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
              ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
            }
            const rulePart = source.ruleText.slice(ruleStartIndex);
            prefix = "".concat(source.domainName).concat(rulePart);
          }
          log("".concat(prefix, " trace start"));
          if (trace) {
            trace();
          }
          log("".concat(prefix, " trace end"));
        } catch (e) {}
        if (typeof window.__debug === "function") {
          window.__debug(source);
        }
      }
      function logMessage(source, message) {
        let forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        const name = source.name,
          ruleText = source.ruleText,
          verbose = source.verbose;
        if (!forced && !verbose) {
          return;
        }
        const nativeConsole = console.log;
        if (!convertMessageToString) {
          nativeConsole("".concat(name, ":"), message);
          return;
        }
        let messageStr = "".concat(name, ": ").concat(message);
        if (ruleText) {
          const RULE_MARKER = "#%#//scriptlet";
          const markerIdx = ruleText.indexOf(RULE_MARKER);
          if (markerIdx > -1) {
            const ruleWithoutDomains = ruleText.slice(markerIdx, ruleText.length);
            messageStr += "; cannot apply rule: ".concat(ruleWithoutDomains);
          }
        }
        nativeConsole(messageStr);
      }
      function toRegExp() {
        let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        const DEFAULT_VALUE = ".?";
        const FORWARD_SLASH = "/";
        if (input === "") {
          return new RegExp(DEFAULT_VALUE);
        }
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
          return new RegExp(input.slice(1, -1));
        }
        const escaped = input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
      }
      const updatedArgs = args ? [].concat(source).concat(args) : [source];
      try {
        xmlPrune.apply(this, updatedArgs);
      } catch (e) {
        console.log(e);
      }
    }
    const scriptletsMap = {
      "abort-current-inline-script": abortCurrentInlineScript,
      "abort-current-script.js": abortCurrentInlineScript,
      "ubo-abort-current-script.js": abortCurrentInlineScript,
      "acs.js": abortCurrentInlineScript,
      "ubo-acs.js": abortCurrentInlineScript,
      "ubo-abort-current-script": abortCurrentInlineScript,
      "ubo-acs": abortCurrentInlineScript,
      "abort-current-inline-script.js": abortCurrentInlineScript,
      "ubo-abort-current-inline-script.js": abortCurrentInlineScript,
      "acis.js": abortCurrentInlineScript,
      "ubo-acis.js": abortCurrentInlineScript,
      "ubo-abort-current-inline-script": abortCurrentInlineScript,
      "ubo-acis": abortCurrentInlineScript,
      "abp-abort-current-inline-script": abortCurrentInlineScript,
      "abort-on-property-read": abortOnPropertyRead,
      "abort-on-property-read.js": abortOnPropertyRead,
      "ubo-abort-on-property-read.js": abortOnPropertyRead,
      "aopr.js": abortOnPropertyRead,
      "ubo-aopr.js": abortOnPropertyRead,
      "ubo-abort-on-property-read": abortOnPropertyRead,
      "ubo-aopr": abortOnPropertyRead,
      "abp-abort-on-property-read": abortOnPropertyRead,
      "abort-on-property-write": abortOnPropertyWrite,
      "abort-on-property-write.js": abortOnPropertyWrite,
      "ubo-abort-on-property-write.js": abortOnPropertyWrite,
      "aopw.js": abortOnPropertyWrite,
      "ubo-aopw.js": abortOnPropertyWrite,
      "ubo-abort-on-property-write": abortOnPropertyWrite,
      "ubo-aopw": abortOnPropertyWrite,
      "abp-abort-on-property-write": abortOnPropertyWrite,
      "abort-on-stack-trace": abortOnStackTrace,
      "abort-on-stack-trace.js": abortOnStackTrace,
      "ubo-abort-on-stack-trace.js": abortOnStackTrace,
      "aost.js": abortOnStackTrace,
      "ubo-aost.js": abortOnStackTrace,
      "ubo-abort-on-stack-trace": abortOnStackTrace,
      "ubo-aost": abortOnStackTrace,
      "abp-abort-on-stack-trace": abortOnStackTrace,
      "adjust-setInterval": adjustSetInterval,
      "nano-setInterval-booster.js": adjustSetInterval,
      "ubo-nano-setInterval-booster.js": adjustSetInterval,
      "nano-sib.js": adjustSetInterval,
      "ubo-nano-sib.js": adjustSetInterval,
      "ubo-nano-setInterval-booster": adjustSetInterval,
      "ubo-nano-sib": adjustSetInterval,
      "adjust-setTimeout": adjustSetTimeout,
      "nano-setTimeout-booster.js": adjustSetTimeout,
      "ubo-nano-setTimeout-booster.js": adjustSetTimeout,
      "nano-stb.js": adjustSetTimeout,
      "ubo-nano-stb.js": adjustSetTimeout,
      "ubo-nano-setTimeout-booster": adjustSetTimeout,
      "ubo-nano-stb": adjustSetTimeout,
      "debug-current-inline-script": debugCurrentInlineScript,
      "debug-on-property-read": debugOnPropertyRead,
      "debug-on-property-write": debugOnPropertyWrite,
      "dir-string": dirString,
      "abp-dir-string": dirString,
      "disable-newtab-links": disableNewtabLinks,
      "disable-newtab-links.js": disableNewtabLinks,
      "ubo-disable-newtab-links.js": disableNewtabLinks,
      "ubo-disable-newtab-links": disableNewtabLinks,
      "close-window": forceWindowClose,
      "window-close-if.js": forceWindowClose,
      "ubo-window-close-if.js": forceWindowClose,
      "ubo-window-close-if": forceWindowClose,
      "hide-in-shadow-dom": hideInShadowDom,
      "inject-css-in-shadow-dom": injectCssInShadowDom,
      "json-prune": jsonPrune,
      "json-prune.js": jsonPrune,
      "ubo-json-prune.js": jsonPrune,
      "ubo-json-prune": jsonPrune,
      "abp-json-prune": jsonPrune,
      log: log,
      "log-addEventListener": logAddEventListener,
      "addEventListener-logger.js": logAddEventListener,
      "ubo-addEventListener-logger.js": logAddEventListener,
      "aell.js": logAddEventListener,
      "ubo-aell.js": logAddEventListener,
      "ubo-addEventListener-logger": logAddEventListener,
      "ubo-aell": logAddEventListener,
      "log-eval": logEval,
      "log-on-stack-trace": logOnStacktrace,
      "m3u-prune": m3uPrune,
      "m3u-prune.js": m3uPrune,
      "ubo-m3u-prune.js": m3uPrune,
      "ubo-m3u-prune": m3uPrune,
      "no-topics": noTopics,
      noeval: noeval,
      "noeval.js": noeval,
      "silent-noeval.js": noeval,
      "ubo-noeval.js": noeval,
      "ubo-silent-noeval.js": noeval,
      "ubo-noeval": noeval,
      "ubo-silent-noeval": noeval,
      nowebrtc: nowebrtc,
      "nowebrtc.js": nowebrtc,
      "ubo-nowebrtc.js": nowebrtc,
      "ubo-nowebrtc": nowebrtc,
      "prevent-addEventListener": preventAddEventListener,
      "addEventListener-defuser.js": preventAddEventListener,
      "ubo-addEventListener-defuser.js": preventAddEventListener,
      "aeld.js": preventAddEventListener,
      "ubo-aeld.js": preventAddEventListener,
      "ubo-addEventListener-defuser": preventAddEventListener,
      "ubo-aeld": preventAddEventListener,
      "prevent-adfly": preventAdfly,
      "adfly-defuser.js": preventAdfly,
      "ubo-adfly-defuser.js": preventAdfly,
      "ubo-adfly-defuser": preventAdfly,
      "prevent-bab": preventBab,
      "prevent-element-src-loading": preventElementSrcLoading,
      "prevent-eval-if": preventEvalIf,
      "noeval-if.js": preventEvalIf,
      "ubo-noeval-if.js": preventEvalIf,
      "ubo-noeval-if": preventEvalIf,
      "prevent-fab-3.2.0": preventFab,
      "nofab.js": preventFab,
      "ubo-nofab.js": preventFab,
      "fuckadblock.js-3.2.0": preventFab,
      "ubo-fuckadblock.js-3.2.0": preventFab,
      "ubo-nofab": preventFab,
      "prevent-fetch": preventFetch,
      "no-fetch-if.js": preventFetch,
      "ubo-no-fetch-if.js": preventFetch,
      "ubo-no-fetch-if": preventFetch,
      "prevent-popads-net": preventPopadsNet,
      "popads.net.js": preventPopadsNet,
      "ubo-popads.net.js": preventPopadsNet,
      "ubo-popads.net": preventPopadsNet,
      "prevent-refresh": preventRefresh,
      "refresh-defuser.js": preventRefresh,
      "refresh-defuser": preventRefresh,
      "ubo-refresh-defuser.js": preventRefresh,
      "ubo-refresh-defuser": preventRefresh,
      "prevent-requestAnimationFrame": preventRequestAnimationFrame,
      "no-requestAnimationFrame-if.js": preventRequestAnimationFrame,
      "ubo-no-requestAnimationFrame-if.js": preventRequestAnimationFrame,
      "norafif.js": preventRequestAnimationFrame,
      "ubo-norafif.js": preventRequestAnimationFrame,
      "ubo-no-requestAnimationFrame-if": preventRequestAnimationFrame,
      "ubo-norafif": preventRequestAnimationFrame,
      "prevent-setInterval": preventSetInterval,
      "no-setInterval-if.js": preventSetInterval,
      "ubo-no-setInterval-if.js": preventSetInterval,
      "setInterval-defuser.js": preventSetInterval,
      "ubo-setInterval-defuser.js": preventSetInterval,
      "nosiif.js": preventSetInterval,
      "ubo-nosiif.js": preventSetInterval,
      "sid.js": preventSetInterval,
      "ubo-sid.js": preventSetInterval,
      "ubo-no-setInterval-if": preventSetInterval,
      "ubo-setInterval-defuser": preventSetInterval,
      "ubo-nosiif": preventSetInterval,
      "ubo-sid": preventSetInterval,
      "prevent-setTimeout": preventSetTimeout,
      "no-setTimeout-if.js": preventSetTimeout,
      "ubo-no-setTimeout-if.js": preventSetTimeout,
      "nostif.js": preventSetTimeout,
      "ubo-nostif.js": preventSetTimeout,
      "ubo-no-setTimeout-if": preventSetTimeout,
      "ubo-nostif": preventSetTimeout,
      "setTimeout-defuser.js": preventSetTimeout,
      "ubo-setTimeout-defuser.js": preventSetTimeout,
      "ubo-setTimeout-defuser": preventSetTimeout,
      "std.js": preventSetTimeout,
      "ubo-std.js": preventSetTimeout,
      "ubo-std": preventSetTimeout,
      "prevent-window-open": preventWindowOpen,
      "window.open-defuser.js": preventWindowOpen,
      "ubo-window.open-defuser.js": preventWindowOpen,
      "ubo-window.open-defuser": preventWindowOpen,
      "nowoif.js": preventWindowOpen,
      "ubo-nowoif.js": preventWindowOpen,
      "ubo-nowoif": preventWindowOpen,
      "prevent-xhr": preventXHR,
      "no-xhr-if.js": preventXHR,
      "ubo-no-xhr-if.js": preventXHR,
      "ubo-no-xhr-if": preventXHR,
      "remove-attr": removeAttr,
      "remove-attr.js": removeAttr,
      "ubo-remove-attr.js": removeAttr,
      "ra.js": removeAttr,
      "ubo-ra.js": removeAttr,
      "ubo-remove-attr": removeAttr,
      "ubo-ra": removeAttr,
      "remove-class": removeClass,
      "remove-class.js": removeClass,
      "ubo-remove-class.js": removeClass,
      "rc.js": removeClass,
      "ubo-rc.js": removeClass,
      "ubo-remove-class": removeClass,
      "ubo-rc": removeClass,
      "remove-cookie": removeCookie,
      "cookie-remover.js": removeCookie,
      "ubo-cookie-remover.js": removeCookie,
      "ubo-cookie-remover": removeCookie,
      "remove-in-shadow-dom": removeInShadowDom,
      "set-attr": setAttr,
      "set-constant": setConstant,
      "set-constant.js": setConstant,
      "ubo-set-constant.js": setConstant,
      "set.js": setConstant,
      "ubo-set.js": setConstant,
      "ubo-set-constant": setConstant,
      "ubo-set": setConstant,
      "abp-override-property-read": setConstant,
      "set-cookie": setCookie,
      "set-cookie-reload": setCookieReload,
      "set-local-storage-item": setLocalStorageItem,
      "set-popads-dummy": setPopadsDummy,
      "popads-dummy.js": setPopadsDummy,
      "ubo-popads-dummy.js": setPopadsDummy,
      "ubo-popads-dummy": setPopadsDummy,
      "set-session-storage-item": setSessionStorageItem,
      "trusted-click-element": trustedClickElement,
      "trusted-replace-fetch-response": trustedReplaceFetchResponse,
      "trusted-replace-xhr-response": trustedReplaceXhrResponse,
      "trusted-set-constant": trustedSetConstant,
      "trusted-set-cookie": trustedSetCookie,
      "trusted-set-cookie-reload": trustedSetCookieReload,
      "trusted-set-local-storage-item": trustedSetLocalStorageItem,
      "xml-prune": xmlPrune,
      "xml-prune.js": xmlPrune,
      "ubo-xml-prune.js": xmlPrune,
      "ubo-xml-prune": xmlPrune
    };
    var getScriptletFunction = function getScriptletFunction(name) {
      return scriptletsMap[name];
    };
    function getScriptletCode(source) {
      if (!validator.isValidScriptletName(source.name)) {
        return null;
      }
      const scriptletFunction = getScriptletFunction(source.name);
      if (typeof scriptletFunction !== 'function') {
        throw new Error("Error: cannot invoke scriptlet with name: '".concat(source.name, "'"));
      }
      const scriptletFunctionString = scriptletFunction.toString();
      const result = source.engine === 'corelibs' || source.engine === 'test' ? wrapInNonameFunc(scriptletFunctionString) : passSourceAndProps(source, scriptletFunctionString);
      return result;
    }
    const scriptletsObject = function () {
      return {
        invoke: getScriptletCode,
        getScriptletFunction,
        isValidScriptletName: validator.isValidScriptletName,
        isValidScriptletRule,
        isAdgScriptletRule: validator.isAdgScriptletRule,
        isUboScriptletRule: validator.isUboScriptletRule,
        isAbpSnippetRule: validator.isAbpSnippetRule,
        convertUboToAdg: convertUboScriptletToAdg,
        convertAbpToAdg: convertAbpSnippetToAdg,
        convertScriptletToAdg,
        convertAdgToUbo: convertAdgScriptletToUbo,
        redirects
      };
    }();
    scriptlets_umd.exports = scriptletsObject;
}));
var scriptlets = scriptlets_umd.exports;

/**
 * Redirect modifier class
 */
var RedirectModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     * @param ruleText
     * @param isAllowlist
     * @param isRedirectingOnlyBlocked is redirect-rule modifier
     */
    function RedirectModifier(value, ruleText, isAllowlist, isRedirectingOnlyBlocked) {
        if (isRedirectingOnlyBlocked === void 0) { isRedirectingOnlyBlocked = false; }
        /**
         * Is redirecting only blocked requests
         * See $redirect-rule options
         */
        this.isRedirectingOnlyBlocked = false;
        RedirectModifier.validate(ruleText, value, isAllowlist);
        this.redirectTitle = value;
        this.isRedirectingOnlyBlocked = isRedirectingOnlyBlocked;
    }
    /**
     * Redirect title
     */
    RedirectModifier.prototype.getValue = function () {
        return this.redirectTitle;
    };
    /**
     * Validates redirect rule
     *
     * @param ruleText
     * @param redirectTitle
     * @param isAllowlist
     */
    RedirectModifier.validate = function (ruleText, redirectTitle, isAllowlist) {
        if (isAllowlist && !redirectTitle) {
            return;
        }
        if (!redirectTitle) {
            throw new SyntaxError('Invalid $redirect rule, redirect value must not be empty');
        }
        var redirects = scriptlets.redirects;
        var ruleTextToValidate = ruleText.replace(NETWORK_RULE_OPTIONS.REDIRECTRULE, NETWORK_RULE_OPTIONS.REDIRECT);
        if (!redirects.isAdgRedirectRule(ruleTextToValidate) || !redirects.isValidAdgRedirectRule(ruleTextToValidate)) {
            throw new SyntaxError('$redirect modifier is invalid');
        }
    };
    return RedirectModifier;
}());

var ErrorStatusCodes;
(function (ErrorStatusCodes) {
    ErrorStatusCodes[ErrorStatusCodes["ComplexRegex"] = 1001] = "ComplexRegex";
    ErrorStatusCodes[ErrorStatusCodes["RuleLimit"] = 1002] = "RuleLimit";
    ErrorStatusCodes[ErrorStatusCodes["RegexpRuleLimit"] = 1003] = "RegexpRuleLimit";
    ErrorStatusCodes[ErrorStatusCodes["RemoveparamRegexpIsNotSupported"] = 1004] = "RemoveparamRegexpIsNotSupported";
    ErrorStatusCodes[ErrorStatusCodes["RemoveparamInversionIsNotSupported"] = 1005] = "RemoveparamInversionIsNotSupported";
})(ErrorStatusCodes || (ErrorStatusCodes = {}));
var SEPARATOR = '|';

/**
 * Query parameters filtering modifier class
 * Works with '$removeparam' modifier
 */
var RemoveParamModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     */
    function RemoveParamModifier(value) {
        /**
         * Value list
         */
        this.valueList = [];
        this.value = value;
        var rawValue = value;
        if (value.startsWith('~')) {
            rawValue = value.substring(1);
            this.errorMv3 = ErrorStatusCodes.RemoveparamInversionIsNotSupported;
        }
        if (rawValue.startsWith('/')) {
            this.valueRegExp = SimpleRegex.patternFromString(rawValue);
            this.errorMv3 = ErrorStatusCodes.RemoveparamRegexpIsNotSupported;
        }
        else {
            this.valueRegExp = new RegExp("((^|&)(".concat(SimpleRegex.escapeRegexSpecials(rawValue), ")=[^&#]*)"), 'g');
        }
        if (!this.errorMv3 && rawValue.length !== 0) {
            this.valueList = rawValue.split(SEPARATOR);
            if (this.valueList.some(function (param) { return param.startsWith('~'); })) {
                this.errorMv3 = ErrorStatusCodes.RemoveparamInversionIsNotSupported;
            }
        }
    }
    /**
     * Modifier value
     */
    RemoveParamModifier.prototype.getValue = function () {
        return this.value;
    };
    /**
     * Modifier value list
     */
    RemoveParamModifier.prototype.getValueList = function () {
        return this.valueList;
    };
    /**
     * MV3 error code
     */
    RemoveParamModifier.prototype.getErrorMv3 = function () {
        return this.errorMv3;
    };
    /**
     * Removes query parameters from url
     *
     * @param url
     */
    RemoveParamModifier.prototype.removeParameters = function (url) {
        var sepIndex = url.indexOf('?');
        if (sepIndex < 0) {
            return url;
        }
        if (!this.value) {
            return url.substring(0, sepIndex);
        }
        if (sepIndex === url.length - 1) {
            return url;
        }
        if (this.value.startsWith('~')) {
            return cleanUrlParamByRegExp(url, this.valueRegExp, true);
        }
        return cleanUrlParamByRegExp(url, this.valueRegExp);
    };
    return RemoveParamModifier;
}());

/**
 * Headers filtering modifier class.
 * Rules with $removeheader modifier are intended to remove headers from HTTP requests and responses.
 */
var RemoveHeaderModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     * @param isAllowlist
     */
    function RemoveHeaderModifier(value, isAllowlist) {
        this.value = value.toLowerCase();
        if (!isAllowlist && !this.value) {
            throw new SyntaxError('Invalid $removeheader rule, removeheader value must not be empty');
        }
        this.isRequestModifier = this.value.startsWith(RemoveHeaderModifier.REQUEST_PREFIX);
        var headerName = this.isRequestModifier
            ? this.value.substring(RemoveHeaderModifier.REQUEST_PREFIX.length) : this.value;
        this.applicableHeaderName = RemoveHeaderModifier.isAllowedHeader(headerName) ? headerName : null;
    }
    /**
     * Modifier value
     */
    RemoveHeaderModifier.prototype.getValue = function () {
        return this.value;
    };
    /**
     * Returns effective header name to be removed
     *
     * @param isRequestHeaders
     */
    RemoveHeaderModifier.prototype.getApplicableHeaderName = function (isRequestHeaders) {
        if (!this.applicableHeaderName) {
            return null;
        }
        if (isRequestHeaders !== this.isRequestModifier) {
            return null;
        }
        return this.applicableHeaderName;
    };
    /**
     * Some headers are forbidden to remove
     *
     * @param headerName
     */
    RemoveHeaderModifier.isAllowedHeader = function (headerName) {
        return !this.FORBIDDEN_HEADERS.includes(headerName);
    };
    /**
     * List of forbidden headers
     */
    RemoveHeaderModifier.FORBIDDEN_HEADERS = [
        'access-control-allow-origin',
        'access-control-allow-credentials',
        'access-control-allow-headers',
        'access-control-allow-methods',
        'access-control-expose-headers',
        'access-control-max-age',
        'access-control-request-headers',
        'access-control-request-method',
        'origin',
        'timing-allow-origin',
        'allow',
        'cross-origin-embedder-policy',
        'cross-origin-opener-policy',
        'cross-origin-resource-policy',
        'content-security-policy',
        'content-security-policy-report-only',
        'expect-ct',
        'feature-policy',
        'origin-isolation',
        'strict-transport-security',
        'upgrade-insecure-requests',
        'x-content-type-options',
        'x-download-options',
        'x-frame-options',
        'x-permitted-cross-domain-policies',
        'x-powered-by',
        'x-xss-protection',
        'public-key-pins',
        'public-key-pins-report-only',
        'sec-websocket-key',
        'sec-websocket-extensions',
        'sec-websocket-accept',
        'sec-websocket-protocol',
        'sec-websocket-version',
        'p3p',
        'sec-fetch-mode',
        'sec-fetch-dest',
        'sec-fetch-site',
        'sec-fetch-user',
        'referrer-policy',
        'content-type',
        'content-length',
        'accept',
        'accept-encoding',
        'host',
        'connection',
        'transfer-encoding',
        'upgrade',
    ];
    /**
     * Request prefix
     */
    RemoveHeaderModifier.REQUEST_PREFIX = 'request:';
    return RemoveHeaderModifier;
}());

/**
 * This is a helper class that is used specifically to work with app restrictions.
 *
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
 *
 * Examples:
 * ||baddomain.com^$app=org.example.app
 * ||baddomain.com^$app=org.example.app1|org.example.app2
 */
var AppModifier = /** @class */ (function () {
    /**
     * Parses the `apps` string
     *
     * @param apps - apps string
     *
     * @throws an error if the app string is empty or invalid
     */
    function AppModifier(apps) {
        if (!apps) {
            throw new SyntaxError('$app modifier cannot be empty');
        }
        var permittedApps = [];
        var restrictedApps = [];
        var parts = apps.split(SEPARATOR);
        for (var i = 0; i < parts.length; i += 1) {
            var app = parts[i];
            var restricted = false;
            if (app.startsWith('~')) {
                restricted = true;
                app = app.substring(1).trim();
            }
            if (app === '') {
                throw new SyntaxError("Empty app specified in \"".concat(apps, "\""));
            }
            if (restricted) {
                restrictedApps.push(app);
            }
            else {
                permittedApps.push(app);
            }
        }
        this.restrictedApps = restrictedApps.length > 0 ? restrictedApps : null;
        this.permittedApps = permittedApps.length > 0 ? permittedApps : null;
    }
    return AppModifier;
}());

var isCidr$1 = {exports: {}};

var cidrRegex = {exports: {}};

const word = '[a-fA-F\\d:]';
const b = options => options && options.includeBoundaries ?
	`(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` :
	'';
const v4$1 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';
const v6seg = '[a-fA-F\\d]{1,4}';
const v6$1 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4$1}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4$1}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4$1}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4$1}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4$1}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4$1}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4$1}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim();
const v46Exact = new RegExp(`(?:^${v4$1}$)|(?:^${v6$1}$)`);
const v4exact$1 = new RegExp(`^${v4$1}$`);
const v6exact$1 = new RegExp(`^${v6$1}$`);
const ip = options => options && options.exact ?
	v46Exact :
	new RegExp(`(?:${b(options)}${v4$1}${b(options)})|(?:${b(options)}${v6$1}${b(options)})`, 'g');
ip.v4 = options => options && options.exact ? v4exact$1 : new RegExp(`${b(options)}${v4$1}${b(options)}`, 'g');
ip.v6 = options => options && options.exact ? v6exact$1 : new RegExp(`${b(options)}${v6$1}${b(options)}`, 'g');
var ipRegex$2 = ip;

const ipRegex$1 = ipRegex$2;
const defaultOpts = {exact: false};
const v4str = `${ipRegex$1.v4().source}\\/(3[0-2]|[12]?[0-9])`;
const v6str = `${ipRegex$1.v6().source}\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])`;
const v4exact = new RegExp(`^${v4str}$`);
const v6exact = new RegExp(`^${v6str}$`);
const v46exact = new RegExp(`(?:^${v4str}$)|(?:^${v6str}$)`);
cidrRegex.exports = ({exact} = defaultOpts) => exact ? v46exact : new RegExp(`(?:${v4str})|(?:${v6str})`, "g");
cidrRegex.exports.v4 = ({exact} = defaultOpts) => exact ? v4exact : new RegExp(v4str, "g");
cidrRegex.exports.v6 = ({exact} = defaultOpts) => exact ? v6exact : new RegExp(v6str, "g");

const {v4, v6} = cidrRegex.exports;
const re4 = v4({exact: true});
const re6 = v6({exact: true});
isCidr$1.exports = str => re4.test(str) ? 4 : (re6.test(str) ? 6 : 0);
isCidr$1.exports.v4 = str => re4.test(str);
isCidr$1.exports.v6 = str => re6.test(str);
var isCidr = isCidr$1.exports;

const ipRegex = ipRegex$2;
const isIp = string => ipRegex({exact: true}).test(string);
isIp.v4 = string => ipRegex.v4({exact: true}).test(string);
isIp.v6 = string => ipRegex.v6({exact: true}).test(string);
isIp.version = string => isIp(string) ? (isIp.v4(string) ? 4 : 6) : undefined;
var isIp_1 = isIp;

var Netmask_1;
(function() {
  var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;
  long2ip = function(long) {
    var a, b, c, d;
    a = (long & (0xff << 24)) >>> 24;
    b = (long & (0xff << 16)) >>> 16;
    c = (long & (0xff << 8)) >>> 8;
    d = long & 0xff;
    return [a, b, c, d].join('.');
  };
  ip2long = function(ip) {
    var b, c, i, j, n, ref;
    b = [];
    for (i = j = 0; j <= 3; i = ++j) {
      if (ip.length === 0) {
        break;
      }
      if (i > 0) {
        if (ip[0] !== '.') {
          throw new Error('Invalid IP');
        }
        ip = ip.substring(1);
      }
      ref = atob(ip), n = ref[0], c = ref[1];
      ip = ip.substring(c);
      b.push(n);
    }
    if (ip.length !== 0) {
      throw new Error('Invalid IP');
    }
    switch (b.length) {
      case 1:
        if (b[0] > 0xFFFFFFFF) {
          throw new Error('Invalid IP');
        }
        return b[0] >>> 0;
      case 2:
        if (b[0] > 0xFF || b[1] > 0xFFFFFF) {
          throw new Error('Invalid IP');
        }
        return (b[0] << 24 | b[1]) >>> 0;
      case 3:
        if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFFFF) {
          throw new Error('Invalid IP');
        }
        return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
      case 4:
        if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFF || b[3] > 0xFF) {
          throw new Error('Invalid IP');
        }
        return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
      default:
        throw new Error('Invalid IP');
    }
  };
  chr = function(b) {
    return b.charCodeAt(0);
  };
  chr0 = chr('0');
  chra = chr('a');
  chrA = chr('A');
  atob = function(s) {
    var base, dmax, i, n, start;
    n = 0;
    base = 10;
    dmax = '9';
    i = 0;
    if (s.length > 1 && s[i] === '0') {
      if (s[i + 1] === 'x' || s[i + 1] === 'X') {
        i += 2;
        base = 16;
      } else if ('0' <= s[i + 1] && s[i + 1] <= '9') {
        i++;
        base = 8;
        dmax = '7';
      }
    }
    start = i;
    while (i < s.length) {
      if ('0' <= s[i] && s[i] <= dmax) {
        n = (n * base + (chr(s[i]) - chr0)) >>> 0;
      } else if (base === 16) {
        if ('a' <= s[i] && s[i] <= 'f') {
          n = (n * base + (10 + chr(s[i]) - chra)) >>> 0;
        } else if ('A' <= s[i] && s[i] <= 'F') {
          n = (n * base + (10 + chr(s[i]) - chrA)) >>> 0;
        } else {
          break;
        }
      } else {
        break;
      }
      if (n > 0xFFFFFFFF) {
        throw new Error('too large');
      }
      i++;
    }
    if (i === start) {
      throw new Error('empty octet');
    }
    return [n, i];
  };
  Netmask = (function() {
    function Netmask(net, mask) {
      var i, j, ref;
      if (typeof net !== 'string') {
        throw new Error("Missing `net' parameter");
      }
      if (!mask) {
        ref = net.split('/', 2), net = ref[0], mask = ref[1];
      }
      if (!mask) {
        mask = 32;
      }
      if (typeof mask === 'string' && mask.indexOf('.') > -1) {
        try {
          this.maskLong = ip2long(mask);
        } catch (error1) {
          throw new Error("Invalid mask: " + mask);
        }
        for (i = j = 32; j >= 0; i = --j) {
          if (this.maskLong === (0xffffffff << (32 - i)) >>> 0) {
            this.bitmask = i;
            break;
          }
        }
      } else if (mask || mask === 0) {
        this.bitmask = parseInt(mask, 10);
        this.maskLong = 0;
        if (this.bitmask > 0) {
          this.maskLong = (0xffffffff << (32 - this.bitmask)) >>> 0;
        }
      } else {
        throw new Error("Invalid mask: empty");
      }
      try {
        this.netLong = (ip2long(net) & this.maskLong) >>> 0;
      } catch (error1) {
        throw new Error("Invalid net address: " + net);
      }
      if (!(this.bitmask <= 32)) {
        throw new Error("Invalid mask for ip4: " + mask);
      }
      this.size = Math.pow(2, 32 - this.bitmask);
      this.base = long2ip(this.netLong);
      this.mask = long2ip(this.maskLong);
      this.hostmask = long2ip(~this.maskLong);
      this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
      this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
      this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
    }
    Netmask.prototype.contains = function(ip) {
      if (typeof ip === 'string' && (ip.indexOf('/') > 0 || ip.split('.').length !== 4)) {
        ip = new Netmask(ip);
      }
      if (ip instanceof Netmask) {
        return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
      } else {
        return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
      }
    };
    Netmask.prototype.next = function(count) {
      if (count == null) {
        count = 1;
      }
      return new Netmask(long2ip(this.netLong + (this.size * count)), this.mask);
    };
    Netmask.prototype.forEach = function(fn) {
      var index, lastLong, long;
      long = ip2long(this.first);
      lastLong = ip2long(this.last);
      index = 0;
      while (long <= lastLong) {
        fn(long2ip(long), long, index);
        index++;
        long++;
      }
    };
    Netmask.prototype.toString = function() {
      return this.base + "/" + this.bitmask;
    };
    return Netmask;
  })();
  Netmask_1 = Netmask;
}).call(commonjsGlobal);

var global$2 = (typeof global !== "undefined" ? global :
            typeof self !== "undefined" ? self :
            typeof window !== "undefined" ? window : {});

var lookup$1 = [];
var revLookup$1 = [];
var Arr$1 = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited$1 = false;
function init$1 () {
  inited$1 = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup$1[i] = code[i];
    revLookup$1[code.charCodeAt(i)] = i;
  }
  revLookup$1['-'.charCodeAt(0)] = 62;
  revLookup$1['_'.charCodeAt(0)] = 63;
}
function toByteArray$1 (b64) {
  if (!inited$1) {
    init$1();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
  arr = new Arr$1(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup$1[b64.charCodeAt(i)] << 18) | (revLookup$1[b64.charCodeAt(i + 1)] << 12) | (revLookup$1[b64.charCodeAt(i + 2)] << 6) | revLookup$1[b64.charCodeAt(i + 3)];
    arr[L++] = (tmp >> 16) & 0xFF;
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }
  if (placeHolders === 2) {
    tmp = (revLookup$1[b64.charCodeAt(i)] << 2) | (revLookup$1[b64.charCodeAt(i + 1)] >> 4);
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = (revLookup$1[b64.charCodeAt(i)] << 10) | (revLookup$1[b64.charCodeAt(i + 1)] << 4) | (revLookup$1[b64.charCodeAt(i + 2)] >> 2);
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }
  return arr
}
function tripletToBase64$1 (num) {
  return lookup$1[num >> 18 & 0x3F] + lookup$1[num >> 12 & 0x3F] + lookup$1[num >> 6 & 0x3F] + lookup$1[num & 0x3F]
}
function encodeChunk$1 (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output.push(tripletToBase64$1(tmp));
  }
  return output.join('')
}
function fromByteArray$1 (uint8) {
  if (!inited$1) {
    init$1();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = '';
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk$1(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup$1[tmp >> 2];
    output += lookup$1[(tmp << 4) & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
    output += lookup$1[tmp >> 10];
    output += lookup$1[(tmp >> 4) & 0x3F];
    output += lookup$1[(tmp << 2) & 0x3F];
    output += '=';
  }
  parts.push(output);
  return parts.join('')
}

function read$1 (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}
function write$1 (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s * 128;
}

var toString$1 = {}.toString;
var isArray$3 = Array.isArray || function (arr) {
  return toString$1.call(arr) == '[object Array]';
};

var INSPECT_MAX_BYTES$1 = 50;
Buffer$1.TYPED_ARRAY_SUPPORT = global$2.TYPED_ARRAY_SUPPORT !== undefined
  ? global$2.TYPED_ARRAY_SUPPORT
  : true;
kMaxLength$1();
function kMaxLength$1 () {
  return Buffer$1.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}
function createBuffer$1 (that, length) {
  if (kMaxLength$1() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer$1.prototype;
  } else {
    if (that === null) {
      that = new Buffer$1(length);
    }
    that.length = length;
  }
  return that
}
function Buffer$1 (arg, encodingOrOffset, length) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
    return new Buffer$1(arg, encodingOrOffset, length)
  }
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe$1(this, arg)
  }
  return from$1(this, arg, encodingOrOffset, length)
}
Buffer$1.poolSize = 8192;
Buffer$1._augment = function (arr) {
  arr.__proto__ = Buffer$1.prototype;
  return arr
};
function from$1 (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer$1(that, value, encodingOrOffset, length)
  }
  if (typeof value === 'string') {
    return fromString$1(that, value, encodingOrOffset)
  }
  return fromObject$1(that, value)
}
Buffer$1.from = function (value, encodingOrOffset, length) {
  return from$1(null, value, encodingOrOffset, length)
};
if (Buffer$1.TYPED_ARRAY_SUPPORT) {
  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
  Buffer$1.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer$1[Symbol.species] === Buffer$1) ;
}
function assertSize$1 (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}
function alloc$1 (that, size, fill, encoding) {
  assertSize$1(size);
  if (size <= 0) {
    return createBuffer$1(that, size)
  }
  if (fill !== undefined) {
    return typeof encoding === 'string'
      ? createBuffer$1(that, size).fill(fill, encoding)
      : createBuffer$1(that, size).fill(fill)
  }
  return createBuffer$1(that, size)
}
Buffer$1.alloc = function (size, fill, encoding) {
  return alloc$1(null, size, fill, encoding)
};
function allocUnsafe$1 (that, size) {
  assertSize$1(size);
  that = createBuffer$1(that, size < 0 ? 0 : checked$1(size) | 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that
}
Buffer$1.allocUnsafe = function (size) {
  return allocUnsafe$1(null, size)
};
Buffer$1.allocUnsafeSlow = function (size) {
  return allocUnsafe$1(null, size)
};
function fromString$1 (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }
  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }
  var length = byteLength$1(string, encoding) | 0;
  that = createBuffer$1(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that
}
function fromArrayLike$1 (that, array) {
  var length = array.length < 0 ? 0 : checked$1(array.length) | 0;
  that = createBuffer$1(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that
}
function fromArrayBuffer$1 (that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }
  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer$1.prototype;
  } else {
    that = fromArrayLike$1(that, array);
  }
  return that
}
function fromObject$1 (that, obj) {
  if (internalIsBuffer$1(obj)) {
    var len = checked$1(obj.length) | 0;
    that = createBuffer$1(that, len);
    if (that.length === 0) {
      return that
    }
    obj.copy(that, 0, 0, len);
    return that
  }
  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan$1(obj.length)) {
        return createBuffer$1(that, 0)
      }
      return fromArrayLike$1(that, obj)
    }
    if (obj.type === 'Buffer' && isArray$3(obj.data)) {
      return fromArrayLike$1(that, obj.data)
    }
  }
  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}
function checked$1 (length) {
  if (length >= kMaxLength$1()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength$1().toString(16) + ' bytes')
  }
  return length | 0
}
Buffer$1.isBuffer = isBuffer$2;
function internalIsBuffer$1 (b) {
  return !!(b != null && b._isBuffer)
}
Buffer$1.compare = function compare (a, b) {
  if (!internalIsBuffer$1(a) || !internalIsBuffer$1(b)) {
    throw new TypeError('Arguments must be Buffers')
  }
  if (a === b) return 0
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
};
Buffer$1.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};
Buffer$1.concat = function concat (list, length) {
  if (!isArray$3(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }
  if (list.length === 0) {
    return Buffer$1.alloc(0)
  }
  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer$1.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer$1(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};
function byteLength$1 (string, encoding) {
  if (internalIsBuffer$1(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }
  var len = string.length;
  if (len === 0) return 0
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes$1(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes$1(string).length
      default:
        if (loweredCase) return utf8ToBytes$1(string).length
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$1.byteLength = byteLength$1;
function slowToString$1 (encoding, start, end) {
  var loweredCase = false;
  if (start === undefined || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return ''
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return ''
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return ''
  }
  if (!encoding) encoding = 'utf8';
  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice$1(this, start, end)
      case 'utf8':
      case 'utf-8':
        return utf8Slice$1(this, start, end)
      case 'ascii':
        return asciiSlice$1(this, start, end)
      case 'latin1':
      case 'binary':
        return latin1Slice$1(this, start, end)
      case 'base64':
        return base64Slice$1(this, start, end)
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice$1(this, start, end)
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$1.prototype._isBuffer = true;
function swap$1 (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer$1.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap$1(this, i, i + 1);
  }
  return this
};
Buffer$1.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap$1(this, i, i + 3);
    swap$1(this, i + 1, i + 2);
  }
  return this
};
Buffer$1.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap$1(this, i, i + 7);
    swap$1(this, i + 1, i + 6);
    swap$1(this, i + 2, i + 5);
    swap$1(this, i + 3, i + 4);
  }
  return this
};
Buffer$1.prototype.toString = function toString () {
  var length = this.length | 0;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice$1(this, 0, length)
  return slowToString$1.apply(this, arguments)
};
Buffer$1.prototype.equals = function equals (b) {
  if (!internalIsBuffer$1(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer$1.compare(this, b) === 0
};
Buffer$1.prototype.inspect = function inspect () {
  var str = '';
  var max = INSPECT_MAX_BYTES$1;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>'
};
Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer$1(target)) {
    throw new TypeError('Argument must be a Buffer')
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
};
function bidirectionalIndexOf$1 (buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : (buffer.length - 1);
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }
  if (typeof val === 'string') {
    val = Buffer$1.from(val, encoding);
  }
  if (internalIsBuffer$1(val)) {
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf$1(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF;
    if (Buffer$1.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf$1(buffer, [ val ], byteOffset, encoding, dir)
  }
  throw new TypeError('val must be string, number or Buffer')
}
function arrayIndexOf$1 (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }
  return -1
}
Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};
Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf$1(this, val, byteOffset, encoding, true)
};
Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf$1(this, val, byteOffset, encoding, false)
};
function hexWrite$1 (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}
function utf8Write$1 (buf, string, offset, length) {
  return blitBuffer$1(utf8ToBytes$1(string, buf.length - offset), buf, offset, length)
}
function asciiWrite$1 (buf, string, offset, length) {
  return blitBuffer$1(asciiToBytes$1(string), buf, offset, length)
}
function latin1Write$1 (buf, string, offset, length) {
  return asciiWrite$1(buf, string, offset, length)
}
function base64Write$1 (buf, string, offset, length) {
  return blitBuffer$1(base64ToBytes$1(string), buf, offset, length)
}
function ucs2Write$1 (buf, string, offset, length) {
  return blitBuffer$1(utf16leToBytes$1(string, buf.length - offset), buf, offset, length)
}
Buffer$1.prototype.write = function write (string, offset, length, encoding) {
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }
  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;
  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }
  if (!encoding) encoding = 'utf8';
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite$1(this, string, offset, length)
      case 'utf8':
      case 'utf-8':
        return utf8Write$1(this, string, offset, length)
      case 'ascii':
        return asciiWrite$1(this, string, offset, length)
      case 'latin1':
      case 'binary':
        return latin1Write$1(this, string, offset, length)
      case 'base64':
        return base64Write$1(this, string, offset, length)
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write$1(this, string, offset, length)
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer$1.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};
function base64Slice$1 (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray$1(buf)
  } else {
    return fromByteArray$1(buf.slice(start, end))
  }
}
function utf8Slice$1 (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray$1(res)
}
var MAX_ARGUMENTS_LENGTH$1 = 0x1000;
function decodeCodePointsArray$1 (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH$1) {
    return String.fromCharCode.apply(String, codePoints)
  }
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH$1)
    );
  }
  return res
}
function asciiSlice$1 (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}
function latin1Slice$1 (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}
function hexSlice$1 (buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex$1(buf[i]);
  }
  return out
}
function utf16leSlice$1 (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res
}
Buffer$1.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start) end = start;
  var newBuf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$1.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$1(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }
  return newBuf
};
function checkOffset$1 (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}
Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset$1(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  return val
};
Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset$1(offset, byteLength, this.length);
  }
  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }
  return val
};
Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 1, this.length);
  return this[offset]
};
Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};
Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};
Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 4, this.length);
  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};
Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 4, this.length);
  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};
Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset$1(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val
};
Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset$1(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val
};
Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};
Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};
Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};
Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 4, this.length);
  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};
Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 4, this.length);
  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};
Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 4, this.length);
  return read$1(this, offset, true, 23, 4)
};
Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 4, this.length);
  return read$1(this, offset, false, 23, 4)
};
Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 8, this.length);
  return read$1(this, offset, true, 52, 8)
};
Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 8, this.length);
  return read$1(this, offset, false, 52, 8)
};
function checkInt$1 (buf, value, offset, ext, max, min) {
  if (!internalIsBuffer$1(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}
Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt$1(this, value, offset, byteLength, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }
  return offset + byteLength
};
Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt$1(this, value, offset, byteLength, maxBytes, 0);
  }
  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }
  return offset + byteLength
};
Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 1, 0xff, 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = (value & 0xff);
  return offset + 1
};
function objectWriteUInt16$1 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16$1(this, value, offset, true);
  }
  return offset + 2
};
Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16$1(this, value, offset, false);
  }
  return offset + 2
};
function objectWriteUInt32$1 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
  }
}
Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
  } else {
    objectWriteUInt32$1(this, value, offset, true);
  }
  return offset + 4
};
Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32$1(this, value, offset, false);
  }
  return offset + 4
};
Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt$1(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }
  return offset + byteLength
};
Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt$1(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }
  return offset + byteLength
};
Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};
Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16$1(this, value, offset, true);
  }
  return offset + 2
};
Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16$1(this, value, offset, false);
  }
  return offset + 2
};
Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
  } else {
    objectWriteUInt32$1(this, value, offset, true);
  }
  return offset + 4
};
Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32$1(this, value, offset, false);
  }
  return offset + 4
};
function checkIEEE754$1 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}
function writeFloat$1 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754$1(buf, value, offset, 4);
  }
  write$1(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}
Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat$1(this, value, offset, true, noAssert)
};
Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat$1(this, value, offset, false, noAssert)
};
function writeDouble$1 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754$1(buf, value, offset, 8);
  }
  write$1(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}
Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble$1(this, value, offset, true, noAssert)
};
Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble$1(this, value, offset, false, noAssert)
};
Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i;
  if (this === target && start < targetStart && targetStart < end) {
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }
  return len
};
Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }
  if (end <= start) {
    return this
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer$1(val)
      ? val
      : utf8ToBytes$1(new Buffer$1(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this
};
var INVALID_BASE64_RE$1 = /[^+\/0-9A-Za-z-_]/g;
function base64clean$1 (str) {
  str = stringtrim$1(str).replace(INVALID_BASE64_RE$1, '');
  if (str.length < 2) return ''
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}
function stringtrim$1 (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}
function toHex$1 (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}
function utf8ToBytes$1 (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      if (!leadSurrogate) {
        if (codePoint > 0xDBFF) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }
        leadSurrogate = codePoint;
        continue
      }
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }
    leadSurrogate = null;
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }
  return bytes
}
function asciiToBytes$1 (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}
function utf16leToBytes$1 (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray
}
function base64ToBytes$1 (str) {
  return toByteArray$1(base64clean$1(str))
}
function blitBuffer$1 (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}
function isnan$1 (val) {
  return val !== val
}
function isBuffer$2(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer$1(obj) || isSlowBuffer$1(obj))
}
function isFastBuffer$1 (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}
function isSlowBuffer$1 (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer$1(obj.slice(0, 0))
}

function defaultSetTimout$1() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout$1 () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout$1 = defaultSetTimout$1;
var cachedClearTimeout$1 = defaultClearTimeout$1;
if (typeof global$2.setTimeout === 'function') {
    cachedSetTimeout$1 = setTimeout;
}
if (typeof global$2.clearTimeout === 'function') {
    cachedClearTimeout$1 = clearTimeout;
}
function runTimeout$1(fun) {
    if (cachedSetTimeout$1 === setTimeout) {
        return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout$1 === defaultSetTimout$1 || !cachedSetTimeout$1) && setTimeout) {
        cachedSetTimeout$1 = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        return cachedSetTimeout$1(fun, 0);
    } catch(e){
        try {
            return cachedSetTimeout$1.call(null, fun, 0);
        } catch(e){
            return cachedSetTimeout$1.call(this, fun, 0);
        }
    }
}
function runClearTimeout$1(marker) {
    if (cachedClearTimeout$1 === clearTimeout) {
        return clearTimeout(marker);
    }
    if ((cachedClearTimeout$1 === defaultClearTimeout$1 || !cachedClearTimeout$1) && clearTimeout) {
        cachedClearTimeout$1 = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        return cachedClearTimeout$1(marker);
    } catch (e){
        try {
            return cachedClearTimeout$1.call(null, marker);
        } catch (e){
            return cachedClearTimeout$1.call(this, marker);
        }
    }
}
var queue$1 = [];
var draining$1 = false;
var currentQueue$1;
var queueIndex$1 = -1;
function cleanUpNextTick$1() {
    if (!draining$1 || !currentQueue$1) {
        return;
    }
    draining$1 = false;
    if (currentQueue$1.length) {
        queue$1 = currentQueue$1.concat(queue$1);
    } else {
        queueIndex$1 = -1;
    }
    if (queue$1.length) {
        drainQueue$1();
    }
}
function drainQueue$1() {
    if (draining$1) {
        return;
    }
    var timeout = runTimeout$1(cleanUpNextTick$1);
    draining$1 = true;
    var len = queue$1.length;
    while(len) {
        currentQueue$1 = queue$1;
        queue$1 = [];
        while (++queueIndex$1 < len) {
            if (currentQueue$1) {
                currentQueue$1[queueIndex$1].run();
            }
        }
        queueIndex$1 = -1;
        len = queue$1.length;
    }
    currentQueue$1 = null;
    draining$1 = false;
    runClearTimeout$1(timeout);
}
function nextTick$1(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue$1.push(new Item$1(fun, args));
    if (queue$1.length === 1 && !draining$1) {
        runTimeout$1(drainQueue$1);
    }
}
function Item$1(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item$1.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title$1 = 'browser';
var platform$1 = 'browser';
var browser$2 = true;
var env$1 = {};
var argv$1 = [];
var version$1 = '';
var versions$1 = {};
var release$1 = {};
var config$1 = {};
function noop$2() {}
var on$1 = noop$2;
var addListener$1 = noop$2;
var once$1 = noop$2;
var off$1 = noop$2;
var removeListener$1 = noop$2;
var removeAllListeners$1 = noop$2;
var emit$1 = noop$2;
function binding$1(name) {
    throw new Error('process.binding is not supported');
}
function cwd$1 () { return '/' }
function chdir$1 (dir) {
    throw new Error('process.chdir is not supported');
}function umask$1() { return 0; }
var performance$1 = global$2.performance || {};
var performanceNow$1 =
  performance$1.now        ||
  performance$1.mozNow     ||
  performance$1.msNow      ||
  performance$1.oNow       ||
  performance$1.webkitNow  ||
  function(){ return (new Date()).getTime() };
function hrtime$1(previousTimestamp){
  var clocktime = performanceNow$1.call(performance$1)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}
var startTime$1 = new Date();
function uptime$1() {
  var currentTime = new Date();
  var dif = currentTime - startTime$1;
  return dif / 1000;
}
var process$1 = {
  nextTick: nextTick$1,
  title: title$1,
  browser: browser$2,
  env: env$1,
  argv: argv$1,
  version: version$1,
  versions: versions$1,
  on: on$1,
  addListener: addListener$1,
  once: once$1,
  off: off$1,
  removeListener: removeListener$1,
  removeAllListeners: removeAllListeners$1,
  emit: emit$1,
  binding: binding$1,
  cwd: cwd$1,
  chdir: chdir$1,
  umask: umask$1,
  hrtime: hrtime$1,
  platform: platform$1,
  release: release$1,
  config: config$1,
  uptime: uptime$1
};

var global$1 = (typeof global$1 !== "undefined" ? global$1 :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init () {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray (b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = (tmp >> 16) & 0xFF;
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output.push(tripletToBase64(tmp));
  }
  return output.join('')
}

function fromByteArray (uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[(tmp << 4) & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
    output += lookup[tmp >> 10];
    output += lookup[(tmp >> 4) & 0x3F];
    output += lookup[(tmp << 2) & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('')
}

function read (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

function write (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString = {}.toString;

var isArray$2 = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
  ? global$1.TYPED_ARRAY_SUPPORT
  : true;

/*
 * Export kMaxLength after typed array support is determined.
 */
kMaxLength();

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr
};

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
};

function allocUnsafe (that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
};

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that
}

function fromObject (that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len);
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray$2(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}
Buffer.isBuffer = isBuffer$1;
function internalIsBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer.concat = function concat (list, length) {
  if (!isArray$2(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};

function byteLength (string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString (encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer.prototype.toString = function toString () {
  var length = this.length | 0;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer.prototype.equals = function equals (b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
};

Buffer.prototype.inspect = function inspect () {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>'
};

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset;  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf)
  } else {
    return fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4)
};

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4)
};

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8)
};

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = (value & 0xff);
  return offset + 1
};

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}


function base64ToBytes (str) {
  return toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
}

function isFastBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
}

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser = true;
var env = {};
var argv = [];
var version = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config = {};

function noop$1() {}

var on = noop$1;
var addListener = noop$1;
var once = noop$1;
var off = noop$1;
var removeListener = noop$1;
var removeAllListeners = noop$1;
var emit = noop$1;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var browser$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env,
  argv: argv,
  version: version,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};

var process = browser$1;

var inherits;
if (typeof Object.create === 'function'){
  inherits = function inherits(ctor, superCtor) {
    // implementation from standard node.js 'util' module
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$1 = inherits;

var formatRegExp = /%[sdj%]/g;
function format(f) {
  if (!isString$1(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect$1(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull$1(x) || !isObject$1(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect$1(x);
    }
  }
  return str;
}

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
function deprecate(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined$1(global$1.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

var debugs = {};
var debugEnviron;
function debuglog(set) {
  if (isUndefined$1(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
}

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect$1(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean$1(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    _extend(ctx, opts);
  }
  // set default options
  if (isUndefined$1(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined$1(ctx.depth)) ctx.depth = 2;
  if (isUndefined$1(ctx.colors)) ctx.colors = false;
  if (isUndefined$1(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect$1.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect$1.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect$1.styles[styleType];

  if (style) {
    return '\u001b[' + inspect$1.colors[style][0] + 'm' + str +
           '\u001b[' + inspect$1.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction$1(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== inspect$1 &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString$1(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError$1(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction$1(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp$1(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate$1(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError$1(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray$1(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction$1(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp$1(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate$1(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError$1(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp$1(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined$1(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString$1(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber$1(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean$1(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull$1(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull$1(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined$1(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var length = output.reduce(function(prev, cur) {
    if (cur.indexOf('\n') >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray$1(ar) {
  return Array.isArray(ar);
}

function isBoolean$1(arg) {
  return typeof arg === 'boolean';
}

function isNull$1(arg) {
  return arg === null;
}

function isNullOrUndefined$1(arg) {
  return arg == null;
}

function isNumber$1(arg) {
  return typeof arg === 'number';
}

function isString$1(arg) {
  return typeof arg === 'string';
}

function isSymbol$1(arg) {
  return typeof arg === 'symbol';
}

function isUndefined$1(arg) {
  return arg === void 0;
}

function isRegExp$1(re) {
  return isObject$1(re) && objectToString$1(re) === '[object RegExp]';
}

function isObject$1(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isDate$1(d) {
  return isObject$1(d) && objectToString$1(d) === '[object Date]';
}

function isError$1(e) {
  return isObject$1(e) &&
      (objectToString$1(e) === '[object Error]' || e instanceof Error);
}

function isFunction$1(arg) {
  return typeof arg === 'function';
}

function isPrimitive$1(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}

function isBuffer(maybeBuf) {
  return Buffer.isBuffer(maybeBuf);
}

function objectToString$1(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
function log() {
  console.log('%s - %s', timestamp(), format.apply(null, arguments));
}

function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject$1(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var _polyfillNode_util = {
  inherits: inherits$1,
  _extend: _extend,
  log: log,
  isBuffer: isBuffer,
  isPrimitive: isPrimitive$1,
  isFunction: isFunction$1,
  isError: isError$1,
  isDate: isDate$1,
  isObject: isObject$1,
  isRegExp: isRegExp$1,
  isUndefined: isUndefined$1,
  isSymbol: isSymbol$1,
  isString: isString$1,
  isNumber: isNumber$1,
  isNullOrUndefined: isNullOrUndefined$1,
  isNull: isNull$1,
  isBoolean: isBoolean$1,
  isArray: isArray$1,
  inspect: inspect$1,
  deprecate: deprecate,
  format: format,
  debuglog: debuglog
};

var _polyfillNode_util$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    format: format,
    deprecate: deprecate,
    debuglog: debuglog,
    inspect: inspect$1,
    isArray: isArray$1,
    isBoolean: isBoolean$1,
    isNull: isNull$1,
    isNullOrUndefined: isNullOrUndefined$1,
    isNumber: isNumber$1,
    isString: isString$1,
    isSymbol: isSymbol$1,
    isUndefined: isUndefined$1,
    isRegExp: isRegExp$1,
    isObject: isObject$1,
    isDate: isDate$1,
    isError: isError$1,
    isFunction: isFunction$1,
    isPrimitive: isPrimitive$1,
    isBuffer: isBuffer,
    log: log,
    inherits: inherits$1,
    _extend: _extend,
    'default': _polyfillNode_util
});

function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var hasOwn = Object.prototype.hasOwnProperty;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};
var pSlice = Array.prototype.slice;
var _functionsHaveNames;
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== 'undefined') {
    return _functionsHaveNames;
  }
  return _functionsHaveNames = (function () {
    return function foo() {}.name === 'foo';
  }());
}
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer$1(arrbuf)) {
    return false;
  }
  if (typeof global$1.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

function assert$2(value, message) {
  if (!value) fail(value, true, message, '==', ok);
}

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!isFunction$1(func)) {
    return;
  }
  if (functionsHaveNames()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert$2.AssertionError = AssertionError;
function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
}

// assert.AssertionError instanceof Error
inherits$1(AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames() || !isFunction$1(something)) {
    return inspect$1(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert$2.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', ok);
}
assert$2.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);
assert$2.equal = equal;
function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', equal);
}

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);
assert$2.notEqual = notEqual;
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', notEqual);
  }
}

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);
assert$2.deepEqual = deepEqual$1;
function deepEqual$1(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', deepEqual$1);
  }
}
assert$2.deepStrictEqual = deepStrictEqual;
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', deepStrictEqual);
  }
}

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer$1(actual) && isBuffer$1(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (isDate$1(actual) && isDate$1(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (isRegExp$1(actual) && isRegExp$1(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer$1(actual) !== isBuffer$1(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (isPrimitive$1(a) || isPrimitive$1(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);
assert$2.notDeepEqual = notDeepEqual;
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', notDeepEqual);
  }
}

assert$2.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);
assert$2.strictEqual = strictEqual;
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', strictEqual);
  }
}

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
assert$2.notStrictEqual = notStrictEqual;
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', notStrictEqual);
  }
}

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && isError$1(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);
assert$2.throws = throws;
function throws(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
}

// EXTENSION! This is annoying to write outside this module.
assert$2.doesNotThrow = doesNotThrow;
function doesNotThrow(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
}

assert$2.ifError = ifError;
function ifError(err) {
  if (err) throw err;
}

var _polyfillNode_assert = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': assert$2,
    AssertionError: AssertionError,
    fail: fail,
    ok: ok,
    assert: ok,
    equal: equal,
    notEqual: notEqual,
    deepEqual: deepEqual$1,
    deepStrictEqual: deepStrictEqual,
    notDeepEqual: notDeepEqual,
    notDeepStrictEqual: notDeepStrictEqual,
    strictEqual: strictEqual,
    notStrictEqual: notStrictEqual,
    throws: throws,
    doesNotThrow: doesNotThrow,
    ifError: ifError
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_assert);

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.usingDomains = false;

EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active ) ;
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
                                          [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + type + ' listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };
    
// Alias for removeListener added in NodeJS 10.0
// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
EventEmitter.prototype.off = function(type, listener){
    return this.removeListener(type, listener);
};

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount$1.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount$1;
function listenerCount$1(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}

BufferList.prototype.push = function (v) {
  var entry = { data: v, next: null };
  if (this.length > 0) this.tail.next = entry;else this.head = entry;
  this.tail = entry;
  ++this.length;
};

BufferList.prototype.unshift = function (v) {
  var entry = { data: v, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};

BufferList.prototype.shift = function () {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
  --this.length;
  return ret;
};

BufferList.prototype.clear = function () {
  this.head = this.tail = null;
  this.length = 0;
};

BufferList.prototype.join = function (s) {
  if (this.length === 0) return '';
  var p = this.head;
  var ret = '' + p.data;
  while (p = p.next) {
    ret += s + p.data;
  }return ret;
};

BufferList.prototype.concat = function (n) {
  if (this.length === 0) return Buffer.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = Buffer.allocUnsafe(n >>> 0);
  var p = this.head;
  var i = 0;
  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }
  return ret;
};

// Copyright Joyent, Inc. and other Node contributors.
var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     };


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
function StringDecoder(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
}

// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

Readable.ReadableState = ReadableState;

var debug = debuglog('stream');
inherits$1(Readable, EventEmitter);

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount (emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options, stream) {

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  EventEmitter.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = Buffer.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false);

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (listenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners('data').length) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1) return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = EventEmitter.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

// A bit simpler than readable streams.
Writable.WritableState = WritableState;
inherits$1(Writable, EventEmitter);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function WritableState(options, stream) {
  Object.defineProperty(this, 'buffer', {
    get: deprecate(function () {
      return this.getBuffer();
    }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
  });
  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
function Writable(options) {

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  EventEmitter.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  nextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  // Always throw error if a null is written
  // if we are not in object mode then throw
  // if it is not a buffer, string, or undefined.
  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) nextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
        nextTick(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
        afterWrite(stream, state, finished, cb);
      }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}

inherits$1(Duplex, Readable);

var keys = Object.keys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

// a transform stream is a readable/writable stream where you do
inherits$1(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er) {
      done(stream, er);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('Not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er) {
  if (er) return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

inherits$1(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

inherits$1(Stream$1, EventEmitter);
Stream$1.Readable = Readable;
Stream$1.Writable = Writable;
Stream$1.Duplex = Duplex;
Stream$1.Transform = Transform;
Stream$1.PassThrough = PassThrough;

// Backwards-compat with node 0.4.x
Stream$1.Stream = Stream$1;

// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream$1() {
  EventEmitter.call(this);
}

Stream$1.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EventEmitter.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

var _polyfillNode_stream = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': Stream$1,
    Readable: Readable,
    Writable: Writable,
    Duplex: Duplex,
    Transform: Transform,
    PassThrough: PassThrough,
    Stream: Stream$1
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_stream);

var require$$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_util$1);

var assert$1 = require$$0;
var Stream = require$$1.Stream;
var util$2 = require$$2;
var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
function _capitalize(str) {
    return (str.charAt(0).toUpperCase() + str.slice(1));
}
function _toss(name, expected, oper, arg, actual) {
    throw new assert$1.AssertionError({
        message: util$2.format('%s (%s) is required', name, expected),
        actual: (actual === undefined) ? typeof (arg) : actual(arg),
        expected: expected,
        operator: oper || '===',
        stackStartFunction: _toss.caller
    });
}
function _getClass(arg) {
    return (Object.prototype.toString.call(arg).slice(8, -1));
}
function noop() {
}
var types = {
    bool: {
        check: function (arg) { return typeof (arg) === 'boolean'; }
    },
    func: {
        check: function (arg) { return typeof (arg) === 'function'; }
    },
    string: {
        check: function (arg) { return typeof (arg) === 'string'; }
    },
    object: {
        check: function (arg) {
            return typeof (arg) === 'object' && arg !== null;
        }
    },
    number: {
        check: function (arg) {
            return typeof (arg) === 'number' && !isNaN(arg);
        }
    },
    finite: {
        check: function (arg) {
            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);
        }
    },
    buffer: {
        check: function (arg) { return isBuffer$2(arg); },
        operator: 'Buffer.isBuffer'
    },
    array: {
        check: function (arg) { return Array.isArray(arg); },
        operator: 'Array.isArray'
    },
    stream: {
        check: function (arg) { return arg instanceof Stream; },
        operator: 'instanceof',
        actual: _getClass
    },
    date: {
        check: function (arg) { return arg instanceof Date; },
        operator: 'instanceof',
        actual: _getClass
    },
    regexp: {
        check: function (arg) { return arg instanceof RegExp; },
        operator: 'instanceof',
        actual: _getClass
    },
    uuid: {
        check: function (arg) {
            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);
        },
        operator: 'isUUID'
    }
};
function _setExports(ndebug) {
    var keys = Object.keys(types);
    var out;
    if (process$1.env.NODE_NDEBUG) {
        out = noop;
    } else {
        out = function (arg, msg) {
            if (!arg) {
                _toss(msg, 'true', arg);
            }
        };
    }
    keys.forEach(function (k) {
        if (ndebug) {
            out[k] = noop;
            return;
        }
        var type = types[k];
        out[k] = function (arg, msg) {
            if (!type.check(arg)) {
                _toss(msg, k, type.operator, arg, type.actual);
            }
        };
    });
    keys.forEach(function (k) {
        var name = 'optional' + _capitalize(k);
        if (ndebug) {
            out[name] = noop;
            return;
        }
        var type = types[k];
        out[name] = function (arg, msg) {
            if (arg === undefined || arg === null) {
                return;
            }
            if (!type.check(arg)) {
                _toss(msg, k, type.operator, arg, type.actual);
            }
        };
    });
    keys.forEach(function (k) {
        var name = 'arrayOf' + _capitalize(k);
        if (ndebug) {
            out[name] = noop;
            return;
        }
        var type = types[k];
        var expected = '[' + k + ']';
        out[name] = function (arg, msg) {
            if (!Array.isArray(arg)) {
                _toss(msg, expected, type.operator, arg, type.actual);
            }
            var i;
            for (i = 0; i < arg.length; i++) {
                if (!type.check(arg[i])) {
                    _toss(msg, expected, type.operator, arg, type.actual);
                }
            }
        };
    });
    keys.forEach(function (k) {
        var name = 'optionalArrayOf' + _capitalize(k);
        if (ndebug) {
            out[name] = noop;
            return;
        }
        var type = types[k];
        var expected = '[' + k + ']';
        out[name] = function (arg, msg) {
            if (arg === undefined || arg === null) {
                return;
            }
            if (!Array.isArray(arg)) {
                _toss(msg, expected, type.operator, arg, type.actual);
            }
            var i;
            for (i = 0; i < arg.length; i++) {
                if (!type.check(arg[i])) {
                    _toss(msg, expected, type.operator, arg, type.actual);
                }
            }
        };
    });
    Object.keys(assert$1).forEach(function (k) {
        if (k === 'AssertionError') {
            out[k] = assert$1[k];
            return;
        }
        if (ndebug) {
            out[k] = noop;
            return;
        }
        out[k] = assert$1[k];
    });
    out._setExports = _setExports;
    return out;
}
var assert_1 = _setExports(process$1.env.NODE_NDEBUG);

var jsprim$1 = {};

var extsprintf$1 = {};

var mod_assert$2 = require$$0;
var mod_util$2 = require$$2;
extsprintf$1.sprintf = jsSprintf$1;
extsprintf$1.printf = jsPrintf$1;
extsprintf$1.fprintf = jsFprintf$1;
function jsSprintf$1(fmt)
{
	var regex = [
	    '([^%]*)',
	    '%',
	    '([\'\\-+ #0]*?)',
	    '([1-9]\\d*)?',
	    '(\\.([1-9]\\d*))?',
	    '[lhjztL]*?',
	    '([diouxXfFeEgGaAcCsSp%jr])'
	].join('');
	var re = new RegExp(regex);
	var args = Array.prototype.slice.call(arguments, 1);
	var flags, width, precision, conversion;
	var left, pad, sign, arg, match;
	var ret = '';
	var argn = 1;
	mod_assert$2.equal('string', typeof (fmt));
	while ((match = re.exec(fmt)) !== null) {
		ret += match[1];
		fmt = fmt.substring(match[0].length);
		flags = match[2] || '';
		width = match[3] || 0;
		precision = match[4] || '';
		conversion = match[6];
		left = false;
		sign = false;
		pad = ' ';
		if (conversion == '%') {
			ret += '%';
			continue;
		}
		if (args.length === 0)
			throw (new Error('too few args to sprintf'));
		arg = args.shift();
		argn++;
		if (flags.match(/[\' #]/))
			throw (new Error(
			    'unsupported flags: ' + flags));
		if (precision.length > 0)
			throw (new Error(
			    'non-zero precision not supported'));
		if (flags.match(/-/))
			left = true;
		if (flags.match(/0/))
			pad = '0';
		if (flags.match(/\+/))
			sign = true;
		switch (conversion) {
		case 's':
			if (arg === undefined || arg === null)
				throw (new Error('argument ' + argn +
				    ': attempted to print undefined or null ' +
				    'as a string'));
			ret += doPad$1(pad, width, left, arg.toString());
			break;
		case 'd':
			arg = Math.floor(arg);
		case 'f':
			sign = sign && arg > 0 ? '+' : '';
			ret += sign + doPad$1(pad, width, left,
			    arg.toString());
			break;
		case 'x':
			ret += doPad$1(pad, width, left, arg.toString(16));
			break;
		case 'j':
			if (width === 0)
				width = 10;
			ret += mod_util$2.inspect(arg, false, width);
			break;
		case 'r':
			ret += dumpException$1(arg);
			break;
		default:
			throw (new Error('unsupported conversion: ' +
			    conversion));
		}
	}
	ret += fmt;
	return (ret);
}
function jsPrintf$1() {
	var args = Array.prototype.slice.call(arguments);
	args.unshift(process$1.stdout);
	jsFprintf$1.apply(null, args);
}
function jsFprintf$1(stream) {
	var args = Array.prototype.slice.call(arguments, 1);
	return (stream.write(jsSprintf$1.apply(this, args)));
}
function doPad$1(chr, width, left, str)
{
	var ret = str;
	while (ret.length < width) {
		if (left)
			ret += chr;
		else
			ret = chr + ret;
	}
	return (ret);
}
function dumpException$1(ex)
{
	var ret;
	if (!(ex instanceof Error))
		throw (new Error(jsSprintf$1('invalid type for %%r: %j', ex)));
	ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;
	if (ex.cause && typeof (ex.cause) === 'function') {
		var cex = ex.cause();
		if (cex) {
			ret += '\nCaused by: ' + dumpException$1(cex);
		}
	}
	return (ret);
}

var extsprintf = {};

var mod_assert$1 = require$$0;
var mod_util$1 = require$$2;
extsprintf.sprintf = jsSprintf;
extsprintf.printf = jsPrintf;
extsprintf.fprintf = jsFprintf;
function jsSprintf(ofmt)
{
	var regex = [
	    '([^%]*)',
	    '%',
	    '([\'\\-+ #0]*?)',
	    '([1-9]\\d*)?',
	    '(\\.([1-9]\\d*))?',
	    '[lhjztL]*?',
	    '([diouxXfFeEgGaAcCsSp%jr])'
	].join('');
	var re = new RegExp(regex);
	var args = Array.prototype.slice.call(arguments, 1);
	var fmt = ofmt;
	var flags, width, precision, conversion;
	var left, pad, sign, arg, match;
	var ret = '';
	var argn = 1;
	var posn = 0;
	var convposn;
	var curconv;
	mod_assert$1.equal('string', typeof (fmt),
	    'first argument must be a format string');
	while ((match = re.exec(fmt)) !== null) {
		ret += match[1];
		fmt = fmt.substring(match[0].length);
		curconv = match[0].substring(match[1].length);
		convposn = posn + match[1].length + 1;
		posn += match[0].length;
		flags = match[2] || '';
		width = match[3] || 0;
		precision = match[4] || '';
		conversion = match[6];
		left = false;
		sign = false;
		pad = ' ';
		if (conversion == '%') {
			ret += '%';
			continue;
		}
		if (args.length === 0) {
			throw (jsError(ofmt, convposn, curconv,
			    'has no matching argument ' +
			    '(too few arguments passed)'));
		}
		arg = args.shift();
		argn++;
		if (flags.match(/[\' #]/)) {
			throw (jsError(ofmt, convposn, curconv,
			    'uses unsupported flags'));
		}
		if (precision.length > 0) {
			throw (jsError(ofmt, convposn, curconv,
			    'uses non-zero precision (not supported)'));
		}
		if (flags.match(/-/))
			left = true;
		if (flags.match(/0/))
			pad = '0';
		if (flags.match(/\+/))
			sign = true;
		switch (conversion) {
		case 's':
			if (arg === undefined || arg === null) {
				throw (jsError(ofmt, convposn, curconv,
				    'attempted to print undefined or null ' +
				    'as a string (argument ' + argn + ' to ' +
				    'sprintf)'));
			}
			ret += doPad(pad, width, left, arg.toString());
			break;
		case 'd':
			arg = Math.floor(arg);
		case 'f':
			sign = sign && arg > 0 ? '+' : '';
			ret += sign + doPad(pad, width, left,
			    arg.toString());
			break;
		case 'x':
			ret += doPad(pad, width, left, arg.toString(16));
			break;
		case 'j':
			if (width === 0)
				width = 10;
			ret += mod_util$1.inspect(arg, false, width);
			break;
		case 'r':
			ret += dumpException(arg);
			break;
		default:
			throw (jsError(ofmt, convposn, curconv,
			    'is not supported'));
		}
	}
	ret += fmt;
	return (ret);
}
function jsError(fmtstr, convposn, curconv, reason) {
	mod_assert$1.equal(typeof (fmtstr), 'string');
	mod_assert$1.equal(typeof (curconv), 'string');
	mod_assert$1.equal(typeof (convposn), 'number');
	mod_assert$1.equal(typeof (reason), 'string');
	return (new Error('format string "' + fmtstr +
	    '": conversion specifier "' + curconv + '" at character ' +
	    convposn + ' ' + reason));
}
function jsPrintf() {
	var args = Array.prototype.slice.call(arguments);
	args.unshift(process$1.stdout);
	jsFprintf.apply(null, args);
}
function jsFprintf(stream) {
	var args = Array.prototype.slice.call(arguments, 1);
	return (stream.write(jsSprintf.apply(this, args)));
}
function doPad(chr, width, left, str)
{
	var ret = str;
	while (ret.length < width) {
		if (left)
			ret += chr;
		else
			ret = chr + ret;
	}
	return (ret);
}
function dumpException(ex)
{
	var ret;
	if (!(ex instanceof Error))
		throw (new Error(jsSprintf('invalid type for %%r: %j', ex)));
	ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;
	if (ex.cause && typeof (ex.cause) === 'function') {
		var cex = ex.cause();
		if (cex) {
			ret += '\nCaused by: ' + dumpException(cex);
		}
	}
	return (ret);
}

var util$1 = {};

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
util$1.isArray = isArray;
function isBoolean(arg) {
  return typeof arg === 'boolean';
}
util$1.isBoolean = isBoolean;
function isNull(arg) {
  return arg === null;
}
util$1.isNull = isNull;
function isNullOrUndefined(arg) {
  return arg == null;
}
util$1.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
  return typeof arg === 'number';
}
util$1.isNumber = isNumber;
function isString(arg) {
  return typeof arg === 'string';
}
util$1.isString = isString;
function isSymbol(arg) {
  return typeof arg === 'symbol';
}
util$1.isSymbol = isSymbol;
function isUndefined(arg) {
  return arg === void 0;
}
util$1.isUndefined = isUndefined;
function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
util$1.isRegExp = isRegExp;
function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
util$1.isObject = isObject;
function isDate(d) {
  return objectToString(d) === '[object Date]';
}
util$1.isDate = isDate;
function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
util$1.isError = isError;
function isFunction(arg) {
  return typeof arg === 'function';
}
util$1.isFunction = isFunction;
function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||
         typeof arg === 'undefined';
}
util$1.isPrimitive = isPrimitive;
util$1.isBuffer = isBuffer$2;
function objectToString(o) {
  return Object.prototype.toString.call(o);
}

var mod_assertplus = assert_1;
var mod_util = require$$2;
var mod_extsprintf$1 = extsprintf;
var mod_isError = util$1.isError;
var sprintf = mod_extsprintf$1.sprintf;
var verror = VError;
VError.VError = VError;
VError.SError = SError;
VError.WError = WError;
VError.MultiError = MultiError;
function parseConstructorArguments(args)
{
	var argv, options, sprintf_args, shortmessage, k;
	mod_assertplus.object(args, 'args');
	mod_assertplus.bool(args.strict, 'args.strict');
	mod_assertplus.array(args.argv, 'args.argv');
	argv = args.argv;
	if (argv.length === 0) {
		options = {};
		sprintf_args = [];
	} else if (mod_isError(argv[0])) {
		options = { 'cause': argv[0] };
		sprintf_args = argv.slice(1);
	} else if (typeof (argv[0]) === 'object') {
		options = {};
		for (k in argv[0]) {
			options[k] = argv[0][k];
		}
		sprintf_args = argv.slice(1);
	} else {
		mod_assertplus.string(argv[0],
		    'first argument to VError, SError, or WError ' +
		    'constructor must be a string, object, or Error');
		options = {};
		sprintf_args = argv;
	}
	mod_assertplus.object(options);
	if (!options.strict && !args.strict) {
		sprintf_args = sprintf_args.map(function (a) {
			return (a === null ? 'null' :
			    a === undefined ? 'undefined' : a);
		});
	}
	if (sprintf_args.length === 0) {
		shortmessage = '';
	} else {
		shortmessage = sprintf.apply(null, sprintf_args);
	}
	return ({
	    'options': options,
	    'shortmessage': shortmessage
	});
}
function VError()
{
	var args, obj, parsed, cause, ctor, message, k;
	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof VError)) {
		obj = Object.create(VError.prototype);
		VError.apply(obj, arguments);
		return (obj);
	}
	parsed = parseConstructorArguments({
	    'argv': args,
	    'strict': false
	});
	if (parsed.options.name) {
		mod_assertplus.string(parsed.options.name,
		    'error\'s "name" must be a string');
		this.name = parsed.options.name;
	}
	this.jse_shortmsg = parsed.shortmessage;
	message = parsed.shortmessage;
	cause = parsed.options.cause;
	if (cause) {
		mod_assertplus.ok(mod_isError(cause), 'cause is not an Error');
		this.jse_cause = cause;
		if (!parsed.options.skipCauseMessage) {
			message += ': ' + cause.message;
		}
	}
	this.jse_info = {};
	if (parsed.options.info) {
		for (k in parsed.options.info) {
			this.jse_info[k] = parsed.options.info[k];
		}
	}
	this.message = message;
	Error.call(this, message);
	if (Error.captureStackTrace) {
		ctor = parsed.options.constructorOpt || this.constructor;
		Error.captureStackTrace(this, ctor);
	}
	return (this);
}
mod_util.inherits(VError, Error);
VError.prototype.name = 'VError';
VError.prototype.toString = function ve_toString()
{
	var str = (this.hasOwnProperty('name') && this.name ||
		this.constructor.name || this.constructor.prototype.name);
	if (this.message)
		str += ': ' + this.message;
	return (str);
};
VError.prototype.cause = function ve_cause()
{
	var cause = VError.cause(this);
	return (cause === null ? undefined : cause);
};
VError.cause = function (err)
{
	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
	return (mod_isError(err.jse_cause) ? err.jse_cause : null);
};
VError.info = function (err)
{
	var rv, cause, k;
	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
	cause = VError.cause(err);
	if (cause !== null) {
		rv = VError.info(cause);
	} else {
		rv = {};
	}
	if (typeof (err.jse_info) == 'object' && err.jse_info !== null) {
		for (k in err.jse_info) {
			rv[k] = err.jse_info[k];
		}
	}
	return (rv);
};
VError.findCauseByName = function (err, name)
{
	var cause;
	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
	mod_assertplus.string(name, 'name');
	mod_assertplus.ok(name.length > 0, 'name cannot be empty');
	for (cause = err; cause !== null; cause = VError.cause(cause)) {
		mod_assertplus.ok(mod_isError(cause));
		if (cause.name == name) {
			return (cause);
		}
	}
	return (null);
};
VError.hasCauseWithName = function (err, name)
{
	return (VError.findCauseByName(err, name) !== null);
};
VError.fullStack = function (err)
{
	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
	var cause = VError.cause(err);
	if (cause) {
		return (err.stack + '\ncaused by: ' + VError.fullStack(cause));
	}
	return (err.stack);
};
VError.errorFromList = function (errors)
{
	mod_assertplus.arrayOfObject(errors, 'errors');
	if (errors.length === 0) {
		return (null);
	}
	errors.forEach(function (e) {
		mod_assertplus.ok(mod_isError(e));
	});
	if (errors.length == 1) {
		return (errors[0]);
	}
	return (new MultiError(errors));
};
VError.errorForEach = function (err, func)
{
	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
	mod_assertplus.func(func, 'func');
	if (err instanceof MultiError) {
		err.errors().forEach(function iterError(e) { func(e); });
	} else {
		func(err);
	}
};
function SError()
{
	var args, obj, parsed, options;
	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof SError)) {
		obj = Object.create(SError.prototype);
		SError.apply(obj, arguments);
		return (obj);
	}
	parsed = parseConstructorArguments({
	    'argv': args,
	    'strict': true
	});
	options = parsed.options;
	VError.call(this, options, '%s', parsed.shortmessage);
	return (this);
}
mod_util.inherits(SError, VError);
function MultiError(errors)
{
	mod_assertplus.array(errors, 'list of errors');
	mod_assertplus.ok(errors.length > 0, 'must be at least one error');
	this.ase_errors = errors;
	VError.call(this, {
	    'cause': errors[0]
	}, 'first of %d error%s', errors.length, errors.length == 1 ? '' : 's');
}
mod_util.inherits(MultiError, VError);
MultiError.prototype.name = 'MultiError';
MultiError.prototype.errors = function me_errors()
{
	return (this.ase_errors.slice(0));
};
function WError()
{
	var args, obj, parsed, options;
	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof WError)) {
		obj = Object.create(WError.prototype);
		WError.apply(obj, args);
		return (obj);
	}
	parsed = parseConstructorArguments({
	    'argv': args,
	    'strict': false
	});
	options = parsed.options;
	options['skipCauseMessage'] = true;
	VError.call(this, options, '%s', parsed.shortmessage);
	return (this);
}
mod_util.inherits(WError, VError);
WError.prototype.name = 'WError';
WError.prototype.toString = function we_toString()
{
	var str = (this.hasOwnProperty('name') && this.name ||
		this.constructor.name || this.constructor.prototype.name);
	if (this.message)
		str += ': ' + this.message;
	if (this.jse_cause && this.jse_cause.message)
		str += '; caused by ' + this.jse_cause.toString();
	return (str);
};
WError.prototype.cause = function we_cause(c)
{
	if (mod_isError(c))
		this.jse_cause = c;
	return (this.jse_cause);
};

var validate = {exports: {}};

(function (module) {
(function (root, factory) {
    if (module.exports) {
        module.exports = factory();
    } else {
        root.jsonSchema = factory();
    }
}(commonjsGlobal, function () {
var exports = validate;
exports.Integer = {type:"integer"};
var primitiveConstructors = {
	String: String,
	Boolean: Boolean,
	Number: Number,
	Object: Object,
	Array: Array,
	Date: Date
};
exports.validate = validate;
function validate(instance,schema) {
		return validate(instance, schema, {changing: false});
	}exports.checkPropertyChange = function(value,schema, property) {
		return validate(value, schema, {changing: property || "property"});
	};
var validate = exports._validate = function(instance,schema,options) {
	if (!options) options = {};
	var _changing = options.changing;
	function getType(schema){
		return schema.type || (primitiveConstructors[schema.name] == schema && schema.name.toLowerCase());
	}
	var errors = [];
	function checkProp(value, schema, path,i){
		var l;
		path += path ? typeof i == 'number' ? '[' + i + ']' : typeof i == 'undefined' ? '' : '.' + i : i;
		function addError(message){
			errors.push({property:path,message:message});
		}
		if((typeof schema != 'object' || schema instanceof Array) && (path || typeof schema != 'function') && !(schema && getType(schema))){
			if(typeof schema == 'function'){
				if(!(value instanceof schema)){
					addError("is not an instance of the class/constructor " + schema.name);
				}
			}else if(schema){
				addError("Invalid schema/property definition " + schema);
			}
			return null;
		}
		if(_changing && schema.readonly){
			addError("is a readonly field, it can not be changed");
		}
		if(schema['extends']){
			checkProp(value,schema['extends'],path,i);
		}
		function checkType(type,value){
			if(type){
				if(typeof type == 'string' && type != 'any' &&
						(type == 'null' ? value !== null : typeof value != type) &&
						!(value instanceof Array && type == 'array') &&
						!(value instanceof Date && type == 'date') &&
						!(type == 'integer' && value%1===0)){
					return [{property:path,message:value + " - " + (typeof value) + " value found, but a " + type + " is required"}];
				}
				if(type instanceof Array){
					var unionErrors=[];
					for(var j = 0; j < type.length; j++){
						if(!(unionErrors=checkType(type[j],value)).length){
							break;
						}
					}
					if(unionErrors.length){
						return unionErrors;
					}
				}else if(typeof type == 'object'){
					var priorErrors = errors;
					errors = [];
					checkProp(value,type,path);
					var theseErrors = errors;
					errors = priorErrors;
					return theseErrors;
				}
			}
			return [];
		}
		if(value === undefined){
			if(schema.required){
				addError("is missing and it is required");
			}
		}else {
			errors = errors.concat(checkType(getType(schema),value));
			if(schema.disallow && !checkType(schema.disallow,value).length){
				addError(" disallowed value was matched");
			}
			if(value !== null){
				if(value instanceof Array){
					if(schema.items){
						var itemsIsArray = schema.items instanceof Array;
						var propDef = schema.items;
						for (i = 0, l = value.length; i < l; i += 1) {
							if (itemsIsArray)
								propDef = schema.items[i];
							if (options.coerce)
								value[i] = options.coerce(value[i], propDef);
							errors.concat(checkProp(value[i],propDef,path,i));
						}
					}
					if(schema.minItems && value.length < schema.minItems){
						addError("There must be a minimum of " + schema.minItems + " in the array");
					}
					if(schema.maxItems && value.length > schema.maxItems){
						addError("There must be a maximum of " + schema.maxItems + " in the array");
					}
				}else if(schema.properties || schema.additionalProperties){
					errors.concat(checkObj(value, schema.properties, path, schema.additionalProperties));
				}
				if(schema.pattern && typeof value == 'string' && !value.match(schema.pattern)){
					addError("does not match the regex pattern " + schema.pattern);
				}
				if(schema.maxLength && typeof value == 'string' && value.length > schema.maxLength){
					addError("may only be " + schema.maxLength + " characters long");
				}
				if(schema.minLength && typeof value == 'string' && value.length < schema.minLength){
					addError("must be at least " + schema.minLength + " characters long");
				}
				if(typeof schema.minimum !== 'undefined' && typeof value == typeof schema.minimum &&
						schema.minimum > value){
					addError("must have a minimum value of " + schema.minimum);
				}
				if(typeof schema.maximum !== 'undefined' && typeof value == typeof schema.maximum &&
						schema.maximum < value){
					addError("must have a maximum value of " + schema.maximum);
				}
				if(schema['enum']){
					var enumer = schema['enum'];
					l = enumer.length;
					var found;
					for(var j = 0; j < l; j++){
						if(enumer[j]===value){
							found=1;
							break;
						}
					}
					if(!found){
						addError("does not have a value in the enumeration " + enumer.join(", "));
					}
				}
				if(typeof schema.maxDecimal == 'number' &&
					(value.toString().match(new RegExp("\\.[0-9]{" + (schema.maxDecimal + 1) + ",}")))){
					addError("may only have " + schema.maxDecimal + " digits of decimal places");
				}
			}
		}
		return null;
	}
	function checkObj(instance,objTypeDef,path,additionalProp){
		if(typeof objTypeDef =='object'){
			if(typeof instance != 'object' || instance instanceof Array){
				errors.push({property:path,message:"an object is required"});
			}
			for(var i in objTypeDef){
				if(objTypeDef.hasOwnProperty(i) && i != '__proto__' && i != 'constructor'){
					var value = instance.hasOwnProperty(i) ? instance[i] : undefined;
					if (value === undefined && options.existingOnly) continue;
					var propDef = objTypeDef[i];
					if(value === undefined && propDef["default"]){
						value = instance[i] = propDef["default"];
					}
					if(options.coerce && i in instance){
						value = instance[i] = options.coerce(value, propDef);
					}
					checkProp(value,propDef,path,i);
				}
			}
		}
		for(i in instance){
			if(instance.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_') && objTypeDef && !objTypeDef[i] && additionalProp===false){
				if (options.filter) {
					delete instance[i];
					continue;
				} else {
					errors.push({property:path,message:"The property " + i +
						" is not defined in the schema and the schema does not allow additional properties"});
				}
			}
			var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
			if(requires && !(requires in instance)){
				errors.push({property:path,message:"the presence of the property " + i + " requires that " + requires + " also be present"});
			}
			value = instance[i];
			if(additionalProp && (!(objTypeDef && typeof objTypeDef == 'object') || !(i in objTypeDef))){
				if(options.coerce){
					value = instance[i] = options.coerce(value, additionalProp);
				}
				checkProp(value,additionalProp,path,i);
			}
			if(!_changing && value && value.$schema){
				errors = errors.concat(checkProp(value,value.$schema,path,i));
			}
		}
		return errors;
	}
	if(schema){
		checkProp(instance,schema,'',_changing || '');
	}
	if(!_changing && instance && instance.$schema){
		checkProp(instance,instance.$schema,'','');
	}
	return {valid:!errors.length,errors:errors};
};
exports.mustBeValid = function(result){
	if(!result.valid){
		throw new TypeError(result.errors.map(function(error){return "for property " + error.property + ': ' + error.message;}).join(", \n"));
	}
};
return exports;
}));
}(validate));

var mod_assert = assert_1;
var mod_extsprintf = extsprintf$1;
var mod_verror = verror;
var mod_jsonschema = validate.exports;
jsprim$1.deepCopy = deepCopy;
jsprim$1.deepEqual = deepEqual;
jsprim$1.isEmpty = isEmpty;
jsprim$1.hasKey = hasKey;
jsprim$1.forEachKey = forEachKey;
jsprim$1.pluck = pluck;
jsprim$1.flattenObject = flattenObject;
jsprim$1.flattenIter = flattenIter;
jsprim$1.validateJsonObject = validateJsonObjectJS;
jsprim$1.validateJsonObjectJS = validateJsonObjectJS;
jsprim$1.randElt = randElt;
jsprim$1.extraProperties = extraProperties;
jsprim$1.mergeObjects = mergeObjects;
jsprim$1.startsWith = startsWith$1;
jsprim$1.endsWith = endsWith;
jsprim$1.parseInteger = parseInteger;
jsprim$1.iso8601 = iso8601;
jsprim$1.rfc1123 = rfc1123;
jsprim$1.parseDateTime = parseDateTime;
jsprim$1.hrtimediff = hrtimeDiff;
jsprim$1.hrtimeDiff = hrtimeDiff;
jsprim$1.hrtimeAccum = hrtimeAccum;
jsprim$1.hrtimeAdd = hrtimeAdd;
jsprim$1.hrtimeNanosec = hrtimeNanosec;
jsprim$1.hrtimeMicrosec = hrtimeMicrosec;
jsprim$1.hrtimeMillisec = hrtimeMillisec;
function deepCopy(obj)
{
	var ret, key;
	var marker = '__deepCopy';
	if (obj && obj[marker])
		throw (new Error('attempted deep copy of cyclic object'));
	if (obj && obj.constructor == Object) {
		ret = {};
		obj[marker] = true;
		for (key in obj) {
			if (key == marker)
				continue;
			ret[key] = deepCopy(obj[key]);
		}
		delete (obj[marker]);
		return (ret);
	}
	if (obj && obj.constructor == Array) {
		ret = [];
		obj[marker] = true;
		for (key = 0; key < obj.length; key++)
			ret.push(deepCopy(obj[key]));
		delete (obj[marker]);
		return (ret);
	}
	return (obj);
}
function deepEqual(obj1, obj2)
{
	if (typeof (obj1) != typeof (obj2))
		return (false);
	if (obj1 === null || obj2 === null || typeof (obj1) != 'object')
		return (obj1 === obj2);
	if (obj1.constructor != obj2.constructor)
		return (false);
	var k;
	for (k in obj1) {
		if (!(k in obj2))
			return (false);
		if (!deepEqual(obj1[k], obj2[k]))
			return (false);
	}
	for (k in obj2) {
		if (!(k in obj1))
			return (false);
	}
	return (true);
}
function isEmpty(obj)
{
	var key;
	for (key in obj)
		return (false);
	return (true);
}
function hasKey(obj, key)
{
	mod_assert.equal(typeof (key), 'string');
	return (Object.prototype.hasOwnProperty.call(obj, key));
}
function forEachKey(obj, callback)
{
	for (var key in obj) {
		if (hasKey(obj, key)) {
			callback(key, obj[key]);
		}
	}
}
function pluck(obj, key)
{
	mod_assert.equal(typeof (key), 'string');
	return (pluckv(obj, key));
}
function pluckv(obj, key)
{
	if (obj === null || typeof (obj) !== 'object')
		return (undefined);
	if (obj.hasOwnProperty(key))
		return (obj[key]);
	var i = key.indexOf('.');
	if (i == -1)
		return (undefined);
	var key1 = key.substr(0, i);
	if (!obj.hasOwnProperty(key1))
		return (undefined);
	return (pluckv(obj[key1], key.substr(i + 1)));
}
function flattenIter(data, depth, callback)
{
	doFlattenIter(data, depth, [], callback);
}
function doFlattenIter(data, depth, accum, callback)
{
	var each;
	var key;
	if (depth === 0) {
		each = accum.slice(0);
		each.push(data);
		callback(each);
		return;
	}
	mod_assert.ok(data !== null);
	mod_assert.equal(typeof (data), 'object');
	mod_assert.equal(typeof (depth), 'number');
	mod_assert.ok(depth >= 0);
	for (key in data) {
		each = accum.slice(0);
		each.push(key);
		doFlattenIter(data[key], depth - 1, each, callback);
	}
}
function flattenObject(data, depth)
{
	if (depth === 0)
		return ([ data ]);
	mod_assert.ok(data !== null);
	mod_assert.equal(typeof (data), 'object');
	mod_assert.equal(typeof (depth), 'number');
	mod_assert.ok(depth >= 0);
	var rv = [];
	var key;
	for (key in data) {
		flattenObject(data[key], depth - 1).forEach(function (p) {
			rv.push([ key ].concat(p));
		});
	}
	return (rv);
}
function startsWith$1(str, prefix)
{
	return (str.substr(0, prefix.length) == prefix);
}
function endsWith(str, suffix)
{
	return (str.substr(
	    str.length - suffix.length, suffix.length) == suffix);
}
function iso8601(d)
{
	if (typeof (d) == 'number')
		d = new Date(d);
	mod_assert.ok(d.constructor === Date);
	return (mod_extsprintf.sprintf('%4d-%02d-%02dT%02d:%02d:%02d.%03dZ',
	    d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(),
	    d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(),
	    d.getUTCMilliseconds()));
}
var RFC1123_MONTHS = [
    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
var RFC1123_DAYS = [
    'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
function rfc1123(date) {
	return (mod_extsprintf.sprintf('%s, %02d %s %04d %02d:%02d:%02d GMT',
	    RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(),
	    RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(),
	    date.getUTCHours(), date.getUTCMinutes(),
	    date.getUTCSeconds()));
}
function parseDateTime(str)
{
	var numeric = +str;
	if (!isNaN(numeric)) {
		return (new Date(numeric));
	} else {
		return (new Date(str));
	}
}
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
var PI_DEFAULTS = {
	base: 10,
	allowSign: true,
	allowPrefix: false,
	allowTrailing: false,
	allowImprecise: false,
	trimWhitespace: false,
	leadingZeroIsOctal: false
};
var CP_0 = 0x30;
var CP_9 = 0x39;
var CP_A = 0x41;
var CP_B = 0x42;
var CP_O = 0x4f;
var CP_T = 0x54;
var CP_X = 0x58;
var CP_Z = 0x5a;
var CP_a = 0x61;
var CP_b = 0x62;
var CP_o = 0x6f;
var CP_t = 0x74;
var CP_x = 0x78;
var CP_z = 0x7a;
var PI_CONV_DEC = 0x30;
var PI_CONV_UC = 0x37;
var PI_CONV_LC = 0x57;
function parseInteger(str, uopts)
{
	mod_assert.string(str, 'str');
	mod_assert.optionalObject(uopts, 'options');
	var baseOverride = false;
	var options = PI_DEFAULTS;
	if (uopts) {
		baseOverride = hasKey(uopts, 'base');
		options = mergeObjects(options, uopts);
		mod_assert.number(options.base, 'options.base');
		mod_assert.ok(options.base >= 2, 'options.base >= 2');
		mod_assert.ok(options.base <= 36, 'options.base <= 36');
		mod_assert.bool(options.allowSign, 'options.allowSign');
		mod_assert.bool(options.allowPrefix, 'options.allowPrefix');
		mod_assert.bool(options.allowTrailing,
		    'options.allowTrailing');
		mod_assert.bool(options.allowImprecise,
		    'options.allowImprecise');
		mod_assert.bool(options.trimWhitespace,
		    'options.trimWhitespace');
		mod_assert.bool(options.leadingZeroIsOctal,
		    'options.leadingZeroIsOctal');
		if (options.leadingZeroIsOctal) {
			mod_assert.ok(!baseOverride,
			    '"base" and "leadingZeroIsOctal" are ' +
			    'mutually exclusive');
		}
	}
	var c;
	var pbase = -1;
	var base = options.base;
	var start;
	var mult = 1;
	var value = 0;
	var idx = 0;
	var len = str.length;
	if (options.trimWhitespace) {
		while (idx < len && isSpace(str.charCodeAt(idx))) {
			++idx;
		}
	}
	if (options.allowSign) {
		if (str[idx] === '-') {
			idx += 1;
			mult = -1;
		} else if (str[idx] === '+') {
			idx += 1;
		}
	}
	if (str[idx] === '0') {
		if (options.allowPrefix) {
			pbase = prefixToBase(str.charCodeAt(idx + 1));
			if (pbase !== -1 && (!baseOverride || pbase === base)) {
				base = pbase;
				idx += 2;
			}
		}
		if (pbase === -1 && options.leadingZeroIsOctal) {
			base = 8;
		}
	}
	for (start = idx; idx < len; ++idx) {
		c = translateDigit(str.charCodeAt(idx));
		if (c !== -1 && c < base) {
			value *= base;
			value += c;
		} else {
			break;
		}
	}
	if (start === idx) {
		return (new Error('invalid number: ' + JSON.stringify(str)));
	}
	if (options.trimWhitespace) {
		while (idx < len && isSpace(str.charCodeAt(idx))) {
			++idx;
		}
	}
	if (idx < len && !options.allowTrailing) {
		return (new Error('trailing characters after number: ' +
		    JSON.stringify(str.slice(idx))));
	}
	if (value === 0) {
		return (0);
	}
	var result = value * mult;
	if (!options.allowImprecise &&
	    (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {
		return (new Error('number is outside of the supported range: ' +
		    JSON.stringify(str.slice(start, idx))));
	}
	return (result);
}
function translateDigit(d)
{
	if (d >= CP_0 && d <= CP_9) {
		return (d - PI_CONV_DEC);
	} else if (d >= CP_A && d <= CP_Z) {
		return (d - PI_CONV_UC);
	} else if (d >= CP_a && d <= CP_z) {
		return (d - PI_CONV_LC);
	} else {
		return (-1);
	}
}
function isSpace(c)
{
	return (c === 0x20) ||
	    (c >= 0x0009 && c <= 0x000d) ||
	    (c === 0x00a0) ||
	    (c === 0x1680) ||
	    (c === 0x180e) ||
	    (c >= 0x2000 && c <= 0x200a) ||
	    (c === 0x2028) ||
	    (c === 0x2029) ||
	    (c === 0x202f) ||
	    (c === 0x205f) ||
	    (c === 0x3000) ||
	    (c === 0xfeff);
}
function prefixToBase(c)
{
	if (c === CP_b || c === CP_B) {
		return (2);
	} else if (c === CP_o || c === CP_O) {
		return (8);
	} else if (c === CP_t || c === CP_T) {
		return (10);
	} else if (c === CP_x || c === CP_X) {
		return (16);
	} else {
		return (-1);
	}
}
function validateJsonObjectJS(schema, input)
{
	var report = mod_jsonschema.validate(input, schema);
	if (report.errors.length === 0)
		return (null);
	var error = report.errors[0];
	var propname = error['property'];
	var reason = error['message'].toLowerCase();
	var i, j;
	if ((i = reason.indexOf('the property ')) != -1 &&
	    (j = reason.indexOf(' is not defined in the schema and the ' +
	    'schema does not allow additional properties')) != -1) {
		i += 'the property '.length;
		if (propname === '')
			propname = reason.substr(i, j - i);
		else
			propname = propname + '.' + reason.substr(i, j - i);
		reason = 'unsupported property';
	}
	var rv = new mod_verror.VError('property "%s": %s', propname, reason);
	rv.jsv_details = error;
	return (rv);
}
function randElt(arr)
{
	mod_assert.ok(Array.isArray(arr) && arr.length > 0,
	    'randElt argument must be a non-empty array');
	return (arr[Math.floor(Math.random() * arr.length)]);
}
function assertHrtime(a)
{
	mod_assert.ok(a[0] >= 0 && a[1] >= 0,
	    'negative numbers not allowed in hrtimes');
	mod_assert.ok(a[1] < 1e9, 'nanoseconds column overflow');
}
function hrtimeDiff(a, b)
{
	assertHrtime(a);
	assertHrtime(b);
	mod_assert.ok(a[0] > b[0] || (a[0] == b[0] && a[1] >= b[1]),
	    'negative differences not allowed');
	var rv = [ a[0] - b[0], 0 ];
	if (a[1] >= b[1]) {
		rv[1] = a[1] - b[1];
	} else {
		rv[0]--;
		rv[1] = 1e9 - (b[1] - a[1]);
	}
	return (rv);
}
function hrtimeNanosec(a)
{
	assertHrtime(a);
	return (Math.floor(a[0] * 1e9 + a[1]));
}
function hrtimeMicrosec(a)
{
	assertHrtime(a);
	return (Math.floor(a[0] * 1e6 + a[1] / 1e3));
}
function hrtimeMillisec(a)
{
	assertHrtime(a);
	return (Math.floor(a[0] * 1e3 + a[1] / 1e6));
}
function hrtimeAccum(a, b)
{
	assertHrtime(a);
	assertHrtime(b);
	a[1] += b[1];
	if (a[1] >= 1e9) {
		a[0]++;
		a[1] -= 1e9;
	}
	a[0] += b[0];
	return (a);
}
function hrtimeAdd(a, b)
{
	assertHrtime(a);
	var rv = [ a[0], a[1] ];
	return (hrtimeAccum(rv, b));
}
function extraProperties(obj, allowed)
{
	mod_assert.ok(typeof (obj) === 'object' && obj !== null,
	    'obj argument must be a non-null object');
	mod_assert.ok(Array.isArray(allowed),
	    'allowed argument must be an array of strings');
	for (var i = 0; i < allowed.length; i++) {
		mod_assert.ok(typeof (allowed[i]) === 'string',
		    'allowed argument must be an array of strings');
	}
	return (Object.keys(obj).filter(function (key) {
		return (allowed.indexOf(key) === -1);
	}));
}
function mergeObjects(provided, overrides, defaults)
{
	var rv, k;
	rv = {};
	if (defaults) {
		for (k in defaults)
			rv[k] = defaults[k];
	}
	if (provided) {
		for (k in provided)
			rv[k] = provided[k];
	}
	if (overrides) {
		for (k in overrides)
			rv[k] = overrides[k];
	}
	return (rv);
}

var assert = assert_1;
var jsprim = jsprim$1;
var util = require$$2;
function ParseError(input, message, index) {
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ParseError);
  this.input = input;
  this.message = message;
  if (index !== undefined) {
    this.message += ' at index ' + index;
  }
}
util.inherits(ParseError, Error);
function modulo(a, n) {
  return (n + (a % n)) % n;
}
function _arrayToOctetString(input) {
  var out;
  out = (input[0] >> 8) + '.' + (input[0] & 0xff) + '.';
  out += (input[1] >> 8) + '.' + (input[1] & 0xff);
  return out;
}
function _isAddr(addr) {
  if (typeof (addr) === 'object') {
    if (Array.isArray(addr._fields) && typeof (addr._attrs) === 'object') {
      return true;
    }
  }
  return false;
}
function _toAddr(input) {
  if (typeof (input) === 'string') {
    return ip6addrParse(input);
  } else if (_isAddr(input)) {
    return input;
  } else {
    throw new Error('Invalid argument: Addr or parsable string expected');
  }
}
function _arrayToHex(input, zeroElide, zeroPad) {
  var i;
  var elStart = null;
  var elLen = 0;
  if (zeroElide) {
    var start = null;
    var len = null;
    for (i = 0; i < input.length; i++) {
      if (input[i] === 0) {
        if (start === null) {
          start = i;
          len = 1;
        } else {
          len++;
        }
      } else if (start !== null) {
        if (len > elLen) {
          elStart = start;
          elLen = len;
        }
        start = null;
      }
    }
    if (start !== null && len > elLen) {
      elStart = start;
      elLen = len;
    }
  }
  var output = [];
  var num;
  for (i = 0; i < input.length; i++) {
    if (elStart !== null) {
      if (i === elStart) {
        if (elLen === 8) {
          return ['::'];
        } else if (elStart === 0 || elStart + elLen === input.length) {
          output.push(':');
        } else {
          output.push('');
        }
      }
      if (i >= elStart && i < elStart + elLen) {
        continue;
      }
    }
    num = input[i].toString(16);
    if (zeroPad && num.length != 4) {
      num = '0000'.slice(num.length) + num;
    }
    output.push(num);
  }
  return output;
}
function _ipv4Mapped(input) {
  var comp = [0, 0, 0, 0, 0, 0xffff];
  var i;
  for (i = 0; i < 6; i++) {
    if (input[i] != comp[i])
      return false;
  }
  return true;
}
function _prefixToAddr(len) {
  assert.number(len);
  len = len | 0;
  assert.ok(len <= 128);
  assert.ok(len >= 0);
  var output = new Addr();
  var i;
  for (i = 0; len > 16; i++, len -= 16) {
    output._fields[i] = 0xffff;
  }
  if (len > 0) {
    output._fields[i] = 0xffff - ((1 << (16 - len)) - 1);
  }
  return output;
}
function _toCIDR(input) {
  if (typeof (input) === 'string') {
    return new CIDR(input);
  } else if (input instanceof CIDR) {
    return input;
  } else {
    throw new Error('Invalid argument: CIDR or parsable string expected');
  }
}
var strDefaults = {
  format: 'auto',
  zeroElide: true,
  zeroPad: false
};
function getStrOpt(opts, name) {
  if (opts && opts.hasOwnProperty(name)) {
    return opts[name];
  } else {
    return strDefaults[name];
  }
}
function Addr() {
  this._fields = [0, 0, 0, 0, 0, 0, 0, 0];
  this._attrs = {};
}
Addr.prototype.kind = function getKind() {
  if (v4subnet.contains(this)) {
    return 'ipv4';
  } else {
    return 'ipv6';
  }
};
Addr.prototype.toString = function toString(opts) {
  assert.optionalObject(opts, 'opts');
  var format = getStrOpt(opts, 'format');
  var zeroElide = getStrOpt(opts, 'zeroElide');
  var zeroPad = getStrOpt(opts, 'zeroPad');
  assert.string(format, 'opts.format');
  assert.bool(zeroElide, 'opts.zeroElide');
  assert.bool(zeroPad, 'opts.zeroPad');
  if (format === 'auto') {
    if (this._attrs.ipv4Bare) {
      format = 'v4';
    } else if (this._attrs.ipv4Mapped) {
      format = 'v4-mapped';
    } else {
      format = 'v6';
    }
  }
  switch (format) {
  case 'v4':
    if (!v4subnet.contains(this)) {
        throw new Error('cannot print non-v4 address in dotted quad notation');
    }
    return _arrayToOctetString(this._fields.slice(6));
  case 'v4-mapped':
    if (!v4subnet.contains(this)) {
        throw new Error('cannot print non-v4 address as a v4-mapped address');
    }
    var output = _arrayToHex(this._fields.slice(0, 6), zeroElide, zeroPad);
    output.push(_arrayToOctetString(this._fields.slice(6)));
    return output.join(':');
  case 'v6':
    return _arrayToHex(this._fields, zeroElide, zeroPad).join(':');
  default:
    throw new Error('unrecognized format method "' + format + '"');
  }
};
Addr.prototype.toBuffer = function toBuffer(buf) {
  if (buf !== undefined) {
    if (!isBuffer$2(buf)) {
      throw new Error('optional arg must be Buffer');
    }
  } else {
    buf = new Buffer$1(16);
  }
  var i;
  for (i = 0; i < 8; i++) {
    buf.writeUInt16BE(this._fields[i], i*2);
  }
  return buf;
};
Addr.prototype.toLong = function toLong() {
  if (!v4subnet.contains(this)) {
    throw new Error('only possible for ipv4-mapped addresses');
  }
  return ((this._fields[6] << 16) >>> 0) + this._fields[7];
};
Addr.prototype.clone = function cloneAddr() {
  var out = new Addr();
  out._fields = this._fields.slice();
  for (var k in this._attrs) {
      out._attrs[k] = this._attrs[k];
  }
  return out;
};
Addr.prototype.offset = function offset(num) {
  if (num < -4294967295 || num > 4294967295) {
    throw new Error('offsets should be between -4294967295 and 4294967295');
  }
  var out = this.clone();
  var i, moved;
  for (i = 7; i >= 0; i--) {
    moved = out._fields[i] + num;
    if (moved > 65535) {
      num = moved >>> 16;
      moved = moved & 0xffff;
    } else if (moved < 0) {
      num = Math.floor(moved / (1 << 16));
      moved = modulo(moved, 1 << 16);
    } else {
      num = 0;
    }
    out._fields[i] = moved;
    if (num !== 0) {
      if ((i === 0) || (i === 6 && this._attrs.ipv4Mapped)) {
        return null;
      }
    } else {
      break;
    }
  }
  return out;
};
Addr.prototype.and = function addrAnd(input) {
  input = _toAddr(input);
  var i;
  var output = this.clone();
  for (i = 0; i < 8; i++) {
    output._fields[i] = output._fields[i] & input._fields[i];
  }
  return output;
};
Addr.prototype.or = function addrOr(input) {
  input = _toAddr(input);
  var i;
  var output = this.clone();
  for (i = 0; i < 8; i++) {
    output._fields[i] = output._fields[i] | input._fields[i];
  }
  return output;
};
Addr.prototype.not = function addrNot() {
  var i;
  var output = this.clone();
  for (i = 0; i < 8; i++) {
    output._fields[i] = (~ output._fields[i]) & 0xffff;
  }
  return output;
};
Addr.prototype.compare = function compareMember(addr) {
  return ip6addrCompare(this, addr);
};
function CIDR(addr, prefixLen) {
  if (prefixLen === undefined) {
    assert.string(addr);
    var fields = addr.match(/^([a-fA-F0-9:.]+)\/([0-9]+)$/);
    if (fields === null) {
      throw new Error('Invalid argument: <addr>/<prefix> expected');
    }
    addr = fields[1];
    prefixLen = parseInt(fields[2], 10);
  }
  assert.number(prefixLen);
  prefixLen = prefixLen | 0;
  addr = _toAddr(addr);
  if (addr._attrs.ipv4Bare) {
    prefixLen += 96;
  }
  if (prefixLen < 0 || prefixLen > 128) {
    throw new Error('Invalid prefix length');
  }
  this._prefix = prefixLen;
  this._mask = _prefixToAddr(prefixLen);
  this._addr = addr.and(this._mask);
}
CIDR.prototype.contains = function cidrContains(input) {
  input = _toAddr(input);
  return (this._addr.compare(input.and(this._mask)) === 0);
};
CIDR.prototype.first = function cidrFirst() {
  if (this._prefix >= 127) {
    return this._addr;
  } else {
    return this._addr.offset(1);
  }
};
CIDR.prototype.last = function cidrLast() {
  var ending = this._addr.or(this._mask.not());
  if (this._prefix >= 127) {
    return ending;
  } else {
    if (this._addr._attrs.ipv4Mapped) {
      return ending.offset(-1);
    } else {
      return ending;
    }
  }
};
CIDR.prototype.broadcast = function getBroadcast() {
  if (!v4subnet.contains(this._addr)) {
    throw new Error('Only IPv4 networks have broadcast addresses');
  }
  return this._addr.or(this._mask.not());
};
CIDR.prototype.compare = function compareCIDR(cidr) {
  return ip6cidrCompare(this, cidr);
};
CIDR.prototype.prefixLength = function getPrefixLength(format) {
  assert.optionalString(format, 'format');
  if (format === undefined || format === 'auto') {
    format = this._addr._attrs.ipv4Bare ? 'v4' : 'v6';
  }
  switch (format) {
  case 'v4':
    if (!v4subnet.contains(this._addr)) {
        throw new Error('cannot return v4 prefix length for non-v4 address');
    }
    return this._prefix - 96;
  case 'v6':
    return this._prefix;
  default:
    throw new Error('unrecognized format method "' + format + '"');
  }
};
CIDR.prototype.address = function getAddressComponent() {
  return this._addr;
};
CIDR.prototype.toString = function cidrString(opts) {
  assert.optionalObject(opts, 'opts');
  var format = getStrOpt(opts, 'format');
  if (format === 'v4-mapped') {
    format = 'v6';
  }
  return this._addr.toString(opts) + '/' + this.prefixLength(format);
};
var v4subnet = new CIDR('::ffff:0:0', 96);
function ip6cidrCompare(a, b) {
  a = _toCIDR(a);
  b = _toCIDR(b);
  var cmp = ip6addrCompare(a._addr, b._addr);
  return cmp === 0 ? b._prefix - a._prefix : cmp;
}
function AddrRange(begin, end) {
  begin = _toAddr(begin);
  end = _toAddr(end);
  if (begin.compare(end) > 0) {
    throw new Error('begin address must be <= end address');
  }
  this._begin = begin;
  this._end = end;
}
AddrRange.prototype.contains = function addrRangeContains(input) {
  input = _toAddr(input);
  return (this._begin.compare(input) <= 0 && this._end.compare(input) >= 0);
};
AddrRange.prototype.first = function addrRangeFirst() {
  return this._begin;
};
AddrRange.prototype.last = function addrRangeLast() {
  return this._end;
};
function ip6addrParse(input) {
  if (typeof (input) === 'string') {
    return parseString(input);
  } else if (typeof (input) === 'number') {
    return parseLong(input);
  } else if (typeof (input) === 'object' && _isAddr(input)) {
    return input;
  } else {
    throw new Error('Invalid argument: only string|number allowed');
  }
}
function parseString(input) {
  assert.string(input);
  input = input.toLowerCase();
  var result = new Addr();
  var ip6Fields = [];
  var ip4Fields = [];
  var expIndex = null;
  var value = '';
  var i, c;
  if (input.length > 40) {
    throw new ParseError(input, 'Input too long');
  }
  for (i = 0; i < input.length; i++) {
    c = input[i];
    if (c === ':') {
      if ((i+1) < input.length && input[i+1] === ':') {
        if (expIndex !== null) {
          throw new ParseError(input, 'Multiple :: delimiters', i);
        }
        if (value !== '') {
          ip6Fields.push(value);
          value = '';
        }
        expIndex = ip6Fields.length;
        i++;
      } else {
        if (value === '') {
          throw new ParseError(input, 'illegal delimiter', i);
        }
        ip6Fields.push(value);
        value = '';
      }
    } else if (c === '.') {
      ip4Fields.push(value);
      value = '';
    } else {
      value = value + c;
    }
  }
  if (value !== '') {
    if (ip4Fields.length !== 0) {
      ip4Fields.push(value);
    } else {
      ip6Fields.push(value);
    }
    value = '';
  } else {
    if (expIndex !== ip6Fields.length || ip4Fields.length > 0) {
      throw new ParseError(input, 'Cannot end with delimiter besides ::');
    }
  }
  if (ip4Fields.length === 0) {
    if (ip6Fields.length > 8) {
      throw new ParseError(input, 'Too many fields');
    } else if (ip6Fields.length < 8 && expIndex === null) {
      throw new ParseError(input, 'Too few fields');
    }
  } else {
    if (ip4Fields.length !== 4) {
      throw new ParseError(input, 'IPv4 portion must have 4 fields');
    }
    if (ip6Fields.length === 0 && expIndex === null) {
      result._attrs.ipv4Bare = true;
      ip6Fields = ['ffff'];
      expIndex = 0;
    }
    if (ip6Fields.length > 6) {
      throw new ParseError(input, 'Too many fields');
    } else if (ip6Fields.length < 6 && expIndex === null) {
      throw new ParseError(input, 'Too few fields');
    }
  }
  var field, num;
  for (i = 0; i < ip6Fields.length; i++) {
    field = ip6Fields[i];
    num = jsprim.parseInteger(field, { base: 16, allowSign: false });
    if (num instanceof Error || num < 0 || num > 65535) {
      throw new ParseError(input, 'Invalid field value: ' + field);
    }
    ip6Fields[i] = num;
  }
  for (i = 0; i < ip4Fields.length; i++) {
    field = ip4Fields[i];
    num = jsprim.parseInteger(field, { base: 10, allowSign: false });
    if (num instanceof Error || num < 0 || num > 255) {
      throw new ParseError(input, 'Invalid field value: ' + field);
    }
    ip4Fields[i] = num;
  }
  if (ip4Fields.length !== 0) {
    ip6Fields.push((ip4Fields[0]*256) + ip4Fields[1]);
    ip6Fields.push((ip4Fields[2]*256) + ip4Fields[3]);
  }
  if (ip6Fields.length < 8 && expIndex !== null) {
    var filler = [];
    for (i = 0; i < (8 - ip6Fields.length); i++) {
      filler.push(0);
    }
    ip6Fields = Array.prototype.concat(
      ip6Fields.slice(0, expIndex),
      filler,
      ip6Fields.slice(expIndex)
    );
  }
  if (ip4Fields.length !== 0) {
    if (!_ipv4Mapped(ip6Fields)) {
      throw new ParseError(input, 'invalid dotted-quad notation');
    } else {
      result._attrs.ipv4Mapped = true;
    }
  }
  result._fields = ip6Fields;
  return result;
}
function parseLong(input) {
  assert.number(input);
  if (input !== Math.floor(input)) {
    throw new Error('Value must be integer');
  }
  if (input < 0 || input > 0xffffffff) {
    throw new Error('Value must be 32 bit');
  }
  var out = new Addr();
  out._fields[7] = input & 0xffff;
  out._fields[6] = (input >>> 16);
  out._fields[5] = 0xffff;
  out._attrs.ipv4Bare = true;
  out._attrs.ipv4Mapped = true;
  return out;
}
function ip6addrCompare(a, b) {
  a = _toAddr(a);
  b = _toAddr(b);
  var i;
  for (i = 0; i < 8; i++) {
    if (a._fields[i] < b._fields[i]) {
      return -1;
    } else if (a._fields[i] > b._fields[i]) {
      return 1;
    }
  }
  return 0;
}
var ip6addr = {
  parse: ip6addrParse,
  compare: ip6addrCompare,
  createCIDR: function (addr, len) {
    return new CIDR(addr, len);
  },
  compareCIDR: ip6cidrCompare,
  createAddrRange: function (begin, end) {
    return new AddrRange(begin, end);
  }
};

/**
 * This is the base class representing double values modifiers
 */
var BaseValuesModifier = /** @class */ (function () {
    /**
     * Parses the values string
     *
     * @param values - values string
     *
     * @throws an error if the string is empty or invalid
     */
    function BaseValuesModifier(values) {
        if (!values) {
            throw new SyntaxError('Modifier cannot be empty');
        }
        this.value = values;
        var permittedValues = [];
        var restrictedValues = [];
        var parts = values.split(SEPARATOR);
        for (var i = 0; i < parts.length; i += 1) {
            var app = parts[i];
            var restricted = false;
            if (app.startsWith('~')) {
                restricted = true;
                app = app.substring(1).trim();
            }
            if (app === '') {
                throw new SyntaxError("Empty values specified in \"".concat(values, "\""));
            }
            if (restricted) {
                restrictedValues.push(app);
            }
            else {
                permittedValues.push(app);
            }
        }
        this.restricted = restrictedValues.length > 0 ? restrictedValues : null;
        this.permitted = permittedValues.length > 0 ? permittedValues : null;
    }
    BaseValuesModifier.prototype.getPermitted = function () {
        return this.permitted;
    };
    BaseValuesModifier.prototype.getRestricted = function () {
        return this.restricted;
    };
    BaseValuesModifier.prototype.getValue = function () {
        return this.value;
    };
    BaseValuesModifier.prototype.match = function (value) {
        if (!this.restricted && !this.permitted) {
            return true;
        }
        if (this.restricted && this.restricted.includes(value)) {
            return false;
        }
        if (this.permitted) {
            return this.permitted.includes(value);
        }
        return true;
    };
    return BaseValuesModifier;
}());

/**
 * Netmasks class
 */
var NetmasksCollection = /** @class */ (function () {
    function NetmasksCollection() {
        this.ipv4Masks = [];
        this.ipv6Masks = [];
    }
    /**
     * Returns true if any of the containing masks contains provided value
     *
     * @param value
     */
    NetmasksCollection.prototype.contains = function (value) {
        if (isIp_1.v4(value)) {
            return this.ipv4Masks.some(function (x) { return x.contains(value); });
        }
        return this.ipv6Masks.some(function (x) { return x.contains(value); });
    };
    return NetmasksCollection;
}());
/**
 * The client modifier allows specifying clients this rule will be working for.
 * It accepts client names (not ClientIDs), IP addresses, or CIDR ranges.
 */
var ClientModifier = /** @class */ (function (_super) {
    __extends(ClientModifier, _super);
    /**
     * Constructor
     *
     * @param value
     */
    function ClientModifier(value) {
        var _this = _super.call(this, value) || this;
        var permitted = _this.getPermitted();
        if (permitted) {
            _this.permitted = ClientModifier.stripValues(permitted);
            _this.permittedNetmasks = ClientModifier.parseNetmasks(_this.permitted);
        }
        var restricted = _this.getRestricted();
        if (restricted) {
            _this.restricted = ClientModifier.stripValues(restricted);
            _this.restrictedNetmasks = ClientModifier.parseNetmasks(_this.restricted);
        }
        return _this;
    }
    /**
     * Unquotes and unescapes string
     *
     * @param values
     */
    ClientModifier.stripValues = function (values) {
        return values.map(function (v) {
            if ((v.startsWith('"') && v.endsWith('"'))
                || (v.startsWith('\'') && v.endsWith('\''))) {
                // eslint-disable-next-line no-param-reassign
                v = v.substr(1, v.length - 2);
            }
            return v.replace(/\\/ig, '');
        });
    };
    /**
     * Checks if this modifier matches provided params
     *
     * @param clientName
     * @param clientIP
     */
    ClientModifier.prototype.matchAny = function (clientName, clientIP) {
        if (this.restricted) {
            if (clientName && this.restricted.includes(clientName)) {
                return false;
            }
            if (clientIP && this.restricted.includes(clientIP)) {
                return false;
            }
            return true;
        }
        if (this.restrictedNetmasks) {
            if (clientIP && this.restrictedNetmasks.contains(clientIP)) {
                return false;
            }
            return true;
        }
        if (this.permitted) {
            if (clientName && this.permitted.includes(clientName)) {
                return true;
            }
            if (clientIP && this.permitted.includes(clientIP)) {
                return true;
            }
        }
        if (this.permittedNetmasks) {
            if (clientIP && this.permittedNetmasks.contains(clientIP)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Parses netmasks from client's strings
     *
     * @param values
     */
    ClientModifier.parseNetmasks = function (values) {
        var result = new NetmasksCollection();
        values.forEach(function (x) {
            var cidrVersion = isCidr(x);
            if (cidrVersion === 4) {
                result.ipv4Masks.push(new Netmask_1(x));
            }
            else if (cidrVersion === 6) {
                result.ipv6Masks.push(ip6addr.createCIDR(x));
            }
        });
        return result;
    };
    return ClientModifier;
}(BaseValuesModifier));

/**
 * The dnsrewrite response modifier allows replacing the content of the response
 * to the DNS request for the matching hosts.
 *
 * TODO: This modifier is not yet implemented
 * https://github.com/AdguardTeam/AdGuardHome/wiki/Hosts-Blocklists#dnsrewrite
 */
var DnsRewriteModifier = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param value
     */
    function DnsRewriteModifier(value) {
        this.value = value;
    }
    /**
     * Modifier value
     */
    DnsRewriteModifier.prototype.getValue = function () {
        return this.value;
    };
    return DnsRewriteModifier;
}());

/**
 * The dnstype modifier allows specifying DNS request type on which this rule will be triggered.
 */
var DnsTypeModifier = /** @class */ (function (_super) {
    __extends(DnsTypeModifier, _super);
    /**
     * Constructor
     *
     * @param value
     */
    function DnsTypeModifier(value) {
        var _this = _super.call(this, value) || this;
        if (_this.permitted) {
            _this.restricted = null;
        }
        return _this;
    }
    return DnsTypeModifier;
}(BaseValuesModifier));

/**
 * The ctag modifier allows to block domains only for specific types of DNS client tags.
 */
var CtagModifier = /** @class */ (function (_super) {
    __extends(CtagModifier, _super);
    /**
     * Constructor
     *
     * @param value
     */
    function CtagModifier(value) {
        var _this = _super.call(this, value) || this;
        _this.validate();
        return _this;
    }
    /**
     * Validates tag values
     */
    CtagModifier.prototype.validate = function () {
        if (!this.getValue()) {
            throw new Error('Invalid rule: Ctag modifier must not be empty');
        }
        var tags = this.permitted ? this.permitted : this.restricted;
        if (tags && tags.some(function (x) { return !CtagModifier.ALLOWED_TAGS.includes(x); })) {
            throw new Error('Invalid rule: Invalid ctag modifier');
        }
    };
    /**
     * The list of allowed tags
     */
    CtagModifier.ALLOWED_TAGS = [
        // By device type:
        'device_audio',
        'device_camera',
        'device_gameconsole',
        'device_laptop',
        'device_nas',
        'device_pc',
        'device_phone',
        'device_printer',
        'device_securityalarm',
        'device_tablet',
        'device_tv',
        'device_other',
        // By operating system:
        'os_android',
        'os_ios',
        'os_linux',
        'os_macos',
        'os_windows',
        'os_other',
        // By user group:
        'user_admin',
        'user_regular',
        'user_child',
    ];
    return CtagModifier;
}(BaseValuesModifier));

/**
 * Rule pattern class
 *
 * This class parses rule pattern text to simple fields.
 */
var Pattern = /** @class */ (function () {
    /**
     * Constructor
     * @param pattern
     * @param matchcase
     */
    function Pattern(pattern, matchcase) {
        if (matchcase === void 0) { matchcase = false; }
        this.pattern = pattern;
        this.shortcut = SimpleRegex.extractShortcut(this.pattern);
        this.matchcase = matchcase;
    }
    /**
     * Checks if this rule pattern matches the specified request.
     *
     * @param request - request to check
     * @param shortcutMatched if true, it means that the request already matches
     * this pattern's shortcut and we don't need to match it again.
     * @returns true if pattern matches
     */
    Pattern.prototype.matchPattern = function (request, shortcutMatched) {
        this.prepare();
        if (this.patternShortcut) {
            return shortcutMatched || this.matchShortcut(request.urlLowercase);
        }
        if (this.hostname) {
            // If we have a `||example.org^` rule, it's easier to match
            // against the request's hostname only without matching
            // a regular expression.
            return request.hostname === this.hostname
                || ( // First light check without new string memory allocation
                request.hostname.endsWith(this.hostname)
                    // Strict check
                    && request.hostname.endsWith(".".concat(this.hostname)));
        }
        // If the regular expression is invalid, just return false right away.
        if (this.regexInvalid || !this.regex) {
            return false;
        }
        // This is needed for DNS filtering only, not used in browser blocking.
        if (this.shouldMatchHostname(request)) {
            return this.regex.test(request.hostname);
        }
        return this.regex.test(request.url);
    };
    /**
     * Checks if this rule pattern matches the specified relative path string.
     * This method is used in cosmetic rules to implement the $path modifier matching logic.
     *
     * @param path - path to check
     * @returns true if pattern matches
     */
    Pattern.prototype.matchPathPattern = function (path) {
        this.prepare();
        if (this.hostname) {
            return false;
        }
        var pathIsEmptyString = this.pattern === '';
        // No-value $path should match root URL
        if (pathIsEmptyString && path === '/') {
            return true;
        }
        if (!pathIsEmptyString && this.patternShortcut) {
            return this.matchShortcut(path);
        }
        // If the regular expression is invalid, just return false right away.
        if (this.regexInvalid || !this.regex) {
            return false;
        }
        return this.regex.test(path);
    };
    /**
     * matchShortcut simply checks if shortcut is a substring of the URL.
     * @param request - request to check.
     */
    Pattern.prototype.matchShortcut = function (str) {
        return str.indexOf(this.shortcut) >= 0;
    };
    /**
     * Prepares this pattern
     */
    Pattern.prototype.prepare = function () {
        if (this.prepared) {
            return;
        }
        this.prepared = true;
        // If shortcut and pattern are the same, we don't need to actually compile
        // a regex and can simply use matchShortcut instead,
        // except for the $match-case modifier
        if (this.pattern === this.shortcut && !this.matchcase) {
            this.patternShortcut = true;
            return;
        }
        // Rules like `/example/*` are rather often in the real-life filters,
        // we might want to process them.
        if (this.pattern.startsWith(this.shortcut)
            && this.pattern.length === this.shortcut.length + 1
            && this.pattern.endsWith('*')) {
            this.patternShortcut = true;
            return;
        }
        if (this.pattern.startsWith(SimpleRegex.MASK_START_URL)
            && this.pattern.endsWith(SimpleRegex.MASK_SEPARATOR)
            && this.pattern.indexOf('*') < 0
            && this.pattern.indexOf('/') < 0) {
            this.hostname = this.pattern.slice(2, this.pattern.length - 1);
            return;
        }
        this.compileRegex();
    };
    /**
     * Compiles this pattern regex
     */
    Pattern.prototype.compileRegex = function () {
        var regexText = SimpleRegex.patternToRegexp(this.pattern);
        try {
            var flags = 'i';
            if (this.matchcase) {
                flags = '';
            }
            this.regex = new RegExp(regexText, flags);
        }
        catch (e) {
            this.regexInvalid = true;
        }
    };
    /**
     * Checks if we should match hostnames and not the URL
     * this is important for the cases when we use urlfilter for DNS-level blocking
     * Note, that even though we may work on a DNS-level, we should still sometimes match full URL instead
     *
     * @param request
     */
    Pattern.prototype.shouldMatchHostname = function (request) {
        if (!request.isHostnameRequest) {
            return false;
        }
        return !this.isPatternDomainSpecific();
    };
    /**
     * In case pattern starts with the following it targets some specific domain
     */
    Pattern.prototype.isPatternDomainSpecific = function () {
        if (this.patternDomainSpecific === undefined) {
            this.patternDomainSpecific = this.pattern.startsWith(SimpleRegex.MASK_START_URL)
                || this.pattern.startsWith('http://')
                || this.pattern.startsWith('https:/')
                || this.pattern.startsWith('://');
        }
        return this.patternDomainSpecific;
    };
    return Pattern;
}());

/**
 * NetworkRuleOption is the enumeration of various rule options.
 * In order to save memory, we store some options as a flag.
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#modifiers
 */
var NetworkRuleOption;
(function (NetworkRuleOption) {
    /** $third-party modifier */
    NetworkRuleOption[NetworkRuleOption["ThirdParty"] = 1] = "ThirdParty";
    /** $match-case modifier */
    NetworkRuleOption[NetworkRuleOption["MatchCase"] = 2] = "MatchCase";
    /** $important modifier */
    NetworkRuleOption[NetworkRuleOption["Important"] = 4] = "Important";
    // Allowlist rules modifiers
    // Each of them can disable part of the functionality
    /** $elemhide modifier */
    NetworkRuleOption[NetworkRuleOption["Elemhide"] = 8] = "Elemhide";
    /** $generichide modifier */
    NetworkRuleOption[NetworkRuleOption["Generichide"] = 16] = "Generichide";
    /** $specifichide modifier */
    NetworkRuleOption[NetworkRuleOption["Specifichide"] = 32] = "Specifichide";
    /** $genericblock modifier */
    NetworkRuleOption[NetworkRuleOption["Genericblock"] = 64] = "Genericblock";
    /** $jsinject modifier */
    NetworkRuleOption[NetworkRuleOption["Jsinject"] = 128] = "Jsinject";
    /** $urlblock modifier */
    NetworkRuleOption[NetworkRuleOption["Urlblock"] = 256] = "Urlblock";
    /** $content modifier */
    NetworkRuleOption[NetworkRuleOption["Content"] = 512] = "Content";
    /** $extension modifier */
    NetworkRuleOption[NetworkRuleOption["Extension"] = 1024] = "Extension";
    /** $stealth modifier */
    NetworkRuleOption[NetworkRuleOption["Stealth"] = 2048] = "Stealth";
    // Content modifying
    // $empty modifier
    NetworkRuleOption[NetworkRuleOption["Empty"] = 4096] = "Empty";
    // $mp4 modifier
    NetworkRuleOption[NetworkRuleOption["Mp4"] = 8192] = "Mp4";
    // Other modifiers
    /** $popup modifier */
    NetworkRuleOption[NetworkRuleOption["Popup"] = 16384] = "Popup";
    /** $csp modifier */
    NetworkRuleOption[NetworkRuleOption["Csp"] = 32768] = "Csp";
    /** $replace modifier */
    NetworkRuleOption[NetworkRuleOption["Replace"] = 65536] = "Replace";
    /** $cookie modifier */
    NetworkRuleOption[NetworkRuleOption["Cookie"] = 131072] = "Cookie";
    /** $redirect modifier */
    NetworkRuleOption[NetworkRuleOption["Redirect"] = 262144] = "Redirect";
    /** $badfilter modifier */
    NetworkRuleOption[NetworkRuleOption["Badfilter"] = 524288] = "Badfilter";
    /** $removeparam modifier */
    NetworkRuleOption[NetworkRuleOption["RemoveParam"] = 1048576] = "RemoveParam";
    /** $removeheader modifier */
    NetworkRuleOption[NetworkRuleOption["RemoveHeader"] = 2097152] = "RemoveHeader";
    /** $jsonprune modifier */
    NetworkRuleOption[NetworkRuleOption["JsonPrune"] = 4194304] = "JsonPrune";
    /** $hls modifier */
    NetworkRuleOption[NetworkRuleOption["Hls"] = 8388608] = "Hls";
    // Compatibility dependent
    /** $network modifier */
    NetworkRuleOption[NetworkRuleOption["Network"] = 16777216] = "Network";
    /** dns modifiers */
    NetworkRuleOption[NetworkRuleOption["Client"] = 33554432] = "Client";
    NetworkRuleOption[NetworkRuleOption["DnsRewrite"] = 67108864] = "DnsRewrite";
    NetworkRuleOption[NetworkRuleOption["DnsType"] = 134217728] = "DnsType";
    NetworkRuleOption[NetworkRuleOption["Ctag"] = 268435456] = "Ctag";
    // Document
    NetworkRuleOption[NetworkRuleOption["Document"] = 536870912] = "Document";
    // Groups (for validation)
    /** Blacklist-only modifiers */
    NetworkRuleOption[NetworkRuleOption["BlacklistOnly"] = 12288] = "BlacklistOnly";
    /** Allowlist-only modifiers */
    NetworkRuleOption[NetworkRuleOption["AllowlistOnly"] = 4088] = "AllowlistOnly";
    /** Options supported by host-level network rules * */
    NetworkRuleOption[NetworkRuleOption["OptionHostLevelRules"] = 503840772] = "OptionHostLevelRules";
    /**
     * Removeparam compatible modifiers
     *
     * $removeparam rules are compatible only with content type modifiers ($script, $stylesheet, etc)
     * and this list of modifiers:
     */
    NetworkRuleOption[NetworkRuleOption["RemoveParamCompatibleOptions"] = 538443783] = "RemoveParamCompatibleOptions";
    /**
     * Removeheader compatible modifiers
     *
     * $removeheader rules are compatible only with content type modifiers ($script, $stylesheet, etc)
     * and this list of modifiers:
     */
    NetworkRuleOption[NetworkRuleOption["RemoveHeaderCompatibleOptions"] = 539492359] = "RemoveHeaderCompatibleOptions";
})(NetworkRuleOption || (NetworkRuleOption = {}));
/**
 * Helper class that is used for passing {@link NetworkRule.parseRuleText}
 * result to the caller. Should not be used outside of this file.
 */
var BasicRuleParts = /** @class */ (function () {
    function BasicRuleParts() {
    }
    return BasicRuleParts;
}());
/**
 * Basic network filtering rule.
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules
 */
var NetworkRule = /** @class */ (function () {
    /**
     * Creates an instance of the {@link NetworkRule}.
     * It parses this rule and extracts the rule pattern (see {@link SimpleRegex}),
     * and rule modifiers.
     *
     * @param ruleText - original rule text.
     * @param filterListId - ID of the filter list this rule belongs to.
     *
     * @throws error if it fails to parse the rule.
     */
    function NetworkRule(ruleText, filterListId) {
        this.permittedDomains = null;
        this.restrictedDomains = null;
        /**
         * Domains in denyallow modifier providing exceptions for permitted domains
         * https://github.com/AdguardTeam/CoreLibs/issues/1304
         */
        this.denyAllowDomains = null;
        /** Flag with all enabled rule options */
        this.enabledOptions = 0;
        /** Flag with all disabled rule options */
        this.disabledOptions = 0;
        /** Flag with all permitted request types. 0 means ALL. */
        this.permittedRequestTypes = 0;
        /** Flag with all restricted request types. 0 means NONE. */
        this.restrictedRequestTypes = 0;
        /**
         * Rule Advanced modifier
         */
        this.advancedModifier = null;
        /**
         * Rule App modifier
         */
        this.appModifier = null;
        /**
         * Priority weight
         * Used in rules priority comparision
         */
        this.priorityWeight = 0;
        this.ruleText = ruleText;
        this.filterListId = filterListId;
        var ruleParts = NetworkRule.parseRuleText(ruleText);
        this.allowlist = !!ruleParts.allowlist;
        var pattern = ruleParts.pattern;
        if (pattern && NetworkRule.hasSpaces(pattern)) {
            throw new SyntaxError('Rule has spaces, seems to be an host rule');
        }
        if (ruleParts.options) {
            this.loadOptions(ruleParts.options);
        }
        if (pattern === SimpleRegex.MASK_START_URL
            || pattern === SimpleRegex.MASK_ANY_CHARACTER
            || pattern === ''
            || pattern.length < SimpleRegex.MIN_GENERIC_RULE_LENGTH) {
            // Except cookie, removeparam rules and dns compatible rules, they have their own atmosphere
            var hasCookieModifier = this.advancedModifier instanceof CookieModifier;
            var hasRemoveParamModifier = this.advancedModifier instanceof RemoveParamModifier;
            // https://github.com/AdguardTeam/tsurlfilter/issues/56
            var isDnsCompatible = isCompatibleWith(CompatibilityTypes.dns);
            if (!hasCookieModifier && !hasRemoveParamModifier && !isDnsCompatible) {
                if (!(this.hasPermittedDomains() || this.hasPermittedApps())) {
                    // Rule matches too much and does not have any domain restriction
                    // We should not allow this kind of rules
                    // eslint-disable-next-line max-len
                    throw new SyntaxError('The rule is too wide, add domain restriction or make the pattern more specific');
                }
            }
        }
        this.pattern = new Pattern(pattern, this.isOptionEnabled(NetworkRuleOption.MatchCase));
    }
    NetworkRule.prototype.getText = function () {
        return this.ruleText;
    };
    NetworkRule.prototype.getFilterListId = function () {
        return this.filterListId;
    };
    /**
     * Returns rule pattern,
     * which currently is used only in the rule validator module
     */
    NetworkRule.prototype.getPattern = function () {
        return this.pattern.pattern;
    };
    /**
     * Returns `true` if the rule is "allowlist", e.g. if it disables other
     * rules when the pattern matches the request.
     */
    NetworkRule.prototype.isAllowlist = function () {
        return this.allowlist;
    };
    /**
     * Checks if the rule is a document-level allowlist rule
     * This means that the rule is supposed to disable or modify blocking
     * of the page subrequests.
     * For instance, `@@||example.org^$urlblock` unblocks all sub-requests.
     */
    NetworkRule.prototype.isDocumentLevelAllowlistRule = function () {
        if (!this.isAllowlist()) {
            return false;
        }
        return this.isOptionEnabled(NetworkRuleOption.Urlblock)
            || this.isOptionEnabled(NetworkRuleOption.Genericblock)
            || this.isOptionEnabled(NetworkRuleOption.Content);
    };
    /**
     * Checks if the rule is a document allowlist rule.
     * For instance,
     * "@@||example.org^$document"
     * completely disables filtering on all pages at example.com and all subdomains.
     */
    NetworkRule.prototype.isDocumentAllowlistRule = function () {
        if (!this.isAllowlist()) {
            return false;
        }
        return this.isOptionEnabled(NetworkRuleOption.Document);
    };
    /**
     * The longest part of pattern without any special characters.
     * It is used to improve the matching performance.
     */
    NetworkRule.prototype.getShortcut = function () {
        return this.pattern.shortcut;
    };
    /**
     * Gets list of permitted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
     */
    NetworkRule.prototype.getPermittedDomains = function () {
        return this.permittedDomains;
    };
    /**
     * Gets list of restricted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
     */
    NetworkRule.prototype.getRestrictedDomains = function () {
        return this.restrictedDomains;
    };
    /**
     * Gets list of permitted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
     */
    NetworkRule.prototype.getPermittedApps = function () {
        if (this.appModifier) {
            return this.appModifier.permittedApps;
        }
        return null;
    };
    /**
     * Gets list of restricted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
     */
    NetworkRule.prototype.getRestrictedApps = function () {
        if (this.appModifier) {
            return this.appModifier.restrictedApps;
        }
        return null;
    };
    /** Flag with all permitted request types. 0 means ALL. */
    NetworkRule.prototype.getPermittedRequestTypes = function () {
        return this.permittedRequestTypes;
    };
    /** Flag with all restricted request types. 0 means NONE. */
    NetworkRule.prototype.getRestrictedRequestTypes = function () {
        return this.restrictedRequestTypes;
    };
    /**
     * Advanced modifier
     */
    NetworkRule.prototype.getAdvancedModifier = function () {
        return this.advancedModifier;
    };
    /**
     * Advanced modifier value
     */
    NetworkRule.prototype.getAdvancedModifierValue = function () {
        return this.advancedModifier && this.advancedModifier.getValue();
    };
    /**
     * isRegexRule returns true if rule's pattern is a regular expression.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#regexp-support
     */
    NetworkRule.prototype.isRegexRule = function () {
        return (this.getPattern().startsWith(SimpleRegex.MASK_REGEX_RULE)
            && this.getPattern().endsWith(SimpleRegex.MASK_REGEX_RULE));
    };
    NetworkRule.prototype.matchesPermittedDomains = function (hostname) {
        if (this.hasPermittedDomains()
            && DomainModifier.isDomainOrSubdomainOfAny(hostname, this.permittedDomains)) {
            return true;
        }
        return false;
    };
    /**
     * Checks if this filtering rule matches the specified request.
     * @param request - request to check.
     * @param useShortcut - the flag to use this rule shortcut
     *
     * In case we use Trie in lookup table, we don't need to use shortcut cause we already check if request's url
     * includes full rule shortcut.
     */
    NetworkRule.prototype.match = function (request, useShortcut) {
        if (useShortcut === void 0) { useShortcut = true; }
        // Regex rules should not be tested by shortcut
        if (useShortcut && !this.matchShortcut(request)) {
            return false;
        }
        if (this.isOptionEnabled(NetworkRuleOption.ThirdParty) && !request.thirdParty) {
            return false;
        }
        if (this.isOptionDisabled(NetworkRuleOption.ThirdParty) && request.thirdParty) {
            return false;
        }
        if (!this.matchRequestType(request.requestType)) {
            return false;
        }
        if (!this.matchDomainModifier(request)) {
            return false;
        }
        if (this.isOptionEnabled(NetworkRuleOption.RemoveParam)) {
            if (!this.matchRequestTypeExplicit(request.requestType)) {
                return false;
            }
        }
        if (!this.matchDenyAllowDomains(request.hostname)) {
            return false;
        }
        if (!this.matchDnsType(request.dnsType)) {
            return false;
        }
        if (!this.matchClientTags(request.clientTags)) {
            return false;
        }
        if (!this.matchClient(request.clientName, request.clientIP)) {
            return false;
        }
        return this.pattern.matchPattern(request, true);
    };
    /**
     * matchShortcut simply checks if shortcut is a substring of the URL.
     * @param request - request to check.
     */
    NetworkRule.prototype.matchShortcut = function (request) {
        return request.urlLowercase.indexOf(this.getShortcut()) >= 0;
    };
    /**
     * matchDomain checks if the filtering rule is allowed on this domain.
     * @param domain - domain to check.
     */
    NetworkRule.prototype.matchDomain = function (domain) {
        if (this.hasRestrictedDomains()) {
            if (DomainModifier.isDomainOrSubdomainOfAny(domain, this.restrictedDomains)) {
                // Domain or host is restricted
                // i.e. $domain=~example.org
                return false;
            }
        }
        if (this.hasPermittedDomains()) {
            if (!DomainModifier.isDomainOrSubdomainOfAny(domain, this.permittedDomains)) {
                // Domain is not among permitted
                // i.e. $domain=example.org and we're checking example.com
                return false;
            }
        }
        return true;
    };
    /**
     * Check if request matches domain modifier by request referrer (general case) or by request target
     *
     * In some cases the $domain modifier can match not only the referrer domain, but also the target domain.
     * This happens when the following is true (1 AND ((2 AND 3) OR 4):
     *
     * 1) The request has document type
     * 2) The rule's pattern doesn't match any particular domain(s)
     * 3) The rule's pattern doesn't contain regular expressions
     * 4) The $domain modifier contains only excluded domains (e.g., $domain=~example.org|~example.com)
     *
     * When all these conditions are met, the domain modifier will match both the referrer domain and the target domain.
     * https://github.com/AdguardTeam/tsurlfilter/issues/45
     * @param request
     */
    NetworkRule.prototype.matchDomainModifier = function (request) {
        if (!this.permittedDomains && !this.restrictedDomains) {
            return true;
        }
        var isDocumentType = request.requestType === RequestType.Document
            || request.requestType === RequestType.Subdocument;
        var hasOnlyExcludedDomains = (!this.permittedDomains || this.permittedDomains.length === 0)
            && this.restrictedDomains
            && this.restrictedDomains.length > 0;
        var patternIsRegex = this.isRegexRule();
        var patternIsDomainSpecific = this.pattern.isPatternDomainSpecific();
        var matchesTargetByPatternCondition = !patternIsRegex && !patternIsDomainSpecific;
        if (isDocumentType && (hasOnlyExcludedDomains || matchesTargetByPatternCondition)) {
            // check if matches source hostname if exists or if matches target hostname
            return (request.sourceHostname && this.matchDomain(request.sourceHostname))
                || this.matchDomain(request.hostname);
        }
        return this.matchDomain(request.sourceHostname || '');
    };
    /**
     * checks if the filtering rule is allowed on this domain.
     * @param domain
     */
    NetworkRule.prototype.matchDenyAllowDomains = function (domain) {
        if (!this.denyAllowDomains) {
            return true;
        }
        if (this.denyAllowDomains.length > 0) {
            if (DomainModifier.isDomainOrSubdomainOfAny(domain, this.denyAllowDomains)) {
                return false;
            }
        }
        return true;
    };
    /**
     * Return TRUE if this rule matches with the tags associated with a client
     *
     * @param clientTags
     */
    NetworkRule.prototype.matchClientTags = function (clientTags) {
        var advancedModifier = this.getAdvancedModifier();
        if (!advancedModifier || !(advancedModifier instanceof CtagModifier)) {
            return true;
        }
        if (!clientTags) {
            return false;
        }
        var cTagsModifier = advancedModifier;
        return clientTags.every(function (x) { return cTagsModifier.match(x); });
    };
    /**
     * returns TRUE if the rule matches with the specified client
     *
     * @param clientName
     * @param clientIP
     */
    NetworkRule.prototype.matchClient = function (clientName, clientIP) {
        var advancedModifier = this.getAdvancedModifier();
        if (!advancedModifier || !(advancedModifier instanceof ClientModifier)) {
            return true;
        }
        if (!clientName && !clientIP) {
            return false;
        }
        var modifier = advancedModifier;
        return modifier.matchAny(clientName, clientIP);
    };
    /**
     * Return TRUE if this rule matches with the request dnstype
     *
     * @param dnstype
     */
    NetworkRule.prototype.matchDnsType = function (dnstype) {
        var advancedModifier = this.getAdvancedModifier();
        if (!advancedModifier || !(advancedModifier instanceof DnsTypeModifier)) {
            return true;
        }
        if (!dnstype) {
            return false;
        }
        var modifier = advancedModifier;
        return modifier.match(dnstype);
    };
    /**
     * Checks if rule has permitted domains
     */
    NetworkRule.prototype.hasPermittedDomains = function () {
        return this.permittedDomains != null && this.permittedDomains.length > 0;
    };
    /**
     * Checks if rule has restricted domains
     */
    NetworkRule.prototype.hasRestrictedDomains = function () {
        return this.restrictedDomains != null && this.restrictedDomains.length > 0;
    };
    /**
     * Checks if rule has permitted apps
     */
    NetworkRule.prototype.hasPermittedApps = function () {
        if (!this.appModifier) {
            return false;
        }
        return this.appModifier.permittedApps !== null && this.appModifier.permittedApps.length > 0;
    };
    /**
     * matchRequestType checks if the request's type matches the rule properties
     * @param requestType - request type to check.
     */
    NetworkRule.prototype.matchRequestType = function (requestType) {
        if (this.permittedRequestTypes !== 0) {
            if ((this.permittedRequestTypes & requestType) !== requestType) {
                return false;
            }
        }
        if (this.restrictedRequestTypes !== 0) {
            if ((this.restrictedRequestTypes & requestType) === requestType) {
                return false;
            }
        }
        return true;
    };
    /**
     * In case of $removeparam modifier,
     * we only allow it to target other content types if the rule has an explicit content-type modifier.
     */
    NetworkRule.prototype.matchRequestTypeExplicit = function (requestType) {
        if (this.permittedRequestTypes === 0
            && this.restrictedRequestTypes === 0
            && requestType !== RequestType.Document
            && requestType !== RequestType.Subdocument) {
            return false;
        }
        return this.matchRequestType(requestType);
    };
    /**
     * Checks if pattern has spaces
     * Used in order to do not create network rules from host rules
     * @param pattern
     * @private
     */
    NetworkRule.hasSpaces = function (pattern) {
        return pattern.indexOf(' ') > -1;
    };
    /**
     * Parses the options string and saves them.
     * More on the rule modifiers:
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers
     *
     * @param options - string with the rule modifiers
     *
     * @throws an error if there is an unsupported modifier
     */
    NetworkRule.prototype.loadOptions = function (options) {
        var optionParts = splitByDelimiterWithEscapeCharacter(options, ',', '\\', false);
        for (var i = 0; i < optionParts.length; i += 1) {
            var option = optionParts[i];
            var valueIndex = option.indexOf('=');
            var optionName = option;
            var optionValue = '';
            if (valueIndex > 0) {
                optionName = option.substring(0, valueIndex);
                optionValue = option.substring(valueIndex + 1);
            }
            this.loadOption(optionName, optionValue);
        }
        // More specified rule has more priority
        this.priorityWeight = optionParts.length;
        this.validateOptions();
        // In the case of allowlist rules $document implicitly includes all other modifiers:
        // `$content`, `$elemhide`, `$jsinject`, `$urlblock`.
        if (this.isAllowlist() && this.isOptionEnabled(NetworkRuleOption.Document)) {
            this.setOptionEnabled(NetworkRuleOption.Elemhide, true, true);
            this.setOptionEnabled(NetworkRuleOption.Jsinject, true, true);
            this.setOptionEnabled(NetworkRuleOption.Urlblock, true, true);
            this.setOptionEnabled(NetworkRuleOption.Content, true, true);
            this.priorityWeight += 4;
        }
        // $popup should work accumulatively with requestType modifiers
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1992
        if (this.isOptionEnabled(NetworkRuleOption.Popup) && this.permittedRequestTypes !== 0) {
            this.permittedRequestTypes |= RequestType.Document;
        }
        else if (this.isOptionEnabled(NetworkRuleOption.Popup)) {
            this.permittedRequestTypes = RequestType.Document;
        }
        // Rules of these types can be applied to documents only
        // $jsinject, $elemhide, $urlblock, $genericblock, $generichide and $content for allowlist rules.
        if (this.isOptionEnabled(NetworkRuleOption.Jsinject)
            || this.isOptionEnabled(NetworkRuleOption.Elemhide)
            || this.isOptionEnabled(NetworkRuleOption.Content)
            || this.isOptionEnabled(NetworkRuleOption.Urlblock)
            || this.isOptionEnabled(NetworkRuleOption.Genericblock)
            || this.isOptionEnabled(NetworkRuleOption.Generichide)) {
            this.permittedRequestTypes = RequestType.Document;
        }
    };
    /**
     * Returns true if the specified option is enabled.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option - rule option to check.
     */
    NetworkRule.prototype.isOptionEnabled = function (option) {
        return (this.enabledOptions & option) === option;
    };
    /**
     * Returns true if one and only option is enabled
     *
     * @param option
     */
    NetworkRule.prototype.isSingleOptionEnabled = function (option) {
        return this.enabledOptions === option;
    };
    /**
     * Returns true if the specified option is disabled.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option - rule option to check.
     */
    NetworkRule.prototype.isOptionDisabled = function (option) {
        return (this.disabledOptions & option) === option;
    };
    /**
     * Checks if the rule has higher priority that the specified rule
     * allowlist + $important > $important > allowlist > basic rules
     */
    NetworkRule.prototype.isHigherPriority = function (r) {
        var important = this.isOptionEnabled(NetworkRuleOption.Important);
        var rImportant = r.isOptionEnabled(NetworkRuleOption.Important);
        if (this.isAllowlist() && important && !(r.isAllowlist() && rImportant)) {
            return true;
        }
        if (r.isAllowlist() && rImportant && !(this.isAllowlist() && important)) {
            return false;
        }
        if (important && !rImportant) {
            return true;
        }
        if (rImportant && !important) {
            return false;
        }
        if (this.isAllowlist() && !r.isAllowlist()) {
            return true;
        }
        if (r.isAllowlist() && !this.isAllowlist()) {
            return false;
        }
        var generic = this.isGeneric();
        var rGeneric = r.isGeneric();
        if (!generic && rGeneric) {
            // specific rules have priority over generic rules
            return true;
        }
        return this.priorityWeight > r.priorityWeight;
    };
    /**
     * Returns true if the rule is considered "generic"
     * "generic" means that the rule is not restricted to a limited set of domains
     * Please note that it might be forbidden on some domains, though.
     *
     * @return {boolean}
     */
    NetworkRule.prototype.isGeneric = function () {
        return !this.hasPermittedDomains();
    };
    /**
     * Returns true if this rule negates the specified rule
     * Only makes sense when this rule has a `badfilter` modifier
     */
    NetworkRule.prototype.negatesBadfilter = function (specifiedRule) {
        if (!this.isOptionEnabled(NetworkRuleOption.Badfilter)) {
            return false;
        }
        if (this.allowlist !== specifiedRule.allowlist) {
            return false;
        }
        if (this.pattern.pattern !== specifiedRule.pattern.pattern) {
            return false;
        }
        if (this.permittedRequestTypes !== specifiedRule.permittedRequestTypes) {
            return false;
        }
        if (this.restrictedRequestTypes !== specifiedRule.restrictedRequestTypes) {
            return false;
        }
        if ((this.enabledOptions ^ NetworkRuleOption.Badfilter) !== specifiedRule.enabledOptions) {
            return false;
        }
        if (this.disabledOptions !== specifiedRule.disabledOptions) {
            return false;
        }
        if (!stringArraysEquals(this.restrictedDomains, specifiedRule.restrictedDomains)) {
            return false;
        }
        if (!stringArraysHaveIntersection(this.permittedDomains, specifiedRule.permittedDomains)) {
            return false;
        }
        return true;
    };
    /**
     * Checks if this rule can be used for hosts-level blocking
     */
    NetworkRule.prototype.isHostLevelNetworkRule = function () {
        if (this.hasPermittedDomains() || this.hasRestrictedDomains()) {
            return false;
        }
        if (this.permittedRequestTypes !== 0 && this.restrictedRequestTypes !== 0) {
            return false;
        }
        if (this.disabledOptions !== 0) {
            return false;
        }
        if (this.enabledOptions !== 0) {
            return ((this.enabledOptions
                & NetworkRuleOption.OptionHostLevelRules)
                | (this.enabledOptions
                    ^ NetworkRuleOption.OptionHostLevelRules)) === NetworkRuleOption.OptionHostLevelRules;
        }
        return true;
    };
    /**
     * Enables or disables the specified option.
     *
     * @param option - option to enable or disable.
     * @param enabled - true to enable, false to disable.
     * @param skipRestrictions - skip options allowlist/blacklist restrictions
     *
     * @throws an error if the option we're trying to enable cannot be.
     * For instance, you cannot enable $elemhide for blacklist rules.
     */
    NetworkRule.prototype.setOptionEnabled = function (option, enabled, skipRestrictions) {
        if (skipRestrictions === void 0) { skipRestrictions = false; }
        if (!skipRestrictions) {
            if (this.allowlist && (option & NetworkRuleOption.BlacklistOnly) === option) {
                throw new SyntaxError("Modifier ".concat(NetworkRuleOption[option], " cannot be used in allowlist rule"));
            }
            if (!this.allowlist && (option & NetworkRuleOption.AllowlistOnly) === option) {
                throw new SyntaxError("Modifier ".concat(NetworkRuleOption[option], " cannot be used in blacklist rule"));
            }
        }
        if (enabled) {
            this.enabledOptions |= option;
        }
        else {
            this.disabledOptions |= option;
        }
    };
    /**
     * Permits or forbids the specified request type.
     * "Permits" means that the rule will match **only** the types that are permitted.
     * "Restricts" means that the rule will match **all but restricted**.
     *
     * @param requestType - request type.
     * @param permitted - true if it's permitted (whic)
     */
    NetworkRule.prototype.setRequestType = function (requestType, permitted) {
        if (permitted) {
            this.permittedRequestTypes |= requestType;
        }
        else {
            this.restrictedRequestTypes |= requestType;
        }
    };
    /**
     * Sets and validates exceptionally allowed domains presented in $denyallow modifier
     *
     * @param optionValue
     */
    NetworkRule.prototype.setDenyAllowDomains = function (optionValue) {
        var domainModifier = new DomainModifier(optionValue, PIPE_SEPARATOR);
        if (domainModifier.restrictedDomains && domainModifier.restrictedDomains.length > 0) {
            throw new SyntaxError('Invalid modifier: $denyallow domains cannot be negated');
        }
        if (domainModifier.permittedDomains
            && domainModifier.permittedDomains.some(function (x) { return x.includes(SimpleRegex.MASK_ANY_CHARACTER); })) {
            throw new SyntaxError('Invalid modifier: $denyallow domains wildcards are not supported');
        }
        this.denyAllowDomains = domainModifier.permittedDomains;
    };
    /**
     * Loads the specified modifier:
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers
     *
     * @param optionName - modifier name.
     * @param optionValue - modifier value.
     *
     * @throws an error if there is an unsupported modifier
     */
    NetworkRule.prototype.loadOption = function (optionName, optionValue) {
        var OPTIONS = NetworkRule.OPTIONS;
        if (optionName.startsWith(OPTIONS.NOOP)) {
            /**
             * A noop modifier does nothing and can be used to increase some rules readability.
             * It consists of the sequence of underscore characters (_) of any length
             * and can appear in a rule as many times as it's needed.
             */
            if (!optionName.split(OPTIONS.NOOP).some(function (s) { return !!s; })) {
                return;
            }
        }
        switch (optionName) {
            // General options
            case OPTIONS.THIRD_PARTY:
            case NOT_MARK + OPTIONS.FIRST_PARTY:
                this.setOptionEnabled(NetworkRuleOption.ThirdParty, true);
                break;
            case NOT_MARK + OPTIONS.THIRD_PARTY:
            case OPTIONS.FIRST_PARTY:
                this.setOptionEnabled(NetworkRuleOption.ThirdParty, false);
                break;
            case OPTIONS.MATCH_CASE:
                this.setOptionEnabled(NetworkRuleOption.MatchCase, true);
                break;
            case NOT_MARK + OPTIONS.MATCH_CASE:
                this.setOptionEnabled(NetworkRuleOption.MatchCase, false);
                break;
            case OPTIONS.IMPORTANT:
                this.setOptionEnabled(NetworkRuleOption.Important, true);
                break;
            // $domain modifier
            case OPTIONS.DOMAIN: {
                var domainModifier = new DomainModifier(optionValue, PIPE_SEPARATOR);
                this.permittedDomains = domainModifier.permittedDomains;
                this.restrictedDomains = domainModifier.restrictedDomains;
                break;
            }
            case OPTIONS.DENYALLOW: {
                this.setDenyAllowDomains(optionValue);
                break;
            }
            // Document-level allowlist rules
            case OPTIONS.ELEMHIDE:
                this.setOptionEnabled(NetworkRuleOption.Elemhide, true);
                break;
            case OPTIONS.GENERICHIDE:
                this.setOptionEnabled(NetworkRuleOption.Generichide, true);
                break;
            case OPTIONS.SPECIFICHIDE:
                this.setOptionEnabled(NetworkRuleOption.Specifichide, true);
                break;
            case OPTIONS.GENERICBLOCK:
                this.setOptionEnabled(NetworkRuleOption.Genericblock, true);
                break;
            case OPTIONS.JSINJECT:
                this.setOptionEnabled(NetworkRuleOption.Jsinject, true);
                break;
            case OPTIONS.URLBLOCK:
                this.setOptionEnabled(NetworkRuleOption.Urlblock, true);
                break;
            case OPTIONS.CONTENT:
                this.setOptionEnabled(NetworkRuleOption.Content, true);
                break;
            // $document
            case OPTIONS.DOCUMENT:
            case OPTIONS.DOC:
                this.setOptionEnabled(NetworkRuleOption.Document, true);
                this.setRequestType(RequestType.Document, true);
                break;
            case NOT_MARK + OPTIONS.DOCUMENT:
            case NOT_MARK + OPTIONS.DOC:
                this.setOptionEnabled(NetworkRuleOption.Document, false);
                this.setRequestType(RequestType.Document, false);
                break;
            // Stealth mode $stealth
            case OPTIONS.STEALTH:
                this.setOptionEnabled(NetworkRuleOption.Stealth, true);
                break;
            // $popup blocking option
            case OPTIONS.POPUP:
                this.setOptionEnabled(NetworkRuleOption.Popup, true);
                break;
            // $empty and $mp4
            // Deprecated in favor of $redirect
            case OPTIONS.EMPTY:
                this.setOptionEnabled(NetworkRuleOption.Empty, true);
                break;
            case OPTIONS.MP4:
                this.setOptionEnabled(NetworkRuleOption.Mp4, true);
                break;
            // Content type options
            case OPTIONS.SCRIPT:
                this.setRequestType(RequestType.Script, true);
                break;
            case NOT_MARK + OPTIONS.SCRIPT:
                this.setRequestType(RequestType.Script, false);
                break;
            case OPTIONS.STYLESHEET:
                this.setRequestType(RequestType.Stylesheet, true);
                break;
            case NOT_MARK + OPTIONS.STYLESHEET:
                this.setRequestType(RequestType.Stylesheet, false);
                break;
            case OPTIONS.SUBDOCUMENT:
                this.setRequestType(RequestType.Subdocument, true);
                break;
            case NOT_MARK + OPTIONS.SUBDOCUMENT:
                this.setRequestType(RequestType.Subdocument, false);
                break;
            case OPTIONS.OBJECT:
                this.setRequestType(RequestType.Object, true);
                break;
            case NOT_MARK + OPTIONS.OBJECT:
                this.setRequestType(RequestType.Object, false);
                break;
            case OPTIONS.IMAGE:
                this.setRequestType(RequestType.Image, true);
                break;
            case NOT_MARK + OPTIONS.IMAGE:
                this.setRequestType(RequestType.Image, false);
                break;
            case OPTIONS.XMLHTTPREQUEST:
                this.setRequestType(RequestType.XmlHttpRequest, true);
                break;
            case NOT_MARK + OPTIONS.XMLHTTPREQUEST:
                this.setRequestType(RequestType.XmlHttpRequest, false);
                break;
            case OPTIONS.MEDIA:
                this.setRequestType(RequestType.Media, true);
                break;
            case NOT_MARK + OPTIONS.MEDIA:
                this.setRequestType(RequestType.Media, false);
                break;
            case OPTIONS.FONT:
                this.setRequestType(RequestType.Font, true);
                break;
            case NOT_MARK + OPTIONS.FONT:
                this.setRequestType(RequestType.Font, false);
                break;
            case OPTIONS.WEBSOCKET:
                this.setRequestType(RequestType.Websocket, true);
                break;
            case NOT_MARK + OPTIONS.WEBSOCKET:
                this.setRequestType(RequestType.Websocket, false);
                break;
            case OPTIONS.OTHER:
                this.setRequestType(RequestType.Other, true);
                break;
            case NOT_MARK + OPTIONS.OTHER:
                this.setRequestType(RequestType.Other, false);
                break;
            case OPTIONS.PING:
                this.setRequestType(RequestType.Ping, true);
                break;
            case NOT_MARK + OPTIONS.PING:
                this.setRequestType(RequestType.Ping, false);
                break;
            // Special modifiers
            case OPTIONS.BADFILTER:
                this.setOptionEnabled(NetworkRuleOption.Badfilter, true);
                break;
            case OPTIONS.CSP:
                this.setOptionEnabled(NetworkRuleOption.Csp, true);
                this.advancedModifier = new CspModifier(optionValue, this.isAllowlist());
                break;
            case OPTIONS.REPLACE:
                this.setOptionEnabled(NetworkRuleOption.Replace, true);
                this.advancedModifier = new ReplaceModifier(optionValue);
                break;
            case OPTIONS.COOKIE:
                this.setOptionEnabled(NetworkRuleOption.Cookie, true);
                this.advancedModifier = new CookieModifier(optionValue);
                break;
            case OPTIONS.REDIRECT:
                this.setOptionEnabled(NetworkRuleOption.Redirect, true);
                this.advancedModifier = new RedirectModifier(optionValue, this.ruleText, this.isAllowlist());
                break;
            case OPTIONS.REDIRECTRULE:
                this.setOptionEnabled(NetworkRuleOption.Redirect, true);
                this.advancedModifier = new RedirectModifier(optionValue, this.ruleText, this.isAllowlist(), true);
                break;
            case OPTIONS.REMOVEPARAM:
                this.setOptionEnabled(NetworkRuleOption.RemoveParam, true);
                this.advancedModifier = new RemoveParamModifier(optionValue);
                break;
            case OPTIONS.REMOVEHEADER:
                this.setOptionEnabled(NetworkRuleOption.RemoveHeader, true);
                this.advancedModifier = new RemoveHeaderModifier(optionValue, this.isAllowlist());
                break;
            // simple validation of jsonprune rules for compiler
            // https://github.com/AdguardTeam/FiltersCompiler/issues/168
            case OPTIONS.JSONPRUNE: {
                if (isCompatibleWith(CompatibilityTypes.extension)) {
                    throw new SyntaxError('Extension does not support $jsonprune modifier yet');
                }
                this.setOptionEnabled(NetworkRuleOption.JsonPrune, true);
                // TODO: should be properly implemented later
                // https://github.com/AdguardTeam/tsurlfilter/issues/71
                break;
            }
            // simple validation of hls rules for compiler
            // https://github.com/AdguardTeam/FiltersCompiler/issues/169
            case OPTIONS.HLS: {
                if (isCompatibleWith(CompatibilityTypes.extension)) {
                    throw new SyntaxError('Extension does not support $hls modifier yet');
                }
                this.setOptionEnabled(NetworkRuleOption.Hls, true);
                // TODO: should be properly implemented later
                // https://github.com/AdguardTeam/tsurlfilter/issues/72
                break;
            }
            // Dns modifiers
            case OPTIONS.CLIENT: {
                if (isCompatibleWith(CompatibilityTypes.extension)) {
                    throw new SyntaxError('Extension doesn\'t support $client modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Client, true);
                this.advancedModifier = new ClientModifier(optionValue);
                break;
            }
            case OPTIONS.DNSREWRITE: {
                if (isCompatibleWith(CompatibilityTypes.extension)) {
                    throw new SyntaxError('Extension doesn\'t support $dnsrewrite modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.DnsRewrite, true);
                this.advancedModifier = new DnsRewriteModifier(optionValue);
                break;
            }
            case OPTIONS.DNSTYPE: {
                if (isCompatibleWith(CompatibilityTypes.extension)) {
                    throw new SyntaxError('Extension doesn\'t support $dnstype modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.DnsType, true);
                this.advancedModifier = new DnsTypeModifier(optionValue);
                break;
            }
            case OPTIONS.CTAG: {
                if (isCompatibleWith(CompatibilityTypes.extension)) {
                    throw new SyntaxError('Extension doesn\'t support $ctag modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Ctag, true);
                this.advancedModifier = new CtagModifier(optionValue);
                break;
            }
            case OPTIONS.APP: {
                if (isCompatibleWith(CompatibilityTypes.extension)) {
                    throw new SyntaxError('Extension doesn\'t support $app modifier');
                }
                this.appModifier = new AppModifier(optionValue);
                break;
            }
            case OPTIONS.NETWORK:
                if (isCompatibleWith(CompatibilityTypes.extension)) {
                    throw new SyntaxError('Extension doesn\'t support $network modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Network, true);
                break;
            case OPTIONS.EXTENSION:
                if (isCompatibleWith(CompatibilityTypes.extension)) {
                    throw new SyntaxError('Extension doesn\'t support $extension modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Extension, true);
                break;
            case NOT_MARK + OPTIONS.EXTENSION:
                if (isCompatibleWith(CompatibilityTypes.extension)) {
                    throw new SyntaxError('Extension doesn\'t support $extension modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Extension, false);
                break;
            default: {
                // clear empty values
                var modifierView = [optionName, optionValue]
                    .filter(function (i) { return i; })
                    .join('=');
                throw new SyntaxError("Unknown modifier: ".concat(modifierView));
            }
        }
    };
    /**
     * Validates rule options
     */
    NetworkRule.prototype.validateOptions = function () {
        if (this.advancedModifier instanceof RemoveParamModifier) {
            this.validateRemoveParamRule();
        }
        else if (this.advancedModifier instanceof RemoveHeaderModifier) {
            this.validateRemoveHeaderRule();
        }
    };
    /**
     * $removeparam rules are not compatible with any other modifiers except $domain,
     * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
     * The rules with any other modifiers are considered invalid and will be discarded.
     */
    NetworkRule.prototype.validateRemoveParamRule = function () {
        if ((this.enabledOptions | NetworkRuleOption.RemoveParamCompatibleOptions)
            !== NetworkRuleOption.RemoveParamCompatibleOptions) {
            throw new SyntaxError('$removeparam rules are not compatible with some other modifiers');
        }
    };
    /**
     * $removeheader rules are not compatible with any other modifiers except $domain,
     * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
     * The rules with any other modifiers are considered invalid and will be discarded.
     */
    NetworkRule.prototype.validateRemoveHeaderRule = function () {
        if ((this.enabledOptions | NetworkRuleOption.RemoveHeaderCompatibleOptions)
            !== NetworkRuleOption.RemoveHeaderCompatibleOptions) {
            throw new SyntaxError('$removeheader rules are not compatible with some other modifiers');
        }
    };
    /**
     * parseRuleText splits the rule text into multiple parts.
     * @param ruleText - original rule text
     * @returns basic rule parts
     *
     * @throws error if the rule is empty (for instance, empty string or `@@`)
     */
    NetworkRule.parseRuleText = function (ruleText) {
        var ruleParts = new BasicRuleParts();
        ruleParts.allowlist = false;
        var startIndex = 0;
        if (ruleText.startsWith(NetworkRule.MASK_ALLOWLIST)) {
            ruleParts.allowlist = true;
            startIndex = NetworkRule.MASK_ALLOWLIST.length;
        }
        if (ruleText.length <= startIndex) {
            throw new SyntaxError('Rule is too short');
        }
        // Setting pattern to rule text (for the case of empty options)
        ruleParts.pattern = ruleText.substring(startIndex);
        // Avoid parsing options inside of a regex rule
        if (ruleParts.pattern.startsWith(SimpleRegex.MASK_REGEX_RULE)
            && ruleParts.pattern.endsWith(SimpleRegex.MASK_REGEX_RULE)
            && !ruleParts.pattern.includes("".concat(NetworkRule.OPTIONS.REPLACE, "="))) {
            return ruleParts;
        }
        var removeParamIndex = ruleText.lastIndexOf("".concat(NetworkRule.OPTIONS.REMOVEPARAM, "="));
        var endIndex = removeParamIndex >= 0 ? removeParamIndex : ruleText.length - 2;
        var foundEscaped = false;
        for (var i = endIndex; i >= startIndex; i -= 1) {
            var c = ruleText.charAt(i);
            if (c === NetworkRule.OPTIONS_DELIMITER) {
                if (i > startIndex && ruleText.charAt(i - 1) === NetworkRule.ESCAPE_CHARACTER) {
                    foundEscaped = true;
                }
                else {
                    ruleParts.pattern = ruleText.substring(startIndex, i);
                    ruleParts.options = ruleText.substring(i + 1);
                    if (foundEscaped) {
                        // Find and replace escaped options delimiter
                        ruleParts.options = ruleParts.options.replace(NetworkRule.RE_ESCAPED_OPTIONS_DELIMITER, NetworkRule.OPTIONS_DELIMITER);
                        // Reset the regexp state
                        NetworkRule.RE_ESCAPED_OPTIONS_DELIMITER.lastIndex = 0;
                    }
                    // Options delimiter was found, exiting loop
                    break;
                }
            }
        }
        return ruleParts;
    };
    /**
     * Separates the rule pattern from the list of modifiers.
     *
     * ```
     * rule = ["@@"] pattern [ "$" modifiers ]
     * modifiers = [modifier0, modifier1[, ...[, modifierN]]]
     * ```
     */
    NetworkRule.OPTIONS_DELIMITER = OPTIONS_DELIMITER;
    /**
     * This character is used to escape special characters in modifiers values
     */
    NetworkRule.ESCAPE_CHARACTER = ESCAPE_CHARACTER;
    // eslint-disable-next-line max-len
    NetworkRule.RE_ESCAPED_OPTIONS_DELIMITER = new RegExp("".concat(NetworkRule.ESCAPE_CHARACTER).concat(NetworkRule.OPTIONS_DELIMITER), 'g');
    /**
     * A marker that is used in rules of exception.
     * To turn off filtering for a request, start your rule with this marker.
     */
    NetworkRule.MASK_ALLOWLIST = MASK_ALLOWLIST;
    /**
     * Mark that negates options
     */
    NetworkRule.NOT_MARK = NOT_MARK;
    /**
     * Rule options
     */
    NetworkRule.OPTIONS = NETWORK_RULE_OPTIONS;
    return NetworkRule;
}());

export { COMMA_SEPARATOR as C, DomainModifier as D, ErrorStatusCodes as E, NetworkRuleOption as N, PIPE_SEPARATOR as P, RemoveHeaderModifier as R, SEPARATOR as S, __spreadArray as _, NetworkRule as a, config$2 as b, commonjsGlobal as c, Pattern as d, __awaiter as e, __generator as f, scriptlets_umd as g, RemoveParamModifier as h, isIp_1 as i, CookieModifier as j, CompatibilityTypes as k, logger as l, isCompatibleWith as m, setConfiguration as n, setLogger as o, scriptlets as s };
