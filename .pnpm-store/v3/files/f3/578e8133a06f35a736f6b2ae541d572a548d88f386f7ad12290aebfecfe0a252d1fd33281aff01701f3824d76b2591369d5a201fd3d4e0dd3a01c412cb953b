import scriptlets, { IConfiguration } from '@adguard/scriptlets';
import * as rule from './rule';
import { Request } from '../request';
import { Pattern } from './pattern';
/**
 * CosmeticRuleType is an enumeration of the possible
 * cosmetic rule types.
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-rules
 */
export declare enum CosmeticRuleType {
    /**
     * Cosmetic rules that just hide page elements.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#element-hiding-rules
     */
    ElementHiding = 0,
    /**
     * Cosmetic rules that allow adding custom CSS styles.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules
     */
    Css = 1,
    /**
     * Cosmetic rules that allow executing custom JS scripts.
     * Some restrictions are applied to this type of rules by default.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#javascript-rules
     */
    Js = 2,
    /**
     * Special type of rules that allows filtering HTML code of web pages.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules
     */
    Html = 3
}
/**
 * Pseudo class indicators. They are used to detect if rule is extended or not even if rule does not
 * have extended css marker
 */
export declare const EXT_CSS_PSEUDO_INDICATORS: string[];
/**
 * Init script params
 */
interface InitScriptParams {
    debug?: boolean;
    request?: Partial<Request>;
}
/**
 * Get scriptlet data response type
 */
type ScriptletData = {
    params: IConfiguration;
    func: (source: scriptlets.IConfiguration, args: string[]) => void;
};
/**
 * Implements a basic cosmetic rule.
 *
 * Cosmetic rules syntax are almost similar and looks like this:
 * ```
 * rule = [domains] "marker" content
 * domains = [domain0, domain1[, ...[, domainN]]]
 * ```
 *
 * The rule type is defined by the `marker` value, you can find the list of them
 * in the {@see CosmeticRuleMarker} enumeration.
 *
 * What matters, though, is what's in the `content` part of it.
 *
 * Examples:
 * * `example.org##.banner` -- element hiding rule
 * * `example.org#$#.banner { display: block; }` -- CSS rule
 * * `example.org#%#window.x=1;` -- JS rule
 * * `example.org#%#//scriptlet('scriptlet-name')` -- Scriptlet rule
 * * `example.org$$div[id="test"]` -- HTML filtering rule
 */
export declare class CosmeticRule implements rule.IRule {
    private readonly ruleText;
    private readonly filterListId;
    private readonly type;
    private readonly content;
    private allowlist;
    private extendedCss;
    private readonly permittedDomains;
    private readonly restrictedDomains;
    /**
     * $path modifier pattern. It is only set if $path modifier is specified for this rule.
     */
    pathModifier: Pattern | undefined;
    /**
     * Js script to execute
     */
    script: string | undefined;
    /**
     * Object with script code ready to execute and debug, domain values
     * @private
     */
    private scriptData;
    /**
     * Object with scriptlet function and params
     * @private
     */
    private scriptletData;
    /**
     * If the rule contains scriptlet content
     */
    isScriptlet: boolean;
    /**
     * The problem with pseudo-classes is that any unknown pseudo-class makes browser ignore the whole CSS rule,
     * which contains a lot more selectors. So, if CSS selector contains a pseudo-class, we should try to validate it.
     * <p>
     * One more problem with pseudo-classes is that they are actively used in uBlock, hence it may mess AG styles.
     */
    private static readonly SUPPORTED_PSEUDO_CLASSES;
    /**
     * Parses first pseudo class from the specified CSS selector
     *
     * @param selector
     * @returns pseudo class name if found or null
     */
    static parsePseudoClass(selector: string): string | null;
    getText(): string;
    getFilterListId(): number;
    /**
     * Cosmetic rule type (always present)
     */
    getType(): CosmeticRuleType;
    /**
     * Allowlist means that this rule is meant to disable other rules.
     * For instance, https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#elemhide-exceptions
     */
    isAllowlist(): boolean;
    /**
     * Gets the rule content. The meaning of this field depends on the rule type.
     * For instance, for an element hiding rule, this is just a CSS selector.
     * While, for a CSS rule, this is a CSS selector + style.
     */
    getContent(): string;
    /**
     * Returns the script ready to be executed or null (if it failed to prepare a scriptlet/script to be executed)
     * This function initializes and caches the scriptlet's code in a lazy manner.
     * If it receives a new `InitScriptParams` argument afterwards, it will rebuild the
     * scriptlet data.
     * @param options
     */
    getScript(options?: InitScriptParams): string | null;
    /**
     * Returns the scriptlet's data consisting of the scriptlet function and its arguments.
     * This method is supposed to be used in the manifest V3 extension.
     */
    getScriptletData(): ScriptletData | null;
    /**
     * Updates this.scriptData and if scriptlet this.scriptletData with js ready to execute
     *
     * @param options
     */
    initScript(options?: InitScriptParams): void;
    /**
     * Gets list of permitted domains.
     */
    getPermittedDomains(): string[] | undefined;
    /**
     * Returns true if the rule is considered "generic"
     * "generic" means that the rule is not restricted to a limited set of domains
     * Please note that it might be forbidden on some domains, though.
     *
     * @return {boolean}
     */
    isGeneric(): boolean;
    /**
     * Gets list of restricted domains.
     */
    getRestrictedDomains(): string[] | undefined;
    isExtendedCss(): boolean;
    /**
     * Creates an instance of the {@link CosmeticRule}.
     * It parses the rule and extracts the permitted/restricted domains,
     * and also the cosmetic rule's content.
     *
     * Depending on the rule type, the content might be transformed in
     * one of the helper classes, or kept as string when it's appropriate.
     *
     * @param ruleText - original rule text.
     * @param filterListId - ID of the filter list this rule belongs to.
     *
     * @throws error if it fails to parse the rule.
     */
    constructor(ruleText: string, filterListId: number);
    /**
     * Match returns true if this rule can be used on the specified request.
     *
     * @param request - request to check
     */
    match(request: Request): boolean;
    static parseType(marker: string): CosmeticRuleType;
    /**
     * Determines if rule is allowlist rule
     * @param marker
     * @private
     */
    private static parseAllowlist;
    /**
     * Validate pseudo-classes
     *
     * @param ruleText
     * @param ruleContent
     * @throws SyntaxError
     */
    private static validatePseudoClasses;
    private static ELEMHIDE_VALIDATION_REGEX;
    /**
     * Simple validation for elemhide rules
     *
     * @param ruleText
     * @param ruleContent
     * @throws SyntaxError
     */
    private static validateElemhideRule;
    private static validateJsRules;
    /**
     * Validates css injection rules
     *
     * @param ruleText
     * @param ruleContent
     * @throws SyntaxError
     */
    private static validateCssRules;
    /**
     * Checks if the rule has permitted domains
     */
    private hasPermittedDomains;
    /**
     * Checks if the rule has restricted domains
     */
    private hasRestrictedDomains;
    /**
     * Checks if the hostname matches permitted domains
     * @param hostname
     */
    matchesPermittedDomains(hostname: string): boolean;
    /**
     * Checks if the hostname matches the restricted domains.
     * @param hostname
     */
    matchesRestrictedDomains(hostname: string): boolean;
    /**
     * Validates cosmetic rule text
     * @param ruleText
     * @param type
     * @param content
     * @param isExtCss
     * @private
     */
    private static validate;
}
export {};
