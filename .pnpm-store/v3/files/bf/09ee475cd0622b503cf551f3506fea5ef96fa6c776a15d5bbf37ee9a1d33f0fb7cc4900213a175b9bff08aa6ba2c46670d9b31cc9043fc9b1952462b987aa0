/**
 * Utils class
 */
var ElementUtils = /** @class */ (function () {
    function ElementUtils() {
    }
    /**
     * Serialize HTML element
     *
     * @param element
     */
    ElementUtils.elementToString = function (element) {
        var s = [];
        s.push('<');
        s.push(element.localName);
        var attributes = element.attributes;
        for (var i = 0; i < attributes.length; i += 1) {
            var attr = attributes[i];
            s.push(' ');
            s.push(attr.name);
            s.push('="');
            var value = attr.value === null ? '' : attr.value.replace(/"/g, '\\"');
            s.push(value);
            s.push('"');
        }
        s.push('>');
        return s.join('');
    };
    /**
     * Appends node children to the array
     *
     * @param node - element whose children we would like to add
     * @param arrayWithNodes - array where we add children
     */
    ElementUtils.appendChildren = function (node, arrayWithNodes) {
        var children = node.querySelectorAll('*');
        if (children && children.length > 0) {
            for (var i = 0; i < children.length; i += 1) {
                arrayWithNodes.push(children[i]);
            }
        }
    };
    /**
     * Adds elements into array if they are not in the array yet
     *
     * @param {*} targetArray
     * @param {*} sourceArray
     */
    ElementUtils.addUnique = function (targetArray, sourceArray) {
        if (sourceArray.length > 0) {
            for (var i = 0; i < sourceArray.length; i += 1) {
                var sourceElement = sourceArray[i];
                if (targetArray.indexOf(sourceElement) === -1) {
                    targetArray.push(sourceElement);
                }
            }
        }
    };
    /**
     * Removes all elements in array
     *
     * @param elements
     */
    ElementUtils.removeElements = function (elements) {
        for (var i = 0; i < elements.length; i += 1) {
            var element = elements[i];
            element.remove();
        }
    };
    /**
     * Parses hits info from style content
     *
     * @param content style
     * @param attributeMarker
     */
    ElementUtils.parseInfo = function (content, attributeMarker) {
        if (!content || content.indexOf(attributeMarker) < 0) {
            return null;
        }
        var filterIdAndRuleText = decodeURIComponent(content);
        // 'content' value may include open and close quotes.
        filterIdAndRuleText = ElementUtils.removeQuotes(filterIdAndRuleText);
        // Remove prefix
        filterIdAndRuleText = filterIdAndRuleText.substring(attributeMarker.length);
        // Attribute 'content' in css looks like: {content: 'adguard{filterId};{ruleText}'}
        var index = filterIdAndRuleText.indexOf(';');
        if (index < 0) {
            return null;
        }
        var filterId = parseInt(filterIdAndRuleText.substring(0, index), 10);
        if (Number.isNaN(filterId)) {
            return null;
        }
        var ruleText = filterIdAndRuleText.substring(index + 1);
        return { filterId: filterId, ruleText: ruleText };
    };
    /**
     * Parses hits info from style content
     *
     * @param content style
     * @param attributeMarker
     */
    // eslint-disable-next-line max-len
    ElementUtils.parseExtendedStyleInfo = function (content, attributeMarker) {
        var important = '!important';
        var indexOfImportant = content.lastIndexOf(important);
        if (indexOfImportant === -1) {
            return ElementUtils.parseInfo(content, attributeMarker);
        }
        var contentWithoutImportant = content.substring(0, indexOfImportant).trim();
        return ElementUtils.parseInfo(contentWithoutImportant, attributeMarker);
    };
    /**
     * Unquotes specified value
     */
    ElementUtils.removeQuotes = function (value) {
        if (value.length > 1
            && ((value[0] === '"' && value[value.length - 1] === '"')
                || (value[0] === '\'' && value[value.length - 1] === '\''))) {
            // Remove double-quotes or single-quotes
            return value.substring(1, value.length - 1);
        }
        return value;
    };
    return ElementUtils;
}());

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * This storage is used to keep track of counted rules
 * regarding to node elements
 */
var HitsStorage = /** @class */ (function () {
    function HitsStorage() {
        /**
         * Start count number
         */
        this.counter = 0;
        /**
         * Storage random identificator
         */
        this.randomKey = HitsStorage.generateRandomKey();
        /**
         * Map storage
         */
        this.map = new Map();
    }
    /**
     * Checks if element is counted
     *
     * @param element html element
     * @param rule rule text
     */
    HitsStorage.prototype.isCounted = function (element, rule) {
        var hitAddress = element[this.randomKey];
        if (hitAddress) {
            var countedHit = this.map.get(hitAddress);
            if (countedHit) {
                return countedHit.element === element && countedHit.rule === rule;
            }
        }
        return false;
    };
    /**
     * Stores rule-element info in storage
     *
     * @param element html element
     * @param rule rule text
     */
    HitsStorage.prototype.setCounted = function (element, rule) {
        var counter = this.getCounter();
        // eslint-disable-next-line no-param-reassign
        element[this.randomKey] = counter;
        this.map.set(counter, { element: element, rule: rule });
    };
    /**
     * @return current count number
     */
    HitsStorage.prototype.getCounter = function () {
        this.counter += 1;
        return this.counter;
    };
    /**
     * Random id generator
     * @returns {String} - random key with desired length
     */
    HitsStorage.generateRandomKey = function () {
        var keyLength = 10;
        var possibleValues = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        var result = '';
        for (var i = 0; i < keyLength; i += 1) {
            result += possibleValues.charAt(Math.floor(Math.random() * possibleValues.length));
        }
        return result;
    };
    return HitsStorage;
}());

/**
 * Class represents collecting css style hits process
 *
 * During applying css styles to element we add special 'content:' attribute
 * Example:
 * .selector -> .selector { content: 'adguard{filterId};{ruleText} !important;}
 *
 * then here we parse this attribute and calls provided callback function
 */
var CssHitsCounter = /** @class */ (function () {
    /**
     * This function prepares calculation of css hits.
     * We are waiting for 'load' event and start calculation.
     * @param callback - ({filterId: number; ruleText: string; element: string}[]) => {} handles counted css hits
     */
    function CssHitsCounter(callback) {
        /**
         * Hits storage
         */
        this.hitsStorage = new HitsStorage();
        /**
         * Mutation observer
         */
        this.observer = null;
        /**
         * Counting on process flag
         */
        this.countIsWorking = false;
        this.onCssHitsFoundCallback = callback;
        if (document.readyState === 'complete'
            || document.readyState === 'interactive') {
            this.countCssHits();
        }
        else {
            document.addEventListener('readystatechange', this.startCounter.bind(this));
        }
    }
    /**
     * Stops css hits counting process
     */
    CssHitsCounter.prototype.stop = function () {
        this.onCssHitsFoundCallback = function () { };
        if (this.observer) {
            this.observer.disconnect();
        }
    };
    /**
     * Callback used to collect statistics of elements affected by extended css rules
     *
     * @param {object} affectedEl
     * @return {object} affectedEl
     */
    CssHitsCounter.prototype.countAffectedByExtendedCss = function (affectedEl) {
        if (affectedEl && affectedEl.rules && affectedEl.rules.length > 0) {
            var result = [];
            for (var _i = 0, _a = affectedEl.rules; _i < _a.length; _i++) {
                var rule = _a[_i];
                if (rule.style && rule.style.content) {
                    var styleInfo = ElementUtils.parseExtendedStyleInfo(rule.style.content, CssHitsCounter.CONTENT_ATTR_PREFIX);
                    if (styleInfo === null) {
                        continue;
                    }
                    var filterId = styleInfo.filterId, ruleText = styleInfo.ruleText;
                    if (filterId !== undefined && ruleText !== undefined) {
                        result.push({
                            filterId: filterId,
                            ruleText: ruleText,
                            element: ElementUtils.elementToString(affectedEl.node),
                        });
                        // clear style content to avoid duplicate counting
                        rule.style.content = '';
                    }
                }
            }
            this.onCssHitsFoundCallback(result);
        }
        return affectedEl;
    };
    /**
     * Starts counting process
     */
    CssHitsCounter.prototype.startCounter = function () {
        if (document.readyState === 'interactive'
            || document.readyState === 'complete') {
            this.countCssHits();
            document.removeEventListener('readystatechange', this.startCounter);
        }
    };
    /**
     * Counts css hits
     */
    CssHitsCounter.prototype.countCssHits = function () {
        this.countAllCssHits();
        this.countCssHitsForMutations();
    };
    /**
     * Counts css hits for already affected elements
     */
    CssHitsCounter.prototype.countAllCssHits = function () {
        var _this = this;
        // we don't start counting again all css hits till previous count process wasn't finished
        if (this.countIsWorking) {
            return;
        }
        this.countIsWorking = true;
        var elements = document.querySelectorAll('*');
        this.countCssHitsBatch(elements, 0, CssHitsCounter.CSS_HITS_BATCH_SIZE, CssHitsCounter.CSS_HITS_BATCH_SIZE, [], function (result) {
            if (result.length > 0) {
                _this.onCssHitsFoundCallback(result);
            }
            _this.countIsWorking = false;
        });
    };
    /**
     * Main calculation function.
     * 1. Selects sub collection from elements.
     * 2. For each element from sub collection: retrieves calculated css 'content'
     * attribute and if it contains 'adguard'
     * marker then retrieves rule text and filter identifier.
     * 3. Starts next task with some delay.
     *
     * @param elements Collection of all elements
     * @param start Start of batch
     * @param end End of batch
     * @param step Size of batch
     * @param result Collection for save result
     * @param callback Finish callback
     */
    // eslint-disable-next-line max-len
    CssHitsCounter.prototype.countCssHitsBatch = function (elements, start, end, step, result, callback) {
        var _this = this;
        var length = Math.min(end, elements.length);
        result = result.concat(this.countCssHitsForElements(elements, start, length));
        if (length === elements.length) {
            callback(result);
            return;
        }
        start = end;
        end += step;
        // Start next task with some delay
        window.setTimeout(function () {
            _this.countCssHitsBatch(elements, start, end, step, result, callback);
        }, CssHitsCounter.COUNT_CSS_HITS_BATCH_DELAY);
    };
    /**
     * Counts css hits for array of elements
     *
     * @param elements
     * @param start
     * @param length
     */
    CssHitsCounter.prototype.countCssHitsForElements = function (elements, start, length) {
        var RULE_FILTER_SEPARATOR = ';';
        start = start || 0;
        length = length || elements.length;
        var result = [];
        for (var i = start; i < length; i += 1) {
            var element = elements[i];
            var cssHitData = CssHitsCounter.getCssHitData(element);
            if (!cssHitData) {
                continue;
            }
            var filterId = cssHitData.filterId, ruleText = cssHitData.ruleText;
            var ruleAndFilterString = filterId + RULE_FILTER_SEPARATOR + ruleText;
            if (this.hitsStorage.isCounted(element, ruleAndFilterString)) {
                continue;
            }
            this.hitsStorage.setCounted(element, ruleAndFilterString);
            result.push({
                filterId: filterId,
                ruleText: ruleText,
                element: ElementUtils.elementToString(element),
            });
        }
        return result;
    };
    /**
     * Counts css hits for mutations
     */
    CssHitsCounter.prototype.countCssHitsForMutations = function () {
        var _this = this;
        // eslint-disable-next-line prefer-destructuring
        var MutationObserver = window.MutationObserver;
        if (!MutationObserver) {
            return;
        }
        if (this.observer) {
            this.observer.disconnect();
        }
        /**
         * To avoid cases where two css hits counters try to append and remove the
         * same elements one after the other, we do not append already met nodes.
         */
        var probesWeakSet = new WeakSet();
        var timeoutId = null;
        this.observer = new MutationObserver((function (mutationRecords) {
            // Collect probe elements, count them, then remove from their targets
            var probeElements = [];
            var childrenOfProbeElements = [];
            var potentialProbeElements = [];
            mutationRecords.forEach(function (mutationRecord) {
                if (mutationRecord.addedNodes.length === 0) {
                    return;
                }
                for (var i = 0; i < mutationRecord.addedNodes.length; i += 1) {
                    var node = mutationRecord.addedNodes[i];
                    if (!(node instanceof Element) || CssHitsCounter.isIgnoredNodeTag(node.tagName)) {
                        continue;
                    }
                    var target = mutationRecord.target;
                    if (!node.parentNode && target) {
                        // If this node has been appended to the DOM and counted once, do not add
                        // it again.
                        if (probesWeakSet.has(node)) {
                            return;
                        }
                        // Most likely this is a "probe" element that was added and then
                        // immediately removed from DOM.
                        // We re-add it and check if any rule matched it
                        probeElements.push(node);
                        // To ensure that this "probe" node has only been added once to the DOM,
                        // we add it to the weak set.
                        probesWeakSet.add(node);
                        // CSS rules could be applied to the nodes inside probe element
                        // that's why we get all child elements of added node
                        ElementUtils.appendChildren(node, childrenOfProbeElements);
                        if (_this.observer) {
                            _this.observer.disconnect();
                        }
                        mutationRecord.target.appendChild(node);
                    }
                    else if (node.parentNode && target) {
                        // Sometimes probe elements are appended to the DOM
                        potentialProbeElements.push(node);
                        ElementUtils.appendChildren(node, potentialProbeElements);
                    }
                }
            });
            // If the list of potential probe elements is relatively small,
            // we can count CSS hits immediately
            if (potentialProbeElements.length > 0
                && potentialProbeElements.length <= CssHitsCounter.CSS_HITS_BATCH_SIZE) {
                var result = _this.countCssHitsForElements(potentialProbeElements, 0, null);
                if (result.length > 0) {
                    _this.onCssHitsFoundCallback(result);
                }
            }
            var allProbeElements = [];
            ElementUtils.addUnique(allProbeElements, childrenOfProbeElements);
            ElementUtils.addUnique(allProbeElements, probeElements);
            if (allProbeElements.length > 0) {
                var result = _this.countCssHitsForElements(allProbeElements, 0, null);
                if (result.length > 0) {
                    _this.onCssHitsFoundCallback(result);
                }
                /**
                 * don't remove child elements of probe elements
                 * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1096
                 */
                ElementUtils.removeElements(probeElements);
                _this.startObserver();
            }
            // debounce counting all css hits when mutation record fires
            if (timeoutId) {
                window.clearTimeout(timeoutId);
            }
            timeoutId = window.setTimeout(function () {
                _this.countAllCssHits();
                window.clearTimeout(timeoutId);
            }, CssHitsCounter.COUNT_ALL_CSS_HITS_TIMEOUT_MS);
        }));
        this.startObserver();
    };
    /**
     * Starts mutation observer
     */
    CssHitsCounter.prototype.startObserver = function () {
        if (this.observer) {
            this.observer.observe(document.documentElement, {
                childList: true,
                subtree: true,
                attributes: true,
            });
        }
    };
    /**
     * Function checks if elements style content attribute contains data injected with AdGuard
     *
     * @param {Node} element
     * @returns {({filterId: Number, ruleText: String} | null)}
     */
    CssHitsCounter.getCssHitData = function (element) {
        var style = getComputedStyle(element);
        return ElementUtils.parseInfo(style.content, CssHitsCounter.CONTENT_ATTR_PREFIX);
    };
    /**
     * Check if tag is ignored
     * @param nodeTag
     */
    CssHitsCounter.isIgnoredNodeTag = function (nodeTag) {
        var ignoredTags = ['script'];
        return ignoredTags.includes(nodeTag.toLowerCase());
    };
    /**
     * We split CSS hits counting into smaller batches of elements
     * and schedule them one by one using setTimeout
     */
    CssHitsCounter.COUNT_CSS_HITS_BATCH_DELAY = 5;
    /**
     * Size of small batches of elements we count
     */
    CssHitsCounter.CSS_HITS_BATCH_SIZE = 25;
    /**
     * In order to find elements hidden by AdGuard we look for a `:content` pseudo-class
     * with values starting with this prefix. Filter information will be
     * encoded in this value as well.
     */
    CssHitsCounter.CONTENT_ATTR_PREFIX = 'adguard';
    /**
     * We delay countAllCssHits function if it was called too frequently from mutationObserver
     */
    CssHitsCounter.COUNT_ALL_CSS_HITS_TIMEOUT_MS = 500;
    return CssHitsCounter;
}());

export { CssHitsCounter };
