{"version":3,"file":"jsdocUtils.js","names":["tagStructure","setTagStructure","mode","getDefaultTagStructureForMode","flattenRoots","params","root","hasRestElement","hasPropertyRest","rests","names","reduce","acc","cur","Array","isArray","nms","flattened","inner","filter","Boolean","push","concat","isRestProperty","restElement","name","getPropertiesFromPropertySignature","propSignature","type","undefined","typeAnnotation","key","members","map","member","getFunctionParameterNames","functionNode","checkDefaultObjects","getParamName","param","isProperty","hasLeftTypeAnnotation","left","propertyNames","annotationParamName","hasLeftName","properties","roots","prop","value","elements","idx","right","raw","includes","argument","parameter","Error","hasParams","length","getJsdocTagsDeep","jsdoc","targetTagName","ret","tag","tags","entries","modeWarnSettings","WarnSettings","getTagNamesForMode","context","jsdocTags","typeScriptTags","closureTags","hasBeenWarned","report","loc","start","column","line","message","markSettingAsWarned","getPreferredTagName","tagPreference","prefValues","Object","values","some","prefVal","replacement","tagPreferenceFixed","fromEntries","replace","prototype","hasOwnProperty","call","tagNames","preferredTagName","find","aliases","isValidTag","definedTags","validTagNames","keys","flat","additionalTags","allTags","hasTag","targetTagLower","toLowerCase","doc","hasATag","targetTagNames","hasDefinedTypeTag","tagType","trim","ensureMap","has","set","Map","get","overrideTagStructure","structuredTags","tagMap","required","tagStruct","requiredName","requiredType","typeOrNameRequired","getTagStructureForMode","isNamepathDefiningTag","tagMustHaveTypePosition","tagMightHaveTypePosition","namepathTypes","Set","tagMightHaveNamePosition","tagMightHaveNamepath","tagMustHaveNamePosition","tagMightHaveEitherTypeOrNamePosition","tagMustHaveEitherTypeOrNamePosition","tagMissingRequiredTypeOrNamepath","mustHaveTypePosition","mightHaveTypePosition","hasTypePosition","hasNameOrNamepathPosition","mustHaveEither","hasEither","hasNonFunctionYield","node","checkYieldReturnValue","body","bodyNode","arguments","element","expression","test","consequent","alternate","block","handler","finalizer","cases","someCase","nde","declarations","id","init","expressions","subExpression","property","computed","quasi","object","source","parent","hasYieldValue","generator","hasThrowValue","innerFunction","async","parseClosureTemplateTag","split","enforcedContexts","defaultContexts","contexts","options","getContextObject","checkJsdoc","selInfo","lastIndex","selector","comment","bind","old","args","filterTags","tagsWithNamesAndDescriptions","getTagsByType","descName","tagsWithoutNames","tagsWithNames","tagName","tagWithName","getIndent","sourceCode","text","match","isConstructor","kind","isGetter","isSetter","hasAccessorPair","sourceKind","sourceName","oppositeKind","children","exemptSpeciaMethods","schema","hasSchemaOption","schemaProperties","default","checkGetters","checkSetters","dropPathSegmentQuotes","str","comparePaths","otherPathName","pathDoesNotBeginWith","startsWith","getRegexFromString","regexString","requiredFlags","flags","regex","uniqueFlags","join","RegExp","hasReturnValue","hasValueOrExecutorHasNonEmptyResolveValue"],"sources":["../src/jsdocUtils.js"],"sourcesContent":["/* eslint-disable jsdoc/no-undefined-types */\n\nimport WarnSettings from './WarnSettings';\nimport getDefaultTagStructureForMode from './getDefaultTagStructureForMode';\nimport {\n  jsdocTags,\n  closureTags,\n  typeScriptTags,\n} from './tagNames';\nimport {\n  hasReturnValue,\n  hasValueOrExecutorHasNonEmptyResolveValue,\n} from './utils/hasReturnValue';\n\n/**\n * @typedef {\"jsdoc\"|\"typescript\"|\"closure\"} ParserMode\n */\n\nlet tagStructure;\n\nconst setTagStructure = (mode) => {\n  tagStructure = getDefaultTagStructureForMode(mode);\n};\n\n// Given a nested array of property names, reduce them to a single array,\n// appending the name of the root element along the way if present.\nconst flattenRoots = (params, root = '') => {\n  let hasRestElement = false;\n  let hasPropertyRest = false;\n  const rests = [];\n\n  const names = params.reduce((acc, cur) => {\n    if (Array.isArray(cur)) {\n      let nms;\n      if (Array.isArray(cur[1])) {\n        nms = cur[1];\n      } else {\n        if (cur[1].hasRestElement) {\n          hasRestElement = true;\n        }\n\n        if (cur[1].hasPropertyRest) {\n          hasPropertyRest = true;\n        }\n\n        nms = cur[1].names;\n      }\n\n      const flattened = flattenRoots(nms, root ? `${root}.${cur[0]}` : cur[0]);\n      if (flattened.hasRestElement) {\n        hasRestElement = true;\n      }\n\n      if (flattened.hasPropertyRest) {\n        hasPropertyRest = true;\n      }\n\n      const inner = [\n        root ? `${root}.${cur[0]}` : cur[0],\n        ...flattened.names,\n      ].filter(Boolean);\n      rests.push(false, ...flattened.rests);\n\n      return acc.concat(inner);\n    }\n\n    if (typeof cur === 'object') {\n      if (cur.isRestProperty) {\n        hasPropertyRest = true;\n        rests.push(true);\n      } else {\n        rests.push(false);\n      }\n\n      if (cur.restElement) {\n        hasRestElement = true;\n      }\n\n      acc.push(root ? `${root}.${cur.name}` : cur.name);\n    } else if (typeof cur !== 'undefined') {\n      rests.push(false);\n      acc.push(root ? `${root}.${cur}` : cur);\n    }\n\n    return acc;\n  }, []);\n\n  return {\n    hasPropertyRest,\n    hasRestElement,\n    names,\n    rests,\n  };\n};\n\n/**\n * @param {object} propSignature\n * @returns {undefined|Array|string}\n */\nconst getPropertiesFromPropertySignature = (propSignature) => {\n  if (\n    propSignature.type === 'TSIndexSignature' ||\n    propSignature.type === 'TSConstructSignatureDeclaration' ||\n    propSignature.type === 'TSCallSignatureDeclaration'\n  ) {\n    return undefined;\n  }\n\n  if (propSignature.typeAnnotation && propSignature.typeAnnotation.typeAnnotation.type === 'TSTypeLiteral') {\n    return [\n      propSignature.key.name, propSignature.typeAnnotation.typeAnnotation.members.map((member) => {\n        return getPropertiesFromPropertySignature(member);\n      }),\n    ];\n  }\n\n  return propSignature.key.name;\n};\n\n/**\n * @param {object} functionNode\n * @param {boolean} checkDefaultObjects\n * @returns {Array}\n */\nconst getFunctionParameterNames = (\n  functionNode, checkDefaultObjects,\n) => {\n  // eslint-disable-next-line complexity\n  const getParamName = (param, isProperty) => {\n    const hasLeftTypeAnnotation = 'left' in param && 'typeAnnotation' in param.left;\n\n    if ('typeAnnotation' in param || hasLeftTypeAnnotation) {\n      const typeAnnotation = hasLeftTypeAnnotation ? param.left.typeAnnotation : param.typeAnnotation;\n\n      if (typeAnnotation.typeAnnotation.type === 'TSTypeLiteral') {\n        const propertyNames = typeAnnotation.typeAnnotation.members.map((member) => {\n          return getPropertiesFromPropertySignature(member);\n        });\n        const flattened = {\n          ...flattenRoots(propertyNames),\n          annotationParamName: param.name,\n        };\n        const hasLeftName = 'left' in param && 'name' in param.left;\n\n        if ('name' in param || hasLeftName) {\n          return [\n            hasLeftName ? param.left.name : param.name, flattened,\n          ];\n        }\n\n        return [\n          undefined, flattened,\n        ];\n      }\n    }\n\n    if ('name' in param) {\n      return param.name;\n    }\n\n    if ('left' in param && 'name' in param.left) {\n      return param.left.name;\n    }\n\n    if (param.type === 'ObjectPattern' || param.left?.type === 'ObjectPattern') {\n      const properties = param.properties || param.left?.properties;\n      const roots = properties.map((prop) => {\n        return getParamName(prop, true);\n      });\n\n      return [\n        undefined, flattenRoots(roots),\n      ];\n    }\n\n    if (param.type === 'Property') {\n      // eslint-disable-next-line default-case\n      switch (param.value.type) {\n      case 'ArrayPattern':\n        return [\n          param.key.name, param.value.elements.map((prop, idx) => {\n            return {\n              name: idx,\n              restElement: prop.type === 'RestElement',\n            };\n          }),\n        ];\n      case 'ObjectPattern':\n        return [\n          param.key.name, param.value.properties.map((prop) => {\n            return getParamName(prop, isProperty);\n          }),\n        ];\n      case 'AssignmentPattern': {\n        // eslint-disable-next-line default-case\n        switch (param.value.left.type) {\n        case 'Identifier':\n          // Default parameter\n          if (checkDefaultObjects && param.value.right.type === 'ObjectExpression') {\n            return [\n              param.key.name, param.value.right.properties.map((prop) => {\n                return getParamName(prop, isProperty);\n              }),\n            ];\n          }\n\n          break;\n        case 'ObjectPattern':\n          return [\n            param.key.name, param.value.left.properties.map((prop) => {\n              return getParamName(prop, isProperty);\n            }),\n          ];\n        case 'ArrayPattern':\n          return [\n            param.key.name, param.value.left.elements.map((prop, idx) => {\n              return {\n                name: idx,\n                restElement: prop.type === 'RestElement',\n              };\n            }),\n          ];\n        }\n      }\n      }\n\n      switch (param.key.type) {\n      case 'Identifier':\n        return param.key.name;\n\n      // The key of an object could also be a string or number\n      case 'Literal':\n        return param.key.raw ||\n          // istanbul ignore next -- `raw` may not be present in all parsers\n          param.key.value;\n\n      // case 'MemberExpression':\n      default:\n        // Todo: We should really create a structure (and a corresponding\n        //   option analogous to `checkRestProperty`) which allows for\n        //   (and optionally requires) dynamic properties to have a single\n        //   line of documentation\n        return undefined;\n      }\n    }\n\n    if (param.type === 'ArrayPattern' || param.left?.type === 'ArrayPattern') {\n      const elements = param.elements || param.left?.elements;\n      const roots = elements.map((prop, idx) => {\n        return {\n          name: `\"${idx}\"`,\n          restElement: prop?.type === 'RestElement',\n        };\n      });\n\n      return [\n        undefined, flattenRoots(roots),\n      ];\n    }\n\n    if ([\n      'RestElement', 'ExperimentalRestProperty',\n    ].includes(param.type)) {\n      return {\n        isRestProperty: isProperty,\n        name: param.argument.name,\n        restElement: true,\n      };\n    }\n\n    if (param.type === 'TSParameterProperty') {\n      return getParamName(param.parameter, true);\n    }\n\n    throw new Error(`Unsupported function signature format: \\`${param.type}\\`.`);\n  };\n\n  if (!functionNode) {\n    return [];\n  }\n\n  return (functionNode.params || functionNode.value?.params || []).map((param) => {\n    return getParamName(param);\n  });\n};\n\n/**\n * @param {Node} functionNode\n * @returns {Integer}\n */\nconst hasParams = (functionNode) => {\n  // Should also check `functionNode.value.params` if supporting `MethodDefinition`\n  return functionNode.params.length;\n};\n\n/**\n * Gets all names of the target type, including those that refer to a path, e.g.\n * \"@param foo; @param foo.bar\".\n *\n * @param {object} jsdoc\n * @param {string} targetTagName\n * @returns {Array<object>}\n */\nconst getJsdocTagsDeep = (jsdoc, targetTagName) => {\n  const ret = [];\n  for (const [\n    idx,\n    {\n      name,\n      tag,\n      type,\n    },\n  ] of jsdoc.tags.entries()) {\n    if (tag !== targetTagName) {\n      continue;\n    }\n\n    ret.push({\n      idx,\n      name,\n      type,\n    });\n  }\n\n  return ret;\n};\n\nconst modeWarnSettings = WarnSettings();\n\n/**\n * @param {string} mode\n * @param context\n */\nconst getTagNamesForMode = (mode, context) => {\n  switch (mode) {\n  case 'jsdoc':\n    return jsdocTags;\n  case 'typescript':\n    return typeScriptTags;\n  case 'closure': case 'permissive':\n    return closureTags;\n  default:\n    if (!modeWarnSettings.hasBeenWarned(context, 'mode')) {\n      context.report({\n        loc: {\n          start: {\n            column: 1,\n            line: 1,\n          },\n        },\n        message: `Unrecognized value \\`${mode}\\` for \\`settings.jsdoc.mode\\`.`,\n      });\n      modeWarnSettings.markSettingAsWarned(context, 'mode');\n    }\n\n    // We'll avoid breaking too many other rules\n    return jsdocTags;\n  }\n};\n\n/**\n * @param context\n * @param {ParserMode} mode\n * @param {string} name\n * @param {object} tagPreference\n * @returns {string|object}\n */\nconst getPreferredTagName = (\n  context,\n  mode,\n  name,\n  tagPreference = {},\n) => {\n  const prefValues = Object.values(tagPreference);\n  if (prefValues.includes(name) || prefValues.some((prefVal) => {\n    return prefVal && typeof prefVal === 'object' && prefVal.replacement === name;\n  })) {\n    return name;\n  }\n\n  // Allow keys to have a 'tag ' prefix to avoid upstream bug in ESLint\n  // that disallows keys that conflict with Object.prototype,\n  // e.g. 'tag constructor' for 'constructor':\n  // https://github.com/eslint/eslint/issues/13289\n  // https://github.com/gajus/eslint-plugin-jsdoc/issues/537\n  const tagPreferenceFixed = Object.fromEntries(\n    Object\n      .entries(tagPreference)\n      .map(([\n        key,\n        value,\n      ]) => {\n        return [\n          key.replace(/^tag /u, ''), value,\n        ];\n      }),\n  );\n\n  if (Object.prototype.hasOwnProperty.call(tagPreferenceFixed, name)) {\n    return tagPreferenceFixed[name];\n  }\n\n  const tagNames = getTagNamesForMode(mode, context);\n\n  const preferredTagName = Object.entries(tagNames).find(([\n    , aliases,\n  ]) => {\n    return aliases.includes(name);\n  })?.[0];\n  if (preferredTagName) {\n    return preferredTagName;\n  }\n\n  return name;\n};\n\n/**\n * @param context\n * @param {ParserMode} mode\n * @param {string} name\n * @param {Array} definedTags\n * @returns {boolean}\n */\nconst isValidTag = (\n  context,\n  mode,\n  name,\n  definedTags,\n) => {\n  const tagNames = getTagNamesForMode(mode, context);\n\n  const validTagNames = Object.keys(tagNames).concat(Object.values(tagNames).flat());\n  const additionalTags = definedTags;\n  const allTags = validTagNames.concat(additionalTags);\n\n  return allTags.includes(name);\n};\n\n/**\n * @param {object} jsdoc\n * @param {string} targetTagName\n * @returns {boolean}\n */\nconst hasTag = (jsdoc, targetTagName) => {\n  const targetTagLower = targetTagName.toLowerCase();\n\n  return jsdoc.tags.some((doc) => {\n    return doc.tag.toLowerCase() === targetTagLower;\n  });\n};\n\n/**\n * @param {object} jsdoc\n * @param {Array} targetTagNames\n * @returns {boolean}\n */\nconst hasATag = (jsdoc, targetTagNames) => {\n  return targetTagNames.some((targetTagName) => {\n    return hasTag(jsdoc, targetTagName);\n  });\n};\n\n/**\n * Checks if the JSDoc comment declares a defined type.\n *\n * @param {JsDocTag} tag\n *   the tag which should be checked.\n * @returns {boolean}\n *   true in case a defined type is declared; otherwise false.\n */\nconst hasDefinedTypeTag = (tag) => {\n  // The function should not continue in the event the type is not defined...\n  if (typeof tag === 'undefined' || tag === null) {\n    return false;\n  }\n\n  // .. same applies if it declares an `{undefined}` or `{void}` type\n  const tagType = tag.type.trim();\n  if (tagType === 'undefined' || tagType === 'void') {\n    return false;\n  }\n\n  // In any other case, a type is present\n  return true;\n};\n\n/**\n * @param map\n * @param tag\n * @returns {Map}\n */\nconst ensureMap = (map, tag) => {\n  if (!map.has(tag)) {\n    map.set(tag, new Map());\n  }\n\n  return map.get(tag);\n};\n\n/**\n * @param structuredTags\n * @param tagMap\n */\nconst overrideTagStructure = (structuredTags, tagMap = tagStructure) => {\n  for (const [\n    tag,\n    {\n      name,\n      type,\n      required = [],\n    },\n  ] of Object.entries(structuredTags)) {\n    const tagStruct = ensureMap(tagMap, tag);\n\n    tagStruct.set('nameContents', name);\n    tagStruct.set('typeAllowed', type);\n\n    const requiredName = required.includes('name');\n    if (requiredName && name === false) {\n      throw new Error('Cannot add \"name\" to `require` with the tag\\'s `name` set to `false`');\n    }\n\n    tagStruct.set('nameRequired', requiredName);\n\n    const requiredType = required.includes('type');\n    if (requiredType && type === false) {\n      throw new Error('Cannot add \"type\" to `require` with the tag\\'s `type` set to `false`');\n    }\n\n    tagStruct.set('typeRequired', requiredType);\n\n    const typeOrNameRequired = required.includes('typeOrNameRequired');\n    if (typeOrNameRequired && name === false) {\n      throw new Error('Cannot add \"typeOrNameRequired\" to `require` with the tag\\'s `name` set to `false`');\n    }\n\n    if (typeOrNameRequired && type === false) {\n      throw new Error('Cannot add \"typeOrNameRequired\" to `require` with the tag\\'s `type` set to `false`');\n    }\n\n    tagStruct.set('typeOrNameRequired', typeOrNameRequired);\n  }\n};\n\n/**\n * @param mode\n * @param structuredTags\n * @returns {Map}\n */\nconst getTagStructureForMode = (mode, structuredTags) => {\n  const tagStruct = getDefaultTagStructureForMode(mode);\n\n  try {\n    overrideTagStructure(structuredTags, tagStruct);\n  } catch {\n    //\n  }\n\n  return tagStruct;\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst isNamepathDefiningTag = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return tagStruct.get('nameContents') === 'namepath-defining';\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMustHaveTypePosition = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return tagStruct.get('typeRequired');\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMightHaveTypePosition = (tag, tagMap = tagStructure) => {\n  if (tagMustHaveTypePosition(tag, tagMap)) {\n    return true;\n  }\n\n  const tagStruct = ensureMap(tagMap, tag);\n\n  const ret = tagStruct.get('typeAllowed');\n\n  return ret === undefined ? true : ret;\n};\n\nconst namepathTypes = new Set([\n  'namepath-defining', 'namepath-referencing',\n]);\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMightHaveNamePosition = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  const ret = tagStruct.get('nameContents');\n\n  return ret === undefined ? true : Boolean(ret);\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMightHaveNamepath = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return namepathTypes.has(tagStruct.get('nameContents'));\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMustHaveNamePosition = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return tagStruct.get('nameRequired');\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMightHaveEitherTypeOrNamePosition = (tag, tagMap) => {\n  return tagMightHaveTypePosition(tag, tagMap) || tagMightHaveNamepath(tag, tagMap);\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMustHaveEitherTypeOrNamePosition = (tag, tagMap) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return tagStruct.get('typeOrNameRequired');\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMissingRequiredTypeOrNamepath = (tag, tagMap = tagStructure) => {\n  const mustHaveTypePosition = tagMustHaveTypePosition(tag.tag, tagMap);\n  const mightHaveTypePosition = tagMightHaveTypePosition(tag.tag, tagMap);\n  const hasTypePosition = mightHaveTypePosition && Boolean(tag.type);\n  const hasNameOrNamepathPosition = (\n    tagMustHaveNamePosition(tag.tag, tagMap) ||\n    tagMightHaveNamepath(tag.tag, tagMap)\n  ) && Boolean(tag.name);\n  const mustHaveEither = tagMustHaveEitherTypeOrNamePosition(tag.tag, tagMap);\n  const hasEither = tagMightHaveEitherTypeOrNamePosition(tag.tag, tagMap) &&\n    (hasTypePosition || hasNameOrNamepathPosition);\n\n  return mustHaveEither && !hasEither && !mustHaveTypePosition;\n};\n\n// eslint-disable-next-line complexity\nconst hasNonFunctionYield = (node, checkYieldReturnValue) => {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n  case 'BlockStatement': {\n    return node.body.some((bodyNode) => {\n      return ![\n        'ArrowFunctionExpression',\n        'FunctionDeclaration',\n        'FunctionExpression',\n      ].includes(bodyNode.type) && hasNonFunctionYield(\n        bodyNode, checkYieldReturnValue,\n      );\n    });\n  }\n\n  // istanbul ignore next -- In Babel?\n  case 'OptionalCallExpression':\n  case 'CallExpression':\n    return node.arguments.some((element) => {\n      return hasNonFunctionYield(element, checkYieldReturnValue);\n    });\n  case 'ChainExpression':\n  case 'ExpressionStatement': {\n    return hasNonFunctionYield(node.expression, checkYieldReturnValue);\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasNonFunctionYield(node.body, checkYieldReturnValue);\n  }\n\n  case 'ConditionalExpression':\n  case 'IfStatement': {\n    return hasNonFunctionYield(node.test, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.consequent, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.alternate, checkYieldReturnValue);\n  }\n\n  case 'TryStatement': {\n    return hasNonFunctionYield(node.block, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.handler && node.handler.body, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.finalizer, checkYieldReturnValue);\n  }\n\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasNonFunctionYield(nde, checkYieldReturnValue);\n        });\n      },\n    );\n  }\n\n  case 'ArrayPattern':\n  case 'ArrayExpression':\n    return node.elements.some((element) => {\n      return hasNonFunctionYield(element, checkYieldReturnValue);\n    });\n  case 'AssignmentPattern':\n    return hasNonFunctionYield(node.right, checkYieldReturnValue);\n\n  case 'VariableDeclaration': {\n    return node.declarations.some((nde) => {\n      return hasNonFunctionYield(nde, checkYieldReturnValue);\n    });\n  }\n\n  case 'VariableDeclarator': {\n    return hasNonFunctionYield(node.id, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.init, checkYieldReturnValue);\n  }\n\n  case 'AssignmentExpression':\n  case 'BinaryExpression':\n  case 'LogicalExpression': {\n    return hasNonFunctionYield(node.left, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.right, checkYieldReturnValue);\n  }\n\n  // Comma\n  case 'SequenceExpression':\n  case 'TemplateLiteral':\n    return node.expressions.some((subExpression) => {\n      return hasNonFunctionYield(subExpression, checkYieldReturnValue);\n    });\n\n  case 'ObjectPattern':\n  case 'ObjectExpression':\n    return node.properties.some((property) => {\n      return hasNonFunctionYield(property, checkYieldReturnValue);\n    });\n\n  // istanbul ignore next -- In Babel?\n  case 'PropertyDefinition':\n  /* eslint-disable no-fallthrough */\n  // istanbul ignore next -- In Babel?\n  case 'ObjectProperty':\n  // istanbul ignore next -- In Babel?\n  case 'ClassProperty':\n  /* eslint-enable no-fallthrough */\n  case 'Property':\n    return node.computed && hasNonFunctionYield(node.key, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.value, checkYieldReturnValue);\n  // istanbul ignore next -- In Babel?\n  case 'ObjectMethod':\n    // istanbul ignore next -- In Babel?\n    return node.computed && hasNonFunctionYield(node.key, checkYieldReturnValue) ||\n      node.arguments.some((nde) => {\n        return hasNonFunctionYield(nde, checkYieldReturnValue);\n      });\n\n  case 'SpreadElement':\n  case 'UnaryExpression':\n    return hasNonFunctionYield(node.argument, checkYieldReturnValue);\n\n  case 'TaggedTemplateExpression':\n    return hasNonFunctionYield(node.quasi, checkYieldReturnValue);\n\n  // ?.\n  // istanbul ignore next -- In Babel?\n  case 'OptionalMemberExpression':\n  case 'MemberExpression':\n    return hasNonFunctionYield(node.object, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.property, checkYieldReturnValue);\n\n  // istanbul ignore next -- In Babel?\n  case 'Import':\n  case 'ImportExpression':\n    return hasNonFunctionYield(node.source, checkYieldReturnValue);\n\n  case 'ReturnStatement': {\n    if (node.argument === null) {\n      return false;\n    }\n\n    return hasNonFunctionYield(node.argument, checkYieldReturnValue);\n  }\n\n  case 'YieldExpression': {\n    if (checkYieldReturnValue) {\n      if (node.parent.type === 'VariableDeclarator') {\n        return true;\n      }\n\n      return false;\n    }\n\n    // void return does not count.\n    if (node.argument === null) {\n      return false;\n    }\n\n    return true;\n  }\n\n  default: {\n    return false;\n  }\n  }\n};\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n *\n * @param {object} node\n * @returns {boolean}\n */\nconst hasYieldValue = (node, checkYieldReturnValue) => {\n  return node.generator && (\n    node.expression || hasNonFunctionYield(node.body, checkYieldReturnValue)\n  );\n};\n\n/**\n * Checks if a node has a throws statement.\n *\n * @param {object} node\n * @param {boolean} innerFunction\n * @returns {boolean}\n */\n// eslint-disable-next-line complexity\nconst hasThrowValue = (node, innerFunction) => {\n  if (!node) {\n    return false;\n  }\n\n  // There are cases where a function may execute its inner function which\n  //   throws, but we're treating functions atomically rather than trying to\n  //   follow them\n  switch (node.type) {\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    return !innerFunction && !node.async && hasThrowValue(node.body, true);\n  }\n\n  case 'BlockStatement': {\n    return node.body.some((bodyNode) => {\n      return bodyNode.type !== 'FunctionDeclaration' && hasThrowValue(bodyNode);\n    });\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasThrowValue(node.body);\n  }\n\n  case 'IfStatement': {\n    return hasThrowValue(node.consequent) || hasThrowValue(node.alternate);\n  }\n\n  // We only consider it to throw an error if the catch or finally blocks throw an error.\n  case 'TryStatement': {\n    return hasThrowValue(node.handler && node.handler.body) ||\n        hasThrowValue(node.finalizer);\n  }\n\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasThrowValue(nde);\n        });\n      },\n    );\n  }\n\n  case 'ThrowStatement': {\n    return true;\n  }\n\n  default: {\n    return false;\n  }\n  }\n};\n\n/**\n * @param {string} tag\n */\n/*\nconst isInlineTag = (tag) => {\n  return /^(@link|@linkcode|@linkplain|@tutorial) /u.test(tag);\n};\n*/\n\n/**\n * Parses GCC Generic/Template types\n *\n * @see {https://github.com/google/closure-compiler/wiki/Generic-Types}\n * @see {https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#template}\n * @param {JsDocTag} tag\n * @returns {Array<string>}\n */\nconst parseClosureTemplateTag = (tag) => {\n  return tag.name\n    .split(',')\n    .map((type) => {\n      return type.trim().replace(/^\\[(?<name>.*?)=.*\\]$/u, '$<name>');\n    });\n};\n\n/**\n * @typedef {true|string[]} DefaultContexts\n */\n\n/**\n * Checks user option for `contexts` array, defaulting to\n *   contexts designated by the rule. Returns an array of\n *   ESTree AST types, indicating allowable contexts.\n *\n * @param {*} context\n * @param {DefaultContexts} defaultContexts\n * @returns {string[]}\n */\nconst enforcedContexts = (context, defaultContexts) => {\n  const {\n    contexts = defaultContexts === true ? [\n      'ArrowFunctionExpression',\n      'FunctionDeclaration',\n      'FunctionExpression',\n      'TSDeclareFunction',\n    ] : defaultContexts,\n  } = context.options[0] || {};\n\n  return contexts;\n};\n\n/**\n * @param {string[]} contexts\n * @param {Function} checkJsdoc\n * @param {Function} handler\n */\nconst getContextObject = (contexts, checkJsdoc, handler) => {\n  const properties = {};\n\n  for (const [\n    idx,\n    prop,\n  ] of contexts.entries()) {\n    let property;\n    let value;\n\n    if (typeof prop === 'object') {\n      const selInfo = {\n        lastIndex: idx,\n        selector: prop.context,\n      };\n      if (prop.comment) {\n        property = prop.context;\n        value = checkJsdoc.bind(\n          null, {\n            ...selInfo,\n            comment: prop.comment,\n          }, handler.bind(null, prop.comment),\n        );\n      } else {\n        property = prop.context;\n        value = checkJsdoc.bind(null, selInfo, null);\n      }\n    } else {\n      const selInfo = {\n        lastIndex: idx,\n        selector: prop,\n      };\n      property = prop;\n      value = checkJsdoc.bind(null, selInfo, null);\n    }\n\n    const old = properties[property];\n    properties[property] = old ? function (...args) {\n      old(...args);\n      value(...args);\n    } : value;\n  }\n\n  return properties;\n};\n\nconst filterTags = (tags, filter) => {\n  return tags.filter((tag) => {\n    return filter(tag);\n  });\n};\n\nconst tagsWithNamesAndDescriptions = new Set([\n  'param', 'arg', 'argument', 'property', 'prop',\n  'template',\n\n  // These two are parsed by our custom parser as though having a `name`\n  'returns', 'return',\n]);\n\nconst getTagsByType = (context, mode, tags, tagPreference) => {\n  const descName = getPreferredTagName(context, mode, 'description', tagPreference);\n  const tagsWithoutNames = [];\n  const tagsWithNames = filterTags(tags, (tag) => {\n    const {\n      tag: tagName,\n    } = tag;\n    const tagWithName = tagsWithNamesAndDescriptions.has(tagName);\n    if (!tagWithName && tagName !== descName) {\n      tagsWithoutNames.push(tag);\n    }\n\n    return tagWithName;\n  });\n\n  return {\n    tagsWithNames,\n    tagsWithoutNames,\n  };\n};\n\nconst getIndent = (sourceCode) => {\n  return (sourceCode.text.match(/^\\n*([ \\t]+)/u)?.[1] ?? '') + ' ';\n};\n\nconst isConstructor = (node) => {\n  return node?.type === 'MethodDefinition' && node.kind === 'constructor' ||\n    node?.parent?.kind === 'constructor';\n};\n\nconst isGetter = (node) => {\n  return node && node.parent?.kind === 'get';\n};\n\nconst isSetter = (node) => {\n  return node && node.parent?.kind === 'set';\n};\n\nconst hasAccessorPair = (node) => {\n  const {\n    type,\n    kind: sourceKind,\n    key: {\n      name: sourceName,\n    },\n  } = node;\n  const oppositeKind = sourceKind === 'get' ? 'set' : 'get';\n\n  const children = type === 'MethodDefinition' ? 'body' : 'properties';\n\n  return node.parent[children].some(({\n    kind,\n    key: {\n      name,\n    },\n  }) => {\n    return kind === oppositeKind && name === sourceName;\n  });\n};\n\nconst exemptSpeciaMethods = (jsdoc, node, context, schema) => {\n  const hasSchemaOption = (prop) => {\n    const schemaProperties = schema[0].properties;\n\n    return context.options[0]?.[prop] ??\n      (schemaProperties[prop] && schemaProperties[prop].default);\n  };\n\n  const checkGetters = hasSchemaOption('checkGetters');\n  const checkSetters = hasSchemaOption('checkSetters');\n\n  return !hasSchemaOption('checkConstructors') &&\n    (\n      isConstructor(node) ||\n      hasATag(jsdoc, [\n        'class',\n        'constructor',\n      ])) ||\n  isGetter(node) && (\n    !checkGetters ||\n    checkGetters === 'no-setter' && hasAccessorPair(node.parent)\n  ) ||\n  isSetter(node) && (\n    !checkSetters ||\n    checkSetters === 'no-getter' && hasAccessorPair(node.parent)\n  );\n};\n\n/**\n * Since path segments may be unquoted (if matching a reserved word,\n * identifier or numeric literal) or single or double quoted, in either\n * the `@param` or in source, we need to strip the quotes to give a fair\n * comparison.\n *\n * @param {string} str\n * @returns {string}\n */\nconst dropPathSegmentQuotes = (str) => {\n  return str.replace(/\\.(['\"])(.*)\\1/gu, '.$2');\n};\n\n/**\n * @param {string} name\n * @returns {(otherPathName: string) => void}\n */\nconst comparePaths = (name) => {\n  return (otherPathName) => {\n    return otherPathName === name ||\n      dropPathSegmentQuotes(otherPathName) === dropPathSegmentQuotes(name);\n  };\n};\n\n/**\n * @param {string} name\n * @param {string} otherPathName\n * @returns {boolean}\n */\nconst pathDoesNotBeginWith = (name, otherPathName) => {\n  return !name.startsWith(otherPathName) &&\n    !dropPathSegmentQuotes(name).startsWith(dropPathSegmentQuotes(otherPathName));\n};\n\n/**\n * @param {string} regexString\n * @param {string} requiredFlags\n * @returns {RegExp}\n */\nconst getRegexFromString = (regexString, requiredFlags) => {\n  const match = regexString.match(/^\\/(.*)\\/([gimyus]*)$/us);\n  let flags = 'u';\n  let regex = regexString;\n  if (match) {\n    [\n      , regex,\n      flags,\n    ] = match;\n    if (!flags) {\n      flags = 'u';\n    }\n  }\n\n  const uniqueFlags = [\n    ...new Set(flags + (requiredFlags || '')),\n  ];\n  flags = uniqueFlags.join('');\n\n  return new RegExp(regex, flags);\n};\n\nexport default {\n  comparePaths,\n  dropPathSegmentQuotes,\n  enforcedContexts,\n  exemptSpeciaMethods,\n  filterTags,\n  flattenRoots,\n  getContextObject,\n  getFunctionParameterNames,\n  getIndent,\n  getJsdocTagsDeep,\n  getPreferredTagName,\n  getRegexFromString,\n  getTagsByType,\n  getTagStructureForMode,\n  hasATag,\n  hasDefinedTypeTag,\n  hasParams,\n  hasReturnValue,\n  hasTag,\n  hasThrowValue,\n  hasValueOrExecutorHasNonEmptyResolveValue,\n  hasYieldValue,\n  isConstructor,\n  isGetter,\n  isNamepathDefiningTag,\n  isSetter,\n  isValidTag,\n  overrideTagStructure,\n  parseClosureTemplateTag,\n  pathDoesNotBeginWith,\n  setTagStructure,\n  tagMightHaveNamepath,\n  tagMightHaveNamePosition,\n  tagMightHaveTypePosition,\n  tagMissingRequiredTypeOrNamepath,\n  tagMustHaveNamePosition,\n  tagMustHaveTypePosition,\n};\n"],"mappings":"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"}