{"version":3,"sources":["../src/index.mjs"],"names":["deepcopy","value","options","customizer","valueType","recursiveCopy","copiedValue","references","WeakMap","visited","WeakSet","clone","type","keys","Object","push","getOwnPropertySymbols","collectionKey","collectionValue","has","get","collectionValueType","copiedCollectionValue","set","add"],"mappings":"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","sourcesContent":["import { detectType } from './detector.mjs';\nimport { get, isCollection, set } from './collection.mjs';\nimport { copy } from './copier.mjs';\n\n/**\n * deepcopy function\n *\n * @param {*} value\n * @param {Object|Function} [options]\n * @return {*}\n */\nexport default function deepcopy(value, options = {}) {\n  if (typeof options === 'function') {\n    options = {\n      customizer: options\n    };\n  }\n\n  const {\n    // TODO: before/after customizer\n    customizer\n    // TODO: max depth\n    // depth = Infinity,\n  } = options;\n\n  const valueType = detectType(value);\n\n  if (!isCollection(valueType)) {\n    return recursiveCopy(value, null, null, null, customizer);\n  }\n\n  const copiedValue = copy(value, valueType, customizer);\n\n  const references = new WeakMap([[value, copiedValue]]);\n  const visited = new WeakSet([value]);\n\n  return recursiveCopy(value, copiedValue, references, visited, customizer);\n}\n\n/**\n * recursively copy\n *\n * @param {*} value target value\n * @param {*} clone clone of value\n * @param {WeakMap} references visited references of clone\n * @param {WeakSet} visited visited references of value\n * @param {Function} customizer user customize function\n * @return {*}\n */\nfunction recursiveCopy(value, clone, references, visited, customizer) {\n  const type = detectType(value);\n  const copiedValue = copy(value, type);\n\n  // return if not a collection value\n  if (!isCollection(type)) {\n    return copiedValue;\n  }\n\n  let keys;\n\n  switch (type) {\n    case 'Arguments':\n    case 'Array':\n      keys = Object.keys(value);\n      break;\n    case 'Object':\n      keys = Object.keys(value);\n      keys.push(...Object.getOwnPropertySymbols(value));\n      break;\n    case 'Map':\n    case 'Set':\n      keys = value.keys();\n      break;\n    default:\n  }\n\n  // walk within collection with iterator\n  for (let collectionKey of keys) {\n    const collectionValue = get(value, collectionKey, type);\n\n    if (visited.has(collectionValue)) {\n      // for [Circular]\n      set(clone, collectionKey, references.get(collectionValue), type);\n    } else {\n      const collectionValueType = detectType(collectionValue);\n      const copiedCollectionValue = copy(collectionValue, collectionValueType);\n\n      // save reference if value is collection\n      if (isCollection(collectionValueType)) {\n        references.set(collectionValue, copiedCollectionValue);\n        visited.add(collectionValue);\n      }\n\n      set(\n        clone,\n        collectionKey,\n        recursiveCopy(\n          collectionValue,\n          copiedCollectionValue,\n          references,\n          visited,\n          customizer\n        ),\n        type\n      );\n    }\n  }\n\n  // TODO: isSealed/isFrozen/isExtensible\n\n  return clone;\n}\n"],"file":"index.js"}