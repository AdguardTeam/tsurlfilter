'use strict';

var axios = require('axios');
var path = require('path');
var fs = require('fs');

var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs$1 (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof commonjsGlobal$1 !== 'undefined' ? commonjsGlobal$1 : typeof self !== 'undefined' ? self : {};
function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}
var sha1 = {exports: {}};
function commonjsRequire$1(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var core$1 = {exports: {}};
var _nodeResolve_empty = {};
var _nodeResolve_empty$1 = Object.freeze({
	__proto__: null,
	default: _nodeResolve_empty
});
var require$$0 = getAugmentedNamespace(_nodeResolve_empty$1);
var hasRequiredCore$1;
function requireCore$1 () {
	if (hasRequiredCore$1) return core$1.exports;
	hasRequiredCore$1 = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				module.exports = factory();
			}
		}(commonjsGlobal, function () {
			var CryptoJS = CryptoJS || (function (Math, undefined$1) {
			    var crypto;
			    if (typeof window !== 'undefined' && window.crypto) {
			        crypto = window.crypto;
			    }
			    if (typeof self !== 'undefined' && self.crypto) {
			        crypto = self.crypto;
			    }
			    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
			        crypto = globalThis.crypto;
			    }
			    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
			        crypto = window.msCrypto;
			    }
			    if (!crypto && typeof commonjsGlobal !== 'undefined' && commonjsGlobal.crypto) {
			        crypto = commonjsGlobal.crypto;
			    }
			    if (!crypto && typeof commonjsRequire$1 === 'function') {
			        try {
			            crypto = require$$0;
			        } catch (err) {}
			    }
			    var cryptoSecureRandomInt = function () {
			        if (crypto) {
			            if (typeof crypto.getRandomValues === 'function') {
			                try {
			                    return crypto.getRandomValues(new Uint32Array(1))[0];
			                } catch (err) {}
			            }
			            if (typeof crypto.randomBytes === 'function') {
			                try {
			                    return crypto.randomBytes(4).readInt32LE();
			                } catch (err) {}
			            }
			        }
			        throw new Error('Native crypto module could not be used to get secure random number.');
			    };
			    var create = Object.create || (function () {
			        function F() {}
			        return function (obj) {
			            var subtype;
			            F.prototype = obj;
			            subtype = new F();
			            F.prototype = null;
			            return subtype;
			        };
			    }());
			    var C = {};
			    var C_lib = C.lib = {};
			    var Base = C_lib.Base = (function () {
			        return {
			            extend: function (overrides) {
			                var subtype = create(this);
			                if (overrides) {
			                    subtype.mixIn(overrides);
			                }
			                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
			                    subtype.init = function () {
			                        subtype.$super.init.apply(this, arguments);
			                    };
			                }
			                subtype.init.prototype = subtype;
			                subtype.$super = this;
			                return subtype;
			            },
			            create: function () {
			                var instance = this.extend();
			                instance.init.apply(instance, arguments);
			                return instance;
			            },
			            init: function () {
			            },
			            mixIn: function (properties) {
			                for (var propertyName in properties) {
			                    if (properties.hasOwnProperty(propertyName)) {
			                        this[propertyName] = properties[propertyName];
			                    }
			                }
			                if (properties.hasOwnProperty('toString')) {
			                    this.toString = properties.toString;
			                }
			            },
			            clone: function () {
			                return this.init.prototype.extend(this);
			            }
			        };
			    }());
			    var WordArray = C_lib.WordArray = Base.extend({
			        init: function (words, sigBytes) {
			            words = this.words = words || [];
			            if (sigBytes != undefined$1) {
			                this.sigBytes = sigBytes;
			            } else {
			                this.sigBytes = words.length * 4;
			            }
			        },
			        toString: function (encoder) {
			            return (encoder || Hex).stringify(this);
			        },
			        concat: function (wordArray) {
			            var thisWords = this.words;
			            var thatWords = wordArray.words;
			            var thisSigBytes = this.sigBytes;
			            var thatSigBytes = wordArray.sigBytes;
			            this.clamp();
			            if (thisSigBytes % 4) {
			                for (var i = 0; i < thatSigBytes; i++) {
			                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
			                }
			            } else {
			                for (var j = 0; j < thatSigBytes; j += 4) {
			                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
			                }
			            }
			            this.sigBytes += thatSigBytes;
			            return this;
			        },
			        clamp: function () {
			            var words = this.words;
			            var sigBytes = this.sigBytes;
			            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
			            words.length = Math.ceil(sigBytes / 4);
			        },
			        clone: function () {
			            var clone = Base.clone.call(this);
			            clone.words = this.words.slice(0);
			            return clone;
			        },
			        random: function (nBytes) {
			            var words = [];
			            for (var i = 0; i < nBytes; i += 4) {
			                words.push(cryptoSecureRandomInt());
			            }
			            return new WordArray.init(words, nBytes);
			        }
			    });
			    var C_enc = C.enc = {};
			    var Hex = C_enc.Hex = {
			        stringify: function (wordArray) {
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;
			            var hexChars = [];
			            for (var i = 0; i < sigBytes; i++) {
			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                hexChars.push((bite >>> 4).toString(16));
			                hexChars.push((bite & 0x0f).toString(16));
			            }
			            return hexChars.join('');
			        },
			        parse: function (hexStr) {
			            var hexStrLength = hexStr.length;
			            var words = [];
			            for (var i = 0; i < hexStrLength; i += 2) {
			                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
			            }
			            return new WordArray.init(words, hexStrLength / 2);
			        }
			    };
			    var Latin1 = C_enc.Latin1 = {
			        stringify: function (wordArray) {
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;
			            var latin1Chars = [];
			            for (var i = 0; i < sigBytes; i++) {
			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                latin1Chars.push(String.fromCharCode(bite));
			            }
			            return latin1Chars.join('');
			        },
			        parse: function (latin1Str) {
			            var latin1StrLength = latin1Str.length;
			            var words = [];
			            for (var i = 0; i < latin1StrLength; i++) {
			                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
			            }
			            return new WordArray.init(words, latin1StrLength);
			        }
			    };
			    var Utf8 = C_enc.Utf8 = {
			        stringify: function (wordArray) {
			            try {
			                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
			            } catch (e) {
			                throw new Error('Malformed UTF-8 data');
			            }
			        },
			        parse: function (utf8Str) {
			            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
			        }
			    };
			    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
			        reset: function () {
			            this._data = new WordArray.init();
			            this._nDataBytes = 0;
			        },
			        _append: function (data) {
			            if (typeof data == 'string') {
			                data = Utf8.parse(data);
			            }
			            this._data.concat(data);
			            this._nDataBytes += data.sigBytes;
			        },
			        _process: function (doFlush) {
			            var processedWords;
			            var data = this._data;
			            var dataWords = data.words;
			            var dataSigBytes = data.sigBytes;
			            var blockSize = this.blockSize;
			            var blockSizeBytes = blockSize * 4;
			            var nBlocksReady = dataSigBytes / blockSizeBytes;
			            if (doFlush) {
			                nBlocksReady = Math.ceil(nBlocksReady);
			            } else {
			                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
			            }
			            var nWordsReady = nBlocksReady * blockSize;
			            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
			            if (nWordsReady) {
			                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
			                    this._doProcessBlock(dataWords, offset);
			                }
			                processedWords = dataWords.splice(0, nWordsReady);
			                data.sigBytes -= nBytesReady;
			            }
			            return new WordArray.init(processedWords, nBytesReady);
			        },
			        clone: function () {
			            var clone = Base.clone.call(this);
			            clone._data = this._data.clone();
			            return clone;
			        },
			        _minBufferSize: 0
			    });
			    C_lib.Hasher = BufferedBlockAlgorithm.extend({
			        cfg: Base.extend(),
			        init: function (cfg) {
			            this.cfg = this.cfg.extend(cfg);
			            this.reset();
			        },
			        reset: function () {
			            BufferedBlockAlgorithm.reset.call(this);
			            this._doReset();
			        },
			        update: function (messageUpdate) {
			            this._append(messageUpdate);
			            this._process();
			            return this;
			        },
			        finalize: function (messageUpdate) {
			            if (messageUpdate) {
			                this._append(messageUpdate);
			            }
			            var hash = this._doFinalize();
			            return hash;
			        },
			        blockSize: 512/32,
			        _createHelper: function (hasher) {
			            return function (message, cfg) {
			                return new hasher.init(cfg).finalize(message);
			            };
			        },
			        _createHmacHelper: function (hasher) {
			            return function (message, key) {
			                return new C_algo.HMAC.init(hasher, key).finalize(message);
			            };
			        }
			    });
			    var C_algo = C.algo = {};
			    return C;
			}(Math));
			return CryptoJS;
		}));
	} (core$1));
	return core$1.exports;
}
(function (module, exports) {
(function (root, factory) {
		{
			module.exports = factory(requireCore$1());
		}
	}(commonjsGlobal, function (CryptoJS) {
		(function () {
		    var C = CryptoJS;
		    var C_lib = C.lib;
		    var WordArray = C_lib.WordArray;
		    var Hasher = C_lib.Hasher;
		    var C_algo = C.algo;
		    var W = [];
		    var SHA1 = C_algo.SHA1 = Hasher.extend({
		        _doReset: function () {
		            this._hash = new WordArray.init([
		                0x67452301, 0xefcdab89,
		                0x98badcfe, 0x10325476,
		                0xc3d2e1f0
		            ]);
		        },
		        _doProcessBlock: function (M, offset) {
		            var H = this._hash.words;
		            var a = H[0];
		            var b = H[1];
		            var c = H[2];
		            var d = H[3];
		            var e = H[4];
		            for (var i = 0; i < 80; i++) {
		                if (i < 16) {
		                    W[i] = M[offset + i] | 0;
		                } else {
		                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
		                    W[i] = (n << 1) | (n >>> 31);
		                }
		                var t = ((a << 5) | (a >>> 27)) + e + W[i];
		                if (i < 20) {
		                    t += ((b & c) | (~b & d)) + 0x5a827999;
		                } else if (i < 40) {
		                    t += (b ^ c ^ d) + 0x6ed9eba1;
		                } else if (i < 60) {
		                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
		                } else  {
		                    t += (b ^ c ^ d) - 0x359d3e2a;
		                }
		                e = d;
		                d = c;
		                c = (b << 30) | (b >>> 2);
		                b = a;
		                a = t;
		            }
		            H[0] = (H[0] + a) | 0;
		            H[1] = (H[1] + b) | 0;
		            H[2] = (H[2] + c) | 0;
		            H[3] = (H[3] + d) | 0;
		            H[4] = (H[4] + e) | 0;
		        },
		        _doFinalize: function () {
		            var data = this._data;
		            var dataWords = data.words;
		            var nBitsTotal = this._nDataBytes * 8;
		            var nBitsLeft = data.sigBytes * 8;
		            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
		            data.sigBytes = dataWords.length * 4;
		            this._process();
		            return this._hash;
		        },
		        clone: function () {
		            var clone = Hasher.clone.call(this);
		            clone._hash = this._hash.clone();
		            return clone;
		        }
		    });
		    C.SHA1 = Hasher._createHelper(SHA1);
		    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
		}());
		return CryptoJS.SHA1;
	}));
} (sha1));
var sha1Exports = sha1.exports;
var SHA1 = getDefaultExportFromCjs(sha1Exports);
const calculateChecksumSHA1 = (content) => {
    const res = SHA1(content);
    return res.toString();
};
const DIFF_PATH_TAG = 'Diff-Path';
const TypesOfChanges = {
    Add: 'a',
    Delete: 'd',
};
const DIFF_DIRECTIVE = 'diff';
const DIFF_DIRECTIVE_NAME = 'name';
const DIFF_DIRECTIVE_CHECKSUM = 'checksum';
const DIFF_DIRECTIVE_LINE = 'lines';
const parseDiffDirective = (s) => {
    if (!s.startsWith(DIFF_DIRECTIVE)) {
        return null;
    }
    const parts = s
        .split(' ')
        .slice(1);
    const nameExists = parts[0].startsWith(DIFF_DIRECTIVE_NAME);
    if (nameExists) {
        return {
            name: parts[0].slice(`${DIFF_DIRECTIVE_NAME}:`.length),
            checksum: parts[1].slice(`${DIFF_DIRECTIVE_CHECKSUM}:`.length),
            lines: Number(parts[2].slice(`${DIFF_DIRECTIVE_LINE}:`.length)),
        };
    }
    return {
        checksum: parts[0].slice(`${DIFF_DIRECTIVE_CHECKSUM}:`.length),
        lines: Number(parts[1].slice(`${DIFF_DIRECTIVE_LINE}:`.length)),
    };
};
const FILE_EXTENSION = '.patch';
const MS_IN_SECONDS = 1000;
const MS_IN_MINUTES = MS_IN_SECONDS * 60;
const MS_IN_HOURS = MS_IN_MINUTES * 60;
const Resolution = {
    Hours: 'h',
    Minutes: 'm',
    Seconds: 's',
};
const assertNever = (x) => {
    throw new Error(`Unexpected value in resolution: ${x}`);
};
const timestampWithResolutionToMs = (timestamp, resolution) => {
    switch (resolution) {
        case Resolution.Hours:
            return timestamp * MS_IN_HOURS;
        case Resolution.Minutes:
            return timestamp * MS_IN_MINUTES;
        case Resolution.Seconds:
            return timestamp * MS_IN_SECONDS;
        default:
            return assertNever(resolution);
    }
};
const parsePatchName = (patchName) => {
    const parts = patchName
        .slice(0, -FILE_EXTENSION.length)
        .split('-');
    if (parts.length === 4) {
        const [name, parsedResolution, parsedEpochTimestamp, parsedTime,] = parts;
        if (!(Object.values(Resolution)).includes(parsedResolution)) {
            throw new Error(`Unrecognized resolution in patch name: ${patchName}`);
        }
        return {
            name,
            resolution: parsedResolution,
            epochTimestamp: Number.parseInt(parsedEpochTimestamp, 10),
            time: Number.parseInt(parsedTime, 10),
        };
    }
    if (parts.length === 3) {
        const [name, parsedEpochTimestamp, parsedTime,] = parts;
        const resolution = Resolution.Hours;
        return {
            name,
            resolution,
            epochTimestamp: Number.parseInt(parsedEpochTimestamp, 10),
            time: Number.parseInt(parsedTime, 10),
        };
    }
    throw new Error(`Cannot parse the patch name: ${patchName}`);
};
const splitByLines = (s) => {
    return s.split(/(?<=\r?\n)/);
};
const createLogger = (verbose) => {
    return (message) => {
        if (verbose) {
            console.log(message);
        }
    };
};
function isErrorWithMessage(error) {
    return (typeof error === 'object'
        && error !== null
        && 'message' in error
        && typeof error.message === 'string');
}
function toErrorWithMessage(maybeError) {
    if (isErrorWithMessage(maybeError)) {
        return maybeError;
    }
    try {
        return new Error(JSON.stringify(maybeError));
    }
    catch {
        return new Error(String(maybeError));
    }
}
function getErrorMessage(error) {
    return toErrorWithMessage(error).message;
}
const AMOUNT_OF_LINES_TO_PARSE = 50;
const parseTag = (tagName, rules) => {
    const maxLines = Math.min(AMOUNT_OF_LINES_TO_PARSE, rules.length);
    for (let i = 0; i < maxLines; i += 1) {
        const rule = rules[i];
        if (!rule) {
            continue;
        }
        const search = `! ${tagName}: `;
        const indexOfSearch = rule.indexOf(search);
        if (indexOfSearch >= 0) {
            return rule.substring(indexOfSearch + search.length).trim();
        }
    }
    return null;
};
const ERROR_NAME = 'UnacceptableResponseError';
class UnacceptableResponseError extends Error {
    constructor(message) {
        super(message);
        this.name = ERROR_NAME;
        Object.setPrototypeOf(this, UnacceptableResponseError.prototype);
    }
}
const AcceptableHttpStatusCodes = {
    NotFound: 404,
    NoContent: 204,
    Ok: 200,
};
const parseRcsOperation = (rcsOperation) => {
    const [operationInfo, operationCounter] = rcsOperation.split(' ');
    const typeOfOperation = operationInfo[0];
    const startIndex = Number(operationInfo.slice(1)) - 1;
    const numberOfLines = Number(operationCounter);
    if (typeOfOperation !== TypesOfChanges.Add && typeOfOperation !== TypesOfChanges.Delete) {
        throw new Error(`Operation is not valid: cannot parse type: ${rcsOperation}`);
    }
    if (Number.isNaN(startIndex)) {
        throw new Error(`Operation is not valid: cannot parse index: ${rcsOperation}`);
    }
    if (Number.isNaN(numberOfLines)) {
        throw new Error(`Operation is not valid: cannot parse number of lines: ${rcsOperation}`);
    }
    return {
        typeOfOperation,
        startIndex,
        numberOfLines,
    };
};
const applyRcsPatch = (filterContent, patch, checksum) => {
    const lines = filterContent.slice();
    let currentOffset = 0;
    for (let index = 0; index < patch.length; index += 1) {
        const patchLine = patch[index];
        if (patchLine === '') {
            continue;
        }
        const parsedRcsOperation = parseRcsOperation(patchLine);
        const { typeOfOperation, startIndex, numberOfLines, } = parsedRcsOperation;
        const startIndexWithOffset = startIndex + currentOffset;
        if (typeOfOperation === TypesOfChanges.Delete) {
            lines.splice(startIndexWithOffset, numberOfLines);
            currentOffset -= numberOfLines;
        }
        if (typeOfOperation === TypesOfChanges.Add) {
            const stringsToAdd = [];
            let nStringsToAdd = numberOfLines;
            let scanFrom = index + 1;
            while (nStringsToAdd > 0 && scanFrom < patch.length) {
                stringsToAdd.push(patch[scanFrom]);
                scanFrom += 1;
                nStringsToAdd -= 1;
            }
            index += stringsToAdd.length;
            if (startIndexWithOffset < 0) {
                lines.unshift(...stringsToAdd);
            }
            else if (startIndexWithOffset > lines.length) {
                lines.push(...stringsToAdd);
            }
            else {
                lines.splice(startIndexWithOffset + 1, 0, ...stringsToAdd);
            }
            currentOffset += numberOfLines;
        }
    }
    const updatedFilter = lines.join('');
    if (checksum) {
        const c = calculateChecksumSHA1(updatedFilter);
        if (c !== checksum) {
            throw new Error('Checksums are not equal.');
        }
    }
    return updatedFilter;
};
const checkPatchExpired = (diffPath) => {
    const { resolution, epochTimestamp, time, } = parsePatchName(diffPath);
    const createdMs = timestampWithResolutionToMs(epochTimestamp, resolution);
    const ttlMs = timestampWithResolutionToMs(time, resolution);
    return Date.now() > createdMs + ttlMs;
};
const downloadFile = async (baseURL, fileUrl, isFileHostedViaNetworkProtocol, isRecursiveUpdate, log) => {
    try {
        const response = await fetch(new URL(fileUrl, `${baseURL}/`));
        if (!isFileHostedViaNetworkProtocol && !(response.status >= 200 && response.status < 300)) {
            log(`Error during file request: ${response.status} ${response.statusText}`);
            return null;
        }
        if (isFileHostedViaNetworkProtocol) {
            const acceptableHttpStatusCodes = Object.values(AcceptableHttpStatusCodes);
            if (!acceptableHttpStatusCodes.includes(response.status)) {
                const err = `Unacceptable response for network request: ${response.status} ${response.statusText}`;
                log(err);
                throw new UnacceptableResponseError(err);
            }
        }
        if ((response.status === AcceptableHttpStatusCodes.NotFound
            || response.status === AcceptableHttpStatusCodes.NoContent) && !isRecursiveUpdate) {
            log('Update is not available.');
            return null;
        }
        const data = await response.text();
        if (response.status === AcceptableHttpStatusCodes.Ok && data === '') {
            if (!isRecursiveUpdate) {
                log('Update is not available.');
            }
            return null;
        }
        return splitByLines(data);
    }
    catch (e) {
        if (!isFileHostedViaNetworkProtocol) {
            log(`Error during file request to "${baseURL}"/"${fileUrl}": ${getErrorMessage(e)}`);
            return null;
        }
        if (e instanceof UnacceptableResponseError) {
            throw e;
        }
        throw new Error(`Error during network request: ${getErrorMessage(e)}`, { cause: e });
    }
};
const extractBaseUrl = (filterUrl) => {
    let splitDelimeter = '/';
    if (filterUrl.includes('\\')) {
        splitDelimeter = '\\';
    }
    return filterUrl
        .split(splitDelimeter)
        .slice(0, -1)
        .join(splitDelimeter);
};
const applyPatch = async (params) => {
    const applyPatchWrapper = async (innerParams) => {
        const { filterUrl, filterContent, verbose = false, callStack, } = innerParams;
        const filterLines = splitByLines(filterContent);
        const diffPath = parseTag(DIFF_PATH_TAG, filterLines)?.split('#')[0];
        if (!diffPath) {
            return null;
        }
        if (!checkPatchExpired(diffPath)) {
            return filterContent;
        }
        const log = createLogger(verbose);
        let patch = [];
        try {
            const baseUrl = extractBaseUrl(filterUrl);
            const res = await downloadFile(baseUrl, diffPath, baseUrl.startsWith('http://') || baseUrl.startsWith('https://'), callStack > 0, log);
            if (res === null) {
                return filterContent;
            }
            patch = res;
        }
        catch (e) {
            if (e instanceof UnacceptableResponseError) {
                throw e;
            }
            throw new Error(`Error during downloading patch file from "${diffPath}": ${getErrorMessage(e)}`, { cause: e });
        }
        let updatedFilter = '';
        try {
            const diffDirective = parseDiffDirective(patch[0]);
            updatedFilter = applyRcsPatch(filterLines,
            diffDirective ? patch.slice(1) : patch, diffDirective ? diffDirective.checksum : undefined);
        }
        catch (e) {
            throw new Error(`Error during applying the patch from "${diffPath}": ${getErrorMessage(e)}`, { cause: e });
        }
        try {
            const recursiveUpdatedFilter = await applyPatchWrapper({
                filterUrl,
                filterContent: updatedFilter,
                callStack: callStack + 1,
                verbose,
            });
            if (recursiveUpdatedFilter === null) {
                return updatedFilter;
            }
            return recursiveUpdatedFilter;
        }
        catch (e) {
            return updatedFilter;
        }
    };
    return applyPatchWrapper(Object.assign(params, { callStack: 0 }));
};
const DiffUpdater = {
    applyPatch,
};
var DiffUpdater_1 = DiffUpdater;
var UnacceptableResponseError_1 = UnacceptableResponseError;

var md5 = {exports: {}};

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var core = {exports: {}};

var hasRequiredCore;
function requireCore () {
	if (hasRequiredCore) return core.exports;
	hasRequiredCore = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				module.exports = factory();
			}
		}(commonjsGlobal$1, function () {
			var CryptoJS = CryptoJS || (function (Math, undefined$1) {
			    var crypto;
			    if (typeof window !== 'undefined' && window.crypto) {
			        crypto = window.crypto;
			    }
			    if (typeof self !== 'undefined' && self.crypto) {
			        crypto = self.crypto;
			    }
			    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
			        crypto = globalThis.crypto;
			    }
			    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
			        crypto = window.msCrypto;
			    }
			    if (!crypto && typeof commonjsGlobal$1 !== 'undefined' && commonjsGlobal$1.crypto) {
			        crypto = commonjsGlobal$1.crypto;
			    }
			    if (!crypto && typeof commonjsRequire === 'function') {
			        try {
			            crypto = require('crypto');
			        } catch (err) {}
			    }
			    var cryptoSecureRandomInt = function () {
			        if (crypto) {
			            if (typeof crypto.getRandomValues === 'function') {
			                try {
			                    return crypto.getRandomValues(new Uint32Array(1))[0];
			                } catch (err) {}
			            }
			            if (typeof crypto.randomBytes === 'function') {
			                try {
			                    return crypto.randomBytes(4).readInt32LE();
			                } catch (err) {}
			            }
			        }
			        throw new Error('Native crypto module could not be used to get secure random number.');
			    };
			    var create = Object.create || (function () {
			        function F() {}
			        return function (obj) {
			            var subtype;
			            F.prototype = obj;
			            subtype = new F();
			            F.prototype = null;
			            return subtype;
			        };
			    }());
			    var C = {};
			    var C_lib = C.lib = {};
			    var Base = C_lib.Base = (function () {
			        return {
			            extend: function (overrides) {
			                var subtype = create(this);
			                if (overrides) {
			                    subtype.mixIn(overrides);
			                }
			                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
			                    subtype.init = function () {
			                        subtype.$super.init.apply(this, arguments);
			                    };
			                }
			                subtype.init.prototype = subtype;
			                subtype.$super = this;
			                return subtype;
			            },
			            create: function () {
			                var instance = this.extend();
			                instance.init.apply(instance, arguments);
			                return instance;
			            },
			            init: function () {
			            },
			            mixIn: function (properties) {
			                for (var propertyName in properties) {
			                    if (properties.hasOwnProperty(propertyName)) {
			                        this[propertyName] = properties[propertyName];
			                    }
			                }
			                if (properties.hasOwnProperty('toString')) {
			                    this.toString = properties.toString;
			                }
			            },
			            clone: function () {
			                return this.init.prototype.extend(this);
			            }
			        };
			    }());
			    var WordArray = C_lib.WordArray = Base.extend({
			        init: function (words, sigBytes) {
			            words = this.words = words || [];
			            if (sigBytes != undefined$1) {
			                this.sigBytes = sigBytes;
			            } else {
			                this.sigBytes = words.length * 4;
			            }
			        },
			        toString: function (encoder) {
			            return (encoder || Hex).stringify(this);
			        },
			        concat: function (wordArray) {
			            var thisWords = this.words;
			            var thatWords = wordArray.words;
			            var thisSigBytes = this.sigBytes;
			            var thatSigBytes = wordArray.sigBytes;
			            this.clamp();
			            if (thisSigBytes % 4) {
			                for (var i = 0; i < thatSigBytes; i++) {
			                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
			                }
			            } else {
			                for (var j = 0; j < thatSigBytes; j += 4) {
			                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
			                }
			            }
			            this.sigBytes += thatSigBytes;
			            return this;
			        },
			        clamp: function () {
			            var words = this.words;
			            var sigBytes = this.sigBytes;
			            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
			            words.length = Math.ceil(sigBytes / 4);
			        },
			        clone: function () {
			            var clone = Base.clone.call(this);
			            clone.words = this.words.slice(0);
			            return clone;
			        },
			        random: function (nBytes) {
			            var words = [];
			            for (var i = 0; i < nBytes; i += 4) {
			                words.push(cryptoSecureRandomInt());
			            }
			            return new WordArray.init(words, nBytes);
			        }
			    });
			    var C_enc = C.enc = {};
			    var Hex = C_enc.Hex = {
			        stringify: function (wordArray) {
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;
			            var hexChars = [];
			            for (var i = 0; i < sigBytes; i++) {
			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                hexChars.push((bite >>> 4).toString(16));
			                hexChars.push((bite & 0x0f).toString(16));
			            }
			            return hexChars.join('');
			        },
			        parse: function (hexStr) {
			            var hexStrLength = hexStr.length;
			            var words = [];
			            for (var i = 0; i < hexStrLength; i += 2) {
			                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
			            }
			            return new WordArray.init(words, hexStrLength / 2);
			        }
			    };
			    var Latin1 = C_enc.Latin1 = {
			        stringify: function (wordArray) {
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;
			            var latin1Chars = [];
			            for (var i = 0; i < sigBytes; i++) {
			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                latin1Chars.push(String.fromCharCode(bite));
			            }
			            return latin1Chars.join('');
			        },
			        parse: function (latin1Str) {
			            var latin1StrLength = latin1Str.length;
			            var words = [];
			            for (var i = 0; i < latin1StrLength; i++) {
			                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
			            }
			            return new WordArray.init(words, latin1StrLength);
			        }
			    };
			    var Utf8 = C_enc.Utf8 = {
			        stringify: function (wordArray) {
			            try {
			                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
			            } catch (e) {
			                throw new Error('Malformed UTF-8 data');
			            }
			        },
			        parse: function (utf8Str) {
			            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
			        }
			    };
			    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
			        reset: function () {
			            this._data = new WordArray.init();
			            this._nDataBytes = 0;
			        },
			        _append: function (data) {
			            if (typeof data == 'string') {
			                data = Utf8.parse(data);
			            }
			            this._data.concat(data);
			            this._nDataBytes += data.sigBytes;
			        },
			        _process: function (doFlush) {
			            var processedWords;
			            var data = this._data;
			            var dataWords = data.words;
			            var dataSigBytes = data.sigBytes;
			            var blockSize = this.blockSize;
			            var blockSizeBytes = blockSize * 4;
			            var nBlocksReady = dataSigBytes / blockSizeBytes;
			            if (doFlush) {
			                nBlocksReady = Math.ceil(nBlocksReady);
			            } else {
			                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
			            }
			            var nWordsReady = nBlocksReady * blockSize;
			            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
			            if (nWordsReady) {
			                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
			                    this._doProcessBlock(dataWords, offset);
			                }
			                processedWords = dataWords.splice(0, nWordsReady);
			                data.sigBytes -= nBytesReady;
			            }
			            return new WordArray.init(processedWords, nBytesReady);
			        },
			        clone: function () {
			            var clone = Base.clone.call(this);
			            clone._data = this._data.clone();
			            return clone;
			        },
			        _minBufferSize: 0
			    });
			    C_lib.Hasher = BufferedBlockAlgorithm.extend({
			        cfg: Base.extend(),
			        init: function (cfg) {
			            this.cfg = this.cfg.extend(cfg);
			            this.reset();
			        },
			        reset: function () {
			            BufferedBlockAlgorithm.reset.call(this);
			            this._doReset();
			        },
			        update: function (messageUpdate) {
			            this._append(messageUpdate);
			            this._process();
			            return this;
			        },
			        finalize: function (messageUpdate) {
			            if (messageUpdate) {
			                this._append(messageUpdate);
			            }
			            var hash = this._doFinalize();
			            return hash;
			        },
			        blockSize: 512/32,
			        _createHelper: function (hasher) {
			            return function (message, cfg) {
			                return new hasher.init(cfg).finalize(message);
			            };
			        },
			        _createHmacHelper: function (hasher) {
			            return function (message, key) {
			                return new C_algo.HMAC.init(hasher, key).finalize(message);
			            };
			        }
			    });
			    var C_algo = C.algo = {};
			    return C;
			}(Math));
			return CryptoJS;
		}));
	} (core));
	return core.exports;
}

(function (module, exports) {
(function (root, factory) {
		{
			module.exports = factory(requireCore());
		}
	}(commonjsGlobal$1, function (CryptoJS) {
		(function (Math) {
		    var C = CryptoJS;
		    var C_lib = C.lib;
		    var WordArray = C_lib.WordArray;
		    var Hasher = C_lib.Hasher;
		    var C_algo = C.algo;
		    var T = [];
		    (function () {
		        for (var i = 0; i < 64; i++) {
		            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
		        }
		    }());
		    var MD5 = C_algo.MD5 = Hasher.extend({
		        _doReset: function () {
		            this._hash = new WordArray.init([
		                0x67452301, 0xefcdab89,
		                0x98badcfe, 0x10325476
		            ]);
		        },
		        _doProcessBlock: function (M, offset) {
		            for (var i = 0; i < 16; i++) {
		                var offset_i = offset + i;
		                var M_offset_i = M[offset_i];
		                M[offset_i] = (
		                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
		                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
		                );
		            }
		            var H = this._hash.words;
		            var M_offset_0  = M[offset + 0];
		            var M_offset_1  = M[offset + 1];
		            var M_offset_2  = M[offset + 2];
		            var M_offset_3  = M[offset + 3];
		            var M_offset_4  = M[offset + 4];
		            var M_offset_5  = M[offset + 5];
		            var M_offset_6  = M[offset + 6];
		            var M_offset_7  = M[offset + 7];
		            var M_offset_8  = M[offset + 8];
		            var M_offset_9  = M[offset + 9];
		            var M_offset_10 = M[offset + 10];
		            var M_offset_11 = M[offset + 11];
		            var M_offset_12 = M[offset + 12];
		            var M_offset_13 = M[offset + 13];
		            var M_offset_14 = M[offset + 14];
		            var M_offset_15 = M[offset + 15];
		            var a = H[0];
		            var b = H[1];
		            var c = H[2];
		            var d = H[3];
		            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
		            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
		            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
		            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
		            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
		            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
		            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
		            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
		            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
		            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
		            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
		            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
		            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
		            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
		            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
		            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
		            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
		            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
		            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
		            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
		            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
		            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
		            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
		            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
		            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
		            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
		            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
		            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
		            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
		            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
		            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
		            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
		            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
		            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
		            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
		            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
		            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
		            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
		            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
		            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
		            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
		            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
		            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
		            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
		            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
		            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
		            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
		            b = HH(b, c, d, a, M_offset_2,  23, T[47]);
		            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
		            d = II(d, a, b, c, M_offset_7,  10, T[49]);
		            c = II(c, d, a, b, M_offset_14, 15, T[50]);
		            b = II(b, c, d, a, M_offset_5,  21, T[51]);
		            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
		            d = II(d, a, b, c, M_offset_3,  10, T[53]);
		            c = II(c, d, a, b, M_offset_10, 15, T[54]);
		            b = II(b, c, d, a, M_offset_1,  21, T[55]);
		            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
		            d = II(d, a, b, c, M_offset_15, 10, T[57]);
		            c = II(c, d, a, b, M_offset_6,  15, T[58]);
		            b = II(b, c, d, a, M_offset_13, 21, T[59]);
		            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
		            d = II(d, a, b, c, M_offset_11, 10, T[61]);
		            c = II(c, d, a, b, M_offset_2,  15, T[62]);
		            b = II(b, c, d, a, M_offset_9,  21, T[63]);
		            H[0] = (H[0] + a) | 0;
		            H[1] = (H[1] + b) | 0;
		            H[2] = (H[2] + c) | 0;
		            H[3] = (H[3] + d) | 0;
		        },
		        _doFinalize: function () {
		            var data = this._data;
		            var dataWords = data.words;
		            var nBitsTotal = this._nDataBytes * 8;
		            var nBitsLeft = data.sigBytes * 8;
		            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
		            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
		            var nBitsTotalL = nBitsTotal;
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
		                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
		                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
		            );
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
		                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
		                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
		            );
		            data.sigBytes = (dataWords.length + 1) * 4;
		            this._process();
		            var hash = this._hash;
		            var H = hash.words;
		            for (var i = 0; i < 4; i++) {
		                var H_i = H[i];
		                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
		                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
		            }
		            return hash;
		        },
		        clone: function () {
		            var clone = Hasher.clone.call(this);
		            clone._hash = this._hash.clone();
		            return clone;
		        }
		    });
		    function FF(a, b, c, d, x, s, t) {
		        var n = a + ((b & c) | (~b & d)) + x + t;
		        return ((n << s) | (n >>> (32 - s))) + b;
		    }
		    function GG(a, b, c, d, x, s, t) {
		        var n = a + ((b & d) | (c & ~d)) + x + t;
		        return ((n << s) | (n >>> (32 - s))) + b;
		    }
		    function HH(a, b, c, d, x, s, t) {
		        var n = a + (b ^ c ^ d) + x + t;
		        return ((n << s) | (n >>> (32 - s))) + b;
		    }
		    function II(a, b, c, d, x, s, t) {
		        var n = a + (c ^ (b | ~d)) + x + t;
		        return ((n << s) | (n >>> (32 - s))) + b;
		    }
		    C.MD5 = Hasher._createHelper(MD5);
		    C.HmacMD5 = Hasher._createHmacHelper(MD5);
		}(Math));
		return CryptoJS.MD5;
	}));
} (md5));
var md5Exports = md5.exports;
var MD5 = getDefaultExportFromCjs$1(md5Exports);

var encBase64 = {exports: {}};

(function (module, exports) {
(function (root, factory) {
		{
			module.exports = factory(requireCore());
		}
	}(commonjsGlobal$1, function (CryptoJS) {
		(function () {
		    var C = CryptoJS;
		    var C_lib = C.lib;
		    var WordArray = C_lib.WordArray;
		    var C_enc = C.enc;
		    C_enc.Base64 = {
		        stringify: function (wordArray) {
		            var words = wordArray.words;
		            var sigBytes = wordArray.sigBytes;
		            var map = this._map;
		            wordArray.clamp();
		            var base64Chars = [];
		            for (var i = 0; i < sigBytes; i += 3) {
		                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
		                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
		                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;
		                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;
		                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
		                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
		                }
		            }
		            var paddingChar = map.charAt(64);
		            if (paddingChar) {
		                while (base64Chars.length % 4) {
		                    base64Chars.push(paddingChar);
		                }
		            }
		            return base64Chars.join('');
		        },
		        parse: function (base64Str) {
		            var base64StrLength = base64Str.length;
		            var map = this._map;
		            var reverseMap = this._reverseMap;
		            if (!reverseMap) {
		                    reverseMap = this._reverseMap = [];
		                    for (var j = 0; j < map.length; j++) {
		                        reverseMap[map.charCodeAt(j)] = j;
		                    }
		            }
		            var paddingChar = map.charAt(64);
		            if (paddingChar) {
		                var paddingIndex = base64Str.indexOf(paddingChar);
		                if (paddingIndex !== -1) {
		                    base64StrLength = paddingIndex;
		                }
		            }
		            return parseLoop(base64Str, base64StrLength, reverseMap);
		        },
		        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
		    };
		    function parseLoop(base64Str, base64StrLength, reverseMap) {
		      var words = [];
		      var nBytes = 0;
		      for (var i = 0; i < base64StrLength; i++) {
		          if (i % 4) {
		              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
		              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
		              var bitsCombined = bits1 | bits2;
		              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
		              nBytes++;
		          }
		      }
		      return WordArray.create(words, nBytes);
		    }
		}());
		return CryptoJS.enc.Base64;
	}));
} (encBase64));
var encBase64Exports = encBase64.exports;
var Base64 = getDefaultExportFromCjs$1(encBase64Exports);

const CHECKSUM_PATTERN = /^\s*!\s*checksum[\s-:]+([\w+/=]+).*[\r\n]+/i;
/**
 * The maximum number of characters to search for the checksum pattern.
 */
const CHECKSUM_SEARCH_LIMIT = 200;
/**
 * Removes the checksum line from the given content string.
 * @param content The content to remove the checksum from.
 * @returns The content with the checksum line removed.
 */
const removeChecksumLine = (content) => {
    const partOfResponse = content.substring(0, CHECKSUM_SEARCH_LIMIT);
    const match = partOfResponse.match(CHECKSUM_PATTERN);
    if (match) {
        content = content.replace(match[0], '');
    }
    return content;
};
/**
 * Normalizes a message string by removing carriage return characters ('\r') and
 * replacing multiple newline characters ('\n') with a single newline character.
 * This function standardizes the format of newline characters in the message.
 *
 * @param content The string to normalize.
 *
 * @returns The normalized message with '\r' removed and consecutive '\n'
 * characters replaced with a single '\n'.
 */
const normalizeContent = (content) => {
    content = removeChecksumLine(content);
    content = content.replace(/\r/g, '');
    content = content.replace(/\n+/g, '\n');
    return content;
};
/**
 * Calculates the checksum of the given content using the MD5 hashing algorithm
 * and encodes it in Base64. It normalizes the content by removing carriage
 * returns and replacing multiple newlines with a single newline.
 * The checksum is then formatted with a trailing special comment identifier.
 * Trailing '=' characters in the Base64 encoded string are removed to match
 * the expected format.
 *
 * @see
 * {@link https://adblockplus.org/en/filters#special-comments Adblock Plus special comments}
 * {@link https://hg.adblockplus.org/adblockplus/file/tip/addChecksum.py Adblock Plus checksum script}
 *
 * @param content The content to hash.
 *
 * @returns The formatted checksum string.
 */
const calculateChecksumMD5 = (content) => {
    content = normalizeContent(content);
    const checksum = Base64.stringify(MD5(content));
    return checksum.trim().replace(/=+$/g, '');
};
/**
 * Parses the checksum from the given content string.
 *
 * @param str The content string to parse.
 * @returns The checksum value or null if not found.
 */
const parseChecksum = (str) => {
    const partOfResponse = str.substring(0, CHECKSUM_SEARCH_LIMIT);
    const checksumMatch = partOfResponse.match(CHECKSUM_PATTERN);
    if (!checksumMatch) {
        return null;
    }
    return checksumMatch[1] ?? null;
};
/**
 * Checks if the given filter has a valid checksum. If the filter does not have
 * a checksum, it returns false unless the strict parameter is true.
 *
 * @param filter The filter to check.
 * @param strict If true, the function returns true if the filter does not have a
 * checksum.
 * @returns True if the filter has a valid checksum, false otherwise.
 */
const isValidChecksum = (filter, strict = false) => {
    const expectedChecksum = parseChecksum(filter);
    if (!expectedChecksum) {
        return !strict;
    }
    const actualChecksum = calculateChecksumMD5(filter);
    return actualChecksum === expectedChecksum;
};

/**
 * This file is part of AdGuard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * AdGuard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AdGuard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with AdGuard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */
const FiltersDownloaderCreator = (FileDownloadWrapper) => {
    const CONDITION_IF_DIRECTIVE_START = '!#if';
    const CONDITION_ELSE_DIRECTIVE_START = '!#else';
    const CONDITION_DIRECTIVE_END = '!#endif';
    const CONDITION_OPERATOR_NOT = '!';
    const CONDITION_OPERATOR_AND = '&&';
    const CONDITION_OPERATOR_OR = '||';
    const CONDITION_BRACKET_OPEN_CHAR = '(';
    const CONDITION_BRACKET_CLOSE_CHAR = ')';
    const INCLUDE_DIRECTIVE = '!#include';
    const REGEXP_ABSOLUTE_URL = /^([a-z]+:\/\/|\/\/)/i;
    const REGEXP_EXTERNAL_ABSOLUTE_URL = /^((?!file)[a-z]+:\/\/|\/\/)/i;
    /**
     * Checks if the opening and closing brackets in a string are balanced.
     *
     * @param str The input string to check for bracket balance.
     * @returns Returns `true` if the brackets are balanced, `false` otherwise.
     */
    const checkBracketsBalance = (str) => {
        let depth = 0;
        for (let i = 0; i < str.length; i += 1) {
            if (str[i] === CONDITION_BRACKET_OPEN_CHAR) {
                // if the char is an opening parenthesis, then we increase the depth
                depth += 1;
            }
            else if (str[i] === CONDITION_BRACKET_CLOSE_CHAR) {
                // if the char is a closing parenthesis, then we decrease the depth
                depth -= 1;
            }
            //  if the depth is negative we have a closing parenthesis
            //  before any matching opening parenthesis
            if (depth < 0) {
                return false;
            }
        }
        // If the depth is not null then a closing parenthesis is missing
        if (depth > 0) {
            return false;
        }
        return true;
    };
    /**
     * Parses url and returns its origin.
     *
     * @param url URL to parse.
     *
     * @returns URL origin if url can be parsed.
     * @throws If url cannot be parsed.
     */
    const getUrlOrigin = (url) => {
        try {
            const { origin } = new URL(url);
            return origin;
        }
        catch (e) {
            throw new Error(`Invalid url: '${url}'`);
        }
    };
    /**
     * Get the `filterOrigin` from url for relative path resolve.
     *
     * @param url Filter file URL.
     * @param filterUrlOrigin Existing origin url.
     * @returns Valid origin url.
     */
    const getFilterUrlOrigin = (url, filterUrlOrigin) => {
        if (filterUrlOrigin) {
            return filterUrlOrigin;
        }
        return url.substring(0, url.lastIndexOf('/'));
    };
    /**
     * Finds end of condition block started with startIndex.
     *
     * @param rules Array of all rules.
     * @param endDirective End directive for the condition block — `!#else` or `!#endif`.
     * @param startIndex Index of the start for presumed condition block.
     * @param endIndex Index of the end for presumed condition block,
     * needed for `!#else` directive if index of `!#endif` was found before to limit the search.
     *
     * @returns Index of the end of the condition block for the `endDirective`.
     */
    const findConditionBlockEnd = (rules, endDirective, startIndex, endIndex) => {
        const stack = [];
        for (let i = startIndex; i < endIndex; i += 1) {
            const rule = rules[i];
            if (rule.startsWith(CONDITION_IF_DIRECTIVE_START)) {
                stack.push(CONDITION_IF_DIRECTIVE_START);
            }
            else if (rule.startsWith(endDirective)) {
                if (stack.length > 0) {
                    stack.pop();
                }
                else {
                    return i;
                }
            }
        }
        return -1;
    };
    /**
     * Resolves a conditional expression to a boolean value based
     * on defined properties.
     *
     * @param expression The conditional expression to resolve.
     * @param definedExpressions An object containing defined properties for evaluation.
     *
     * @throws Throws an error if the expression is empty.
     *
     * @returns Returns `true` if the expression evaluates to `true` or a defined
     * property exists; otherwise, returns `false`.
     */
    const resolveConditionConstant = (expression, definedExpressions) => {
        if (!expression) {
            throw new Error('Invalid directives: Empty condition');
        }
        const trimmedExpression = expression.trim();
        if (trimmedExpression === 'true') {
            return true;
        }
        const expressionAsKey = trimmedExpression;
        if (definedExpressions?.[expressionAsKey] === true) {
            return true;
        }
        return false;
    };
    /**
     * Resolves a conditional expression and returns whether the expression
     * evaluates to `true` or `false` based on defined properties.
     *
     * @param rawExpression The raw conditional expression to resolve.
     * @param definedProperties An object containing defined expressions for
     * condition resolution.
     *
     * @returns Boolean `true` if the expression evaluates to `true`,
     * `false` otherwise.
     *
     * @throws Error If the expression is empty or contains incorrect brackets.
     */
    const resolveExpression = (rawExpression, definedProperties) => {
        if (!rawExpression) {
            throw new Error('Invalid directives: Empty condition');
        }
        const expression = rawExpression.trim();
        if (!checkBracketsBalance(expression)) {
            throw new Error(`Invalid directives: Incorrect brackets: ${expression}`);
        }
        // Replace bracketed expressions
        const openBracketIndex = expression.lastIndexOf(CONDITION_BRACKET_OPEN_CHAR);
        if (openBracketIndex !== -1) {
            const endBracketIndex = expression.indexOf(CONDITION_BRACKET_CLOSE_CHAR, openBracketIndex);
            const innerExpression = expression.substring(openBracketIndex + 1, endBracketIndex);
            const innerResult = resolveExpression(innerExpression, definedProperties);
            const resolvedInner = expression.substring(0, openBracketIndex)
                + innerResult + expression.substring(endBracketIndex + 1);
            return resolveExpression(resolvedInner, definedProperties);
        }
        let result;
        // Resolve logical operators
        const indexOfAndOperator = expression.indexOf(CONDITION_OPERATOR_AND);
        const indexOfOrOperator = expression.indexOf(CONDITION_OPERATOR_OR);
        const indexOfNotOperator = expression.indexOf(CONDITION_OPERATOR_NOT);
        if (indexOfOrOperator !== -1) {
            result = resolveExpression(expression.substring(0, indexOfOrOperator - 1), definedProperties) || resolveExpression(expression.substring(indexOfOrOperator + CONDITION_OPERATOR_OR.length, expression.length), definedProperties);
        }
        else if (indexOfAndOperator !== -1) {
            result = resolveExpression(expression.substring(0, indexOfAndOperator - 1), definedProperties) && resolveExpression(expression.substring(indexOfAndOperator + CONDITION_OPERATOR_AND.length, expression.length), definedProperties);
        }
        else if (indexOfNotOperator === 0) {
            result = !resolveExpression(expression.substring(CONDITION_OPERATOR_NOT.length), definedProperties);
        }
        else {
            result = resolveConditionConstant(expression, definedProperties);
        }
        return result;
    };
    /**
     * Resolves a conditional directive and returns whether the condition is true based on defined properties.
     *
     * @param directive The conditional directive to resolve.
     * @param definedProperties An object containing defined expressions for condition resolution.
     * @returns `true` if the condition is true, `false` otherwise.
     */
    const resolveCondition = (directive, definedProperties) => {
        const expression = directive.substring(CONDITION_IF_DIRECTIVE_START.length).trim();
        return resolveExpression(expression, definedProperties);
    };
    /**
     * Resolves conditional directives in a list of filtering rules based on
     * defined properties.
     *
     * @param rules The list of filtering rules to resolve.
     * @param definedExpressions An object containing defined expressions for
     * condition resolution.
     *
     * @returns The resolved filtering rules after processing conditional directives.
     *
     * @throws Throws an error if invalid conditional directives are encountered.
     */
    const resolveConditions = (rules, definedExpressions) => {
        if (!definedExpressions) {
            return rules;
        }
        let result = [];
        for (let i = 0; i < rules.length; i += 1) {
            const rule = rules[i];
            if (rule.indexOf(CONDITION_IF_DIRECTIVE_START) === 0) {
                const endLineIndex = findConditionBlockEnd(rules, CONDITION_DIRECTIVE_END, i + 1, rules.length);
                if (endLineIndex === -1) {
                    throw new Error(`Invalid directives: Condition end not found: ${rule}`);
                }
                const elseLineIndex = findConditionBlockEnd(rules, CONDITION_ELSE_DIRECTIVE_START, i + 1, endLineIndex);
                const isConditionMatched = resolveCondition(rule, definedExpressions);
                // if there is no 'else' branch for the condition
                if (elseLineIndex === -1) {
                    if (isConditionMatched) {
                        const rulesUnderCondition = rules.slice(i + 1, endLineIndex);
                        // Resolve inner conditions in recursion
                        result = result.concat(resolveConditions(rulesUnderCondition, definedExpressions));
                    }
                }
                else {
                    // check if there is something after !#else
                    if (rules[elseLineIndex].trim().length !== CONDITION_ELSE_DIRECTIVE_START.length) {
                        throw new Error(`Invalid directives: Found invalid !#else: ${rule}`);
                    }
                    if (isConditionMatched) {
                        const rulesForConditionTrue = rules.slice(i + 1, elseLineIndex);
                        // Resolve inner conditions in recursion
                        result = result.concat(resolveConditions(rulesForConditionTrue, definedExpressions));
                    }
                    else {
                        const rulesForConditionFalse = rules.slice(elseLineIndex + 1, endLineIndex);
                        // Resolve inner conditions in recursion
                        result = result.concat(resolveConditions(rulesForConditionFalse, definedExpressions));
                    }
                }
                // Skip to the end of block
                i = endLineIndex;
            }
            else if (rule.indexOf(CONDITION_ELSE_DIRECTIVE_START) === 0) {
                // Found !#else without !#if
                throw new Error(`Invalid directives: Found unexpected condition else branch: ${rule}`);
            }
            else if (rule.indexOf(CONDITION_DIRECTIVE_END) === 0) {
                // Found !#endif without !#if
                throw new Error(`Invalid directives: Found unexpected condition end: ${rule}`);
            }
            else {
                result.push(rule);
            }
        }
        return result;
    };
    /**
     * Validates a URL to ensure it matches the expected origin.
     *
     * @param url The URL to validate.
     * @param filterUrlOrigin The expected origin URL. If provided, the function
     * checks if the URL matches this origin.
     * @throws Throws an error if the URL is absolute and its origin doesn't
     * match the expected origin.
     */
    const validateUrl = (url, filterUrlOrigin) => {
        if (filterUrlOrigin) {
            if (REGEXP_ABSOLUTE_URL.test(url)) {
                // Include url is absolute
                const urlOrigin = getUrlOrigin(url);
                const filterOrigin = getUrlOrigin(filterUrlOrigin);
                if (urlOrigin !== filterOrigin) {
                    throw new Error(`Include url is rejected with origin: ${urlOrigin}`);
                }
            }
        }
    };
    /**
     * Validates and resolves include directive.
     *
     * @param line Line with directive.
     * @param filterOrigin Filter file URL origin or undefined.
     * @param definedExpressions An object with the defined properties.
     * These properties might be used in pre-processor directives (`#if`, etc.).
     * @returns A promise that returns string with rules if resolved and Error if rejected.
     */
    const resolveInclude = async (line, filterOrigin, definedExpressions) => {
        if (line.indexOf(INCLUDE_DIRECTIVE) !== 0) {
            return Promise.resolve(line);
        }
        const url = line.substring(INCLUDE_DIRECTIVE.length).trim();
        validateUrl(url, filterOrigin);
        let filter;
        try {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            const downloadResult = await downloadFilterRules(url, {
                filterOrigin,
                definedExpressions,
                resolveDirectives: true,
            });
            filter = downloadResult.filter;
        }
        catch (error) {
            throw new Error(`Failed to resolve the include directive: '${line}'`, { cause: error });
        }
        const MAX_LINES_TO_SCAN = 50;
        // Math.min inside for loop, because filter.length changes
        for (let i = 0; i < Math.min(MAX_LINES_TO_SCAN, filter.length); i += 1) {
            if (filter[i].trim().startsWith('! Diff-Path:')) {
                filter.splice(i, 1);
            }
        }
        return filter;
    };
    /**
     * Resolves include directives.
     *
     * @param rules Array of rules.
     * @param filterOrigin Filter file URL origin or null.
     * @param definedExpressions An object with the defined expressions for conditions resolution.
     * These properties might be used in pre-processor directives (`#if`, etc.).
     * @returns A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const resolveIncludes = async (rules, filterOrigin, definedExpressions) => {
        const promises = rules.map((rule) => resolveInclude(rule, filterOrigin, definedExpressions));
        let result = [];
        // We do not use here Promise.all because it freezes the Chromium browsers and electron built on it, if there
        // are more than 1_100_00 promises. Also, we consider that wa can afford promises to be resolved sequentially.
        for (let i = 0; i < promises.length; i += 1) {
            // eslint-disable-next-line no-await-in-loop
            const resolved = await promises[i];
            if (Array.isArray(resolved)) {
                result = result.concat(resolved);
            }
            else {
                result.push(resolved);
            }
        }
        return result;
    };
    /**
     * Splits filter by lines.
     * @param filter Filter to split.
     * @returns Array of strings.
     */
    const splitFilter = (filter) => {
        return filter.trim().split(/[\r\n]+/);
    };
    /**
     * Downloads filter rules from an external URL or a local path and resolves
     * pre-processor directives.
     *
     * @param url Filter file absolute URL or relative path.
     * @param downloadOptions Options to be applied while downloading the filter.
     *
     * @returns A promise that returns an array of strings with rules when
     * resolved or an Error if rejected.
     * @throws Error if validateChecksum flag is true and checksum is invalid.
     */
    const externalDownload = async (url, downloadOptions) => {
        const filterUrlOrigin = downloadOptions?.filterOrigin;
        const filterUrl = !REGEXP_ABSOLUTE_URL.test(url) && REGEXP_ABSOLUTE_URL.test(filterUrlOrigin || '')
            // getting absolute url for external file with relative url
            ? `${filterUrlOrigin}/${url}`
            : url;
        const rawFilter = await FileDownloadWrapper.getExternalFile(filterUrl);
        if (downloadOptions && downloadOptions.validateChecksum) {
            if (!isValidChecksum(rawFilter, downloadOptions.validateChecksumStrict)) {
                throw new Error('Invalid checksum');
            }
        }
        const filter = splitFilter(rawFilter);
        if (!downloadOptions?.resolveDirectives) {
            return {
                filter,
                rawFilter,
            };
        }
        const urlOrigin = getFilterUrlOrigin(filterUrl);
        const conditionsResult = resolveConditions(filter, downloadOptions.definedExpressions);
        const includesResult = await resolveIncludes(conditionsResult, urlOrigin, downloadOptions.definedExpressions);
        return {
            filter: includesResult,
            rawFilter,
        };
    };
    /**
     * Compiles filter content.
     *
     * @param rules Array of strings.
     * @param filterOrigin Filter file URL origin or null.
     * @param definedProperties An object with the defined properties.
     * These properties might be used in pre-processor directives (`#if`, etc.).
     * @returns A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const compile = (rules, filterOrigin, definedProperties) => {
        // Resolve 'if' conditions
        const resolvedConditionsResult = resolveConditions(rules, definedProperties);
        // Resolve 'includes' directives
        return resolveIncludes(resolvedConditionsResult, filterOrigin, definedProperties);
    };
    /**
     * Gets filter rules from a local path and resolves pre-processor directives.
     *
     * @param url Path to the local file.
     * @param downloadOptions Options to be applied while downloading the filter.
     * @returns A promise that returns an array of strings with rules when resolved or an Error if rejected.
     * @throws Error if validateChecksum flag is true and checksum is invalid.
     */
    const getLocalFile = async (url, downloadOptions) => {
        const { filterOrigin } = downloadOptions;
        const urlToLoad = filterOrigin
            ? `${filterOrigin}/${url}`
            : url;
        const origin = getFilterUrlOrigin(urlToLoad, filterOrigin);
        const rawFilter = await FileDownloadWrapper.getLocalFile(urlToLoad, origin);
        if (downloadOptions && downloadOptions.validateChecksum) {
            if (!isValidChecksum(rawFilter, downloadOptions.validateChecksumStrict)) {
                throw new Error('Invalid checksum');
            }
        }
        const filterContent = splitFilter(rawFilter);
        if (!downloadOptions?.resolveDirectives) {
            return {
                filter: filterContent,
                rawFilter,
            };
        }
        const urlOrigin = getFilterUrlOrigin(urlToLoad);
        // Resolve 'if' conditions and 'includes' directives
        const conditionsResult = resolveConditions(filterContent, downloadOptions.definedExpressions);
        const includesResult = await resolveIncludes(conditionsResult, urlOrigin, downloadOptions.definedExpressions);
        return {
            filter: includesResult,
            rawFilter,
        };
    };
    /**
     * Downloads filter rules from a URL and resolves pre-processor directives.
     *
     * @param url Filter file URL.
     * @param downloadOptions
     * These properties might be used in pre-processor directives (`#if`, etc.).
     *
     * @returns A promise that returns an array of strings with rules when
     * resolved or an Error if rejected.
     */
    const downloadFilterRules = (url, downloadOptions) => {
        if (REGEXP_EXTERNAL_ABSOLUTE_URL.test(url)
            || REGEXP_EXTERNAL_ABSOLUTE_URL.test(downloadOptions.filterOrigin || '')) {
            return externalDownload(url, downloadOptions);
        }
        return getLocalFile(url, downloadOptions);
    };
    /**
     * Downloads a specified filter and resolves all the pre-processor directives from there.
     *
     * @param url The URL of the filter to download.
     * @param definedExpressions An object with the defined properties.
     * These properties might be used in pre-processor directives (`#if`, etc.).
     * @param options Options to be applied while downloading the filter.
     *
     * @returns A promise that resolves with a list of rules and rejects with an error if unable to download.
     * @throws Error if validateChecksum flag is true and checksum is invalid.
     */
    const download = async (url, definedExpressions, options) => {
        let filterUrlOrigin;
        if (url && REGEXP_EXTERNAL_ABSOLUTE_URL.test(url)) {
            filterUrlOrigin = getFilterUrlOrigin(url);
        }
        const result = await downloadFilterRules(url, {
            filterOrigin: filterUrlOrigin,
            definedExpressions,
            resolveDirectives: true,
            validateChecksum: options?.validateChecksum,
            validateChecksumStrict: options?.validateChecksumStrict,
        });
        // only included filters can be empty
        if (result.filter && result.filter.join().trim() === '') {
            throw new Error('Response is empty');
        }
        return result.filter;
    };
    /**
     * Resolves conditions and includes based on the provided raw filter, options, and filter URL origin.
     *
     * @param rawFilter The raw filter to be resolved.
     * @param options The options used in the resolution process.
     * @param filterUrlOrigin The origin of the filter URL.
     *
     * @returns A Promise that resolves to the result of resolving the includes.
     */
    async function resolveConditionsAndIncludes(rawFilter, options, filterUrlOrigin) {
        const filter = splitFilter(rawFilter);
        const resolvedConditionsResult = resolveConditions(filter, options.definedExpressions);
        return resolveIncludes(resolvedConditionsResult, filterUrlOrigin, options.definedExpressions);
    }
    /**
     * Downloads filter rules from a URL and resolves pre-processor directives.
     *
     * @param url Filter file URL.
     * @param options Options to be applied while downloading the filter.
     *
     * @returns A promise that returns an array of strings with rules.
     */
    async function downloadAndProcess(url, options) {
        let filterUrlOrigin;
        if (url && REGEXP_EXTERNAL_ABSOLUTE_URL.test(url)) {
            filterUrlOrigin = getFilterUrlOrigin(url);
        }
        const result = await downloadFilterRules(url, {
            filterOrigin: filterUrlOrigin,
            definedExpressions: options.definedExpressions,
            // `false` for not resolving directives
            resolveDirectives: false,
            validateChecksum: options.validateChecksum,
            validateChecksumStrict: options.validateChecksumStrict,
        });
        // only included filters can be empty
        if (result.filter && result.filter.join().trim() === '') {
            throw new Error('Response is empty');
        }
        const includesResult = await resolveConditionsAndIncludes(result.rawFilter, options, filterUrlOrigin);
        return {
            filter: includesResult,
            rawFilter: result.rawFilter,
        };
    }
    /**
     * Downloads filter rules from a URL without resolving pre-processor directives.
     *
     * @param url Filter file URL.
     * @param options Options to be applied while downloading the filter.
     *
     * @returns A promise that returns an array of strings with rules when
     * resolved or an Error if rejected.
     *
     * @throws An error if
     * - validateChecksum flag is true and checksum is invalid;
     * - DiffUpdater.applyPatch() fails and the thrown error is not {@link UnacceptableResponseError}.
     */
    const downloadWithRaw = async (url, options) => {
        options.verbose ??= false;
        options.force ??= false;
        let filterUrlOrigin;
        if (url && REGEXP_EXTERNAL_ABSOLUTE_URL.test(url)) {
            filterUrlOrigin = getFilterUrlOrigin(url);
        }
        // if options.force, then download the whole filter
        // if !options.rawFilter, then return result as is, since it is not possible to apply
        // patches without the raw filter
        if (options.force || !options.rawFilter) {
            return downloadAndProcess(url, options);
        }
        let rawFilter = '';
        try {
            rawFilter = await DiffUpdater_1.applyPatch({
                filterUrl: url,
                filterContent: options.rawFilter,
                verbose: options.verbose,
            });
        }
        catch (e) {
            if (e instanceof UnacceptableResponseError_1) {
                return {
                    filter: splitFilter(options.rawFilter),
                    rawFilter: options.rawFilter,
                    isPatchUpdateFailed: true,
                };
            }
            // if the error is not UnacceptableResponseError, then rethrow it further
            throw e;
        }
        // applyPatch returns null if there is no Diff-Path in the filter metadata
        if (rawFilter === null) {
            const downloadResult = await downloadAndProcess(url, options);
            return downloadResult;
        }
        // if nothing changed, then return result as is
        if (rawFilter === options.rawFilter) {
            return {
                filter: splitFilter(options.rawFilter),
                rawFilter: options.rawFilter,
            };
        }
        const resolveResult = await resolveConditionsAndIncludes(rawFilter, options, filterUrlOrigin);
        return {
            filter: resolveResult,
            rawFilter,
        };
    };
    return {
        compile,
        download,
        downloadWithRaw,
        resolveConditions,
        resolveIncludes,
        getFilterUrlOrigin,
    };
};

const PREFERRED_CONTENT_TYPE = 'text/plain';
/**
 * Supported content types.
 */
const SUPPORTED_CONTENT_TYPES = [
    PREFERRED_CONTENT_TYPE,
    // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1723
    'text/html',
];
/**
 * Returns content type error.
 *
 * @returns Error with description of supported content types.
 */
const getContentTypeError = () => {
    return new Error(`Response content type should be one of: "${SUPPORTED_CONTENT_TYPES.join(', ')}"`);
};
/**
 * Checks if the content type is supported.
 *
 * @param contentTypeHeader Content type header.
 *
 * @returns True if supported.
 */
const isContentTypeSupported = (contentTypeHeader) => {
    if (!contentTypeHeader) {
        return false;
    }
    return SUPPORTED_CONTENT_TYPES.some((ct) => contentTypeHeader.includes(ct));
};

/**
 * This file is part of AdGuard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * AdGuard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AdGuard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with AdGuard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * Executes async request.
 *
 * @param url Url.
 *
 * @returns Promise with request.
 */
const executeRequestAsync = (url) => axios({
    method: 'get',
    url,
    headers: {
        Pragma: 'no-cache',
    },
    validateStatus: null,
});
/**
 * Downloads filter rules from external url.
 *
 * @param url Filter file absolute URL or relative path.
 * @returns A promise that returns string with rules when if resolved and Error if rejected.
 */
const getExternalFile = (url) => {
    return new Promise((resolve, reject) => {
        executeRequestAsync(url)
            .then((response) => {
            if (response.status !== 200 && response.status !== 0) {
                reject(new Error(`Response status for url ${url} is invalid: ${response.status}`));
            }
            const responseContentType = response.headers['content-type'];
            if (!isContentTypeSupported(responseContentType)) {
                reject(getContentTypeError());
            }
            const responseText = response.responseText ? response.responseText : response.data;
            resolve(responseText);
        }).catch((error) => {
            const updatedError = new Error(`Failed to request url '${url}'`, { cause: error });
            reject(updatedError);
        });
    });
};
/**
 * Get filter rules from the local path.
 *
 * @param url Local path.
 * @param filterUrlOrigin Origin path.
 * @returns A promise that returns string with rules when if resolved and Error if rejected.
 */
const getLocalFile = (url, filterUrlOrigin) => {
    const file = fs.readFileSync(path.resolve(filterUrlOrigin, url)).toString();
    return Promise.resolve(file);
};

const FiltersDownloader = FiltersDownloaderCreator({
    getLocalFile,
    getExternalFile,
});

exports.FiltersDownloader = FiltersDownloader;
