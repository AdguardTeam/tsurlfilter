import * as rule from './rule';
import { Request } from '../request';
import { IAdvancedModifier } from '../modifiers/advanced-modifier';
import { RequestType } from '../request-type';
/**
 * NetworkRuleOption is the enumeration of various rule options.
 * In order to save memory, we store some options as a flag.
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#modifiers
 */
export declare enum NetworkRuleOption {
    /** $third-party modifier */
    ThirdParty = 1,
    /** $match-case modifier */
    MatchCase = 2,
    /** $important modifier */
    Important = 4,
    /** $elemhide modifier */
    Elemhide = 8,
    /** $generichide modifier */
    Generichide = 16,
    /** $specifichide modifier */
    Specifichide = 32,
    /** $genericblock modifier */
    Genericblock = 64,
    /** $jsinject modifier */
    Jsinject = 128,
    /** $urlblock modifier */
    Urlblock = 256,
    /** $content modifier */
    Content = 512,
    /** $extension modifier */
    Extension = 1024,
    /** $stealth modifier */
    Stealth = 2048,
    Empty = 4096,
    Mp4 = 8192,
    /** $popup modifier */
    Popup = 16384,
    /** $csp modifier */
    Csp = 32768,
    /** $replace modifier */
    Replace = 65536,
    /** $cookie modifier */
    Cookie = 131072,
    /** $redirect modifier */
    Redirect = 262144,
    /** $badfilter modifier */
    Badfilter = 524288,
    /** $removeparam modifier */
    RemoveParam = 1048576,
    /** $removeheader modifier */
    RemoveHeader = 2097152,
    /** $jsonprune modifier */
    JsonPrune = 4194304,
    /** $hls modifier */
    Hls = 8388608,
    /** $network modifier */
    Network = 16777216,
    /** dns modifiers */
    Client = 33554432,
    DnsRewrite = 67108864,
    DnsType = 134217728,
    Ctag = 268435456,
    Document = 536870912,
    /** Blacklist-only modifiers */
    BlacklistOnly = 12288,
    /** Allowlist-only modifiers */
    AllowlistOnly = 4088,
    /** Options supported by host-level network rules * */
    OptionHostLevelRules = 503840772,
    /**
     * Removeparam compatible modifiers
     *
     * $removeparam rules are compatible only with content type modifiers ($script, $stylesheet, etc)
     * and this list of modifiers:
     */
    RemoveParamCompatibleOptions = 538443783,
    /**
     * Removeheader compatible modifiers
     *
     * $removeheader rules are compatible only with content type modifiers ($script, $stylesheet, etc)
     * and this list of modifiers:
     */
    RemoveHeaderCompatibleOptions = 539492359
}
/**
 * Helper class that is used for passing {@link NetworkRule.parseRuleText}
 * result to the caller. Should not be used outside of this file.
 */
declare class BasicRuleParts {
    /**
     * Basic rule pattern (which can be easily converted into a regex).
     * See {@link SimpleRegex} for more details.
     */
    pattern: string | undefined;
    /**
     * String with all rule options (modifiers).
     */
    options: string | undefined;
    /**
     * Indicates if rule is "allowlist" (e.g. it should unblock requests, not block them).
     */
    allowlist: boolean | undefined;
}
/**
 * Basic network filtering rule.
 * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules
 */
export declare class NetworkRule implements rule.IRule {
    private readonly ruleText;
    private readonly filterListId;
    private readonly allowlist;
    private readonly pattern;
    private permittedDomains;
    private restrictedDomains;
    /**
     * Domains in denyallow modifier providing exceptions for permitted domains
     * https://github.com/AdguardTeam/CoreLibs/issues/1304
     */
    private denyAllowDomains;
    /** Flag with all enabled rule options */
    private enabledOptions;
    /** Flag with all disabled rule options */
    private disabledOptions;
    /** Flag with all permitted request types. 0 means ALL. */
    private permittedRequestTypes;
    /** Flag with all restricted request types. 0 means NONE. */
    private restrictedRequestTypes;
    /**
     * Rule Advanced modifier
     */
    private advancedModifier;
    /**
     * Rule App modifier
     */
    private appModifier;
    /**
     * Priority weight
     * Used in rules priority comparision
     */
    private priorityWeight;
    /**
     * Separates the rule pattern from the list of modifiers.
     *
     * ```
     * rule = ["@@"] pattern [ "$" modifiers ]
     * modifiers = [modifier0, modifier1[, ...[, modifierN]]]
     * ```
     */
    static readonly OPTIONS_DELIMITER = "$";
    /**
     * This character is used to escape special characters in modifiers values
     */
    private static ESCAPE_CHARACTER;
    private static RE_ESCAPED_OPTIONS_DELIMITER;
    /**
     * A marker that is used in rules of exception.
     * To turn off filtering for a request, start your rule with this marker.
     */
    static readonly MASK_ALLOWLIST = "@@";
    /**
     * Mark that negates options
     */
    static readonly NOT_MARK = "~";
    /**
     * Rule options
     */
    static readonly OPTIONS: {
        THIRD_PARTY: string;
        FIRST_PARTY: string;
        MATCH_CASE: string;
        IMPORTANT: string;
        DOMAIN: string;
        DENYALLOW: string;
        ELEMHIDE: string;
        GENERICHIDE: string;
        SPECIFICHIDE: string;
        GENERICBLOCK: string;
        JSINJECT: string;
        URLBLOCK: string;
        CONTENT: string;
        DOCUMENT: string;
        DOC: string;
        STEALTH: string;
        POPUP: string;
        EMPTY: string;
        MP4: string;
        SCRIPT: string;
        STYLESHEET: string;
        SUBDOCUMENT: string;
        OBJECT: string;
        IMAGE: string;
        XMLHTTPREQUEST: string;
        MEDIA: string;
        FONT: string;
        WEBSOCKET: string;
        OTHER: string;
        PING: string;
        BADFILTER: string;
        CSP: string;
        REPLACE: string;
        COOKIE: string;
        REDIRECT: string;
        REDIRECTRULE: string;
        REMOVEPARAM: string;
        REMOVEHEADER: string;
        JSONPRUNE: string;
        HLS: string;
        APP: string;
        NETWORK: string;
        EXTENSION: string;
        NOOP: string;
        CLIENT: string;
        DNSREWRITE: string;
        DNSTYPE: string;
        CTAG: string;
    };
    getText(): string;
    getFilterListId(): number;
    /**
     * Returns rule pattern,
     * which currently is used only in the rule validator module
     */
    getPattern(): string;
    /**
     * Returns `true` if the rule is "allowlist", e.g. if it disables other
     * rules when the pattern matches the request.
     */
    isAllowlist(): boolean;
    /**
     * Checks if the rule is a document-level allowlist rule
     * This means that the rule is supposed to disable or modify blocking
     * of the page subrequests.
     * For instance, `@@||example.org^$urlblock` unblocks all sub-requests.
     */
    isDocumentLevelAllowlistRule(): boolean;
    /**
     * Checks if the rule is a document allowlist rule.
     * For instance,
     * "@@||example.org^$document"
     * completely disables filtering on all pages at example.com and all subdomains.
     */
    isDocumentAllowlistRule(): boolean;
    /**
     * The longest part of pattern without any special characters.
     * It is used to improve the matching performance.
     */
    getShortcut(): string;
    /**
     * Gets list of permitted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
     */
    getPermittedDomains(): string[] | null;
    /**
     * Gets list of restricted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
     */
    getRestrictedDomains(): string[] | null;
    /**
     * Gets list of permitted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
     */
    getPermittedApps(): string[] | null;
    /**
     * Gets list of restricted domains.
     * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
     */
    getRestrictedApps(): string[] | null;
    /** Flag with all permitted request types. 0 means ALL. */
    getPermittedRequestTypes(): RequestType;
    /** Flag with all restricted request types. 0 means NONE. */
    getRestrictedRequestTypes(): RequestType;
    /**
     * Advanced modifier
     */
    getAdvancedModifier(): IAdvancedModifier | null;
    /**
     * Advanced modifier value
     */
    getAdvancedModifierValue(): string | null;
    /**
     * isRegexRule returns true if rule's pattern is a regular expression.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#regexp-support
     */
    isRegexRule(): boolean;
    matchesPermittedDomains(hostname: string): boolean;
    /**
     * Checks if this filtering rule matches the specified request.
     * @param request - request to check.
     * @param useShortcut - the flag to use this rule shortcut
     *
     * In case we use Trie in lookup table, we don't need to use shortcut cause we already check if request's url
     * includes full rule shortcut.
     */
    match(request: Request, useShortcut?: boolean): boolean;
    /**
     * matchShortcut simply checks if shortcut is a substring of the URL.
     * @param request - request to check.
     */
    private matchShortcut;
    /**
     * matchDomain checks if the filtering rule is allowed on this domain.
     * @param domain - domain to check.
     */
    private matchDomain;
    /**
     * Check if request matches domain modifier by request referrer (general case) or by request target
     *
     * In some cases the $domain modifier can match not only the referrer domain, but also the target domain.
     * This happens when the following is true (1 AND ((2 AND 3) OR 4):
     *
     * 1) The request has document type
     * 2) The rule's pattern doesn't match any particular domain(s)
     * 3) The rule's pattern doesn't contain regular expressions
     * 4) The $domain modifier contains only excluded domains (e.g., $domain=~example.org|~example.com)
     *
     * When all these conditions are met, the domain modifier will match both the referrer domain and the target domain.
     * https://github.com/AdguardTeam/tsurlfilter/issues/45
     * @param request
     */
    matchDomainModifier(request: Request): boolean;
    /**
     * checks if the filtering rule is allowed on this domain.
     * @param domain
     */
    private matchDenyAllowDomains;
    /**
     * Return TRUE if this rule matches with the tags associated with a client
     *
     * @param clientTags
     */
    private matchClientTags;
    /**
     * returns TRUE if the rule matches with the specified client
     *
     * @param clientName
     * @param clientIP
     */
    private matchClient;
    /**
     * Return TRUE if this rule matches with the request dnstype
     *
     * @param dnstype
     */
    private matchDnsType;
    /**
     * Checks if rule has permitted domains
     */
    private hasPermittedDomains;
    /**
     * Checks if rule has restricted domains
     */
    private hasRestrictedDomains;
    /**
     * Checks if rule has permitted apps
     */
    private hasPermittedApps;
    /**
     * matchRequestType checks if the request's type matches the rule properties
     * @param requestType - request type to check.
     */
    matchRequestType(requestType: RequestType): boolean;
    /**
     * In case of $removeparam modifier,
     * we only allow it to target other content types if the rule has an explicit content-type modifier.
     */
    private matchRequestTypeExplicit;
    /**
     * Checks if pattern has spaces
     * Used in order to do not create network rules from host rules
     * @param pattern
     * @private
     */
    private static hasSpaces;
    /**
     * Creates an instance of the {@link NetworkRule}.
     * It parses this rule and extracts the rule pattern (see {@link SimpleRegex}),
     * and rule modifiers.
     *
     * @param ruleText - original rule text.
     * @param filterListId - ID of the filter list this rule belongs to.
     *
     * @throws error if it fails to parse the rule.
     */
    constructor(ruleText: string, filterListId: number);
    /**
     * Parses the options string and saves them.
     * More on the rule modifiers:
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers
     *
     * @param options - string with the rule modifiers
     *
     * @throws an error if there is an unsupported modifier
     */
    private loadOptions;
    /**
     * Returns true if the specified option is enabled.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option - rule option to check.
     */
    isOptionEnabled(option: NetworkRuleOption): boolean;
    /**
     * Returns true if one and only option is enabled
     *
     * @param option
     */
    isSingleOptionEnabled(option: NetworkRuleOption): boolean;
    /**
     * Returns true if the specified option is disabled.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option - rule option to check.
     */
    isOptionDisabled(option: NetworkRuleOption): boolean;
    /**
     * Checks if the rule has higher priority that the specified rule
     * allowlist + $important > $important > allowlist > basic rules
     */
    isHigherPriority(r: NetworkRule): boolean;
    /**
     * Returns true if the rule is considered "generic"
     * "generic" means that the rule is not restricted to a limited set of domains
     * Please note that it might be forbidden on some domains, though.
     *
     * @return {boolean}
     */
    isGeneric(): boolean;
    /**
     * Returns true if this rule negates the specified rule
     * Only makes sense when this rule has a `badfilter` modifier
     */
    negatesBadfilter(specifiedRule: NetworkRule): boolean;
    /**
     * Checks if this rule can be used for hosts-level blocking
     */
    isHostLevelNetworkRule(): boolean;
    /**
     * Enables or disables the specified option.
     *
     * @param option - option to enable or disable.
     * @param enabled - true to enable, false to disable.
     * @param skipRestrictions - skip options allowlist/blacklist restrictions
     *
     * @throws an error if the option we're trying to enable cannot be.
     * For instance, you cannot enable $elemhide for blacklist rules.
     */
    private setOptionEnabled;
    /**
     * Permits or forbids the specified request type.
     * "Permits" means that the rule will match **only** the types that are permitted.
     * "Restricts" means that the rule will match **all but restricted**.
     *
     * @param requestType - request type.
     * @param permitted - true if it's permitted (whic)
     */
    private setRequestType;
    /**
     * Sets and validates exceptionally allowed domains presented in $denyallow modifier
     *
     * @param optionValue
     */
    private setDenyAllowDomains;
    /**
     * Loads the specified modifier:
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers
     *
     * @param optionName - modifier name.
     * @param optionValue - modifier value.
     *
     * @throws an error if there is an unsupported modifier
     */
    private loadOption;
    /**
     * Validates rule options
     */
    private validateOptions;
    /**
     * $removeparam rules are not compatible with any other modifiers except $domain,
     * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
     * The rules with any other modifiers are considered invalid and will be discarded.
     */
    private validateRemoveParamRule;
    /**
     * $removeheader rules are not compatible with any other modifiers except $domain,
     * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
     * The rules with any other modifiers are considered invalid and will be discarded.
     */
    private validateRemoveHeaderRule;
    /**
     * parseRuleText splits the rule text into multiple parts.
     * @param ruleText - original rule text
     * @returns basic rule parts
     *
     * @throws error if the rule is empty (for instance, empty string or `@@`)
     */
    static parseRuleText(ruleText: string): BasicRuleParts;
}
export {};
