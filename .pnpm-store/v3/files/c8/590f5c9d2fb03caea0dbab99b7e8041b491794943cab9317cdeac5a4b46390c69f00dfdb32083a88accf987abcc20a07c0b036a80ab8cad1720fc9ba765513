(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.tsUrlFilter = {}));
})(this, (function (exports) { 'use strict';

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    /**
     * Compatibility types are used to configure engine for better support of different libraries
     * For example:
     *  extension doesn't support $app modifier. So if we set in configuration CompatibilityTypes.Extension,
     *  engine would ignore rules with $app modifier
     */
    exports.CompatibilityTypes = void 0;
    (function (CompatibilityTypes) {
        CompatibilityTypes[CompatibilityTypes["Extension"] = 1] = "Extension";
        CompatibilityTypes[CompatibilityTypes["CoreLibs"] = 2] = "CoreLibs";
        CompatibilityTypes[CompatibilityTypes["Dns"] = 4] = "Dns";
    })(exports.CompatibilityTypes || (exports.CompatibilityTypes = {}));
    /**
     * Application configuration class
     */
    var Configuration = /** @class */ (function () {
        function Configuration(inputConfig) {
            this.defaultConfig = {
                engine: null,
                version: null,
                verbose: false,
                compatibility: null,
            };
            /**
             * {'extension'|'corelibs'} engine application type
             */
            this.engine = null;
            /**
             * {string} version
             */
            this.version = null;
            /**
             * {boolean} verbose flag
             */
            this.verbose = false;
            /**
             * compatibility flag
             */
            this.compatibility = exports.CompatibilityTypes.Extension;
            var config = __assign(__assign({}, this.defaultConfig), inputConfig);
            this.engine = config.engine;
            this.version = config.version;
            this.verbose = config.verbose;
            this.compatibility = config.compatibility;
        }
        return Configuration;
    }());
    // eslint-disable-next-line import/no-mutable-exports
    exports.config = new Configuration();
    /**
     * Checks config is compatible with input level
     * @param compatibilityLevel
     * @private
     */
    function isCompatibleWith(compatibilityLevel) {
        if (exports.config.compatibility === null) {
            return false;
        }
        return (exports.config.compatibility & compatibilityLevel) === compatibilityLevel;
    }
    var setConfiguration = function (outerConfig) {
        exports.config = new Configuration(outerConfig);
    };

    /**
     * This class stores found cosmetic css rules content in the appropriate collections
     * It is primarily used by the {@see CosmeticResult}
     */
    var CosmeticStylesResult = /** @class */ (function () {
        /**
         * Constructor
         */
        function CosmeticStylesResult() {
            this.generic = [];
            this.specific = [];
            this.genericExtCss = [];
            this.specificExtCss = [];
        }
        /**
         * Appends rule to the appropriate collection
         * @param rule
         */
        CosmeticStylesResult.prototype.append = function (rule) {
            if (rule.isGeneric()) {
                if (rule.isExtendedCss()) {
                    this.genericExtCss.push(rule);
                }
                else {
                    this.generic.push(rule);
                }
            }
            else if (rule.isExtendedCss()) {
                this.specificExtCss.push(rule);
            }
            else {
                this.specific.push(rule);
            }
        };
        return CosmeticStylesResult;
    }());

    /**
     * This class stores found script rules content in the appropriate collections
     * It is primarily used by the {@see CosmeticResult}
     */
    var CosmeticScriptsResult = /** @class */ (function () {
        /**
         * Constructor
         */
        function CosmeticScriptsResult() {
            this.generic = [];
            this.specific = [];
        }
        /**
         * Appends rule to appropriate collection
         * @param rule
         */
        CosmeticScriptsResult.prototype.append = function (rule) {
            if (rule.isGeneric()) {
                this.generic.push(rule);
            }
            else {
                this.specific.push(rule);
            }
        };
        /**
         * Returns rules collected
         */
        CosmeticScriptsResult.prototype.getRules = function () {
            return __spreadArray(__spreadArray([], this.generic, true), this.specific, true);
        };
        return CosmeticScriptsResult;
    }());

    /**
     * This class stores found cosmetic html rules content in the appropriate collections
     * It is primarily used by the {@see CosmeticResult}
     */
    var CosmeticHtmlResult = /** @class */ (function () {
        /**
         * Constructor
         */
        function CosmeticHtmlResult() {
            this.generic = [];
            this.specific = [];
        }
        /**
         * Appends rule to the appropriate collection
         * @param rule
         */
        CosmeticHtmlResult.prototype.append = function (rule) {
            if (rule.isGeneric()) {
                this.generic.push(rule);
            }
            else {
                this.specific.push(rule);
            }
        };
        /**
         * Returns rules collected
         */
        CosmeticHtmlResult.prototype.getRules = function () {
            return __spreadArray(__spreadArray([], this.generic, true), this.specific, true);
        };
        return CosmeticHtmlResult;
    }());

    /**
     * Cosmetic result is the representation of rules
     * It is primarily used by the {@see CosmeticEngine}
     */
    var CosmeticResult = /** @class */ (function () {
        /**
         * Constructor
         */
        function CosmeticResult() {
            this.elementHiding = new CosmeticStylesResult();
            this.CSS = new CosmeticStylesResult();
            this.JS = new CosmeticScriptsResult();
            this.Html = new CosmeticHtmlResult();
        }
        /**
         * Script rules
         */
        CosmeticResult.prototype.getScriptRules = function () {
            return this.JS.getRules();
        };
        return CosmeticResult;
    }());

    /**
     * CosmeticOption is the enumeration of various content script options.
     * Depending on the set of enabled flags the content script will contain different set of settings.
     */
    exports.CosmeticOption = void 0;
    (function (CosmeticOption) {
        /**
         * if generic elemhide and CSS rules are enabled
         * Could be disabled by a $generichide rule and $elemhide rule.
         */
        CosmeticOption[CosmeticOption["CosmeticOptionGenericCSS"] = 2] = "CosmeticOptionGenericCSS";
        /**
         * if specific elemhide and CSS rules are enabled
         * Could be disabled by a $specifichide rule and $elemhide rule.
         */
        CosmeticOption[CosmeticOption["CosmeticOptionSpecificCSS"] = 4] = "CosmeticOptionSpecificCSS";
        /**
         * if JS rules and scriptlets are enabled
         * Could be disabled by a $jsinject rule.
         */
        CosmeticOption[CosmeticOption["CosmeticOptionJS"] = 8] = "CosmeticOptionJS";
        /**
         * if Html filtering rules are enabled
         * Could be disabled by a $content rule.
         */
        CosmeticOption[CosmeticOption["CosmeticOptionHtml"] = 16] = "CosmeticOptionHtml";
        /**
         * TODO: Add support for these flags
         * They are useful when content script is injected into an iframe
         * In this case we can check what flags were applied to the top-level frame
         */
        CosmeticOption[CosmeticOption["CosmeticOptionSourceGenericCSS"] = 32] = "CosmeticOptionSourceGenericCSS";
        CosmeticOption[CosmeticOption["CosmeticOptionSourceCSS"] = 64] = "CosmeticOptionSourceCSS";
        CosmeticOption[CosmeticOption["CosmeticOptionSourceJS"] = 128] = "CosmeticOptionSourceJS";
        /**
         * everything is enabled
         */
        CosmeticOption[CosmeticOption["CosmeticOptionAll"] = 30] = "CosmeticOptionAll";
        /**
         * everything is disabled
         */
        CosmeticOption[CosmeticOption["CosmeticOptionNone"] = 0] = "CosmeticOptionNone";
    })(exports.CosmeticOption || (exports.CosmeticOption = {}));

    /**
     * Splits the string by the delimiter, ignoring escaped delimiters
     * and without tokenizing.
     * Works for plain strings that don't include string representation of
     * complex entities, e.g $replace modifier values.
     *
     * @param string - string to split
     * @param delimiter - delimiter
     * @param escapeCharacter - escape character
     * @param preserveEmptyTokens - if true, preserve empty parts
     * @param shouldUnescape - if true, unescape characters
     * @return array of string parts
     */
    function splitByDelimiterWithEscapeCharacter(string, delimiter, escapeCharacter, preserveEmptyTokens, shouldUnescape) {
        if (shouldUnescape === void 0) { shouldUnescape = true; }
        if (!string) {
            return [];
        }
        if (string.startsWith(delimiter)) {
            // eslint-disable-next-line no-param-reassign
            string = string.substring(1);
        }
        var words = [];
        if (!string.includes(escapeCharacter)) {
            words = string.split(delimiter);
            if (!preserveEmptyTokens) {
                words = words.filter(function (word) { return !!word; });
            }
            return words;
        }
        var chars = [];
        var makeWord = function () {
            var word = chars.join('');
            words.push(word);
            chars = [];
        };
        for (var i = 0; i < string.length; i += 1) {
            var char = string.charAt(i);
            var isLastChar = i === (string.length - 1);
            if (char === delimiter) {
                var isEscapedChar = i > 0 && string[i - 1] === escapeCharacter;
                if (isEscapedChar) {
                    if (shouldUnescape) {
                        chars.splice(chars.length - 1, 1);
                    }
                    chars.push(char);
                }
                else {
                    makeWord();
                }
                if (isLastChar) {
                    makeWord();
                }
            }
            else if (isLastChar) {
                chars.push(char);
                makeWord();
            }
            else {
                chars.push(char);
            }
        }
        if (!preserveEmptyTokens) {
            words = words.filter(function (word) { return !!word; });
        }
        return words;
    }
    /**
     * Checks if the specified string starts with a substr at the specified index.
     *
     * @param str - String to check
     * @param startIndex - Index to start checking from
     * @param substr - Substring to check
     * @return boolean true if it does start
     */
    function startsAtIndexWith(str, startIndex, substr) {
        if (str.length - startIndex < substr.length) {
            return false;
        }
        for (var i = 0; i < substr.length; i += 1) {
            if (str.charAt(startIndex + i) !== substr.charAt(i)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks if str has unquoted substr
     *
     * @param str
     * @param substr
     */
    function hasUnquotedSubstring(str, substr) {
        var quotes = ['"', "'", '/'];
        if (!str.includes(substr)) {
            return false;
        }
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        if (indexOfAny(str, quotes) === -1) {
            return true;
        }
        var stack = [];
        for (var i = 0; i < str.length; i += 1) {
            var cursor = str[i];
            if (stack.length === 0) {
                if (startsAtIndexWith(str, i, substr)) {
                    return true;
                }
            }
            if (quotes.indexOf(cursor) >= 0
                && (i === 0 || str[i - 1] !== '\\')) {
                var last = stack.pop();
                if (!last) {
                    stack.push(cursor);
                }
                else if (last !== cursor) {
                    stack.push(last);
                    stack.push(cursor);
                }
            }
        }
        return false;
    }
    /**
     * djb2 hash algorithm
     *
     * NOTE: This version uses some bit operands to exclude overflow MAX_SAFE_INTEGER
     * (and moreover, exclude overflow 2^32).
     *
     * @see {@link https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765}
     *
     * @param str string to get hash
     * @return {number} hash
     */
    function fastHash(str) {
        if (str.length === 0) {
            return 0;
        }
        var hash = 5381;
        for (var i = 0; i < str.length; i += 1) {
            hash = hash * 33 ^ str.charCodeAt(i);
        }
        return hash >>> 0;
    }
    /**
     * Look for any symbol from "chars" array starting at "start" index or from the start of the string
     *
     * @param str   String to search
     * @param chars Chars to search for
     * @param start Start index (optional, inclusive)
     * @return int Index of the element found or -1 if not
     */
    function indexOfAny(str, chars, start) {
        if (start === void 0) { start = 0; }
        if (str.length <= start) {
            return -1;
        }
        for (var i = start; i < str.length; i += 1) {
            var c = str.charAt(i);
            if (chars.indexOf(c) > -1) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Replaces all occurences of find with replace in str
     *
     * @param str
     * @param find
     * @param replace
     */
    function replaceAll(str, find, replace) {
        if (!str) {
            return str;
        }
        return str.split(find).join(replace);
    }
    /**
     * Checks if arrays are equal
     *
     * @param left array
     * @param right array
     * @return {boolean} true on equality
     */
    function stringArraysEquals(left, right) {
        if (!left || !right) {
            return !left && !right;
        }
        if (left.length !== right.length) {
            return false;
        }
        for (var i = 0; i < left.length; i += 1) {
            if (left[i] !== right[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks if arrays have an intersection
     *
     * @param left array
     * @param right array
     * @return {boolean} true on equality
     */
    function stringArraysHaveIntersection(left, right) {
        if (!left || !right) {
            return true;
        }
        for (var i = 0; i < left.length; i += 1) {
            if (right.includes(left[i])) {
                return true;
            }
        }
        return false;
    }

    /* eslint-disable prefer-regex-literals */
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp
    // should be escaped . * + ? ^ $ { } ( ) | [ ] / \
    // except of * | ^
    var specialCharacters = ['.', '+', '?', '$', '{', '}', '(', ')', '[', ']', '/', '\\'];
    var reSpecialCharacters = new RegExp("[".concat(specialCharacters.join('\\'), "]"), 'g');
    var reSpecialCharactersFull = /[.*+?^${}()|[\]\\]/g;
    var reEscapedSpecialCharactersFull = /\\[.*+?^${}()|[\]\\]/g;
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#using_special_characters_in_strings
    var escapeSequence = {
        n: '\n',
        r: '\r',
        t: '\t',
        b: '\b',
        f: '\f',
        v: '\v',
    };
    /**
     * Class with static helper methods for working with basic filtering rules patterns.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules
     */
    var SimpleRegex = /** @class */ (function () {
        function SimpleRegex() {
        }
        /**
         * Extracts the shortcut from the rule's pattern.
         * Shortcut is the longest substring of the pattern that does not contain
         * any special characters.
         *
         * Please note, that the shortcut is always lower-case!
         *
         * @param pattern - network rule's pattern.
         * @returns the shortcut or the empty string if we could not extract any.
         */
        SimpleRegex.extractShortcut = function (pattern) {
            if (pattern.startsWith(this.MASK_REGEX_RULE) && pattern.endsWith(this.MASK_REGEX_RULE)) {
                return this.extractRegexpShortcut(pattern);
            }
            return this.extractBasicShortcut(pattern);
        };
        /**
         * Searches for the longest substring of the pattern that
         * does not contain any special characters: *,^,|.
         *
         * @param pattern - network rule's pattern.
         * @returns the shortcut or the empty string
         */
        SimpleRegex.extractBasicShortcut = function (pattern) {
            var longest = '';
            var parts = pattern.split(this.rePatternSpecialCharacters);
            for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
                var part = parts_1[_i];
                if (part.length > longest.length) {
                    longest = part;
                }
            }
            return (longest || '').toLowerCase();
        };
        /**
         * Searches for a shortcut inside of a regexp pattern.
         * Shortcut in this case is a longest string with no REGEX special characters.
         * Also, we discard complicated regexps right away.
         *
         * @param pattern - network rule's pattern (regexp).
         * @returns the shortcut or the empty string
         */
        SimpleRegex.extractRegexpShortcut = function (pattern) {
            var reText = pattern.substring(this.MASK_REGEX_RULE.length, pattern.length - this.MASK_REGEX_RULE.length);
            if (reText.length === 0) {
                // The rule is too short, doing nothing
                return '';
            }
            if (reText.indexOf('?') >= 0) {
                // Do not mess with complex expressions which use lookahead
                // And with those using ? special character
                // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/978
                return '';
            }
            var specialCharacter = '$$$';
            // Prepend specialCharacter for the following replace calls to work properly
            reText = specialCharacter + reText;
            // Strip all types of brackets
            reText = reText.replace(/[^\\]\(.*[^\\]\)/, specialCharacter);
            reText = reText.replace(/[^\\]\[.*[^\\]\]/, specialCharacter);
            reText = reText.replace(/[^\\]\{.*[^\\]\}/, specialCharacter);
            // Strip some special characters
            reText = reText.replace(/[^\\]\\[a-zA-Z]/, specialCharacter);
            // Replace \. with .
            reText = reText.replace(/\\\./g, '.');
            // Split by special characters
            // `.` is one of the special characters so our `specialCharacter`
            // will be removed from the resulting array
            var parts = reText.split(/[\\^$*+?()|[\]{}]/);
            var longest = '';
            for (var i = 0; i < parts.length; i += 1) {
                var part = parts[i];
                if (part.length > longest.length) {
                    longest = part;
                }
            }
            return longest.toLowerCase();
        };
        /**
         * patternToRegexp is a helper method for creating regular expressions from the simple
         * wildcard-based syntax which is used in basic filters:
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules
         *
         * @param pattern - basic rule pattern
         * @returns regular expression
         */
        SimpleRegex.patternToRegexp = function (pattern) {
            if (pattern === this.MASK_START_URL
                || pattern === this.MASK_PIPE
                || pattern === this.MASK_ANY_CHARACTER
                || pattern === '') {
                return this.REGEX_ANY_CHARACTER;
            }
            if (pattern.startsWith(this.MASK_REGEX_RULE) && pattern.endsWith(this.MASK_REGEX_RULE)) {
                // This is a regex rule, just remove the regex markers
                return pattern.substring(this.MASK_REGEX_RULE.length, pattern.length - this.MASK_REGEX_RULE.length);
            }
            // Escape special characters except of * | ^
            var regex = pattern.replace(reSpecialCharacters, '\\$&');
            // Now escape "|" characters but avoid escaping them in the special places
            if (regex.startsWith(this.MASK_START_URL)) {
                regex = regex.substring(0, this.MASK_START_URL.length)
                    + replaceAll(regex.substring(this.MASK_START_URL.length, regex.length - this.MASK_PIPE.length), this.MASK_PIPE, "\\".concat(this.MASK_PIPE))
                    + regex.substring(regex.length - this.MASK_PIPE.length);
            }
            else {
                regex = regex.substring(0, this.MASK_PIPE.length)
                    + replaceAll(regex.substring(this.MASK_PIPE.length, regex.length - this.MASK_PIPE.length), this.MASK_PIPE, "\\".concat(this.MASK_PIPE))
                    + regex.substring(regex.length - this.MASK_PIPE.length);
            }
            // Replace special URL masks
            regex = replaceAll(regex, this.MASK_ANY_CHARACTER, this.REGEX_ANY_CHARACTER);
            regex = replaceAll(regex, this.MASK_SEPARATOR, this.REGEX_SEPARATOR);
            // Replace start URL and pipes
            if (regex.startsWith(this.MASK_START_URL)) {
                regex = this.REGEX_START_URL + regex.substring(this.MASK_START_URL.length);
            }
            else if (regex.startsWith(this.MASK_PIPE)) {
                regex = this.REGEX_START_STRING + regex.substring(this.MASK_PIPE.length);
            }
            if (regex.endsWith(this.MASK_PIPE)) {
                regex = regex.substring(0, regex.length - this.MASK_PIPE.length) + this.REGEX_END_STRING;
            }
            return regex;
        };
        /**
         * Creates RegExp object from string in '/reg_exp/gi' format
         *
         * @param str
         */
        SimpleRegex.patternFromString = function (str) {
            var parts = splitByDelimiterWithEscapeCharacter(str, '/', '\\', true);
            var modifiers = (parts[1] || '');
            if (modifiers.indexOf('g') < 0) {
                modifiers += 'g';
            }
            return new RegExp(parts[0], modifiers);
        };
        /**
         * Escapes characters with special meaning inside a regular expression.
         *
         * @param str
         * @param searchPattern - Pattern for detecting special characters. Optional.
         */
        SimpleRegex.escapeRegexSpecials = function (str, searchPattern) {
            if (searchPattern === void 0) { searchPattern = reSpecialCharactersFull; }
            return str.replace(searchPattern, '\\$&');
        };
        /**
         * Unescapes characters with special meaning inside a regular expression.
         *
         * @param str
         * @param searchPattern - Pattern for detecting special characters. Optional.
         */
        SimpleRegex.unescapeRegexSpecials = function (str, searchPattern) {
            if (searchPattern === void 0) { searchPattern = reEscapedSpecialCharactersFull; }
            return str.replace(searchPattern, function (match) { return match.substring(1); });
        };
        /**
         * Check if pattern is Regex
         */
        SimpleRegex.isRegexPattern = function (str) {
            return str.startsWith('/') && str.endsWith('/');
        };
        /**
         * Unescapes special characters in a string
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#using_special_characters_in_strings
         */
        SimpleRegex.unescapeSpecials = function (str) {
            var keys = Object.keys(escapeSequence).join('|');
            var regex = new RegExp("\\\\(".concat(keys, ")"), 'g');
            return str.replace(regex, function (match, group) {
                return escapeSequence[group];
            });
        };
        /**
         * Matching the beginning of an address. With this character you don't
         * have to specify a particular protocol and subdomain in address mask.
         * It means, || stands for http://*., https://*., ws://*., wss://*. at once.
         */
        SimpleRegex.MASK_START_URL = '||';
        /**
         * REGEX_START_URL corresponds to MASK_START_URL
         */
        SimpleRegex.REGEX_START_URL = '^(http|https|ws|wss)://([a-z0-9-_.]+\\.)?';
        /**
         * A pointer to the beginning or the end of address. The value depends on the
         * character placement in the mask. For example, a rule swf| corresponds
         * to http://example.com/annoyingflash.swf , but not to http://example.com/swf/index.html.
         * |http://example.org corresponds to http://example.org,
         * but not to http://domain.com?url=http://example.org.
         */
        SimpleRegex.MASK_PIPE = '|';
        /**
         * REGEX_END_STRING corresponds to MASK_PIPE if it is in the end of a pattern.
         */
        SimpleRegex.REGEX_END_STRING = '$';
        /**
         * REGEX_START_STRING corresponds to MASK_PIPE if it is in the beginning of a pattern.
         */
        SimpleRegex.REGEX_START_STRING = '^';
        /**
         * Separator character mark. Separator character is any character,
         * but a letter, a digit, or one of the following: _ - .
         */
        SimpleRegex.MASK_SEPARATOR = '^';
        /**
         * REGEX_SEPARATOR corresponds to MASK_SEPARATOR
         */
        SimpleRegex.REGEX_SEPARATOR = '([^ a-zA-Z0-9.%_-]|$)';
        /**
         * This is a wildcard character. It is used to represent "any set of characters".
         * This can also be an empty string or a string of any length.
         */
        SimpleRegex.MASK_ANY_CHARACTER = '*';
        /**
         * Path separator
         */
        SimpleRegex.MASK_BACKSLASH = '/';
        /**
         * REGEX_ANY_CHARACTER corresponds to MASK_ANY_CHARACTER.
         */
        SimpleRegex.REGEX_ANY_CHARACTER = '.*';
        /**
         * Enclose regex in two backslashes to mark a regex rule:
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#regular-expressions-support
         */
        SimpleRegex.MASK_REGEX_RULE = '/';
        /**
         *  Regex for matching special characters in modifier regex pattern
         */
        SimpleRegex.reModifierPatternSpecialCharacters = /[[\],\\]/g;
        /**
          *  Regex for matching escaped special characters in modifier regex pattern
          */
        SimpleRegex.reModifierPatternEscapedSpecialCharacters = /\\[[\],\\]/g;
        /**
         * If string starts with exclamation mark "!" we consider it as comment
         */
        SimpleRegex.MASK_COMMENT = '!';
        /**
         * Min length of rule shortcut
         * This value has been picked as a result of performance experiments
         */
        SimpleRegex.MIN_SHORTCUT_LENGTH = 3;
        /**
         * Min length of generic rule shortcut
         */
        SimpleRegex.MIN_GENERIC_RULE_LENGTH = 4;
        /** Regex with basic matching pattern special characters */
        SimpleRegex.rePatternSpecialCharacters = new RegExp('[*^|]');
        return SimpleRegex;
    }());

    function shareSameDomainSuffix(hostname, vhost) {
        if (hostname.endsWith(vhost)) {
            return (hostname.length === vhost.length ||
                hostname[hostname.length - vhost.length - 1] === '.');
        }
        return false;
    }
    function extractDomainWithSuffix(hostname, publicSuffix) {
        const publicSuffixIndex = hostname.length - publicSuffix.length - 2;
        const lastDotBeforeSuffixIndex = hostname.lastIndexOf('.', publicSuffixIndex);
        if (lastDotBeforeSuffixIndex === -1) {
            return hostname;
        }
        return hostname.slice(lastDotBeforeSuffixIndex + 1);
    }
    function getDomain(suffix, hostname, options) {
        if (options.validHosts !== null) {
            const validHosts = options.validHosts;
            for (let i = 0; i < validHosts.length; i += 1) {
                const vhost = validHosts[i];
                if ( shareSameDomainSuffix(hostname, vhost) === true) {
                    return vhost;
                }
            }
        }
        if (suffix.length === hostname.length) {
            return null;
        }
        return  extractDomainWithSuffix(hostname, suffix);
    }

    function getDomainWithoutSuffix(domain, suffix) {
        return domain.slice(0, -suffix.length - 1);
    }

    function extractHostname(url, urlIsValidHostname) {
        let start = 0;
        let end = url.length;
        let hasUpper = false;
        if (urlIsValidHostname === false) {
            if (url.startsWith('data:') === true) {
                return null;
            }
            while (start < url.length && url.charCodeAt(start) <= 32) {
                start += 1;
            }
            while (end > start + 1 && url.charCodeAt(end - 1) <= 32) {
                end -= 1;
            }
            if (url.charCodeAt(start) === 47  &&
                url.charCodeAt(start + 1) === 47 ) {
                start += 2;
            }
            else {
                const indexOfProtocol = url.indexOf(':/', start);
                if (indexOfProtocol !== -1) {
                    const protocolSize = indexOfProtocol - start;
                    const c0 = url.charCodeAt(start);
                    const c1 = url.charCodeAt(start + 1);
                    const c2 = url.charCodeAt(start + 2);
                    const c3 = url.charCodeAt(start + 3);
                    const c4 = url.charCodeAt(start + 4);
                    if (protocolSize === 5 &&
                        c0 === 104  &&
                        c1 === 116  &&
                        c2 === 116  &&
                        c3 === 112  &&
                        c4 === 115 ) ;
                    else if (protocolSize === 4 &&
                        c0 === 104  &&
                        c1 === 116  &&
                        c2 === 116  &&
                        c3 === 112 ) ;
                    else if (protocolSize === 3 &&
                        c0 === 119  &&
                        c1 === 115  &&
                        c2 === 115 ) ;
                    else if (protocolSize === 2 &&
                        c0 === 119  &&
                        c1 === 115 ) ;
                    else {
                        for (let i = start; i < indexOfProtocol; i += 1) {
                            const lowerCaseCode = url.charCodeAt(i) | 32;
                            if (((lowerCaseCode >= 97 && lowerCaseCode <= 122) ||
                                (lowerCaseCode >= 48 && lowerCaseCode <= 57) ||
                                lowerCaseCode === 46 ||
                                lowerCaseCode === 45 ||
                                lowerCaseCode === 43) === false
                            ) {
                                return null;
                            }
                        }
                    }
                    start = indexOfProtocol + 2;
                    while (url.charCodeAt(start) === 47 ) {
                        start += 1;
                    }
                }
            }
            let indexOfIdentifier = -1;
            let indexOfClosingBracket = -1;
            let indexOfPort = -1;
            for (let i = start; i < end; i += 1) {
                const code = url.charCodeAt(i);
                if (code === 35 ||
                    code === 47 ||
                    code === 63
                ) {
                    end = i;
                    break;
                }
                else if (code === 64) {
                    indexOfIdentifier = i;
                }
                else if (code === 93) {
                    indexOfClosingBracket = i;
                }
                else if (code === 58) {
                    indexOfPort = i;
                }
                else if (code >= 65 && code <= 90) {
                    hasUpper = true;
                }
            }
            if (indexOfIdentifier !== -1 &&
                indexOfIdentifier > start &&
                indexOfIdentifier < end) {
                start = indexOfIdentifier + 1;
            }
            if (url.charCodeAt(start) === 91 ) {
                if (indexOfClosingBracket !== -1) {
                    return url.slice(start + 1, indexOfClosingBracket).toLowerCase();
                }
                return null;
            }
            else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {
                end = indexOfPort;
            }
        }
        while (end > start + 1 && url.charCodeAt(end - 1) === 46 ) {
            end -= 1;
        }
        const hostname = start !== 0 || end !== url.length ? url.slice(start, end) : url;
        if (hasUpper) {
            return hostname.toLowerCase();
        }
        return hostname;
    }

    function isProbablyIpv4(hostname) {
        if (hostname.length < 7) {
            return false;
        }
        if (hostname.length > 15) {
            return false;
        }
        let numberOfDots = 0;
        for (let i = 0; i < hostname.length; i += 1) {
            const code = hostname.charCodeAt(i);
            if (code === 46 ) {
                numberOfDots += 1;
            }
            else if (code < 48  || code > 57 ) {
                return false;
            }
        }
        return (numberOfDots === 3 &&
            hostname.charCodeAt(0) !== 46  &&
            hostname.charCodeAt(hostname.length - 1) !== 46 );
    }
    function isProbablyIpv6(hostname) {
        if (hostname.length < 3) {
            return false;
        }
        let start = hostname[0] === '[' ? 1 : 0;
        let end = hostname.length;
        if (hostname[end - 1] === ']') {
            end -= 1;
        }
        if (end - start > 39) {
            return false;
        }
        let hasColon = false;
        for (; start < end; start += 1) {
            const code = hostname.charCodeAt(start);
            if (code === 58 ) {
                hasColon = true;
            }
            else if (((code >= 48 && code <= 57) ||
                (code >= 97 && code <= 102) ||
                (code >= 65 && code <= 90)) ===
                false) {
                return false;
            }
        }
        return hasColon;
    }
    function isIp$1(hostname) {
        return isProbablyIpv6(hostname) || isProbablyIpv4(hostname);
    }

    function isValidAscii(code) {
        return ((code >= 97 && code <= 122) || (code >= 48 && code <= 57) || code > 127);
    }
    function isValidHostname (hostname) {
        if (hostname.length > 255) {
            return false;
        }
        if (hostname.length === 0) {
            return false;
        }
        if ( isValidAscii(hostname.charCodeAt(0)) === false) {
            return false;
        }
        let lastDotIndex = -1;
        let lastCharCode = -1;
        const len = hostname.length;
        for (let i = 0; i < len; i += 1) {
            const code = hostname.charCodeAt(i);
            if (code === 46 ) {
                if (
                i - lastDotIndex > 64 ||
                    lastCharCode === 46 ||
                    lastCharCode === 45 ||
                    lastCharCode === 95) {
                    return false;
                }
                lastDotIndex = i;
            }
            else if (( isValidAscii(code) || code === 45 || code === 95) ===
                false) {
                return false;
            }
            lastCharCode = code;
        }
        return (
        len - lastDotIndex - 1 <= 63 &&
            lastCharCode !== 45);
    }

    function setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname = true, mixedInputs = true, validHosts = null, validateHostname = true, }) {
        return {
            allowIcannDomains,
            allowPrivateDomains,
            detectIp,
            extractHostname,
            mixedInputs,
            validHosts,
            validateHostname,
        };
    }
    const DEFAULT_OPTIONS =  setDefaultsImpl({});
    function setDefaults(options) {
        if (options === undefined) {
            return DEFAULT_OPTIONS;
        }
        return  setDefaultsImpl(options);
    }

    function getSubdomain(hostname, domain) {
        if (domain.length === hostname.length) {
            return '';
        }
        return hostname.slice(0, -domain.length - 1);
    }

    function getEmptyResult() {
        return {
            domain: null,
            domainWithoutSuffix: null,
            hostname: null,
            isIcann: null,
            isIp: null,
            isPrivate: null,
            publicSuffix: null,
            subdomain: null,
        };
    }
    function resetResult(result) {
        result.domain = null;
        result.domainWithoutSuffix = null;
        result.hostname = null;
        result.isIcann = null;
        result.isIp = null;
        result.isPrivate = null;
        result.publicSuffix = null;
        result.subdomain = null;
    }
    function parseImpl(url, step, suffixLookup, partialOptions, result) {
        const options =  setDefaults(partialOptions);
        if (typeof url !== 'string') {
            return result;
        }
        if (options.extractHostname === false) {
            result.hostname = url;
        }
        else if (options.mixedInputs === true) {
            result.hostname = extractHostname(url, isValidHostname(url));
        }
        else {
            result.hostname = extractHostname(url, false);
        }
        if (step === 0  || result.hostname === null) {
            return result;
        }
        if (options.detectIp === true) {
            result.isIp = isIp$1(result.hostname);
            if (result.isIp === true) {
                return result;
            }
        }
        if (options.validateHostname === true &&
            options.extractHostname === true &&
            isValidHostname(result.hostname) === false) {
            result.hostname = null;
            return result;
        }
        suffixLookup(result.hostname, options, result);
        if (step === 2  || result.publicSuffix === null) {
            return result;
        }
        result.domain = getDomain(result.publicSuffix, result.hostname, options);
        if (step === 3  || result.domain === null) {
            return result;
        }
        result.subdomain = getSubdomain(result.hostname, result.domain);
        if (step === 4 ) {
            return result;
        }
        result.domainWithoutSuffix = getDomainWithoutSuffix(result.domain, result.publicSuffix);
        return result;
    }

    function fastPathLookup (hostname, options, out) {
        if (options.allowPrivateDomains === false && hostname.length > 3) {
            const last = hostname.length - 1;
            const c3 = hostname.charCodeAt(last);
            const c2 = hostname.charCodeAt(last - 1);
            const c1 = hostname.charCodeAt(last - 2);
            const c0 = hostname.charCodeAt(last - 3);
            if (c3 === 109  &&
                c2 === 111  &&
                c1 === 99  &&
                c0 === 46 ) {
                out.isIcann = true;
                out.isPrivate = false;
                out.publicSuffix = 'com';
                return true;
            }
            else if (c3 === 103  &&
                c2 === 114  &&
                c1 === 111  &&
                c0 === 46 ) {
                out.isIcann = true;
                out.isPrivate = false;
                out.publicSuffix = 'org';
                return true;
            }
            else if (c3 === 117  &&
                c2 === 100  &&
                c1 === 101  &&
                c0 === 46 ) {
                out.isIcann = true;
                out.isPrivate = false;
                out.publicSuffix = 'edu';
                return true;
            }
            else if (c3 === 118  &&
                c2 === 111  &&
                c1 === 103  &&
                c0 === 46 ) {
                out.isIcann = true;
                out.isPrivate = false;
                out.publicSuffix = 'gov';
                return true;
            }
            else if (c3 === 116  &&
                c2 === 101  &&
                c1 === 110  &&
                c0 === 46 ) {
                out.isIcann = true;
                out.isPrivate = false;
                out.publicSuffix = 'net';
                return true;
            }
            else if (c3 === 101  &&
                c2 === 100  &&
                c1 === 46 ) {
                out.isIcann = true;
                out.isPrivate = false;
                out.publicSuffix = 'de';
                return true;
            }
        }
        return false;
    }

    const exceptions = (function () {
        const _0 = { "$": 1, "succ": {} }, _1 = { "$": 0, "succ": { "city": _0 } };
        const exceptions = { "$": 0, "succ": { "ck": { "$": 0, "succ": { "www": _0 } }, "jp": { "$": 0, "succ": { "kawasaki": _1, "kitakyushu": _1, "kobe": _1, "nagoya": _1, "sapporo": _1, "sendai": _1, "yokohama": _1 } } } };
        return exceptions;
    })();
    const rules = (function () {
        const _2 = { "$": 1, "succ": {} }, _3 = { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "net": _2, "mil": _2, "org": _2 } }, _4 = { "$": 2, "succ": {} }, _5 = { "$": 1, "succ": { "blogspot": _4 } }, _6 = { "$": 1, "succ": { "gov": _2 } }, _7 = { "$": 0, "succ": { "*": _4 } }, _8 = { "$": 0, "succ": { "*": _2 } }, _9 = { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2, "gov": _2 } }, _10 = { "$": 1, "succ": { "co": _4 } }, _11 = { "$": 1, "succ": { "ng": _4 } }, _12 = { "$": 0, "succ": { "s3": _4 } }, _13 = { "$": 0, "succ": { "dualstack": _12 } }, _14 = { "$": 0, "succ": { "s3": _4, "dualstack": _12, "s3-website": _4 } }, _15 = { "$": 0, "succ": { "apps": _4 } }, _16 = { "$": 0, "succ": { "app": _4 } }, _17 = { "$": 0, "succ": { "j": _4 } }, _18 = { "$": 0, "succ": { "user": _4 } }, _19 = { "$": 1, "succ": { "ybo": _4 } }, _20 = { "$": 1, "succ": { "gov": _2, "blogspot": _4, "nym": _4 } }, _21 = { "$": 0, "succ": { "cust": _4 } }, _22 = { "$": 1, "succ": { "edu": _2, "biz": _2, "net": _2, "org": _2, "gov": _2, "info": _2, "com": _2 } }, _23 = { "$": 1, "succ": { "blogspot": _4, "nym": _4 } }, _24 = { "$": 1, "succ": { "for": _4 } }, _25 = { "$": 1, "succ": { "barsy": _4 } }, _26 = { "$": 0, "succ": { "forgot": _4 } }, _27 = { "$": 0, "succ": { "jelastic": _4 } }, _28 = { "$": 1, "succ": { "gs": _2 } }, _29 = { "$": 0, "succ": { "nes": _2 } }, _30 = { "$": 1, "succ": { "k12": _2, "cc": _2, "lib": _2 } }, _31 = { "$": 1, "succ": { "cc": _2, "lib": _2 } };
        const rules = { "$": 0, "succ": { "ac": _3, "ad": { "$": 1, "succ": { "nom": _2 } }, "ae": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "sch": _2, "ac": _2, "gov": _2, "mil": _2, "blogspot": _4, "nom": _4 } }, "aero": { "$": 1, "succ": { "accident-investigation": _2, "accident-prevention": _2, "aerobatic": _2, "aeroclub": _2, "aerodrome": _2, "agents": _2, "aircraft": _2, "airline": _2, "airport": _2, "air-surveillance": _2, "airtraffic": _2, "air-traffic-control": _2, "ambulance": _2, "amusement": _2, "association": _2, "author": _2, "ballooning": _2, "broker": _2, "caa": _2, "cargo": _2, "catering": _2, "certification": _2, "championship": _2, "charter": _2, "civilaviation": _2, "club": _2, "conference": _2, "consultant": _2, "consulting": _2, "control": _2, "council": _2, "crew": _2, "design": _2, "dgca": _2, "educator": _2, "emergency": _2, "engine": _2, "engineer": _2, "entertainment": _2, "equipment": _2, "exchange": _2, "express": _2, "federation": _2, "flight": _2, "fuel": _2, "gliding": _2, "government": _2, "groundhandling": _2, "group": _2, "hanggliding": _2, "homebuilt": _2, "insurance": _2, "journal": _2, "journalist": _2, "leasing": _2, "logistics": _2, "magazine": _2, "maintenance": _2, "media": _2, "microlight": _2, "modelling": _2, "navigation": _2, "parachuting": _2, "paragliding": _2, "passenger-association": _2, "pilot": _2, "press": _2, "production": _2, "recreation": _2, "repbody": _2, "res": _2, "research": _2, "rotorcraft": _2, "safety": _2, "scientist": _2, "services": _2, "show": _2, "skydiving": _2, "software": _2, "student": _2, "trader": _2, "trading": _2, "trainer": _2, "union": _2, "workinggroup": _2, "works": _2 } }, "af": { "$": 1, "succ": { "gov": _2, "com": _2, "org": _2, "net": _2, "edu": _2, "nom": _4 } }, "ag": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "co": _2, "nom": _2 } }, "ai": { "$": 1, "succ": { "off": _2, "com": _2, "net": _2, "org": _2, "uwu": _4, "nom": _4 } }, "al": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "blogspot": _4, "nom": _4 } }, "am": { "$": 1, "succ": { "co": _2, "com": _2, "commune": _2, "net": _2, "org": _2, "blogspot": _4, "neko": _4, "nyaa": _4 } }, "ao": { "$": 1, "succ": { "ed": _2, "gv": _2, "og": _2, "co": _2, "pb": _2, "it": _2 } }, "aq": _2, "ar": { "$": 1, "succ": { "com": _5, "edu": _2, "gob": _2, "gov": _2, "int": _2, "mil": _2, "musica": _2, "net": _2, "org": _2, "tur": _2 } }, "arpa": { "$": 1, "succ": { "e164": _2, "in-addr": _2, "ip6": _2, "iris": _2, "uri": _2, "urn": _2 } }, "as": _6, "asia": { "$": 1, "succ": { "cloudns": _4 } }, "at": { "$": 1, "succ": { "ac": { "$": 1, "succ": { "sth": _2 } }, "co": _5, "gv": _2, "or": _2, "funkfeuer": { "$": 0, "succ": { "wien": _4 } }, "futurecms": { "$": 0, "succ": { "*": _4, "ex": _7, "in": _7 } }, "futurehosting": _4, "futuremailing": _4, "ortsinfo": { "$": 0, "succ": { "ex": _7, "kunden": _7 } }, "biz": _4, "info": _4, "priv": _4, "12hp": _4, "2ix": _4, "4lima": _4, "lima-city": _4 } }, "au": { "$": 1, "succ": { "com": _5, "net": _2, "org": _2, "edu": { "$": 1, "succ": { "act": _2, "catholic": _2, "nsw": { "$": 1, "succ": { "schools": _2 } }, "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 } }, "gov": { "$": 1, "succ": { "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 } }, "asn": _2, "id": _2, "info": _2, "conf": _2, "oz": _2, "act": _2, "nsw": _2, "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 } }, "aw": { "$": 1, "succ": { "com": _2 } }, "ax": { "$": 1, "succ": { "be": _4, "cat": _4, "es": _4, "eu": _4, "gg": _4, "mc": _4, "us": _4, "xy": _4 } }, "az": { "$": 1, "succ": { "com": _2, "net": _2, "int": _2, "gov": _2, "org": _2, "edu": _2, "info": _2, "pp": _2, "mil": _2, "name": _2, "pro": _2, "biz": _2 } }, "ba": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "blogspot": _4 } }, "bb": { "$": 1, "succ": { "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "store": _2, "tv": _2 } }, "bd": _8, "be": { "$": 1, "succ": { "ac": _2, "webhosting": _4, "blogspot": _4, "transurl": _7 } }, "bf": _6, "bg": { "$": 1, "succ": { "0": _2, "1": _2, "2": _2, "3": _2, "4": _2, "5": _2, "6": _2, "7": _2, "8": _2, "9": _2, "a": _2, "b": _2, "c": _2, "d": _2, "e": _2, "f": _2, "g": _2, "h": _2, "i": _2, "j": _2, "k": _2, "l": _2, "m": _2, "n": _2, "o": _2, "p": _2, "q": _2, "r": _2, "s": _2, "t": _2, "u": _2, "v": _2, "w": _2, "x": _2, "y": _2, "z": _2, "blogspot": _4, "barsy": _4 } }, "bh": _9, "bi": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "or": _2, "org": _2 } }, "biz": { "$": 1, "succ": { "cloudns": _4, "dyndns": _4, "for-better": _4, "for-more": _4, "for-some": _4, "for-the": _4, "selfip": _4, "webhop": _4, "bpl": _4, "orx": _4, "mmafan": _4, "myftp": _4, "no-ip": _4, "dscloud": _4 } }, "bj": { "$": 1, "succ": { "asso": _2, "barreau": _2, "gouv": _2, "blogspot": _4 } }, "bm": _9, "bn": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "co": _4 } }, "bo": { "$": 1, "succ": { "com": _2, "edu": _2, "gob": _2, "int": _2, "org": _2, "net": _2, "mil": _2, "tv": _2, "web": _2, "academia": _2, "agro": _2, "arte": _2, "blog": _2, "bolivia": _2, "ciencia": _2, "cooperativa": _2, "democracia": _2, "deporte": _2, "ecologia": _2, "economia": _2, "empresa": _2, "indigena": _2, "industria": _2, "info": _2, "medicina": _2, "movimiento": _2, "musica": _2, "natural": _2, "nombre": _2, "noticias": _2, "patria": _2, "politica": _2, "profesional": _2, "plurinacional": _2, "pueblo": _2, "revista": _2, "salud": _2, "tecnologia": _2, "tksat": _2, "transporte": _2, "wiki": _2 } }, "br": { "$": 1, "succ": { "9guacu": _2, "abc": _2, "adm": _2, "adv": _2, "agr": _2, "aju": _2, "am": _2, "anani": _2, "aparecida": _2, "app": _2, "arq": _2, "art": _2, "ato": _2, "b": _2, "barueri": _2, "belem": _2, "bhz": _2, "bib": _2, "bio": _2, "blog": _2, "bmd": _2, "boavista": _2, "bsb": _2, "campinagrande": _2, "campinas": _2, "caxias": _2, "cim": _2, "cng": _2, "cnt": _2, "com": _5, "contagem": _2, "coop": _2, "coz": _2, "cri": _2, "cuiaba": _2, "curitiba": _2, "def": _2, "des": _2, "det": _2, "dev": _2, "ecn": _2, "eco": _2, "edu": _2, "emp": _2, "enf": _2, "eng": _2, "esp": _2, "etc": _2, "eti": _2, "far": _2, "feira": _2, "flog": _2, "floripa": _2, "fm": _2, "fnd": _2, "fortal": _2, "fot": _2, "foz": _2, "fst": _2, "g12": _2, "geo": _2, "ggf": _2, "goiania": _2, "gov": { "$": 1, "succ": { "ac": _2, "al": _2, "am": _2, "ap": _2, "ba": _2, "ce": _2, "df": _2, "es": _2, "go": _2, "ma": _2, "mg": _2, "ms": _2, "mt": _2, "pa": _2, "pb": _2, "pe": _2, "pi": _2, "pr": _2, "rj": _2, "rn": _2, "ro": _2, "rr": _2, "rs": _2, "sc": _2, "se": _2, "sp": _2, "to": _2 } }, "gru": _2, "imb": _2, "ind": _2, "inf": _2, "jab": _2, "jampa": _2, "jdf": _2, "joinville": _2, "jor": _2, "jus": _2, "leg": { "$": 1, "succ": { "ac": _4, "al": _4, "am": _4, "ap": _4, "ba": _4, "ce": _4, "df": _4, "es": _4, "go": _4, "ma": _4, "mg": _4, "ms": _4, "mt": _4, "pa": _4, "pb": _4, "pe": _4, "pi": _4, "pr": _4, "rj": _4, "rn": _4, "ro": _4, "rr": _4, "rs": _4, "sc": _4, "se": _4, "sp": _4, "to": _4 } }, "lel": _2, "log": _2, "londrina": _2, "macapa": _2, "maceio": _2, "manaus": _2, "maringa": _2, "mat": _2, "med": _2, "mil": _2, "morena": _2, "mp": _2, "mus": _2, "natal": _2, "net": _2, "niteroi": _2, "nom": _8, "not": _2, "ntr": _2, "odo": _2, "ong": _2, "org": _2, "osasco": _2, "palmas": _2, "poa": _2, "ppg": _2, "pro": _2, "psc": _2, "psi": _2, "pvh": _2, "qsl": _2, "radio": _2, "rec": _2, "recife": _2, "rep": _2, "ribeirao": _2, "rio": _2, "riobranco": _2, "riopreto": _2, "salvador": _2, "sampa": _2, "santamaria": _2, "santoandre": _2, "saobernardo": _2, "saogonca": _2, "seg": _2, "sjc": _2, "slg": _2, "slz": _2, "sorocaba": _2, "srv": _2, "taxi": _2, "tc": _2, "tec": _2, "teo": _2, "the": _2, "tmp": _2, "trd": _2, "tur": _2, "tv": _2, "udi": _2, "vet": _2, "vix": _2, "vlog": _2, "wiki": _2, "zlg": _2 } }, "bs": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "we": _4 } }, "bt": _9, "bv": _2, "bw": { "$": 1, "succ": { "co": _2, "org": _2 } }, "by": { "$": 1, "succ": { "gov": _2, "mil": _2, "com": _5, "of": _2, "nym": _4 } }, "bz": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "za": _4, "nom": _4, "nym": _4 } }, "ca": { "$": 1, "succ": { "ab": _2, "bc": _2, "mb": _2, "nb": _2, "nf": _2, "nl": _2, "ns": _2, "nt": _2, "nu": _2, "on": _2, "pe": _2, "qc": _2, "sk": _2, "yk": _2, "gc": _2, "barsy": _4, "awdev": _7, "co": _4, "blogspot": _4, "no-ip": _4 } }, "cat": _2, "cc": { "$": 1, "succ": { "cloudns": _4, "ftpaccess": _4, "game-server": _4, "myphotos": _4, "scrapping": _4, "twmail": _4, "csx": _4, "fantasyleague": _4 } }, "cd": _6, "cf": _5, "cg": _2, "ch": { "$": 1, "succ": { "square7": _4, "blogspot": _4, "linkyard-cloud": _4, "dnsking": _4, "gotdns": _4, "12hp": _4, "2ix": _4, "4lima": _4, "lima-city": _4 } }, "ci": { "$": 1, "succ": { "org": _2, "or": _2, "com": _2, "co": _2, "edu": _2, "ed": _2, "ac": _2, "net": _2, "go": _2, "asso": _2, "xn--aroport-bya": _2, "aéroport": _2, "int": _2, "presse": _2, "md": _2, "gouv": _2, "fin": _4, "nl": _4 } }, "ck": _8, "cl": { "$": 1, "succ": { "aprendemas": _2, "co": _2, "gob": _2, "gov": _2, "mil": _2, "blogspot": _4, "nom": _4 } }, "cm": { "$": 1, "succ": { "co": _2, "com": _2, "gov": _2, "net": _2 } }, "cn": { "$": 1, "succ": { "ac": _2, "com": { "$": 1, "succ": { "amazonaws": { "$": 0, "succ": { "compute": _7, "eb": { "$": 0, "succ": { "cn-north-1": _4, "cn-northwest-1": _4 } }, "elb": _7, "cn-north-1": _12 } } } }, "edu": _2, "gov": _2, "net": _2, "org": _2, "mil": _2, "xn--55qx5d": _2, "公司": _2, "xn--io0a7i": _2, "网络": _2, "xn--od0alg": _2, "網絡": _2, "ah": _2, "bj": _2, "cq": _2, "fj": _2, "gd": _2, "gs": _2, "gz": _2, "gx": _2, "ha": _2, "hb": _2, "he": _2, "hi": _2, "hl": _2, "hn": _2, "jl": _2, "js": _2, "jx": _2, "ln": _2, "nm": _2, "nx": _2, "qh": _2, "sc": _2, "sd": _2, "sh": _2, "sn": _2, "sx": _2, "tj": _2, "xj": _2, "xz": _2, "yn": _2, "zj": _2, "hk": _2, "mo": _2, "tw": _2, "instantcloud": _4 } }, "co": { "$": 1, "succ": { "arts": _2, "com": _5, "edu": _2, "firm": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "rec": _2, "web": _2, "carrd": _4, "crd": _4, "otap": _7, "leadpages": _4, "lpages": _4, "mypi": _4, "n4t": _4, "nodum": _4, "repl": _4 } }, "com": { "$": 1, "succ": { "adobeaemcloud": { "$": 2, "succ": { "dev": _7 } }, "kasserver": _4, "amazonaws": { "$": 0, "succ": { "compute": _7, "compute-1": _7, "us-east-1": { "$": 2, "succ": { "dualstack": _12 } }, "elb": _7, "s3": _4, "s3-ap-northeast-1": _4, "s3-ap-northeast-2": _4, "s3-ap-south-1": _4, "s3-ap-southeast-1": _4, "s3-ap-southeast-2": _4, "s3-ca-central-1": _4, "s3-eu-central-1": _4, "s3-eu-west-1": _4, "s3-eu-west-2": _4, "s3-eu-west-3": _4, "s3-external-1": _4, "s3-fips-us-gov-west-1": _4, "s3-sa-east-1": _4, "s3-us-gov-west-1": _4, "s3-us-east-2": _4, "s3-us-west-1": _4, "s3-us-west-2": _4, "ap-northeast-2": _14, "ap-south-1": _14, "ca-central-1": _14, "eu-central-1": _14, "eu-west-2": _14, "eu-west-3": _14, "us-east-2": _14, "ap-northeast-1": _13, "ap-southeast-1": _13, "ap-southeast-2": _13, "eu-west-1": _13, "sa-east-1": _13, "s3-website-us-east-1": _4, "s3-website-us-west-1": _4, "s3-website-us-west-2": _4, "s3-website-ap-northeast-1": _4, "s3-website-ap-southeast-1": _4, "s3-website-ap-southeast-2": _4, "s3-website-eu-west-1": _4, "s3-website-sa-east-1": _4 } }, "elasticbeanstalk": { "$": 2, "succ": { "ap-northeast-1": _4, "ap-northeast-2": _4, "ap-northeast-3": _4, "ap-south-1": _4, "ap-southeast-1": _4, "ap-southeast-2": _4, "ca-central-1": _4, "eu-central-1": _4, "eu-west-1": _4, "eu-west-2": _4, "eu-west-3": _4, "sa-east-1": _4, "us-east-1": _4, "us-east-2": _4, "us-gov-west-1": _4, "us-west-1": _4, "us-west-2": _4 } }, "on-aptible": _4, "myasustor": _4, "balena-devices": _4, "betainabox": _4, "bplaced": _4, "ar": _4, "br": _4, "cn": _4, "de": _4, "eu": _4, "gb": _4, "hu": _4, "jpn": _4, "kr": _4, "mex": _4, "no": _4, "qc": _4, "ru": _4, "sa": _4, "uk": _4, "us": _4, "uy": _4, "za": _4, "africa": _4, "gr": _4, "co": _4, "xenapponazure": _4, "jdevcloud": _4, "wpdevcloud": _4, "cloudcontrolled": _4, "cloudcontrolapp": _4, "trycloudflare": _4, "customer-oci": { "$": 0, "succ": { "*": _4, "oci": _7, "ocp": _7, "ocs": _7 } }, "dattolocal": _4, "dattorelay": _4, "dattoweb": _4, "mydatto": _4, "builtwithdark": _4, "drayddns": _4, "dreamhosters": _4, "mydrobo": _4, "dyndns-at-home": _4, "dyndns-at-work": _4, "dyndns-blog": _4, "dyndns-free": _4, "dyndns-home": _4, "dyndns-ip": _4, "dyndns-mail": _4, "dyndns-office": _4, "dyndns-pics": _4, "dyndns-remote": _4, "dyndns-server": _4, "dyndns-web": _4, "dyndns-wiki": _4, "dyndns-work": _4, "blogdns": _4, "cechire": _4, "dnsalias": _4, "dnsdojo": _4, "doesntexist": _4, "dontexist": _4, "doomdns": _4, "dyn-o-saur": _4, "dynalias": _4, "est-a-la-maison": _4, "est-a-la-masion": _4, "est-le-patron": _4, "est-mon-blogueur": _4, "from-ak": _4, "from-al": _4, "from-ar": _4, "from-ca": _4, "from-ct": _4, "from-dc": _4, "from-de": _4, "from-fl": _4, "from-ga": _4, "from-hi": _4, "from-ia": _4, "from-id": _4, "from-il": _4, "from-in": _4, "from-ks": _4, "from-ky": _4, "from-ma": _4, "from-md": _4, "from-mi": _4, "from-mn": _4, "from-mo": _4, "from-ms": _4, "from-mt": _4, "from-nc": _4, "from-nd": _4, "from-ne": _4, "from-nh": _4, "from-nj": _4, "from-nm": _4, "from-nv": _4, "from-oh": _4, "from-ok": _4, "from-or": _4, "from-pa": _4, "from-pr": _4, "from-ri": _4, "from-sc": _4, "from-sd": _4, "from-tn": _4, "from-tx": _4, "from-ut": _4, "from-va": _4, "from-vt": _4, "from-wa": _4, "from-wi": _4, "from-wv": _4, "from-wy": _4, "getmyip": _4, "gotdns": _4, "hobby-site": _4, "homelinux": _4, "homeunix": _4, "iamallama": _4, "is-a-anarchist": _4, "is-a-blogger": _4, "is-a-bookkeeper": _4, "is-a-bulls-fan": _4, "is-a-caterer": _4, "is-a-chef": _4, "is-a-conservative": _4, "is-a-cpa": _4, "is-a-cubicle-slave": _4, "is-a-democrat": _4, "is-a-designer": _4, "is-a-doctor": _4, "is-a-financialadvisor": _4, "is-a-geek": _4, "is-a-green": _4, "is-a-guru": _4, "is-a-hard-worker": _4, "is-a-hunter": _4, "is-a-landscaper": _4, "is-a-lawyer": _4, "is-a-liberal": _4, "is-a-libertarian": _4, "is-a-llama": _4, "is-a-musician": _4, "is-a-nascarfan": _4, "is-a-nurse": _4, "is-a-painter": _4, "is-a-personaltrainer": _4, "is-a-photographer": _4, "is-a-player": _4, "is-a-republican": _4, "is-a-rockstar": _4, "is-a-socialist": _4, "is-a-student": _4, "is-a-teacher": _4, "is-a-techie": _4, "is-a-therapist": _4, "is-an-accountant": _4, "is-an-actor": _4, "is-an-actress": _4, "is-an-anarchist": _4, "is-an-artist": _4, "is-an-engineer": _4, "is-an-entertainer": _4, "is-certified": _4, "is-gone": _4, "is-into-anime": _4, "is-into-cars": _4, "is-into-cartoons": _4, "is-into-games": _4, "is-leet": _4, "is-not-certified": _4, "is-slick": _4, "is-uberleet": _4, "is-with-theband": _4, "isa-geek": _4, "isa-hockeynut": _4, "issmarterthanyou": _4, "likes-pie": _4, "likescandy": _4, "neat-url": _4, "saves-the-whales": _4, "selfip": _4, "sells-for-less": _4, "sells-for-u": _4, "servebbs": _4, "simple-url": _4, "space-to-rent": _4, "teaches-yoga": _4, "writesthisblog": _4, "ddnsfree": _4, "ddnsgeek": _4, "giize": _4, "gleeze": _4, "kozow": _4, "loseyourip": _4, "ooguy": _4, "theworkpc": _4, "mytuleap": _4, "evennode": { "$": 0, "succ": { "eu-1": _4, "eu-2": _4, "eu-3": _4, "eu-4": _4, "us-1": _4, "us-2": _4, "us-3": _4, "us-4": _4 } }, "onfabrica": _4, "fbsbx": _15, "fastly-terrarium": _4, "fastvps-server": _4, "mydobiss": _4, "firebaseapp": _4, "freebox-os": _4, "freeboxos": _4, "gentapps": _4, "gentlentapis": _4, "githubusercontent": _4, "0emm": _7, "appspot": { "$": 2, "succ": { "r": _7 } }, "blogspot": _4, "codespot": _4, "googleapis": _4, "googlecode": _4, "pagespeedmobilizer": _4, "publishproxy": _4, "withgoogle": _4, "withyoutube": _4, "awsmppl": _4, "herokuapp": _4, "herokussl": _4, "myravendb": _4, "pixolino": _4, "dopaas": _4, "hidora": _4, "ik-server": { "$": 0, "succ": { "jcloud": _4 } }, "jelastic": { "$": 0, "succ": { "demo": _4 } }, "joyent": { "$": 0, "succ": { "cns": _7 } }, "lpusercontent": _4, "lmpm": _16, "linode": { "$": 0, "succ": { "members": _4, "nodebalancer": _7 } }, "linodeobjects": _7, "barsycenter": _4, "barsyonline": _4, "miniserver": _4, "meteorapp": { "$": 2, "succ": { "eu": _4 } }, "4u": _4, "nfshost": _4, "001www": _4, "ddnslive": _4, "myiphost": _4, "blogsyte": _4, "ciscofreak": _4, "damnserver": _4, "ditchyourip": _4, "dnsiskinky": _4, "dynns": _4, "geekgalaxy": _4, "health-carereform": _4, "homesecuritymac": _4, "homesecuritypc": _4, "myactivedirectory": _4, "mysecuritycamera": _4, "net-freaks": _4, "onthewifi": _4, "point2this": _4, "quicksytes": _4, "securitytactics": _4, "serveexchange": _4, "servehumour": _4, "servep2p": _4, "servesarcasm": _4, "stufftoread": _4, "unusualperson": _4, "workisboring": _4, "3utilities": _4, "ddnsking": _4, "myvnc": _4, "servebeer": _4, "servecounterstrike": _4, "serveftp": _4, "servegame": _4, "servehalflife": _4, "servehttp": _4, "serveirc": _4, "servemp3": _4, "servepics": _4, "servequake": _4, "observableusercontent": { "$": 0, "succ": { "static": _4 } }, "operaunite": _4, "skygearapp": _4, "outsystemscloud": _4, "ownprovider": _4, "pgfog": _4, "pagefrontapp": _4, "pagexl": _4, "gotpantheon": _4, "platter-app": _4, "pleskns": _4, "prgmr": { "$": 0, "succ": { "xen": _4 } }, "qualifioapp": _4, "qbuser": _4, "qa2": _4, "dev-myqnapcloud": _4, "alpha-myqnapcloud": _4, "myqnapcloud": _4, "quipelements": _7, "rackmaze": _4, "rhcloud": _4, "render": _16, "onrender": _4, "logoip": _4, "scrysec": _4, "firewall-gateway": _4, "myshopblocks": _4, "shopitsite": _4, "1kapp": _4, "appchizi": _4, "applinzi": _4, "sinaapp": _4, "vipsinaapp": _4, "bounty-full": { "$": 2, "succ": { "alpha": _4, "beta": _4 } }, "stackhero-network": _4, "playstation-cloud": _4, "stdlib": { "$": 0, "succ": { "api": _4 } }, "temp-dns": _4, "dsmynas": _4, "familyds": _4, "thingdustdata": _4, "bloxcms": _4, "townnews-staging": _4, "hk": _4, "wafflecell": _4, "remotewd": _4, "wiardweb": { "$": 0, "succ": { "pages": _4 } }, "xnbay": { "$": 2, "succ": { "u2": _4, "u2-local": _4 } }, "yolasite": _4, "wpenginepowered": _4, "impertrixcdn": _4, "impertrix": _4 } }, "coop": _2, "cr": { "$": 1, "succ": { "ac": _2, "co": _2, "ed": _2, "fi": _2, "go": _2, "or": _2, "sa": _2 } }, "cu": { "$": 1, "succ": { "com": _2, "edu": _2, "org": _2, "net": _2, "gov": _2, "inf": _2 } }, "cv": _5, "cw": { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2 } }, "cx": { "$": 1, "succ": { "gov": _2, "ath": _4, "info": _4 } }, "cy": { "$": 1, "succ": { "ac": _2, "biz": _2, "com": { "$": 1, "succ": { "blogspot": _4, "scaleforce": _17 } }, "ekloges": _2, "gov": _2, "ltd": _2, "name": _2, "net": _2, "org": _2, "parliament": _2, "press": _2, "pro": _2, "tm": _2 } }, "cz": { "$": 1, "succ": { "co": _4, "realm": _4, "e4": _4, "blogspot": _4, "metacentrum": { "$": 0, "succ": { "cloud": _4, "custom": _4 } }, "muni": { "$": 0, "succ": { "cloud": { "$": 0, "succ": { "flt": _4, "usr": _4 } } } } } }, "de": { "$": 1, "succ": { "bplaced": _4, "square7": _4, "com": _4, "cosidns": { "$": 0, "succ": { "dyn": _4 } }, "dynamisches-dns": _4, "dnsupdater": _4, "internet-dns": _4, "l-o-g-i-n": _4, "dnshome": _4, "fuettertdasnetz": _4, "isteingeek": _4, "istmein": _4, "lebtimnetz": _4, "leitungsen": _4, "traeumtgerade": _4, "ddnss": { "$": 2, "succ": { "dyn": _4, "dyndns": _4 } }, "dyndns1": _4, "dyn-ip24": _4, "home-webserver": { "$": 2, "succ": { "dyn": _4 } }, "myhome-server": _4, "goip": _4, "blogspot": _4, "dyn-berlin": _4, "in-berlin": _4, "in-brb": _4, "in-butter": _4, "in-dsl": _4, "in-vpn": _4, "mein-iserv": _4, "schulserver": _4, "test-iserv": _4, "keymachine": _4, "git-repos": _4, "lcube-server": _4, "svn-repos": _4, "barsy": _4, "logoip": _4, "firewall-gateway": _4, "my-gateway": _4, "my-router": _4, "spdns": _4, "speedpartner": { "$": 0, "succ": { "customer": _4 } }, "taifun-dns": _4, "12hp": _4, "2ix": _4, "4lima": _4, "lima-city": _4, "dd-dns": _4, "dray-dns": _4, "draydns": _4, "dyn-vpn": _4, "dynvpn": _4, "mein-vigor": _4, "my-vigor": _4, "my-wan": _4, "syno-ds": _4, "synology-diskstation": _4, "synology-ds": _4, "uberspace": _7, "virtualuser": _4, "virtual-user": _4, "community-pro": _4, "diskussionsbereich": _4 } }, "dj": _2, "dk": { "$": 1, "succ": { "biz": _4, "co": _4, "firm": _4, "reg": _4, "store": _4, "blogspot": _4 } }, "dm": _9, "do": { "$": 1, "succ": { "art": _2, "com": _2, "edu": _2, "gob": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "sld": _2, "web": _2 } }, "dz": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "gov": _2, "edu": _2, "asso": _2, "pol": _2, "art": _2 } }, "ec": { "$": 1, "succ": { "com": _2, "info": _2, "net": _2, "fin": _2, "k12": _2, "med": _2, "pro": _2, "org": _2, "edu": _2, "gov": _2, "gob": _2, "mil": _2, "nym": _4 } }, "edu": { "$": 1, "succ": { "rit": { "$": 0, "succ": { "git-pages": _4 } } } }, "ee": { "$": 1, "succ": { "edu": _2, "gov": _2, "riik": _2, "lib": _2, "med": _2, "com": _5, "pri": _2, "aip": _2, "org": _2, "fie": _2 } }, "eg": { "$": 1, "succ": { "com": _5, "edu": _2, "eun": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sci": _2 } }, "er": _8, "es": { "$": 1, "succ": { "com": _5, "nom": _2, "org": _2, "gob": _2, "edu": _2 } }, "et": { "$": 1, "succ": { "com": _2, "gov": _2, "org": _2, "edu": _2, "biz": _2, "name": _2, "info": _2, "net": _2 } }, "eu": { "$": 1, "succ": { "mycd": _4, "cloudns": _4, "barsy": _4, "wellbeingzone": _4, "spdns": _4, "transurl": _7, "diskstation": _4 } }, "fi": { "$": 1, "succ": { "aland": _2, "dy": _4, "blogspot": _4, "xn--hkkinen-5wa": _4, "häkkinen": _4, "iki": _4 } }, "fj": { "$": 1, "succ": { "ac": _2, "biz": _2, "com": _2, "gov": _2, "info": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "pro": _2 } }, "fk": _8, "fm": _2, "fo": _2, "fr": { "$": 1, "succ": { "asso": _2, "com": _2, "gouv": _2, "nom": _2, "prd": _2, "tm": _2, "aeroport": _2, "avocat": _2, "avoues": _2, "cci": _2, "chambagri": _2, "chirurgiens-dentistes": _2, "experts-comptables": _2, "geometre-expert": _2, "greta": _2, "huissier-justice": _2, "medecin": _2, "notaires": _2, "pharmacien": _2, "port": _2, "veterinaire": _2, "en-root": _4, "fbx-os": _4, "fbxos": _4, "freebox-os": _4, "freeboxos": _4, "blogspot": _4, "on-web": _4, "chirurgiens-dentistes-en-france": _4 } }, "ga": _2, "gb": _2, "gd": { "$": 1, "succ": { "nom": _4 } }, "ge": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "net": _2, "pvt": _2, "nom": _4 } }, "gf": _2, "gg": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "kaas": _4, "cya": _4, "panel": { "$": 2, "succ": { "daemon": _4 } } } }, "gh": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2 } }, "gi": { "$": 1, "succ": { "com": _2, "ltd": _2, "gov": _2, "mod": _2, "edu": _2, "org": _2 } }, "gl": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "net": _2, "org": _2, "biz": _4, "nom": _4, "xx": _4 } }, "gm": _2, "gn": { "$": 1, "succ": { "ac": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2 } }, "gov": _2, "gp": { "$": 1, "succ": { "com": _2, "net": _2, "mobi": _2, "edu": _2, "org": _2, "asso": _2, "app": _4 } }, "gq": _2, "gr": { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2, "gov": _2, "blogspot": _4, "nym": _4 } }, "gs": _2, "gt": { "$": 1, "succ": { "com": _2, "edu": _2, "gob": _2, "ind": _2, "mil": _2, "net": _2, "org": _2, "nom": _4, "blog": _4, "de": _4, "to": _4 } }, "gu": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "guam": _2, "info": _2, "net": _2, "org": _2, "web": _2 } }, "gw": _2, "gy": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "nym": _4, "be": _4 } }, "hk": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "idv": _2, "net": _2, "org": _2, "xn--55qx5d": _2, "公司": _2, "xn--wcvs22d": _2, "教育": _2, "xn--lcvr32d": _2, "敎育": _2, "xn--mxtq1m": _2, "政府": _2, "xn--gmqw5a": _2, "個人": _2, "xn--ciqpn": _2, "个人": _2, "xn--gmq050i": _2, "箇人": _2, "xn--zf0avx": _2, "網络": _2, "xn--io0a7i": _2, "网络": _2, "xn--mk0axi": _2, "组織": _2, "xn--od0alg": _2, "網絡": _2, "xn--od0aq3b": _2, "网絡": _2, "xn--tn0ag": _2, "组织": _2, "xn--uc0atv": _2, "組織": _2, "xn--uc0ay4a": _2, "組织": _2, "blogspot": _4, "nym": _4, "ltd": _4, "inc": _4 } }, "hm": _2, "hn": { "$": 1, "succ": { "com": _2, "edu": _2, "org": _2, "net": _2, "mil": _2, "gob": _2, "nom": _4, "cc": _4 } }, "hr": { "$": 1, "succ": { "iz": _2, "from": _2, "name": _2, "com": _2, "blogspot": _4, "free": _4 } }, "ht": { "$": 1, "succ": { "com": _2, "shop": _2, "firm": _2, "info": _2, "adult": _2, "net": _2, "pro": _2, "org": _2, "med": _2, "art": _2, "coop": _2, "pol": _2, "asso": _2, "edu": _2, "rel": _2, "gouv": _2, "perso": _2 } }, "hu": { "$": 1, "succ": { "2000": _2, "co": _2, "info": _2, "org": _2, "priv": _2, "sport": _2, "tm": _2, "agrar": _2, "bolt": _2, "casino": _2, "city": _2, "erotica": _2, "erotika": _2, "film": _2, "forum": _2, "games": _2, "hotel": _2, "ingatlan": _2, "jogasz": _2, "konyvelo": _2, "lakas": _2, "media": _2, "news": _2, "reklam": _2, "sex": _2, "shop": _2, "suli": _2, "szex": _2, "tozsde": _2, "utazas": _2, "video": _2, "blogspot": _4 } }, "id": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _5, "desa": _2, "go": _2, "mil": _2, "my": _2, "net": _2, "or": _2, "ponpes": _2, "sch": _2, "web": _2 } }, "ie": _20, "il": { "$": 1, "succ": { "ac": _2, "co": _5, "gov": _2, "idf": _2, "k12": _2, "muni": _2, "net": _2, "org": _2 } }, "im": { "$": 1, "succ": { "ac": _2, "co": { "$": 1, "succ": { "ltd": _2, "plc": _2 } }, "com": _2, "net": _2, "org": _2, "tt": _2, "tv": _2, "ro": _4, "nom": _4 } }, "in": { "$": 1, "succ": { "co": _2, "firm": _2, "net": _2, "org": _2, "gen": _2, "ind": _2, "nic": _2, "ac": _2, "edu": _2, "res": _2, "gov": _2, "mil": _2, "cloudns": _4, "blogspot": _4, "barsy": _4 } }, "info": { "$": 1, "succ": { "cloudns": _4, "dynamic-dns": _4, "dyndns": _4, "barrel-of-knowledge": _4, "barrell-of-knowledge": _4, "for-our": _4, "groks-the": _4, "groks-this": _4, "here-for-more": _4, "knowsitall": _4, "selfip": _4, "webhop": _4, "barsy": _4, "mayfirst": _4, "forumz": _4, "nsupdate": _4, "dvrcam": _4, "ilovecollege": _4, "no-ip": _4, "dnsupdate": _4, "v-info": _4 } }, "int": { "$": 1, "succ": { "eu": _2 } }, "io": { "$": 1, "succ": { "2038": _4, "com": _2, "apigee": _4, "b-data": _4, "backplaneapp": _4, "banzaicloud": { "$": 0, "succ": { "app": _4, "backyards": _7 } }, "boxfuse": _4, "browsersafetymark": _4, "bigv": { "$": 0, "succ": { "uk0": _4 } }, "cleverapps": _4, "dappnode": { "$": 0, "succ": { "dyndns": _4 } }, "dedyn": _4, "drud": _4, "definima": _4, "enonic": { "$": 2, "succ": { "customer": _4 } }, "shw": _4, "github": _4, "gitlab": _4, "lolipop": _4, "hasura-app": _4, "hostyhosting": _4, "moonscale": _7, "jele": _4, "loginline": _4, "barsy": _4, "azurecontainer": _7, "ngrok": _4, "nodeart": { "$": 0, "succ": { "stage": _4 } }, "nodum": _4, "nid": _4, "pantheonsite": _4, "dyn53": _4, "protonet": _4, "qcx": { "$": 2, "succ": { "sys": _7 } }, "vaporcloud": _4, "vbrplsbx": { "$": 0, "succ": { "g": _4 } }, "on-k3s": _7, "on-rio": _7, "readthedocs": _4, "resindevice": _4, "resinstaging": { "$": 0, "succ": { "devices": _4 } }, "hzc": _4, "sandcats": _4, "shiftedit": _4, "mo-siemens": _4, "lair": _15, "stolos": _7, "spacekit": _4, "utwente": _4, "applicationcloud": _4, "scapp": _4, "s5y": _7, "telebit": _4, "thingdust": { "$": 0, "succ": { "dev": _21, "disrec": _21, "prod": _21, "testing": _21 } }, "wedeploy": _4, "basicserver": _4, "virtualserver": _4 } }, "iq": _3, "ir": { "$": 1, "succ": { "ac": _2, "co": _2, "gov": _2, "id": _2, "net": _2, "org": _2, "sch": _2, "xn--mgba3a4f16a": _2, "ایران": _2, "xn--mgba3a4fra": _2, "ايران": _2 } }, "is": { "$": 1, "succ": { "net": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "int": _2, "cupcake": _4, "blogspot": _4 } }, "it": { "$": 1, "succ": { "gov": _2, "edu": _2, "abr": _2, "abruzzo": _2, "aosta-valley": _2, "aostavalley": _2, "bas": _2, "basilicata": _2, "cal": _2, "calabria": _2, "cam": _2, "campania": _2, "emilia-romagna": _2, "emiliaromagna": _2, "emr": _2, "friuli-v-giulia": _2, "friuli-ve-giulia": _2, "friuli-vegiulia": _2, "friuli-venezia-giulia": _2, "friuli-veneziagiulia": _2, "friuli-vgiulia": _2, "friuliv-giulia": _2, "friulive-giulia": _2, "friulivegiulia": _2, "friulivenezia-giulia": _2, "friuliveneziagiulia": _2, "friulivgiulia": _2, "fvg": _2, "laz": _2, "lazio": _2, "lig": _2, "liguria": _2, "lom": _2, "lombardia": _2, "lombardy": _2, "lucania": _2, "mar": _2, "marche": _2, "mol": _2, "molise": _2, "piedmont": _2, "piemonte": _2, "pmn": _2, "pug": _2, "puglia": _2, "sar": _2, "sardegna": _2, "sardinia": _2, "sic": _2, "sicilia": _2, "sicily": _2, "taa": _2, "tos": _2, "toscana": _2, "trentin-sud-tirol": _2, "xn--trentin-sd-tirol-rzb": _2, "trentin-süd-tirol": _2, "trentin-sudtirol": _2, "xn--trentin-sdtirol-7vb": _2, "trentin-südtirol": _2, "trentin-sued-tirol": _2, "trentin-suedtirol": _2, "trentino-a-adige": _2, "trentino-aadige": _2, "trentino-alto-adige": _2, "trentino-altoadige": _2, "trentino-s-tirol": _2, "trentino-stirol": _2, "trentino-sud-tirol": _2, "xn--trentino-sd-tirol-c3b": _2, "trentino-süd-tirol": _2, "trentino-sudtirol": _2, "xn--trentino-sdtirol-szb": _2, "trentino-südtirol": _2, "trentino-sued-tirol": _2, "trentino-suedtirol": _2, "trentino": _2, "trentinoa-adige": _2, "trentinoaadige": _2, "trentinoalto-adige": _2, "trentinoaltoadige": _2, "trentinos-tirol": _2, "trentinostirol": _2, "trentinosud-tirol": _2, "xn--trentinosd-tirol-rzb": _2, "trentinosüd-tirol": _2, "trentinosudtirol": _2, "xn--trentinosdtirol-7vb": _2, "trentinosüdtirol": _2, "trentinosued-tirol": _2, "trentinosuedtirol": _2, "trentinsud-tirol": _2, "xn--trentinsd-tirol-6vb": _2, "trentinsüd-tirol": _2, "trentinsudtirol": _2, "xn--trentinsdtirol-nsb": _2, "trentinsüdtirol": _2, "trentinsued-tirol": _2, "trentinsuedtirol": _2, "tuscany": _2, "umb": _2, "umbria": _2, "val-d-aosta": _2, "val-daosta": _2, "vald-aosta": _2, "valdaosta": _2, "valle-aosta": _2, "valle-d-aosta": _2, "valle-daosta": _2, "valleaosta": _2, "valled-aosta": _2, "valledaosta": _2, "vallee-aoste": _2, "xn--valle-aoste-ebb": _2, "vallée-aoste": _2, "vallee-d-aoste": _2, "xn--valle-d-aoste-ehb": _2, "vallée-d-aoste": _2, "valleeaoste": _2, "xn--valleaoste-e7a": _2, "valléeaoste": _2, "valleedaoste": _2, "xn--valledaoste-ebb": _2, "valléedaoste": _2, "vao": _2, "vda": _2, "ven": _2, "veneto": _2, "ag": _2, "agrigento": _2, "al": _2, "alessandria": _2, "alto-adige": _2, "altoadige": _2, "an": _2, "ancona": _2, "andria-barletta-trani": _2, "andria-trani-barletta": _2, "andriabarlettatrani": _2, "andriatranibarletta": _2, "ao": _2, "aosta": _2, "aoste": _2, "ap": _2, "aq": _2, "aquila": _2, "ar": _2, "arezzo": _2, "ascoli-piceno": _2, "ascolipiceno": _2, "asti": _2, "at": _2, "av": _2, "avellino": _2, "ba": _2, "balsan-sudtirol": _2, "xn--balsan-sdtirol-nsb": _2, "balsan-südtirol": _2, "balsan-suedtirol": _2, "balsan": _2, "bari": _2, "barletta-trani-andria": _2, "barlettatraniandria": _2, "belluno": _2, "benevento": _2, "bergamo": _2, "bg": _2, "bi": _2, "biella": _2, "bl": _2, "bn": _2, "bo": _2, "bologna": _2, "bolzano-altoadige": _2, "bolzano": _2, "bozen-sudtirol": _2, "xn--bozen-sdtirol-2ob": _2, "bozen-südtirol": _2, "bozen-suedtirol": _2, "bozen": _2, "br": _2, "brescia": _2, "brindisi": _2, "bs": _2, "bt": _2, "bulsan-sudtirol": _2, "xn--bulsan-sdtirol-nsb": _2, "bulsan-südtirol": _2, "bulsan-suedtirol": _2, "bulsan": _2, "bz": _2, "ca": _2, "cagliari": _2, "caltanissetta": _2, "campidano-medio": _2, "campidanomedio": _2, "campobasso": _2, "carbonia-iglesias": _2, "carboniaiglesias": _2, "carrara-massa": _2, "carraramassa": _2, "caserta": _2, "catania": _2, "catanzaro": _2, "cb": _2, "ce": _2, "cesena-forli": _2, "xn--cesena-forl-mcb": _2, "cesena-forlì": _2, "cesenaforli": _2, "xn--cesenaforl-i8a": _2, "cesenaforlì": _2, "ch": _2, "chieti": _2, "ci": _2, "cl": _2, "cn": _2, "co": _2, "como": _2, "cosenza": _2, "cr": _2, "cremona": _2, "crotone": _2, "cs": _2, "ct": _2, "cuneo": _2, "cz": _2, "dell-ogliastra": _2, "dellogliastra": _2, "en": _2, "enna": _2, "fc": _2, "fe": _2, "fermo": _2, "ferrara": _2, "fg": _2, "fi": _2, "firenze": _2, "florence": _2, "fm": _2, "foggia": _2, "forli-cesena": _2, "xn--forl-cesena-fcb": _2, "forlì-cesena": _2, "forlicesena": _2, "xn--forlcesena-c8a": _2, "forlìcesena": _2, "fr": _2, "frosinone": _2, "ge": _2, "genoa": _2, "genova": _2, "go": _2, "gorizia": _2, "gr": _2, "grosseto": _2, "iglesias-carbonia": _2, "iglesiascarbonia": _2, "im": _2, "imperia": _2, "is": _2, "isernia": _2, "kr": _2, "la-spezia": _2, "laquila": _2, "laspezia": _2, "latina": _2, "lc": _2, "le": _2, "lecce": _2, "lecco": _2, "li": _2, "livorno": _2, "lo": _2, "lodi": _2, "lt": _2, "lu": _2, "lucca": _2, "macerata": _2, "mantova": _2, "massa-carrara": _2, "massacarrara": _2, "matera": _2, "mb": _2, "mc": _2, "me": _2, "medio-campidano": _2, "mediocampidano": _2, "messina": _2, "mi": _2, "milan": _2, "milano": _2, "mn": _2, "mo": _2, "modena": _2, "monza-brianza": _2, "monza-e-della-brianza": _2, "monza": _2, "monzabrianza": _2, "monzaebrianza": _2, "monzaedellabrianza": _2, "ms": _2, "mt": _2, "na": _2, "naples": _2, "napoli": _2, "no": _2, "novara": _2, "nu": _2, "nuoro": _2, "og": _2, "ogliastra": _2, "olbia-tempio": _2, "olbiatempio": _2, "or": _2, "oristano": _2, "ot": _2, "pa": _2, "padova": _2, "padua": _2, "palermo": _2, "parma": _2, "pavia": _2, "pc": _2, "pd": _2, "pe": _2, "perugia": _2, "pesaro-urbino": _2, "pesarourbino": _2, "pescara": _2, "pg": _2, "pi": _2, "piacenza": _2, "pisa": _2, "pistoia": _2, "pn": _2, "po": _2, "pordenone": _2, "potenza": _2, "pr": _2, "prato": _2, "pt": _2, "pu": _2, "pv": _2, "pz": _2, "ra": _2, "ragusa": _2, "ravenna": _2, "rc": _2, "re": _2, "reggio-calabria": _2, "reggio-emilia": _2, "reggiocalabria": _2, "reggioemilia": _2, "rg": _2, "ri": _2, "rieti": _2, "rimini": _2, "rm": _2, "rn": _2, "ro": _2, "roma": _2, "rome": _2, "rovigo": _2, "sa": _2, "salerno": _2, "sassari": _2, "savona": _2, "si": _2, "siena": _2, "siracusa": _2, "so": _2, "sondrio": _2, "sp": _2, "sr": _2, "ss": _2, "suedtirol": _2, "xn--sdtirol-n2a": _2, "südtirol": _2, "sv": _2, "ta": _2, "taranto": _2, "te": _2, "tempio-olbia": _2, "tempioolbia": _2, "teramo": _2, "terni": _2, "tn": _2, "to": _2, "torino": _2, "tp": _2, "tr": _2, "trani-andria-barletta": _2, "trani-barletta-andria": _2, "traniandriabarletta": _2, "tranibarlettaandria": _2, "trapani": _2, "trento": _2, "treviso": _2, "trieste": _2, "ts": _2, "turin": _2, "tv": _2, "ud": _2, "udine": _2, "urbino-pesaro": _2, "urbinopesaro": _2, "va": _2, "varese": _2, "vb": _2, "vc": _2, "ve": _2, "venezia": _2, "venice": _2, "verbania": _2, "vercelli": _2, "verona": _2, "vi": _2, "vibo-valentia": _2, "vibovalentia": _2, "vicenza": _2, "viterbo": _2, "vr": _2, "vs": _2, "vt": _2, "vv": _2, "blogspot": _4, "16-b": _4, "32-b": _4, "64-b": _4, "syncloud": _4 } }, "je": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2 } }, "jm": _8, "jo": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "edu": _2, "sch": _2, "gov": _2, "mil": _2, "name": _2 } }, "jobs": _2, "jp": { "$": 1, "succ": { "ac": _2, "ad": _2, "co": _2, "ed": _2, "go": _2, "gr": _2, "lg": _2, "ne": { "$": 1, "succ": { "aseinet": _18, "gehirn": _4 } }, "or": _2, "aichi": { "$": 1, "succ": { "aisai": _2, "ama": _2, "anjo": _2, "asuke": _2, "chiryu": _2, "chita": _2, "fuso": _2, "gamagori": _2, "handa": _2, "hazu": _2, "hekinan": _2, "higashiura": _2, "ichinomiya": _2, "inazawa": _2, "inuyama": _2, "isshiki": _2, "iwakura": _2, "kanie": _2, "kariya": _2, "kasugai": _2, "kira": _2, "kiyosu": _2, "komaki": _2, "konan": _2, "kota": _2, "mihama": _2, "miyoshi": _2, "nishio": _2, "nisshin": _2, "obu": _2, "oguchi": _2, "oharu": _2, "okazaki": _2, "owariasahi": _2, "seto": _2, "shikatsu": _2, "shinshiro": _2, "shitara": _2, "tahara": _2, "takahama": _2, "tobishima": _2, "toei": _2, "togo": _2, "tokai": _2, "tokoname": _2, "toyoake": _2, "toyohashi": _2, "toyokawa": _2, "toyone": _2, "toyota": _2, "tsushima": _2, "yatomi": _2 } }, "akita": { "$": 1, "succ": { "akita": _2, "daisen": _2, "fujisato": _2, "gojome": _2, "hachirogata": _2, "happou": _2, "higashinaruse": _2, "honjo": _2, "honjyo": _2, "ikawa": _2, "kamikoani": _2, "kamioka": _2, "katagami": _2, "kazuno": _2, "kitaakita": _2, "kosaka": _2, "kyowa": _2, "misato": _2, "mitane": _2, "moriyoshi": _2, "nikaho": _2, "noshiro": _2, "odate": _2, "oga": _2, "ogata": _2, "semboku": _2, "yokote": _2, "yurihonjo": _2 } }, "aomori": { "$": 1, "succ": { "aomori": _2, "gonohe": _2, "hachinohe": _2, "hashikami": _2, "hiranai": _2, "hirosaki": _2, "itayanagi": _2, "kuroishi": _2, "misawa": _2, "mutsu": _2, "nakadomari": _2, "noheji": _2, "oirase": _2, "owani": _2, "rokunohe": _2, "sannohe": _2, "shichinohe": _2, "shingo": _2, "takko": _2, "towada": _2, "tsugaru": _2, "tsuruta": _2 } }, "chiba": { "$": 1, "succ": { "abiko": _2, "asahi": _2, "chonan": _2, "chosei": _2, "choshi": _2, "chuo": _2, "funabashi": _2, "futtsu": _2, "hanamigawa": _2, "ichihara": _2, "ichikawa": _2, "ichinomiya": _2, "inzai": _2, "isumi": _2, "kamagaya": _2, "kamogawa": _2, "kashiwa": _2, "katori": _2, "katsuura": _2, "kimitsu": _2, "kisarazu": _2, "kozaki": _2, "kujukuri": _2, "kyonan": _2, "matsudo": _2, "midori": _2, "mihama": _2, "minamiboso": _2, "mobara": _2, "mutsuzawa": _2, "nagara": _2, "nagareyama": _2, "narashino": _2, "narita": _2, "noda": _2, "oamishirasato": _2, "omigawa": _2, "onjuku": _2, "otaki": _2, "sakae": _2, "sakura": _2, "shimofusa": _2, "shirako": _2, "shiroi": _2, "shisui": _2, "sodegaura": _2, "sosa": _2, "tako": _2, "tateyama": _2, "togane": _2, "tohnosho": _2, "tomisato": _2, "urayasu": _2, "yachimata": _2, "yachiyo": _2, "yokaichiba": _2, "yokoshibahikari": _2, "yotsukaido": _2 } }, "ehime": { "$": 1, "succ": { "ainan": _2, "honai": _2, "ikata": _2, "imabari": _2, "iyo": _2, "kamijima": _2, "kihoku": _2, "kumakogen": _2, "masaki": _2, "matsuno": _2, "matsuyama": _2, "namikata": _2, "niihama": _2, "ozu": _2, "saijo": _2, "seiyo": _2, "shikokuchuo": _2, "tobe": _2, "toon": _2, "uchiko": _2, "uwajima": _2, "yawatahama": _2 } }, "fukui": { "$": 1, "succ": { "echizen": _2, "eiheiji": _2, "fukui": _2, "ikeda": _2, "katsuyama": _2, "mihama": _2, "minamiechizen": _2, "obama": _2, "ohi": _2, "ono": _2, "sabae": _2, "sakai": _2, "takahama": _2, "tsuruga": _2, "wakasa": _2 } }, "fukuoka": { "$": 1, "succ": { "ashiya": _2, "buzen": _2, "chikugo": _2, "chikuho": _2, "chikujo": _2, "chikushino": _2, "chikuzen": _2, "chuo": _2, "dazaifu": _2, "fukuchi": _2, "hakata": _2, "higashi": _2, "hirokawa": _2, "hisayama": _2, "iizuka": _2, "inatsuki": _2, "kaho": _2, "kasuga": _2, "kasuya": _2, "kawara": _2, "keisen": _2, "koga": _2, "kurate": _2, "kurogi": _2, "kurume": _2, "minami": _2, "miyako": _2, "miyama": _2, "miyawaka": _2, "mizumaki": _2, "munakata": _2, "nakagawa": _2, "nakama": _2, "nishi": _2, "nogata": _2, "ogori": _2, "okagaki": _2, "okawa": _2, "oki": _2, "omuta": _2, "onga": _2, "onojo": _2, "oto": _2, "saigawa": _2, "sasaguri": _2, "shingu": _2, "shinyoshitomi": _2, "shonai": _2, "soeda": _2, "sue": _2, "tachiarai": _2, "tagawa": _2, "takata": _2, "toho": _2, "toyotsu": _2, "tsuiki": _2, "ukiha": _2, "umi": _2, "usui": _2, "yamada": _2, "yame": _2, "yanagawa": _2, "yukuhashi": _2 } }, "fukushima": { "$": 1, "succ": { "aizubange": _2, "aizumisato": _2, "aizuwakamatsu": _2, "asakawa": _2, "bandai": _2, "date": _2, "fukushima": _2, "furudono": _2, "futaba": _2, "hanawa": _2, "higashi": _2, "hirata": _2, "hirono": _2, "iitate": _2, "inawashiro": _2, "ishikawa": _2, "iwaki": _2, "izumizaki": _2, "kagamiishi": _2, "kaneyama": _2, "kawamata": _2, "kitakata": _2, "kitashiobara": _2, "koori": _2, "koriyama": _2, "kunimi": _2, "miharu": _2, "mishima": _2, "namie": _2, "nango": _2, "nishiaizu": _2, "nishigo": _2, "okuma": _2, "omotego": _2, "ono": _2, "otama": _2, "samegawa": _2, "shimogo": _2, "shirakawa": _2, "showa": _2, "soma": _2, "sukagawa": _2, "taishin": _2, "tamakawa": _2, "tanagura": _2, "tenei": _2, "yabuki": _2, "yamato": _2, "yamatsuri": _2, "yanaizu": _2, "yugawa": _2 } }, "gifu": { "$": 1, "succ": { "anpachi": _2, "ena": _2, "gifu": _2, "ginan": _2, "godo": _2, "gujo": _2, "hashima": _2, "hichiso": _2, "hida": _2, "higashishirakawa": _2, "ibigawa": _2, "ikeda": _2, "kakamigahara": _2, "kani": _2, "kasahara": _2, "kasamatsu": _2, "kawaue": _2, "kitagata": _2, "mino": _2, "minokamo": _2, "mitake": _2, "mizunami": _2, "motosu": _2, "nakatsugawa": _2, "ogaki": _2, "sakahogi": _2, "seki": _2, "sekigahara": _2, "shirakawa": _2, "tajimi": _2, "takayama": _2, "tarui": _2, "toki": _2, "tomika": _2, "wanouchi": _2, "yamagata": _2, "yaotsu": _2, "yoro": _2 } }, "gunma": { "$": 1, "succ": { "annaka": _2, "chiyoda": _2, "fujioka": _2, "higashiagatsuma": _2, "isesaki": _2, "itakura": _2, "kanna": _2, "kanra": _2, "katashina": _2, "kawaba": _2, "kiryu": _2, "kusatsu": _2, "maebashi": _2, "meiwa": _2, "midori": _2, "minakami": _2, "naganohara": _2, "nakanojo": _2, "nanmoku": _2, "numata": _2, "oizumi": _2, "ora": _2, "ota": _2, "shibukawa": _2, "shimonita": _2, "shinto": _2, "showa": _2, "takasaki": _2, "takayama": _2, "tamamura": _2, "tatebayashi": _2, "tomioka": _2, "tsukiyono": _2, "tsumagoi": _2, "ueno": _2, "yoshioka": _2 } }, "hiroshima": { "$": 1, "succ": { "asaminami": _2, "daiwa": _2, "etajima": _2, "fuchu": _2, "fukuyama": _2, "hatsukaichi": _2, "higashihiroshima": _2, "hongo": _2, "jinsekikogen": _2, "kaita": _2, "kui": _2, "kumano": _2, "kure": _2, "mihara": _2, "miyoshi": _2, "naka": _2, "onomichi": _2, "osakikamijima": _2, "otake": _2, "saka": _2, "sera": _2, "seranishi": _2, "shinichi": _2, "shobara": _2, "takehara": _2 } }, "hokkaido": { "$": 1, "succ": { "abashiri": _2, "abira": _2, "aibetsu": _2, "akabira": _2, "akkeshi": _2, "asahikawa": _2, "ashibetsu": _2, "ashoro": _2, "assabu": _2, "atsuma": _2, "bibai": _2, "biei": _2, "bifuka": _2, "bihoro": _2, "biratori": _2, "chippubetsu": _2, "chitose": _2, "date": _2, "ebetsu": _2, "embetsu": _2, "eniwa": _2, "erimo": _2, "esan": _2, "esashi": _2, "fukagawa": _2, "fukushima": _2, "furano": _2, "furubira": _2, "haboro": _2, "hakodate": _2, "hamatonbetsu": _2, "hidaka": _2, "higashikagura": _2, "higashikawa": _2, "hiroo": _2, "hokuryu": _2, "hokuto": _2, "honbetsu": _2, "horokanai": _2, "horonobe": _2, "ikeda": _2, "imakane": _2, "ishikari": _2, "iwamizawa": _2, "iwanai": _2, "kamifurano": _2, "kamikawa": _2, "kamishihoro": _2, "kamisunagawa": _2, "kamoenai": _2, "kayabe": _2, "kembuchi": _2, "kikonai": _2, "kimobetsu": _2, "kitahiroshima": _2, "kitami": _2, "kiyosato": _2, "koshimizu": _2, "kunneppu": _2, "kuriyama": _2, "kuromatsunai": _2, "kushiro": _2, "kutchan": _2, "kyowa": _2, "mashike": _2, "matsumae": _2, "mikasa": _2, "minamifurano": _2, "mombetsu": _2, "moseushi": _2, "mukawa": _2, "muroran": _2, "naie": _2, "nakagawa": _2, "nakasatsunai": _2, "nakatombetsu": _2, "nanae": _2, "nanporo": _2, "nayoro": _2, "nemuro": _2, "niikappu": _2, "niki": _2, "nishiokoppe": _2, "noboribetsu": _2, "numata": _2, "obihiro": _2, "obira": _2, "oketo": _2, "okoppe": _2, "otaru": _2, "otobe": _2, "otofuke": _2, "otoineppu": _2, "oumu": _2, "ozora": _2, "pippu": _2, "rankoshi": _2, "rebun": _2, "rikubetsu": _2, "rishiri": _2, "rishirifuji": _2, "saroma": _2, "sarufutsu": _2, "shakotan": _2, "shari": _2, "shibecha": _2, "shibetsu": _2, "shikabe": _2, "shikaoi": _2, "shimamaki": _2, "shimizu": _2, "shimokawa": _2, "shinshinotsu": _2, "shintoku": _2, "shiranuka": _2, "shiraoi": _2, "shiriuchi": _2, "sobetsu": _2, "sunagawa": _2, "taiki": _2, "takasu": _2, "takikawa": _2, "takinoue": _2, "teshikaga": _2, "tobetsu": _2, "tohma": _2, "tomakomai": _2, "tomari": _2, "toya": _2, "toyako": _2, "toyotomi": _2, "toyoura": _2, "tsubetsu": _2, "tsukigata": _2, "urakawa": _2, "urausu": _2, "uryu": _2, "utashinai": _2, "wakkanai": _2, "wassamu": _2, "yakumo": _2, "yoichi": _2 } }, "hyogo": { "$": 1, "succ": { "aioi": _2, "akashi": _2, "ako": _2, "amagasaki": _2, "aogaki": _2, "asago": _2, "ashiya": _2, "awaji": _2, "fukusaki": _2, "goshiki": _2, "harima": _2, "himeji": _2, "ichikawa": _2, "inagawa": _2, "itami": _2, "kakogawa": _2, "kamigori": _2, "kamikawa": _2, "kasai": _2, "kasuga": _2, "kawanishi": _2, "miki": _2, "minamiawaji": _2, "nishinomiya": _2, "nishiwaki": _2, "ono": _2, "sanda": _2, "sannan": _2, "sasayama": _2, "sayo": _2, "shingu": _2, "shinonsen": _2, "shiso": _2, "sumoto": _2, "taishi": _2, "taka": _2, "takarazuka": _2, "takasago": _2, "takino": _2, "tamba": _2, "tatsuno": _2, "toyooka": _2, "yabu": _2, "yashiro": _2, "yoka": _2, "yokawa": _2 } }, "ibaraki": { "$": 1, "succ": { "ami": _2, "asahi": _2, "bando": _2, "chikusei": _2, "daigo": _2, "fujishiro": _2, "hitachi": _2, "hitachinaka": _2, "hitachiomiya": _2, "hitachiota": _2, "ibaraki": _2, "ina": _2, "inashiki": _2, "itako": _2, "iwama": _2, "joso": _2, "kamisu": _2, "kasama": _2, "kashima": _2, "kasumigaura": _2, "koga": _2, "miho": _2, "mito": _2, "moriya": _2, "naka": _2, "namegata": _2, "oarai": _2, "ogawa": _2, "omitama": _2, "ryugasaki": _2, "sakai": _2, "sakuragawa": _2, "shimodate": _2, "shimotsuma": _2, "shirosato": _2, "sowa": _2, "suifu": _2, "takahagi": _2, "tamatsukuri": _2, "tokai": _2, "tomobe": _2, "tone": _2, "toride": _2, "tsuchiura": _2, "tsukuba": _2, "uchihara": _2, "ushiku": _2, "yachiyo": _2, "yamagata": _2, "yawara": _2, "yuki": _2 } }, "ishikawa": { "$": 1, "succ": { "anamizu": _2, "hakui": _2, "hakusan": _2, "kaga": _2, "kahoku": _2, "kanazawa": _2, "kawakita": _2, "komatsu": _2, "nakanoto": _2, "nanao": _2, "nomi": _2, "nonoichi": _2, "noto": _2, "shika": _2, "suzu": _2, "tsubata": _2, "tsurugi": _2, "uchinada": _2, "wajima": _2 } }, "iwate": { "$": 1, "succ": { "fudai": _2, "fujisawa": _2, "hanamaki": _2, "hiraizumi": _2, "hirono": _2, "ichinohe": _2, "ichinoseki": _2, "iwaizumi": _2, "iwate": _2, "joboji": _2, "kamaishi": _2, "kanegasaki": _2, "karumai": _2, "kawai": _2, "kitakami": _2, "kuji": _2, "kunohe": _2, "kuzumaki": _2, "miyako": _2, "mizusawa": _2, "morioka": _2, "ninohe": _2, "noda": _2, "ofunato": _2, "oshu": _2, "otsuchi": _2, "rikuzentakata": _2, "shiwa": _2, "shizukuishi": _2, "sumita": _2, "tanohata": _2, "tono": _2, "yahaba": _2, "yamada": _2 } }, "kagawa": { "$": 1, "succ": { "ayagawa": _2, "higashikagawa": _2, "kanonji": _2, "kotohira": _2, "manno": _2, "marugame": _2, "mitoyo": _2, "naoshima": _2, "sanuki": _2, "tadotsu": _2, "takamatsu": _2, "tonosho": _2, "uchinomi": _2, "utazu": _2, "zentsuji": _2 } }, "kagoshima": { "$": 1, "succ": { "akune": _2, "amami": _2, "hioki": _2, "isa": _2, "isen": _2, "izumi": _2, "kagoshima": _2, "kanoya": _2, "kawanabe": _2, "kinko": _2, "kouyama": _2, "makurazaki": _2, "matsumoto": _2, "minamitane": _2, "nakatane": _2, "nishinoomote": _2, "satsumasendai": _2, "soo": _2, "tarumizu": _2, "yusui": _2 } }, "kanagawa": { "$": 1, "succ": { "aikawa": _2, "atsugi": _2, "ayase": _2, "chigasaki": _2, "ebina": _2, "fujisawa": _2, "hadano": _2, "hakone": _2, "hiratsuka": _2, "isehara": _2, "kaisei": _2, "kamakura": _2, "kiyokawa": _2, "matsuda": _2, "minamiashigara": _2, "miura": _2, "nakai": _2, "ninomiya": _2, "odawara": _2, "oi": _2, "oiso": _2, "sagamihara": _2, "samukawa": _2, "tsukui": _2, "yamakita": _2, "yamato": _2, "yokosuka": _2, "yugawara": _2, "zama": _2, "zushi": _2 } }, "kochi": { "$": 1, "succ": { "aki": _2, "geisei": _2, "hidaka": _2, "higashitsuno": _2, "ino": _2, "kagami": _2, "kami": _2, "kitagawa": _2, "kochi": _2, "mihara": _2, "motoyama": _2, "muroto": _2, "nahari": _2, "nakamura": _2, "nankoku": _2, "nishitosa": _2, "niyodogawa": _2, "ochi": _2, "okawa": _2, "otoyo": _2, "otsuki": _2, "sakawa": _2, "sukumo": _2, "susaki": _2, "tosa": _2, "tosashimizu": _2, "toyo": _2, "tsuno": _2, "umaji": _2, "yasuda": _2, "yusuhara": _2 } }, "kumamoto": { "$": 1, "succ": { "amakusa": _2, "arao": _2, "aso": _2, "choyo": _2, "gyokuto": _2, "kamiamakusa": _2, "kikuchi": _2, "kumamoto": _2, "mashiki": _2, "mifune": _2, "minamata": _2, "minamioguni": _2, "nagasu": _2, "nishihara": _2, "oguni": _2, "ozu": _2, "sumoto": _2, "takamori": _2, "uki": _2, "uto": _2, "yamaga": _2, "yamato": _2, "yatsushiro": _2 } }, "kyoto": { "$": 1, "succ": { "ayabe": _2, "fukuchiyama": _2, "higashiyama": _2, "ide": _2, "ine": _2, "joyo": _2, "kameoka": _2, "kamo": _2, "kita": _2, "kizu": _2, "kumiyama": _2, "kyotamba": _2, "kyotanabe": _2, "kyotango": _2, "maizuru": _2, "minami": _2, "minamiyamashiro": _2, "miyazu": _2, "muko": _2, "nagaokakyo": _2, "nakagyo": _2, "nantan": _2, "oyamazaki": _2, "sakyo": _2, "seika": _2, "tanabe": _2, "uji": _2, "ujitawara": _2, "wazuka": _2, "yamashina": _2, "yawata": _2 } }, "mie": { "$": 1, "succ": { "asahi": _2, "inabe": _2, "ise": _2, "kameyama": _2, "kawagoe": _2, "kiho": _2, "kisosaki": _2, "kiwa": _2, "komono": _2, "kumano": _2, "kuwana": _2, "matsusaka": _2, "meiwa": _2, "mihama": _2, "minamiise": _2, "misugi": _2, "miyama": _2, "nabari": _2, "shima": _2, "suzuka": _2, "tado": _2, "taiki": _2, "taki": _2, "tamaki": _2, "toba": _2, "tsu": _2, "udono": _2, "ureshino": _2, "watarai": _2, "yokkaichi": _2 } }, "miyagi": { "$": 1, "succ": { "furukawa": _2, "higashimatsushima": _2, "ishinomaki": _2, "iwanuma": _2, "kakuda": _2, "kami": _2, "kawasaki": _2, "marumori": _2, "matsushima": _2, "minamisanriku": _2, "misato": _2, "murata": _2, "natori": _2, "ogawara": _2, "ohira": _2, "onagawa": _2, "osaki": _2, "rifu": _2, "semine": _2, "shibata": _2, "shichikashuku": _2, "shikama": _2, "shiogama": _2, "shiroishi": _2, "tagajo": _2, "taiwa": _2, "tome": _2, "tomiya": _2, "wakuya": _2, "watari": _2, "yamamoto": _2, "zao": _2 } }, "miyazaki": { "$": 1, "succ": { "aya": _2, "ebino": _2, "gokase": _2, "hyuga": _2, "kadogawa": _2, "kawaminami": _2, "kijo": _2, "kitagawa": _2, "kitakata": _2, "kitaura": _2, "kobayashi": _2, "kunitomi": _2, "kushima": _2, "mimata": _2, "miyakonojo": _2, "miyazaki": _2, "morotsuka": _2, "nichinan": _2, "nishimera": _2, "nobeoka": _2, "saito": _2, "shiiba": _2, "shintomi": _2, "takaharu": _2, "takanabe": _2, "takazaki": _2, "tsuno": _2 } }, "nagano": { "$": 1, "succ": { "achi": _2, "agematsu": _2, "anan": _2, "aoki": _2, "asahi": _2, "azumino": _2, "chikuhoku": _2, "chikuma": _2, "chino": _2, "fujimi": _2, "hakuba": _2, "hara": _2, "hiraya": _2, "iida": _2, "iijima": _2, "iiyama": _2, "iizuna": _2, "ikeda": _2, "ikusaka": _2, "ina": _2, "karuizawa": _2, "kawakami": _2, "kiso": _2, "kisofukushima": _2, "kitaaiki": _2, "komagane": _2, "komoro": _2, "matsukawa": _2, "matsumoto": _2, "miasa": _2, "minamiaiki": _2, "minamimaki": _2, "minamiminowa": _2, "minowa": _2, "miyada": _2, "miyota": _2, "mochizuki": _2, "nagano": _2, "nagawa": _2, "nagiso": _2, "nakagawa": _2, "nakano": _2, "nozawaonsen": _2, "obuse": _2, "ogawa": _2, "okaya": _2, "omachi": _2, "omi": _2, "ookuwa": _2, "ooshika": _2, "otaki": _2, "otari": _2, "sakae": _2, "sakaki": _2, "saku": _2, "sakuho": _2, "shimosuwa": _2, "shinanomachi": _2, "shiojiri": _2, "suwa": _2, "suzaka": _2, "takagi": _2, "takamori": _2, "takayama": _2, "tateshina": _2, "tatsuno": _2, "togakushi": _2, "togura": _2, "tomi": _2, "ueda": _2, "wada": _2, "yamagata": _2, "yamanouchi": _2, "yasaka": _2, "yasuoka": _2 } }, "nagasaki": { "$": 1, "succ": { "chijiwa": _2, "futsu": _2, "goto": _2, "hasami": _2, "hirado": _2, "iki": _2, "isahaya": _2, "kawatana": _2, "kuchinotsu": _2, "matsuura": _2, "nagasaki": _2, "obama": _2, "omura": _2, "oseto": _2, "saikai": _2, "sasebo": _2, "seihi": _2, "shimabara": _2, "shinkamigoto": _2, "togitsu": _2, "tsushima": _2, "unzen": _2 } }, "nara": { "$": 1, "succ": { "ando": _2, "gose": _2, "heguri": _2, "higashiyoshino": _2, "ikaruga": _2, "ikoma": _2, "kamikitayama": _2, "kanmaki": _2, "kashiba": _2, "kashihara": _2, "katsuragi": _2, "kawai": _2, "kawakami": _2, "kawanishi": _2, "koryo": _2, "kurotaki": _2, "mitsue": _2, "miyake": _2, "nara": _2, "nosegawa": _2, "oji": _2, "ouda": _2, "oyodo": _2, "sakurai": _2, "sango": _2, "shimoichi": _2, "shimokitayama": _2, "shinjo": _2, "soni": _2, "takatori": _2, "tawaramoto": _2, "tenkawa": _2, "tenri": _2, "uda": _2, "yamatokoriyama": _2, "yamatotakada": _2, "yamazoe": _2, "yoshino": _2 } }, "niigata": { "$": 1, "succ": { "aga": _2, "agano": _2, "gosen": _2, "itoigawa": _2, "izumozaki": _2, "joetsu": _2, "kamo": _2, "kariwa": _2, "kashiwazaki": _2, "minamiuonuma": _2, "mitsuke": _2, "muika": _2, "murakami": _2, "myoko": _2, "nagaoka": _2, "niigata": _2, "ojiya": _2, "omi": _2, "sado": _2, "sanjo": _2, "seiro": _2, "seirou": _2, "sekikawa": _2, "shibata": _2, "tagami": _2, "tainai": _2, "tochio": _2, "tokamachi": _2, "tsubame": _2, "tsunan": _2, "uonuma": _2, "yahiko": _2, "yoita": _2, "yuzawa": _2 } }, "oita": { "$": 1, "succ": { "beppu": _2, "bungoono": _2, "bungotakada": _2, "hasama": _2, "hiji": _2, "himeshima": _2, "hita": _2, "kamitsue": _2, "kokonoe": _2, "kuju": _2, "kunisaki": _2, "kusu": _2, "oita": _2, "saiki": _2, "taketa": _2, "tsukumi": _2, "usa": _2, "usuki": _2, "yufu": _2 } }, "okayama": { "$": 1, "succ": { "akaiwa": _2, "asakuchi": _2, "bizen": _2, "hayashima": _2, "ibara": _2, "kagamino": _2, "kasaoka": _2, "kibichuo": _2, "kumenan": _2, "kurashiki": _2, "maniwa": _2, "misaki": _2, "nagi": _2, "niimi": _2, "nishiawakura": _2, "okayama": _2, "satosho": _2, "setouchi": _2, "shinjo": _2, "shoo": _2, "soja": _2, "takahashi": _2, "tamano": _2, "tsuyama": _2, "wake": _2, "yakage": _2 } }, "okinawa": { "$": 1, "succ": { "aguni": _2, "ginowan": _2, "ginoza": _2, "gushikami": _2, "haebaru": _2, "higashi": _2, "hirara": _2, "iheya": _2, "ishigaki": _2, "ishikawa": _2, "itoman": _2, "izena": _2, "kadena": _2, "kin": _2, "kitadaito": _2, "kitanakagusuku": _2, "kumejima": _2, "kunigami": _2, "minamidaito": _2, "motobu": _2, "nago": _2, "naha": _2, "nakagusuku": _2, "nakijin": _2, "nanjo": _2, "nishihara": _2, "ogimi": _2, "okinawa": _2, "onna": _2, "shimoji": _2, "taketomi": _2, "tarama": _2, "tokashiki": _2, "tomigusuku": _2, "tonaki": _2, "urasoe": _2, "uruma": _2, "yaese": _2, "yomitan": _2, "yonabaru": _2, "yonaguni": _2, "zamami": _2 } }, "osaka": { "$": 1, "succ": { "abeno": _2, "chihayaakasaka": _2, "chuo": _2, "daito": _2, "fujiidera": _2, "habikino": _2, "hannan": _2, "higashiosaka": _2, "higashisumiyoshi": _2, "higashiyodogawa": _2, "hirakata": _2, "ibaraki": _2, "ikeda": _2, "izumi": _2, "izumiotsu": _2, "izumisano": _2, "kadoma": _2, "kaizuka": _2, "kanan": _2, "kashiwara": _2, "katano": _2, "kawachinagano": _2, "kishiwada": _2, "kita": _2, "kumatori": _2, "matsubara": _2, "minato": _2, "minoh": _2, "misaki": _2, "moriguchi": _2, "neyagawa": _2, "nishi": _2, "nose": _2, "osakasayama": _2, "sakai": _2, "sayama": _2, "sennan": _2, "settsu": _2, "shijonawate": _2, "shimamoto": _2, "suita": _2, "tadaoka": _2, "taishi": _2, "tajiri": _2, "takaishi": _2, "takatsuki": _2, "tondabayashi": _2, "toyonaka": _2, "toyono": _2, "yao": _2 } }, "saga": { "$": 1, "succ": { "ariake": _2, "arita": _2, "fukudomi": _2, "genkai": _2, "hamatama": _2, "hizen": _2, "imari": _2, "kamimine": _2, "kanzaki": _2, "karatsu": _2, "kashima": _2, "kitagata": _2, "kitahata": _2, "kiyama": _2, "kouhoku": _2, "kyuragi": _2, "nishiarita": _2, "ogi": _2, "omachi": _2, "ouchi": _2, "saga": _2, "shiroishi": _2, "taku": _2, "tara": _2, "tosu": _2, "yoshinogari": _2 } }, "saitama": { "$": 1, "succ": { "arakawa": _2, "asaka": _2, "chichibu": _2, "fujimi": _2, "fujimino": _2, "fukaya": _2, "hanno": _2, "hanyu": _2, "hasuda": _2, "hatogaya": _2, "hatoyama": _2, "hidaka": _2, "higashichichibu": _2, "higashimatsuyama": _2, "honjo": _2, "ina": _2, "iruma": _2, "iwatsuki": _2, "kamiizumi": _2, "kamikawa": _2, "kamisato": _2, "kasukabe": _2, "kawagoe": _2, "kawaguchi": _2, "kawajima": _2, "kazo": _2, "kitamoto": _2, "koshigaya": _2, "kounosu": _2, "kuki": _2, "kumagaya": _2, "matsubushi": _2, "minano": _2, "misato": _2, "miyashiro": _2, "miyoshi": _2, "moroyama": _2, "nagatoro": _2, "namegawa": _2, "niiza": _2, "ogano": _2, "ogawa": _2, "ogose": _2, "okegawa": _2, "omiya": _2, "otaki": _2, "ranzan": _2, "ryokami": _2, "saitama": _2, "sakado": _2, "satte": _2, "sayama": _2, "shiki": _2, "shiraoka": _2, "soka": _2, "sugito": _2, "toda": _2, "tokigawa": _2, "tokorozawa": _2, "tsurugashima": _2, "urawa": _2, "warabi": _2, "yashio": _2, "yokoze": _2, "yono": _2, "yorii": _2, "yoshida": _2, "yoshikawa": _2, "yoshimi": _2 } }, "shiga": { "$": 1, "succ": { "aisho": _2, "gamo": _2, "higashiomi": _2, "hikone": _2, "koka": _2, "konan": _2, "kosei": _2, "koto": _2, "kusatsu": _2, "maibara": _2, "moriyama": _2, "nagahama": _2, "nishiazai": _2, "notogawa": _2, "omihachiman": _2, "otsu": _2, "ritto": _2, "ryuoh": _2, "takashima": _2, "takatsuki": _2, "torahime": _2, "toyosato": _2, "yasu": _2 } }, "shimane": { "$": 1, "succ": { "akagi": _2, "ama": _2, "gotsu": _2, "hamada": _2, "higashiizumo": _2, "hikawa": _2, "hikimi": _2, "izumo": _2, "kakinoki": _2, "masuda": _2, "matsue": _2, "misato": _2, "nishinoshima": _2, "ohda": _2, "okinoshima": _2, "okuizumo": _2, "shimane": _2, "tamayu": _2, "tsuwano": _2, "unnan": _2, "yakumo": _2, "yasugi": _2, "yatsuka": _2 } }, "shizuoka": { "$": 1, "succ": { "arai": _2, "atami": _2, "fuji": _2, "fujieda": _2, "fujikawa": _2, "fujinomiya": _2, "fukuroi": _2, "gotemba": _2, "haibara": _2, "hamamatsu": _2, "higashiizu": _2, "ito": _2, "iwata": _2, "izu": _2, "izunokuni": _2, "kakegawa": _2, "kannami": _2, "kawanehon": _2, "kawazu": _2, "kikugawa": _2, "kosai": _2, "makinohara": _2, "matsuzaki": _2, "minamiizu": _2, "mishima": _2, "morimachi": _2, "nishiizu": _2, "numazu": _2, "omaezaki": _2, "shimada": _2, "shimizu": _2, "shimoda": _2, "shizuoka": _2, "susono": _2, "yaizu": _2, "yoshida": _2 } }, "tochigi": { "$": 1, "succ": { "ashikaga": _2, "bato": _2, "haga": _2, "ichikai": _2, "iwafune": _2, "kaminokawa": _2, "kanuma": _2, "karasuyama": _2, "kuroiso": _2, "mashiko": _2, "mibu": _2, "moka": _2, "motegi": _2, "nasu": _2, "nasushiobara": _2, "nikko": _2, "nishikata": _2, "nogi": _2, "ohira": _2, "ohtawara": _2, "oyama": _2, "sakura": _2, "sano": _2, "shimotsuke": _2, "shioya": _2, "takanezawa": _2, "tochigi": _2, "tsuga": _2, "ujiie": _2, "utsunomiya": _2, "yaita": _2 } }, "tokushima": { "$": 1, "succ": { "aizumi": _2, "anan": _2, "ichiba": _2, "itano": _2, "kainan": _2, "komatsushima": _2, "matsushige": _2, "mima": _2, "minami": _2, "miyoshi": _2, "mugi": _2, "nakagawa": _2, "naruto": _2, "sanagochi": _2, "shishikui": _2, "tokushima": _2, "wajiki": _2 } }, "tokyo": { "$": 1, "succ": { "adachi": _2, "akiruno": _2, "akishima": _2, "aogashima": _2, "arakawa": _2, "bunkyo": _2, "chiyoda": _2, "chofu": _2, "chuo": _2, "edogawa": _2, "fuchu": _2, "fussa": _2, "hachijo": _2, "hachioji": _2, "hamura": _2, "higashikurume": _2, "higashimurayama": _2, "higashiyamato": _2, "hino": _2, "hinode": _2, "hinohara": _2, "inagi": _2, "itabashi": _2, "katsushika": _2, "kita": _2, "kiyose": _2, "kodaira": _2, "koganei": _2, "kokubunji": _2, "komae": _2, "koto": _2, "kouzushima": _2, "kunitachi": _2, "machida": _2, "meguro": _2, "minato": _2, "mitaka": _2, "mizuho": _2, "musashimurayama": _2, "musashino": _2, "nakano": _2, "nerima": _2, "ogasawara": _2, "okutama": _2, "ome": _2, "oshima": _2, "ota": _2, "setagaya": _2, "shibuya": _2, "shinagawa": _2, "shinjuku": _2, "suginami": _2, "sumida": _2, "tachikawa": _2, "taito": _2, "tama": _2, "toshima": _2 } }, "tottori": { "$": 1, "succ": { "chizu": _2, "hino": _2, "kawahara": _2, "koge": _2, "kotoura": _2, "misasa": _2, "nanbu": _2, "nichinan": _2, "sakaiminato": _2, "tottori": _2, "wakasa": _2, "yazu": _2, "yonago": _2 } }, "toyama": { "$": 1, "succ": { "asahi": _2, "fuchu": _2, "fukumitsu": _2, "funahashi": _2, "himi": _2, "imizu": _2, "inami": _2, "johana": _2, "kamiichi": _2, "kurobe": _2, "nakaniikawa": _2, "namerikawa": _2, "nanto": _2, "nyuzen": _2, "oyabe": _2, "taira": _2, "takaoka": _2, "tateyama": _2, "toga": _2, "tonami": _2, "toyama": _2, "unazuki": _2, "uozu": _2, "yamada": _2 } }, "wakayama": { "$": 1, "succ": { "arida": _2, "aridagawa": _2, "gobo": _2, "hashimoto": _2, "hidaka": _2, "hirogawa": _2, "inami": _2, "iwade": _2, "kainan": _2, "kamitonda": _2, "katsuragi": _2, "kimino": _2, "kinokawa": _2, "kitayama": _2, "koya": _2, "koza": _2, "kozagawa": _2, "kudoyama": _2, "kushimoto": _2, "mihama": _2, "misato": _2, "nachikatsuura": _2, "shingu": _2, "shirahama": _2, "taiji": _2, "tanabe": _2, "wakayama": _2, "yuasa": _2, "yura": _2 } }, "yamagata": { "$": 1, "succ": { "asahi": _2, "funagata": _2, "higashine": _2, "iide": _2, "kahoku": _2, "kaminoyama": _2, "kaneyama": _2, "kawanishi": _2, "mamurogawa": _2, "mikawa": _2, "murayama": _2, "nagai": _2, "nakayama": _2, "nanyo": _2, "nishikawa": _2, "obanazawa": _2, "oe": _2, "oguni": _2, "ohkura": _2, "oishida": _2, "sagae": _2, "sakata": _2, "sakegawa": _2, "shinjo": _2, "shirataka": _2, "shonai": _2, "takahata": _2, "tendo": _2, "tozawa": _2, "tsuruoka": _2, "yamagata": _2, "yamanobe": _2, "yonezawa": _2, "yuza": _2 } }, "yamaguchi": { "$": 1, "succ": { "abu": _2, "hagi": _2, "hikari": _2, "hofu": _2, "iwakuni": _2, "kudamatsu": _2, "mitou": _2, "nagato": _2, "oshima": _2, "shimonoseki": _2, "shunan": _2, "tabuse": _2, "tokuyama": _2, "toyota": _2, "ube": _2, "yuu": _2 } }, "yamanashi": { "$": 1, "succ": { "chuo": _2, "doshi": _2, "fuefuki": _2, "fujikawa": _2, "fujikawaguchiko": _2, "fujiyoshida": _2, "hayakawa": _2, "hokuto": _2, "ichikawamisato": _2, "kai": _2, "kofu": _2, "koshu": _2, "kosuge": _2, "minami-alps": _2, "minobu": _2, "nakamichi": _2, "nanbu": _2, "narusawa": _2, "nirasaki": _2, "nishikatsura": _2, "oshino": _2, "otsuki": _2, "showa": _2, "tabayama": _2, "tsuru": _2, "uenohara": _2, "yamanakako": _2, "yamanashi": _2 } }, "xn--4pvxs": _2, "栃木": _2, "xn--vgu402c": _2, "愛知": _2, "xn--c3s14m": _2, "愛媛": _2, "xn--f6qx53a": _2, "兵庫": _2, "xn--8pvr4u": _2, "熊本": _2, "xn--uist22h": _2, "茨城": _2, "xn--djrs72d6uy": _2, "北海道": _2, "xn--mkru45i": _2, "千葉": _2, "xn--0trq7p7nn": _2, "和歌山": _2, "xn--8ltr62k": _2, "長崎": _2, "xn--2m4a15e": _2, "長野": _2, "xn--efvn9s": _2, "新潟": _2, "xn--32vp30h": _2, "青森": _2, "xn--4it797k": _2, "静岡": _2, "xn--1lqs71d": _2, "東京": _2, "xn--5rtp49c": _2, "石川": _2, "xn--5js045d": _2, "埼玉": _2, "xn--ehqz56n": _2, "三重": _2, "xn--1lqs03n": _2, "京都": _2, "xn--qqqt11m": _2, "佐賀": _2, "xn--kbrq7o": _2, "大分": _2, "xn--pssu33l": _2, "大阪": _2, "xn--ntsq17g": _2, "奈良": _2, "xn--uisz3g": _2, "宮城": _2, "xn--6btw5a": _2, "宮崎": _2, "xn--1ctwo": _2, "富山": _2, "xn--6orx2r": _2, "山口": _2, "xn--rht61e": _2, "山形": _2, "xn--rht27z": _2, "山梨": _2, "xn--djty4k": _2, "岩手": _2, "xn--nit225k": _2, "岐阜": _2, "xn--rht3d": _2, "岡山": _2, "xn--klty5x": _2, "島根": _2, "xn--kltx9a": _2, "広島": _2, "xn--kltp7d": _2, "徳島": _2, "xn--uuwu58a": _2, "沖縄": _2, "xn--zbx025d": _2, "滋賀": _2, "xn--ntso0iqx3a": _2, "神奈川": _2, "xn--elqq16h": _2, "福井": _2, "xn--4it168d": _2, "福岡": _2, "xn--klt787d": _2, "福島": _2, "xn--rny31h": _2, "秋田": _2, "xn--7t0a264c": _2, "群馬": _2, "xn--5rtq34k": _2, "香川": _2, "xn--k7yn95e": _2, "高知": _2, "xn--tor131o": _2, "鳥取": _2, "xn--d5qv7z876c": _2, "鹿児島": _2, "kawasaki": _8, "kitakyushu": _8, "kobe": _8, "nagoya": _8, "sapporo": _8, "sendai": _8, "yokohama": _8, "usercontent": _4, "blogspot": _4 } }, "ke": { "$": 1, "succ": { "ac": _2, "co": _5, "go": _2, "info": _2, "me": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2, "nom": _4 } }, "kg": { "$": 1, "succ": { "org": _2, "net": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "blog": _4, "io": _4, "jp": _4, "tv": _4, "uk": _4, "us": _4 } }, "kh": _8, "ki": _22, "km": { "$": 1, "succ": { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "ass": _2, "com": _2, "coop": _2, "asso": _2, "presse": _2, "medecin": _2, "notaires": _2, "pharmaciens": _2, "veterinaire": _2, "gouv": _2 } }, "kn": { "$": 1, "succ": { "net": _2, "org": _2, "edu": _2, "gov": _2 } }, "kp": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "rep": _2, "tra": _2 } }, "kr": { "$": 1, "succ": { "ac": _2, "co": _2, "es": _2, "go": _2, "hs": _2, "kg": _2, "mil": _2, "ms": _2, "ne": _2, "or": _2, "pe": _2, "re": _2, "sc": _2, "busan": _2, "chungbuk": _2, "chungnam": _2, "daegu": _2, "daejeon": _2, "gangwon": _2, "gwangju": _2, "gyeongbuk": _2, "gyeonggi": _2, "gyeongnam": _2, "incheon": _2, "jeju": _2, "jeonbuk": _2, "jeonnam": _2, "seoul": _2, "ulsan": _2, "blogspot": _4 } }, "kw": { "$": 1, "succ": { "com": _2, "edu": _2, "emb": _2, "gov": _2, "ind": _2, "net": _2, "org": _2 } }, "ky": _9, "kz": { "$": 1, "succ": { "org": _2, "edu": _2, "net": _2, "gov": _2, "mil": _2, "com": _2, "nym": _4 } }, "la": { "$": 1, "succ": { "int": _2, "net": _2, "info": _2, "edu": _2, "gov": _2, "per": _2, "com": _2, "org": _2, "bnr": _4, "c": _4, "nym": _4 } }, "lb": _9, "lc": { "$": 1, "succ": { "com": _2, "net": _2, "co": _2, "org": _2, "edu": _2, "gov": _2, "nym": _4, "oy": _4 } }, "li": { "$": 1, "succ": { "blogspot": _4, "caa": _4, "nom": _4, "nym": _4 } }, "lk": { "$": 1, "succ": { "gov": _2, "sch": _2, "net": _2, "int": _2, "com": _2, "org": _2, "edu": _2, "ngo": _2, "soc": _2, "web": _2, "ltd": _2, "assn": _2, "grp": _2, "hotel": _2, "ac": _2 } }, "lr": _9, "ls": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "sc": _2, "de": _4 } }, "lt": _20, "lu": _23, "lv": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "id": _2, "net": _2, "asn": _2, "conf": _2, "nom": _4 } }, "ly": { "$": 1, "succ": { "com": _2, "net": _2, "gov": _2, "plc": _2, "edu": _2, "sch": _2, "med": _2, "org": _2, "id": _2 } }, "ma": { "$": 1, "succ": { "co": _2, "net": _2, "gov": _2, "org": _2, "ac": _2, "press": _2 } }, "mc": { "$": 1, "succ": { "tm": _2, "asso": _2 } }, "md": { "$": 1, "succ": { "blogspot": _4, "at": _4, "de": _4, "jp": _4, "to": _4 } }, "me": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "edu": _2, "ac": _2, "gov": _2, "its": _2, "priv": _2, "c66": _4, "daplie": { "$": 2, "succ": { "localhost": _4 } }, "edgestack": _4, "couk": _4, "ukco": _4, "filegear": _4, "filegear-au": _4, "filegear-de": _4, "filegear-gb": _4, "filegear-ie": _4, "filegear-jp": _4, "filegear-sg": _4, "glitch": _4, "ravendb": _4, "barsy": _4, "nctu": _4, "soundcast": _4, "tcp4": _4, "brasilia": _4, "ddns": _4, "dnsfor": _4, "hopto": _4, "loginto": _4, "noip": _4, "webhop": _4, "nym": _4, "diskstation": _4, "dscloud": _4, "i234": _4, "myds": _4, "synology": _4, "wedeploy": _4, "yombo": _4, "nohost": _4 } }, "mg": { "$": 1, "succ": { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "com": _2, "co": _2 } }, "mh": _2, "mil": _2, "mk": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "edu": _2, "gov": _2, "inf": _2, "name": _2, "blogspot": _4, "nom": _4 } }, "ml": { "$": 1, "succ": { "com": _2, "edu": _2, "gouv": _2, "gov": _2, "net": _2, "org": _2, "presse": _2 } }, "mm": _8, "mn": { "$": 1, "succ": { "gov": _2, "edu": _2, "org": _2, "nyc": _4, "nym": _4 } }, "mo": _9, "mobi": { "$": 1, "succ": { "barsy": _4, "dscloud": _4 } }, "mp": _2, "mq": _2, "mr": { "$": 1, "succ": { "gov": _2, "blogspot": _4 } }, "ms": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "lab": _4 } }, "mt": { "$": 1, "succ": { "com": _5, "edu": _2, "net": _2, "org": _2 } }, "mu": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "ac": _2, "co": _2, "or": _2 } }, "museum": { "$": 1, "succ": { "academy": _2, "agriculture": _2, "air": _2, "airguard": _2, "alabama": _2, "alaska": _2, "amber": _2, "ambulance": _2, "american": _2, "americana": _2, "americanantiques": _2, "americanart": _2, "amsterdam": _2, "and": _2, "annefrank": _2, "anthro": _2, "anthropology": _2, "antiques": _2, "aquarium": _2, "arboretum": _2, "archaeological": _2, "archaeology": _2, "architecture": _2, "art": _2, "artanddesign": _2, "artcenter": _2, "artdeco": _2, "arteducation": _2, "artgallery": _2, "arts": _2, "artsandcrafts": _2, "asmatart": _2, "assassination": _2, "assisi": _2, "association": _2, "astronomy": _2, "atlanta": _2, "austin": _2, "australia": _2, "automotive": _2, "aviation": _2, "axis": _2, "badajoz": _2, "baghdad": _2, "bahn": _2, "bale": _2, "baltimore": _2, "barcelona": _2, "baseball": _2, "basel": _2, "baths": _2, "bauern": _2, "beauxarts": _2, "beeldengeluid": _2, "bellevue": _2, "bergbau": _2, "berkeley": _2, "berlin": _2, "bern": _2, "bible": _2, "bilbao": _2, "bill": _2, "birdart": _2, "birthplace": _2, "bonn": _2, "boston": _2, "botanical": _2, "botanicalgarden": _2, "botanicgarden": _2, "botany": _2, "brandywinevalley": _2, "brasil": _2, "bristol": _2, "british": _2, "britishcolumbia": _2, "broadcast": _2, "brunel": _2, "brussel": _2, "brussels": _2, "bruxelles": _2, "building": _2, "burghof": _2, "bus": _2, "bushey": _2, "cadaques": _2, "california": _2, "cambridge": _2, "can": _2, "canada": _2, "capebreton": _2, "carrier": _2, "cartoonart": _2, "casadelamoneda": _2, "castle": _2, "castres": _2, "celtic": _2, "center": _2, "chattanooga": _2, "cheltenham": _2, "chesapeakebay": _2, "chicago": _2, "children": _2, "childrens": _2, "childrensgarden": _2, "chiropractic": _2, "chocolate": _2, "christiansburg": _2, "cincinnati": _2, "cinema": _2, "circus": _2, "civilisation": _2, "civilization": _2, "civilwar": _2, "clinton": _2, "clock": _2, "coal": _2, "coastaldefence": _2, "cody": _2, "coldwar": _2, "collection": _2, "colonialwilliamsburg": _2, "coloradoplateau": _2, "columbia": _2, "columbus": _2, "communication": _2, "communications": _2, "community": _2, "computer": _2, "computerhistory": _2, "xn--comunicaes-v6a2o": _2, "comunicações": _2, "contemporary": _2, "contemporaryart": _2, "convent": _2, "copenhagen": _2, "corporation": _2, "xn--correios-e-telecomunicaes-ghc29a": _2, "correios-e-telecomunicações": _2, "corvette": _2, "costume": _2, "countryestate": _2, "county": _2, "crafts": _2, "cranbrook": _2, "creation": _2, "cultural": _2, "culturalcenter": _2, "culture": _2, "cyber": _2, "cymru": _2, "dali": _2, "dallas": _2, "database": _2, "ddr": _2, "decorativearts": _2, "delaware": _2, "delmenhorst": _2, "denmark": _2, "depot": _2, "design": _2, "detroit": _2, "dinosaur": _2, "discovery": _2, "dolls": _2, "donostia": _2, "durham": _2, "eastafrica": _2, "eastcoast": _2, "education": _2, "educational": _2, "egyptian": _2, "eisenbahn": _2, "elburg": _2, "elvendrell": _2, "embroidery": _2, "encyclopedic": _2, "england": _2, "entomology": _2, "environment": _2, "environmentalconservation": _2, "epilepsy": _2, "essex": _2, "estate": _2, "ethnology": _2, "exeter": _2, "exhibition": _2, "family": _2, "farm": _2, "farmequipment": _2, "farmers": _2, "farmstead": _2, "field": _2, "figueres": _2, "filatelia": _2, "film": _2, "fineart": _2, "finearts": _2, "finland": _2, "flanders": _2, "florida": _2, "force": _2, "fortmissoula": _2, "fortworth": _2, "foundation": _2, "francaise": _2, "frankfurt": _2, "franziskaner": _2, "freemasonry": _2, "freiburg": _2, "fribourg": _2, "frog": _2, "fundacio": _2, "furniture": _2, "gallery": _2, "garden": _2, "gateway": _2, "geelvinck": _2, "gemological": _2, "geology": _2, "georgia": _2, "giessen": _2, "glas": _2, "glass": _2, "gorge": _2, "grandrapids": _2, "graz": _2, "guernsey": _2, "halloffame": _2, "hamburg": _2, "handson": _2, "harvestcelebration": _2, "hawaii": _2, "health": _2, "heimatunduhren": _2, "hellas": _2, "helsinki": _2, "hembygdsforbund": _2, "heritage": _2, "histoire": _2, "historical": _2, "historicalsociety": _2, "historichouses": _2, "historisch": _2, "historisches": _2, "history": _2, "historyofscience": _2, "horology": _2, "house": _2, "humanities": _2, "illustration": _2, "imageandsound": _2, "indian": _2, "indiana": _2, "indianapolis": _2, "indianmarket": _2, "intelligence": _2, "interactive": _2, "iraq": _2, "iron": _2, "isleofman": _2, "jamison": _2, "jefferson": _2, "jerusalem": _2, "jewelry": _2, "jewish": _2, "jewishart": _2, "jfk": _2, "journalism": _2, "judaica": _2, "judygarland": _2, "juedisches": _2, "juif": _2, "karate": _2, "karikatur": _2, "kids": _2, "koebenhavn": _2, "koeln": _2, "kunst": _2, "kunstsammlung": _2, "kunstunddesign": _2, "labor": _2, "labour": _2, "lajolla": _2, "lancashire": _2, "landes": _2, "lans": _2, "xn--lns-qla": _2, "läns": _2, "larsson": _2, "lewismiller": _2, "lincoln": _2, "linz": _2, "living": _2, "livinghistory": _2, "localhistory": _2, "london": _2, "losangeles": _2, "louvre": _2, "loyalist": _2, "lucerne": _2, "luxembourg": _2, "luzern": _2, "mad": _2, "madrid": _2, "mallorca": _2, "manchester": _2, "mansion": _2, "mansions": _2, "manx": _2, "marburg": _2, "maritime": _2, "maritimo": _2, "maryland": _2, "marylhurst": _2, "media": _2, "medical": _2, "medizinhistorisches": _2, "meeres": _2, "memorial": _2, "mesaverde": _2, "michigan": _2, "midatlantic": _2, "military": _2, "mill": _2, "miners": _2, "mining": _2, "minnesota": _2, "missile": _2, "missoula": _2, "modern": _2, "moma": _2, "money": _2, "monmouth": _2, "monticello": _2, "montreal": _2, "moscow": _2, "motorcycle": _2, "muenchen": _2, "muenster": _2, "mulhouse": _2, "muncie": _2, "museet": _2, "museumcenter": _2, "museumvereniging": _2, "music": _2, "national": _2, "nationalfirearms": _2, "nationalheritage": _2, "nativeamerican": _2, "naturalhistory": _2, "naturalhistorymuseum": _2, "naturalsciences": _2, "nature": _2, "naturhistorisches": _2, "natuurwetenschappen": _2, "naumburg": _2, "naval": _2, "nebraska": _2, "neues": _2, "newhampshire": _2, "newjersey": _2, "newmexico": _2, "newport": _2, "newspaper": _2, "newyork": _2, "niepce": _2, "norfolk": _2, "north": _2, "nrw": _2, "nyc": _2, "nyny": _2, "oceanographic": _2, "oceanographique": _2, "omaha": _2, "online": _2, "ontario": _2, "openair": _2, "oregon": _2, "oregontrail": _2, "otago": _2, "oxford": _2, "pacific": _2, "paderborn": _2, "palace": _2, "paleo": _2, "palmsprings": _2, "panama": _2, "paris": _2, "pasadena": _2, "pharmacy": _2, "philadelphia": _2, "philadelphiaarea": _2, "philately": _2, "phoenix": _2, "photography": _2, "pilots": _2, "pittsburgh": _2, "planetarium": _2, "plantation": _2, "plants": _2, "plaza": _2, "portal": _2, "portland": _2, "portlligat": _2, "posts-and-telecommunications": _2, "preservation": _2, "presidio": _2, "press": _2, "project": _2, "public": _2, "pubol": _2, "quebec": _2, "railroad": _2, "railway": _2, "research": _2, "resistance": _2, "riodejaneiro": _2, "rochester": _2, "rockart": _2, "roma": _2, "russia": _2, "saintlouis": _2, "salem": _2, "salvadordali": _2, "salzburg": _2, "sandiego": _2, "sanfrancisco": _2, "santabarbara": _2, "santacruz": _2, "santafe": _2, "saskatchewan": _2, "satx": _2, "savannahga": _2, "schlesisches": _2, "schoenbrunn": _2, "schokoladen": _2, "school": _2, "schweiz": _2, "science": _2, "scienceandhistory": _2, "scienceandindustry": _2, "sciencecenter": _2, "sciencecenters": _2, "science-fiction": _2, "sciencehistory": _2, "sciences": _2, "sciencesnaturelles": _2, "scotland": _2, "seaport": _2, "settlement": _2, "settlers": _2, "shell": _2, "sherbrooke": _2, "sibenik": _2, "silk": _2, "ski": _2, "skole": _2, "society": _2, "sologne": _2, "soundandvision": _2, "southcarolina": _2, "southwest": _2, "space": _2, "spy": _2, "square": _2, "stadt": _2, "stalbans": _2, "starnberg": _2, "state": _2, "stateofdelaware": _2, "station": _2, "steam": _2, "steiermark": _2, "stjohn": _2, "stockholm": _2, "stpetersburg": _2, "stuttgart": _2, "suisse": _2, "surgeonshall": _2, "surrey": _2, "svizzera": _2, "sweden": _2, "sydney": _2, "tank": _2, "tcm": _2, "technology": _2, "telekommunikation": _2, "television": _2, "texas": _2, "textile": _2, "theater": _2, "time": _2, "timekeeping": _2, "topology": _2, "torino": _2, "touch": _2, "town": _2, "transport": _2, "tree": _2, "trolley": _2, "trust": _2, "trustee": _2, "uhren": _2, "ulm": _2, "undersea": _2, "university": _2, "usa": _2, "usantiques": _2, "usarts": _2, "uscountryestate": _2, "usculture": _2, "usdecorativearts": _2, "usgarden": _2, "ushistory": _2, "ushuaia": _2, "uslivinghistory": _2, "utah": _2, "uvic": _2, "valley": _2, "vantaa": _2, "versailles": _2, "viking": _2, "village": _2, "virginia": _2, "virtual": _2, "virtuel": _2, "vlaanderen": _2, "volkenkunde": _2, "wales": _2, "wallonie": _2, "war": _2, "washingtondc": _2, "watchandclock": _2, "watch-and-clock": _2, "western": _2, "westfalen": _2, "whaling": _2, "wildlife": _2, "williamsburg": _2, "windmill": _2, "workshop": _2, "york": _2, "yorkshire": _2, "yosemite": _2, "youth": _2, "zoological": _2, "zoology": _2, "xn--9dbhblg6di": _2, "ירושלים": _2, "xn--h1aegh": _2, "иком": _2 } }, "mv": { "$": 1, "succ": { "aero": _2, "biz": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "museum": _2, "name": _2, "net": _2, "org": _2, "pro": _2 } }, "mw": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "int": _2, "museum": _2, "net": _2, "org": _2 } }, "mx": { "$": 1, "succ": { "com": _2, "org": _2, "gob": _2, "edu": _2, "net": _2, "blogspot": _4, "nym": _4 } }, "my": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "mil": _2, "name": _2, "blogspot": _4 } }, "mz": { "$": 1, "succ": { "ac": _2, "adv": _2, "co": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 } }, "na": { "$": 1, "succ": { "info": _2, "pro": _2, "name": _2, "school": _2, "or": _2, "dr": _2, "us": _2, "mx": _2, "ca": _2, "in": _2, "cc": _2, "tv": _2, "ws": _2, "mobi": _2, "co": _2, "com": _2, "org": _2 } }, "name": { "$": 1, "succ": { "her": _26, "his": _26 } }, "nc": { "$": 1, "succ": { "asso": _2, "nom": _2 } }, "ne": _2, "net": { "$": 1, "succ": { "adobeaemcloud": _4, "alwaysdata": _4, "cloudfront": _4, "t3l3p0rt": _4, "myfritz": _4, "blackbaudcdn": _4, "boomla": _4, "bplaced": _4, "square7": _4, "gb": _4, "hu": _4, "jp": _4, "se": _4, "uk": _4, "in": _4, "clic2000": _4, "cloudaccess": _4, "cdn77-ssl": _4, "cdn77": { "$": 0, "succ": { "r": _4 } }, "cloudeity": _4, "feste-ip": _4, "knx-server": _4, "static-access": _4, "cryptonomic": _7, "dattolocal": _4, "mydatto": _4, "debian": _4, "bitbridge": _4, "at-band-camp": _4, "blogdns": _4, "broke-it": _4, "buyshouses": _4, "dnsalias": _4, "dnsdojo": _4, "does-it": _4, "dontexist": _4, "dynalias": _4, "dynathome": _4, "endofinternet": _4, "from-az": _4, "from-co": _4, "from-la": _4, "from-ny": _4, "gets-it": _4, "ham-radio-op": _4, "homeftp": _4, "homeip": _4, "homelinux": _4, "homeunix": _4, "in-the-band": _4, "is-a-chef": _4, "is-a-geek": _4, "isa-geek": _4, "kicks-ass": _4, "office-on-the": _4, "podzone": _4, "scrapper-site": _4, "selfip": _4, "sells-it": _4, "servebbs": _4, "serveftp": _4, "thruhere": _4, "webhop": _4, "definima": _4, "casacam": _4, "dynu": _4, "dynv6": _4, "twmail": _4, "ru": _4, "channelsdvr": { "$": 2, "succ": { "u": _4 } }, "fastlylb": { "$": 2, "succ": { "map": _4 } }, "fastly": { "$": 0, "succ": { "freetls": _4, "map": _4, "prod": { "$": 0, "succ": { "a": _4, "global": _4 } }, "ssl": { "$": 0, "succ": { "a": _4, "b": _4, "global": _4 } } } }, "edgeapp": _4, "flynnhosting": _4, "cloudfunctions": _4, "moonscale": _4, "in-dsl": _4, "in-vpn": _4, "ipifony": _4, "iobb": _4, "cloudjiffy": _4, "elastx": { "$": 0, "succ": { "jls-sto1": _4 } }, "saveincloud": _27, "kinghost": _4, "uni5": _4, "barsy": _4, "memset": _4, "azurewebsites": _4, "azure-mobile": _4, "cloudapp": _4, "dnsup": _4, "hicam": _4, "now-dns": _4, "ownip": _4, "vpndns": _4, "eating-organic": _4, "mydissent": _4, "myeffect": _4, "mymediapc": _4, "mypsx": _4, "mysecuritycamera": _4, "nhlfan": _4, "no-ip": _4, "pgafan": _4, "privatizehealthinsurance": _4, "bounceme": _4, "ddns": _4, "redirectme": _4, "serveblog": _4, "serveminecraft": _4, "sytes": _4, "cloudycluster": _4, "rackmaze": _4, "schokokeks": _4, "firewall-gateway": _4, "seidat": _4, "senseering": _4, "siteleaf": _4, "srcf": { "$": 0, "succ": { "soc": _4, "user": _4 } }, "dsmynas": _4, "familyds": _4, "community-pro": _4, "meinforum": _4, "yandexcloud": { "$": 2, "succ": { "storage": _4, "website": _4 } }, "za": _4 } }, "nf": { "$": 1, "succ": { "com": _2, "net": _2, "per": _2, "rec": _2, "web": _2, "arts": _2, "firm": _2, "info": _2, "other": _2, "store": _2 } }, "ng": { "$": 1, "succ": { "com": _5, "edu": _2, "gov": _2, "i": _2, "mil": _2, "mobi": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "col": _4, "firm": _4, "gen": _4, "ltd": _4, "ngo": _4 } }, "ni": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gob": _2, "in": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "web": _2 } }, "nl": { "$": 1, "succ": { "amsw": _4, "virtueeldomein": _4, "co": _4, "hosting-cluster": _4, "blogspot": _4, "khplay": _4, "transurl": _7, "cistron": _4, "demon": _4 } }, "no": { "$": 1, "succ": { "fhs": _2, "vgs": _2, "fylkesbibl": _2, "folkebibl": _2, "museum": _2, "idrett": _2, "priv": _2, "mil": _2, "stat": _2, "dep": _2, "kommune": _2, "herad": _2, "aa": _28, "ah": _28, "bu": _28, "fm": _28, "hl": _28, "hm": _28, "jan-mayen": _28, "mr": _28, "nl": _28, "nt": _28, "of": _28, "ol": _28, "oslo": _28, "rl": _28, "sf": _28, "st": _28, "svalbard": _28, "tm": _28, "tr": _28, "va": _28, "vf": _28, "akrehamn": _2, "xn--krehamn-dxa": _2, "åkrehamn": _2, "algard": _2, "xn--lgrd-poac": _2, "ålgård": _2, "arna": _2, "brumunddal": _2, "bryne": _2, "bronnoysund": _2, "xn--brnnysund-m8ac": _2, "brønnøysund": _2, "drobak": _2, "xn--drbak-wua": _2, "drøbak": _2, "egersund": _2, "fetsund": _2, "floro": _2, "xn--flor-jra": _2, "florø": _2, "fredrikstad": _2, "hokksund": _2, "honefoss": _2, "xn--hnefoss-q1a": _2, "hønefoss": _2, "jessheim": _2, "jorpeland": _2, "xn--jrpeland-54a": _2, "jørpeland": _2, "kirkenes": _2, "kopervik": _2, "krokstadelva": _2, "langevag": _2, "xn--langevg-jxa": _2, "langevåg": _2, "leirvik": _2, "mjondalen": _2, "xn--mjndalen-64a": _2, "mjøndalen": _2, "mo-i-rana": _2, "mosjoen": _2, "xn--mosjen-eya": _2, "mosjøen": _2, "nesoddtangen": _2, "orkanger": _2, "osoyro": _2, "xn--osyro-wua": _2, "osøyro": _2, "raholt": _2, "xn--rholt-mra": _2, "råholt": _2, "sandnessjoen": _2, "xn--sandnessjen-ogb": _2, "sandnessjøen": _2, "skedsmokorset": _2, "slattum": _2, "spjelkavik": _2, "stathelle": _2, "stavern": _2, "stjordalshalsen": _2, "xn--stjrdalshalsen-sqb": _2, "stjørdalshalsen": _2, "tananger": _2, "tranby": _2, "vossevangen": _2, "afjord": _2, "xn--fjord-lra": _2, "åfjord": _2, "agdenes": _2, "al": _2, "xn--l-1fa": _2, "ål": _2, "alesund": _2, "xn--lesund-hua": _2, "ålesund": _2, "alstahaug": _2, "alta": _2, "xn--lt-liac": _2, "áltá": _2, "alaheadju": _2, "xn--laheadju-7ya": _2, "álaheadju": _2, "alvdal": _2, "amli": _2, "xn--mli-tla": _2, "åmli": _2, "amot": _2, "xn--mot-tla": _2, "åmot": _2, "andebu": _2, "andoy": _2, "xn--andy-ira": _2, "andøy": _2, "andasuolo": _2, "ardal": _2, "xn--rdal-poa": _2, "årdal": _2, "aremark": _2, "arendal": _2, "xn--s-1fa": _2, "ås": _2, "aseral": _2, "xn--seral-lra": _2, "åseral": _2, "asker": _2, "askim": _2, "askvoll": _2, "askoy": _2, "xn--asky-ira": _2, "askøy": _2, "asnes": _2, "xn--snes-poa": _2, "åsnes": _2, "audnedaln": _2, "aukra": _2, "aure": _2, "aurland": _2, "aurskog-holand": _2, "xn--aurskog-hland-jnb": _2, "aurskog-høland": _2, "austevoll": _2, "austrheim": _2, "averoy": _2, "xn--avery-yua": _2, "averøy": _2, "balestrand": _2, "ballangen": _2, "balat": _2, "xn--blt-elab": _2, "bálát": _2, "balsfjord": _2, "bahccavuotna": _2, "xn--bhccavuotna-k7a": _2, "báhccavuotna": _2, "bamble": _2, "bardu": _2, "beardu": _2, "beiarn": _2, "bajddar": _2, "xn--bjddar-pta": _2, "bájddar": _2, "baidar": _2, "xn--bidr-5nac": _2, "báidár": _2, "berg": _2, "bergen": _2, "berlevag": _2, "xn--berlevg-jxa": _2, "berlevåg": _2, "bearalvahki": _2, "xn--bearalvhki-y4a": _2, "bearalváhki": _2, "bindal": _2, "birkenes": _2, "bjarkoy": _2, "xn--bjarky-fya": _2, "bjarkøy": _2, "bjerkreim": _2, "bjugn": _2, "bodo": _2, "xn--bod-2na": _2, "bodø": _2, "badaddja": _2, "xn--bdddj-mrabd": _2, "bådåddjå": _2, "budejju": _2, "bokn": _2, "bremanger": _2, "bronnoy": _2, "xn--brnny-wuac": _2, "brønnøy": _2, "bygland": _2, "bykle": _2, "barum": _2, "xn--brum-voa": _2, "bærum": _2, "telemark": { "$": 0, "succ": { "bo": _2, "xn--b-5ga": _2, "bø": _2 } }, "nordland": { "$": 0, "succ": { "bo": _2, "xn--b-5ga": _2, "bø": _2, "heroy": _2, "xn--hery-ira": _2, "herøy": _2 } }, "bievat": _2, "xn--bievt-0qa": _2, "bievát": _2, "bomlo": _2, "xn--bmlo-gra": _2, "bømlo": _2, "batsfjord": _2, "xn--btsfjord-9za": _2, "båtsfjord": _2, "bahcavuotna": _2, "xn--bhcavuotna-s4a": _2, "báhcavuotna": _2, "dovre": _2, "drammen": _2, "drangedal": _2, "dyroy": _2, "xn--dyry-ira": _2, "dyrøy": _2, "donna": _2, "xn--dnna-gra": _2, "dønna": _2, "eid": _2, "eidfjord": _2, "eidsberg": _2, "eidskog": _2, "eidsvoll": _2, "eigersund": _2, "elverum": _2, "enebakk": _2, "engerdal": _2, "etne": _2, "etnedal": _2, "evenes": _2, "evenassi": _2, "xn--eveni-0qa01ga": _2, "evenášši": _2, "evje-og-hornnes": _2, "farsund": _2, "fauske": _2, "fuossko": _2, "fuoisku": _2, "fedje": _2, "fet": _2, "finnoy": _2, "xn--finny-yua": _2, "finnøy": _2, "fitjar": _2, "fjaler": _2, "fjell": _2, "flakstad": _2, "flatanger": _2, "flekkefjord": _2, "flesberg": _2, "flora": _2, "fla": _2, "xn--fl-zia": _2, "flå": _2, "folldal": _2, "forsand": _2, "fosnes": _2, "frei": _2, "frogn": _2, "froland": _2, "frosta": _2, "frana": _2, "xn--frna-woa": _2, "fræna": _2, "froya": _2, "xn--frya-hra": _2, "frøya": _2, "fusa": _2, "fyresdal": _2, "forde": _2, "xn--frde-gra": _2, "førde": _2, "gamvik": _2, "gangaviika": _2, "xn--ggaviika-8ya47h": _2, "gáŋgaviika": _2, "gaular": _2, "gausdal": _2, "gildeskal": _2, "xn--gildeskl-g0a": _2, "gildeskål": _2, "giske": _2, "gjemnes": _2, "gjerdrum": _2, "gjerstad": _2, "gjesdal": _2, "gjovik": _2, "xn--gjvik-wua": _2, "gjøvik": _2, "gloppen": _2, "gol": _2, "gran": _2, "grane": _2, "granvin": _2, "gratangen": _2, "grimstad": _2, "grong": _2, "kraanghke": _2, "xn--kranghke-b0a": _2, "kråanghke": _2, "grue": _2, "gulen": _2, "hadsel": _2, "halden": _2, "halsa": _2, "hamar": _2, "hamaroy": _2, "habmer": _2, "xn--hbmer-xqa": _2, "hábmer": _2, "hapmir": _2, "xn--hpmir-xqa": _2, "hápmir": _2, "hammerfest": _2, "hammarfeasta": _2, "xn--hmmrfeasta-s4ac": _2, "hámmárfeasta": _2, "haram": _2, "hareid": _2, "harstad": _2, "hasvik": _2, "aknoluokta": _2, "xn--koluokta-7ya57h": _2, "ákŋoluokta": _2, "hattfjelldal": _2, "aarborte": _2, "haugesund": _2, "hemne": _2, "hemnes": _2, "hemsedal": _2, "more-og-romsdal": { "$": 0, "succ": { "heroy": _2, "sande": _2 } }, "xn--mre-og-romsdal-qqb": { "$": 0, "succ": { "xn--hery-ira": _2, "sande": _2 } }, "møre-og-romsdal": { "$": 0, "succ": { "herøy": _2, "sande": _2 } }, "hitra": _2, "hjartdal": _2, "hjelmeland": _2, "hobol": _2, "xn--hobl-ira": _2, "hobøl": _2, "hof": _2, "hol": _2, "hole": _2, "holmestrand": _2, "holtalen": _2, "xn--holtlen-hxa": _2, "holtålen": _2, "hornindal": _2, "horten": _2, "hurdal": _2, "hurum": _2, "hvaler": _2, "hyllestad": _2, "hagebostad": _2, "xn--hgebostad-g3a": _2, "hægebostad": _2, "hoyanger": _2, "xn--hyanger-q1a": _2, "høyanger": _2, "hoylandet": _2, "xn--hylandet-54a": _2, "høylandet": _2, "ha": _2, "xn--h-2fa": _2, "hå": _2, "ibestad": _2, "inderoy": _2, "xn--indery-fya": _2, "inderøy": _2, "iveland": _2, "jevnaker": _2, "jondal": _2, "jolster": _2, "xn--jlster-bya": _2, "jølster": _2, "karasjok": _2, "karasjohka": _2, "xn--krjohka-hwab49j": _2, "kárášjohka": _2, "karlsoy": _2, "galsa": _2, "xn--gls-elac": _2, "gálsá": _2, "karmoy": _2, "xn--karmy-yua": _2, "karmøy": _2, "kautokeino": _2, "guovdageaidnu": _2, "klepp": _2, "klabu": _2, "xn--klbu-woa": _2, "klæbu": _2, "kongsberg": _2, "kongsvinger": _2, "kragero": _2, "xn--krager-gya": _2, "kragerø": _2, "kristiansand": _2, "kristiansund": _2, "krodsherad": _2, "xn--krdsherad-m8a": _2, "krødsherad": _2, "kvalsund": _2, "rahkkeravju": _2, "xn--rhkkervju-01af": _2, "ráhkkerávju": _2, "kvam": _2, "kvinesdal": _2, "kvinnherad": _2, "kviteseid": _2, "kvitsoy": _2, "xn--kvitsy-fya": _2, "kvitsøy": _2, "kvafjord": _2, "xn--kvfjord-nxa": _2, "kvæfjord": _2, "giehtavuoatna": _2, "kvanangen": _2, "xn--kvnangen-k0a": _2, "kvænangen": _2, "navuotna": _2, "xn--nvuotna-hwa": _2, "návuotna": _2, "kafjord": _2, "xn--kfjord-iua": _2, "kåfjord": _2, "gaivuotna": _2, "xn--givuotna-8ya": _2, "gáivuotna": _2, "larvik": _2, "lavangen": _2, "lavagis": _2, "loabat": _2, "xn--loabt-0qa": _2, "loabát": _2, "lebesby": _2, "davvesiida": _2, "leikanger": _2, "leirfjord": _2, "leka": _2, "leksvik": _2, "lenvik": _2, "leangaviika": _2, "xn--leagaviika-52b": _2, "leaŋgaviika": _2, "lesja": _2, "levanger": _2, "lier": _2, "lierne": _2, "lillehammer": _2, "lillesand": _2, "lindesnes": _2, "lindas": _2, "xn--linds-pra": _2, "lindås": _2, "lom": _2, "loppa": _2, "lahppi": _2, "xn--lhppi-xqa": _2, "láhppi": _2, "lund": _2, "lunner": _2, "luroy": _2, "xn--lury-ira": _2, "lurøy": _2, "luster": _2, "lyngdal": _2, "lyngen": _2, "ivgu": _2, "lardal": _2, "lerdal": _2, "xn--lrdal-sra": _2, "lærdal": _2, "lodingen": _2, "xn--ldingen-q1a": _2, "lødingen": _2, "lorenskog": _2, "xn--lrenskog-54a": _2, "lørenskog": _2, "loten": _2, "xn--lten-gra": _2, "løten": _2, "malvik": _2, "masoy": _2, "xn--msy-ula0h": _2, "måsøy": _2, "muosat": _2, "xn--muost-0qa": _2, "muosát": _2, "mandal": _2, "marker": _2, "marnardal": _2, "masfjorden": _2, "meland": _2, "meldal": _2, "melhus": _2, "meloy": _2, "xn--mely-ira": _2, "meløy": _2, "meraker": _2, "xn--merker-kua": _2, "meråker": _2, "moareke": _2, "xn--moreke-jua": _2, "moåreke": _2, "midsund": _2, "midtre-gauldal": _2, "modalen": _2, "modum": _2, "molde": _2, "moskenes": _2, "moss": _2, "mosvik": _2, "malselv": _2, "xn--mlselv-iua": _2, "målselv": _2, "malatvuopmi": _2, "xn--mlatvuopmi-s4a": _2, "málatvuopmi": _2, "namdalseid": _2, "aejrie": _2, "namsos": _2, "namsskogan": _2, "naamesjevuemie": _2, "xn--nmesjevuemie-tcba": _2, "nååmesjevuemie": _2, "laakesvuemie": _2, "nannestad": _2, "narvik": _2, "narviika": _2, "naustdal": _2, "nedre-eiker": _2, "akershus": _29, "buskerud": _29, "nesna": _2, "nesodden": _2, "nesseby": _2, "unjarga": _2, "xn--unjrga-rta": _2, "unjárga": _2, "nesset": _2, "nissedal": _2, "nittedal": _2, "nord-aurdal": _2, "nord-fron": _2, "nord-odal": _2, "norddal": _2, "nordkapp": _2, "davvenjarga": _2, "xn--davvenjrga-y4a": _2, "davvenjárga": _2, "nordre-land": _2, "nordreisa": _2, "raisa": _2, "xn--risa-5na": _2, "ráisa": _2, "nore-og-uvdal": _2, "notodden": _2, "naroy": _2, "xn--nry-yla5g": _2, "nærøy": _2, "notteroy": _2, "xn--nttery-byae": _2, "nøtterøy": _2, "odda": _2, "oksnes": _2, "xn--ksnes-uua": _2, "øksnes": _2, "oppdal": _2, "oppegard": _2, "xn--oppegrd-ixa": _2, "oppegård": _2, "orkdal": _2, "orland": _2, "xn--rland-uua": _2, "ørland": _2, "orskog": _2, "xn--rskog-uua": _2, "ørskog": _2, "orsta": _2, "xn--rsta-fra": _2, "ørsta": _2, "hedmark": { "$": 0, "succ": { "os": _2, "valer": _2, "xn--vler-qoa": _2, "våler": _2 } }, "hordaland": { "$": 0, "succ": { "os": _2 } }, "osen": _2, "osteroy": _2, "xn--ostery-fya": _2, "osterøy": _2, "ostre-toten": _2, "xn--stre-toten-zcb": _2, "østre-toten": _2, "overhalla": _2, "ovre-eiker": _2, "xn--vre-eiker-k8a": _2, "øvre-eiker": _2, "oyer": _2, "xn--yer-zna": _2, "øyer": _2, "oygarden": _2, "xn--ygarden-p1a": _2, "øygarden": _2, "oystre-slidre": _2, "xn--ystre-slidre-ujb": _2, "øystre-slidre": _2, "porsanger": _2, "porsangu": _2, "xn--porsgu-sta26f": _2, "porsáŋgu": _2, "porsgrunn": _2, "radoy": _2, "xn--rady-ira": _2, "radøy": _2, "rakkestad": _2, "rana": _2, "ruovat": _2, "randaberg": _2, "rauma": _2, "rendalen": _2, "rennebu": _2, "rennesoy": _2, "xn--rennesy-v1a": _2, "rennesøy": _2, "rindal": _2, "ringebu": _2, "ringerike": _2, "ringsaker": _2, "rissa": _2, "risor": _2, "xn--risr-ira": _2, "risør": _2, "roan": _2, "rollag": _2, "rygge": _2, "ralingen": _2, "xn--rlingen-mxa": _2, "rælingen": _2, "rodoy": _2, "xn--rdy-0nab": _2, "rødøy": _2, "romskog": _2, "xn--rmskog-bya": _2, "rømskog": _2, "roros": _2, "xn--rros-gra": _2, "røros": _2, "rost": _2, "xn--rst-0na": _2, "røst": _2, "royken": _2, "xn--ryken-vua": _2, "røyken": _2, "royrvik": _2, "xn--ryrvik-bya": _2, "røyrvik": _2, "rade": _2, "xn--rde-ula": _2, "råde": _2, "salangen": _2, "siellak": _2, "saltdal": _2, "salat": _2, "xn--slt-elab": _2, "sálát": _2, "xn--slat-5na": _2, "sálat": _2, "samnanger": _2, "vestfold": { "$": 0, "succ": { "sande": _2 } }, "sandefjord": _2, "sandnes": _2, "sandoy": _2, "xn--sandy-yua": _2, "sandøy": _2, "sarpsborg": _2, "sauda": _2, "sauherad": _2, "sel": _2, "selbu": _2, "selje": _2, "seljord": _2, "sigdal": _2, "siljan": _2, "sirdal": _2, "skaun": _2, "skedsmo": _2, "ski": _2, "skien": _2, "skiptvet": _2, "skjervoy": _2, "xn--skjervy-v1a": _2, "skjervøy": _2, "skierva": _2, "xn--skierv-uta": _2, "skiervá": _2, "skjak": _2, "xn--skjk-soa": _2, "skjåk": _2, "skodje": _2, "skanland": _2, "xn--sknland-fxa": _2, "skånland": _2, "skanit": _2, "xn--sknit-yqa": _2, "skánit": _2, "smola": _2, "xn--smla-hra": _2, "smøla": _2, "snillfjord": _2, "snasa": _2, "xn--snsa-roa": _2, "snåsa": _2, "snoasa": _2, "snaase": _2, "xn--snase-nra": _2, "snåase": _2, "sogndal": _2, "sokndal": _2, "sola": _2, "solund": _2, "songdalen": _2, "sortland": _2, "spydeberg": _2, "stange": _2, "stavanger": _2, "steigen": _2, "steinkjer": _2, "stjordal": _2, "xn--stjrdal-s1a": _2, "stjørdal": _2, "stokke": _2, "stor-elvdal": _2, "stord": _2, "stordal": _2, "storfjord": _2, "omasvuotna": _2, "strand": _2, "stranda": _2, "stryn": _2, "sula": _2, "suldal": _2, "sund": _2, "sunndal": _2, "surnadal": _2, "sveio": _2, "svelvik": _2, "sykkylven": _2, "sogne": _2, "xn--sgne-gra": _2, "søgne": _2, "somna": _2, "xn--smna-gra": _2, "sømna": _2, "sondre-land": _2, "xn--sndre-land-0cb": _2, "søndre-land": _2, "sor-aurdal": _2, "xn--sr-aurdal-l8a": _2, "sør-aurdal": _2, "sor-fron": _2, "xn--sr-fron-q1a": _2, "sør-fron": _2, "sor-odal": _2, "xn--sr-odal-q1a": _2, "sør-odal": _2, "sor-varanger": _2, "xn--sr-varanger-ggb": _2, "sør-varanger": _2, "matta-varjjat": _2, "xn--mtta-vrjjat-k7af": _2, "mátta-várjjat": _2, "sorfold": _2, "xn--srfold-bya": _2, "sørfold": _2, "sorreisa": _2, "xn--srreisa-q1a": _2, "sørreisa": _2, "sorum": _2, "xn--srum-gra": _2, "sørum": _2, "tana": _2, "deatnu": _2, "time": _2, "tingvoll": _2, "tinn": _2, "tjeldsund": _2, "dielddanuorri": _2, "tjome": _2, "xn--tjme-hra": _2, "tjøme": _2, "tokke": _2, "tolga": _2, "torsken": _2, "tranoy": _2, "xn--trany-yua": _2, "tranøy": _2, "tromso": _2, "xn--troms-zua": _2, "tromsø": _2, "tromsa": _2, "romsa": _2, "trondheim": _2, "troandin": _2, "trysil": _2, "trana": _2, "xn--trna-woa": _2, "træna": _2, "trogstad": _2, "xn--trgstad-r1a": _2, "trøgstad": _2, "tvedestrand": _2, "tydal": _2, "tynset": _2, "tysfjord": _2, "divtasvuodna": _2, "divttasvuotna": _2, "tysnes": _2, "tysvar": _2, "xn--tysvr-vra": _2, "tysvær": _2, "tonsberg": _2, "xn--tnsberg-q1a": _2, "tønsberg": _2, "ullensaker": _2, "ullensvang": _2, "ulvik": _2, "utsira": _2, "vadso": _2, "xn--vads-jra": _2, "vadsø": _2, "cahcesuolo": _2, "xn--hcesuolo-7ya35b": _2, "čáhcesuolo": _2, "vaksdal": _2, "valle": _2, "vang": _2, "vanylven": _2, "vardo": _2, "xn--vard-jra": _2, "vardø": _2, "varggat": _2, "xn--vrggt-xqad": _2, "várggát": _2, "vefsn": _2, "vaapste": _2, "vega": _2, "vegarshei": _2, "xn--vegrshei-c0a": _2, "vegårshei": _2, "vennesla": _2, "verdal": _2, "verran": _2, "vestby": _2, "vestnes": _2, "vestre-slidre": _2, "vestre-toten": _2, "vestvagoy": _2, "xn--vestvgy-ixa6o": _2, "vestvågøy": _2, "vevelstad": _2, "vik": _2, "vikna": _2, "vindafjord": _2, "volda": _2, "voss": _2, "varoy": _2, "xn--vry-yla5g": _2, "værøy": _2, "vagan": _2, "xn--vgan-qoa": _2, "vågan": _2, "voagat": _2, "vagsoy": _2, "xn--vgsy-qoa0j": _2, "vågsøy": _2, "vaga": _2, "xn--vg-yiab": _2, "vågå": _2, "ostfold": { "$": 0, "succ": { "valer": _2 } }, "xn--stfold-9xa": { "$": 0, "succ": { "xn--vler-qoa": _2 } }, "østfold": { "$": 0, "succ": { "våler": _2 } }, "co": _4, "blogspot": _4 } }, "np": _8, "nr": _22, "nu": { "$": 1, "succ": { "merseine": _4, "mine": _4, "shacknet": _4, "nom": _4, "uwu": _4, "enterprisecloud": _4 } }, "nz": { "$": 1, "succ": { "ac": _2, "co": _5, "cri": _2, "geek": _2, "gen": _2, "govt": _2, "health": _2, "iwi": _2, "kiwi": _2, "maori": _2, "mil": _2, "xn--mori-qsa": _2, "māori": _2, "net": _2, "org": _2, "parliament": _2, "school": _2, "nym": _4 } }, "om": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "gov": _2, "med": _2, "museum": _2, "net": _2, "org": _2, "pro": _2 } }, "onion": _2, "org": { "$": 1, "succ": { "altervista": _4, "amune": { "$": 0, "succ": { "tele": _4 } }, "pimienta": _4, "poivron": _4, "potager": _4, "sweetpepper": _4, "ae": _4, "us": _4, "certmgr": _4, "cdn77": { "$": 0, "succ": { "c": _4, "rsc": _4 } }, "cdn77-secure": { "$": 0, "succ": { "origin": { "$": 0, "succ": { "ssl": _4 } } } }, "cloudns": _4, "duckdns": _4, "tunk": _4, "dyndns": { "$": 2, "succ": { "go": _4, "home": _4 } }, "blogdns": _4, "blogsite": _4, "boldlygoingnowhere": _4, "dnsalias": _4, "dnsdojo": _4, "doesntexist": _4, "dontexist": _4, "doomdns": _4, "dvrdns": _4, "dynalias": _4, "endofinternet": _4, "endoftheinternet": _4, "from-me": _4, "game-host": _4, "gotdns": _4, "hobby-site": _4, "homedns": _4, "homeftp": _4, "homelinux": _4, "homeunix": _4, "is-a-bruinsfan": _4, "is-a-candidate": _4, "is-a-celticsfan": _4, "is-a-chef": _4, "is-a-geek": _4, "is-a-knight": _4, "is-a-linux-user": _4, "is-a-patsfan": _4, "is-a-soxfan": _4, "is-found": _4, "is-lost": _4, "is-saved": _4, "is-very-bad": _4, "is-very-evil": _4, "is-very-good": _4, "is-very-nice": _4, "is-very-sweet": _4, "isa-geek": _4, "kicks-ass": _4, "misconfused": _4, "podzone": _4, "readmyblog": _4, "selfip": _4, "sellsyourhome": _4, "servebbs": _4, "serveftp": _4, "servegame": _4, "stuff-4-sale": _4, "webhop": _4, "ddnss": _4, "accesscam": _4, "camdvr": _4, "freeddns": _4, "mywire": _4, "webredirect": _4, "eu": { "$": 2, "succ": { "al": _4, "asso": _4, "at": _4, "au": _4, "be": _4, "bg": _4, "ca": _4, "cd": _4, "ch": _4, "cn": _4, "cy": _4, "cz": _4, "de": _4, "dk": _4, "edu": _4, "ee": _4, "es": _4, "fi": _4, "fr": _4, "gr": _4, "hr": _4, "hu": _4, "ie": _4, "il": _4, "in": _4, "int": _4, "is": _4, "it": _4, "jp": _4, "kr": _4, "lt": _4, "lu": _4, "lv": _4, "mc": _4, "me": _4, "mk": _4, "mt": _4, "my": _4, "net": _4, "ng": _4, "nl": _4, "no": _4, "nz": _4, "paris": _4, "pl": _4, "pt": _4, "q-a": _4, "ro": _4, "ru": _4, "se": _4, "si": _4, "sk": _4, "tr": _4, "uk": _4, "us": _4 } }, "twmail": _4, "fedorainfracloud": _4, "fedorapeople": _4, "fedoraproject": { "$": 0, "succ": { "cloud": _4, "os": _16, "stg": { "$": 0, "succ": { "os": _16 } } } }, "freedesktop": _4, "hepforge": _4, "in-dsl": _4, "in-vpn": _4, "js": _4, "uklugs": _4, "barsy": _4, "mayfirst": _4, "mozilla-iot": _4, "bmoattachments": _4, "dynserv": _4, "now-dns": _4, "cable-modem": _4, "collegefan": _4, "couchpotatofries": _4, "mlbfan": _4, "mysecuritycamera": _4, "nflfan": _4, "read-books": _4, "ufcfan": _4, "hopto": _4, "myftp": _4, "no-ip": _4, "zapto": _4, "pubtls": _4, "my-firewall": _4, "myfirewall": _4, "spdns": _4, "dsmynas": _4, "familyds": _4, "edugit": _4, "tuxfamily": _4, "diskstation": _4, "hk": _4, "wmflabs": _4, "toolforge": _4, "wmcloud": _4, "za": _4 } }, "pa": { "$": 1, "succ": { "ac": _2, "gob": _2, "com": _2, "org": _2, "sld": _2, "edu": _2, "net": _2, "ing": _2, "abo": _2, "med": _2, "nom": _2 } }, "pe": { "$": 1, "succ": { "edu": _2, "gob": _2, "nom": _2, "mil": _2, "org": _2, "com": _2, "net": _2, "blogspot": _4, "nym": _4 } }, "pf": { "$": 1, "succ": { "com": _2, "org": _2, "edu": _2 } }, "pg": _8, "ph": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "ngo": _2, "mil": _2, "i": _2 } }, "pk": { "$": 1, "succ": { "com": _2, "net": _2, "edu": _2, "org": _2, "fam": _2, "biz": _2, "web": _2, "gov": _2, "gob": _2, "gok": _2, "gon": _2, "gop": _2, "gos": _2, "info": _2 } }, "pl": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "aid": _2, "agro": _2, "atm": _2, "auto": _2, "biz": _2, "edu": _2, "gmina": _2, "gsm": _2, "info": _2, "mail": _2, "miasta": _2, "media": _2, "mil": _2, "nieruchomosci": _2, "nom": _2, "pc": _2, "powiat": _2, "priv": _2, "realestate": _2, "rel": _2, "sex": _2, "shop": _2, "sklep": _2, "sos": _2, "szkola": _2, "targi": _2, "tm": _2, "tourism": _2, "travel": _2, "turystyka": _2, "gov": { "$": 1, "succ": { "ap": _2, "ic": _2, "is": _2, "us": _2, "kmpsp": _2, "kppsp": _2, "kwpsp": _2, "psp": _2, "wskr": _2, "kwp": _2, "mw": _2, "ug": _2, "um": _2, "umig": _2, "ugim": _2, "upow": _2, "uw": _2, "starostwo": _2, "pa": _2, "po": _2, "psse": _2, "pup": _2, "rzgw": _2, "sa": _2, "so": _2, "sr": _2, "wsa": _2, "sko": _2, "uzs": _2, "wiih": _2, "winb": _2, "pinb": _2, "wios": _2, "witd": _2, "wzmiuw": _2, "piw": _2, "wiw": _2, "griw": _2, "wif": _2, "oum": _2, "sdn": _2, "zp": _2, "uppo": _2, "mup": _2, "wuoz": _2, "konsulat": _2, "oirm": _2 } }, "augustow": _2, "babia-gora": _2, "bedzin": _2, "beskidy": _2, "bialowieza": _2, "bialystok": _2, "bielawa": _2, "bieszczady": _2, "boleslawiec": _2, "bydgoszcz": _2, "bytom": _2, "cieszyn": _2, "czeladz": _2, "czest": _2, "dlugoleka": _2, "elblag": _2, "elk": _2, "glogow": _2, "gniezno": _2, "gorlice": _2, "grajewo": _2, "ilawa": _2, "jaworzno": _2, "jelenia-gora": _2, "jgora": _2, "kalisz": _2, "kazimierz-dolny": _2, "karpacz": _2, "kartuzy": _2, "kaszuby": _2, "katowice": _2, "kepno": _2, "ketrzyn": _2, "klodzko": _2, "kobierzyce": _2, "kolobrzeg": _2, "konin": _2, "konskowola": _2, "kutno": _2, "lapy": _2, "lebork": _2, "legnica": _2, "lezajsk": _2, "limanowa": _2, "lomza": _2, "lowicz": _2, "lubin": _2, "lukow": _2, "malbork": _2, "malopolska": _2, "mazowsze": _2, "mazury": _2, "mielec": _2, "mielno": _2, "mragowo": _2, "naklo": _2, "nowaruda": _2, "nysa": _2, "olawa": _2, "olecko": _2, "olkusz": _2, "olsztyn": _2, "opoczno": _2, "opole": _2, "ostroda": _2, "ostroleka": _2, "ostrowiec": _2, "ostrowwlkp": _2, "pila": _2, "pisz": _2, "podhale": _2, "podlasie": _2, "polkowice": _2, "pomorze": _2, "pomorskie": _2, "prochowice": _2, "pruszkow": _2, "przeworsk": _2, "pulawy": _2, "radom": _2, "rawa-maz": _2, "rybnik": _2, "rzeszow": _2, "sanok": _2, "sejny": _2, "slask": _2, "slupsk": _2, "sosnowiec": _2, "stalowa-wola": _2, "skoczow": _2, "starachowice": _2, "stargard": _2, "suwalki": _2, "swidnica": _2, "swiebodzin": _2, "swinoujscie": _2, "szczecin": _2, "szczytno": _2, "tarnobrzeg": _2, "tgory": _2, "turek": _2, "tychy": _2, "ustka": _2, "walbrzych": _2, "warmia": _2, "warszawa": _2, "waw": _2, "wegrow": _2, "wielun": _2, "wlocl": _2, "wloclawek": _2, "wodzislaw": _2, "wolomin": _2, "wroclaw": _2, "zachpomor": _2, "zagan": _2, "zarow": _2, "zgora": _2, "zgorzelec": _2, "beep": _4, "krasnik": _4, "leczna": _4, "lubartow": _4, "lublin": _4, "poniatowa": _4, "swidnik": _4, "co": _4, "art": _4, "gliwice": _4, "krakow": _4, "poznan": _4, "wroc": _4, "zakopane": _4, "gda": _4, "gdansk": _4, "gdynia": _4, "med": _4, "sopot": _4 } }, "pm": { "$": 1, "succ": { "own": _4 } }, "pn": { "$": 1, "succ": { "gov": _2, "co": _2, "org": _2, "edu": _2, "net": _2 } }, "post": _2, "pr": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "isla": _2, "pro": _2, "biz": _2, "info": _2, "name": _2, "est": _2, "prof": _2, "ac": _2 } }, "pro": { "$": 1, "succ": { "aaa": _2, "aca": _2, "acct": _2, "avocat": _2, "bar": _2, "cpa": _2, "eng": _2, "jur": _2, "law": _2, "med": _2, "recht": _2, "cloudns": _4, "dnstrace": { "$": 0, "succ": { "bci": _4 } }, "barsy": _4 } }, "ps": { "$": 1, "succ": { "edu": _2, "gov": _2, "sec": _2, "plo": _2, "com": _2, "org": _2, "net": _2 } }, "pt": { "$": 1, "succ": { "net": _2, "gov": _2, "org": _2, "edu": _2, "int": _2, "publ": _2, "com": _2, "nome": _2, "blogspot": _4, "nym": _4 } }, "pw": { "$": 1, "succ": { "co": _2, "ne": _2, "or": _2, "ed": _2, "go": _2, "belau": _2, "cloudns": _4, "x443": _4, "nom": _4 } }, "py": { "$": 1, "succ": { "com": _2, "coop": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 } }, "qa": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "blogspot": _4, "nom": _4 } }, "re": { "$": 1, "succ": { "asso": _2, "com": _2, "nom": _2, "blogspot": _4 } }, "ro": { "$": 1, "succ": { "arts": _2, "com": _2, "firm": _2, "info": _2, "nom": _2, "nt": _2, "org": _2, "rec": _2, "store": _2, "tm": _2, "www": _2, "shop": _4, "blogspot": _4, "nym": _4 } }, "rs": { "$": 1, "succ": { "ac": _2, "co": _2, "edu": _2, "gov": _2, "in": _2, "org": _2, "blogspot": _4, "ua": _4, "nom": _4, "ox": _4 } }, "ru": { "$": 1, "succ": { "ac": _4, "edu": _4, "gov": _4, "int": _4, "mil": _4, "test": _4, "adygeya": _4, "bashkiria": _4, "bir": _4, "cbg": _4, "com": _4, "dagestan": _4, "grozny": _4, "kalmykia": _4, "kustanai": _4, "marine": _4, "mordovia": _4, "msk": _4, "mytis": _4, "nalchik": _4, "nov": _4, "pyatigorsk": _4, "spb": _4, "vladikavkaz": _4, "vladimir": _4, "blogspot": _4, "regruhosting": _27, "myjino": { "$": 2, "succ": { "hosting": _7, "landing": _7, "spectrum": _7, "vps": _7 } }, "cldmail": { "$": 0, "succ": { "hb": _4 } }, "net": _4, "org": _4, "pp": _4, "ras": _4 } }, "rw": { "$": 1, "succ": { "ac": _2, "co": _2, "coop": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 } }, "sa": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "med": _2, "pub": _2, "edu": _2, "sch": _2 } }, "sb": _9, "sc": _9, "sd": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "med": _2, "tv": _2, "gov": _2, "info": _2 } }, "se": { "$": 1, "succ": { "a": _2, "ac": _2, "b": _2, "bd": _2, "brand": _2, "c": _2, "d": _2, "e": _2, "f": _2, "fh": _2, "fhsk": _2, "fhv": _2, "g": _2, "h": _2, "i": _2, "k": _2, "komforb": _2, "kommunalforbund": _2, "komvux": _2, "l": _2, "lanbib": _2, "m": _2, "n": _2, "naturbruksgymn": _2, "o": _2, "org": _2, "p": _2, "parti": _2, "pp": _2, "press": _2, "r": _2, "s": _2, "t": _2, "tm": _2, "u": _2, "w": _2, "x": _2, "y": _2, "z": _2, "com": _4, "blogspot": _4, "conf": _4 } }, "sg": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "per": _2, "blogspot": _4 } }, "sh": { "$": 1, "succ": { "com": _2, "net": _2, "gov": _2, "org": _2, "mil": _2, "hashbang": _4, "platform": { "$": 0, "succ": { "bc": _4, "ent": _4, "eu": _4, "us": _4 } }, "now": _4, "vxl": _4, "wedeploy": _4 } }, "si": { "$": 1, "succ": { "gitpage": _4, "blogspot": _4, "nom": _4 } }, "sj": _2, "sk": _23, "sl": _9, "sm": _2, "sn": { "$": 1, "succ": { "art": _2, "com": _2, "edu": _2, "gouv": _2, "org": _2, "perso": _2, "univ": _2, "blogspot": _4 } }, "so": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "sch": _4 } }, "sr": _2, "ss": { "$": 1, "succ": { "biz": _2, "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2 } }, "st": { "$": 1, "succ": { "co": _2, "com": _2, "consulado": _2, "edu": _2, "embaixada": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "principe": _2, "saotome": _2, "store": _2, "nom": _4, "noho": _4 } }, "su": { "$": 1, "succ": { "abkhazia": _4, "adygeya": _4, "aktyubinsk": _4, "arkhangelsk": _4, "armenia": _4, "ashgabad": _4, "azerbaijan": _4, "balashov": _4, "bashkiria": _4, "bryansk": _4, "bukhara": _4, "chimkent": _4, "dagestan": _4, "east-kazakhstan": _4, "exnet": _4, "georgia": _4, "grozny": _4, "ivanovo": _4, "jambyl": _4, "kalmykia": _4, "kaluga": _4, "karacol": _4, "karaganda": _4, "karelia": _4, "khakassia": _4, "krasnodar": _4, "kurgan": _4, "kustanai": _4, "lenug": _4, "mangyshlak": _4, "mordovia": _4, "msk": _4, "murmansk": _4, "nalchik": _4, "navoi": _4, "north-kazakhstan": _4, "nov": _4, "obninsk": _4, "penza": _4, "pokrovsk": _4, "sochi": _4, "spb": _4, "tashkent": _4, "termez": _4, "togliatti": _4, "troitsk": _4, "tselinograd": _4, "tula": _4, "tuva": _4, "vladikavkaz": _4, "vladimir": _4, "vologda": _4, "nym": _4 } }, "sv": { "$": 1, "succ": { "com": _2, "edu": _2, "gob": _2, "org": _2, "red": _2 } }, "sx": { "$": 1, "succ": { "gov": _2, "nym": _4 } }, "sy": _3, "sz": { "$": 1, "succ": { "co": _2, "ac": _2, "org": _2 } }, "tc": { "$": 1, "succ": { "ch": _4, "me": _4, "we": _4 } }, "td": _5, "tel": _2, "tf": _2, "tg": _2, "th": { "$": 1, "succ": { "ac": _2, "co": _2, "go": _2, "in": _2, "mi": _2, "net": _2, "or": _2, "online": _4, "shop": _4 } }, "tj": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "go": _2, "gov": _2, "int": _2, "mil": _2, "name": _2, "net": _2, "nic": _2, "org": _2, "test": _2, "web": _2, "nom": _4 } }, "tk": _2, "tl": _6, "tm": { "$": 1, "succ": { "com": _2, "co": _2, "org": _2, "net": _2, "nom": _2, "gov": _2, "mil": _2, "edu": _2 } }, "tn": { "$": 1, "succ": { "com": _2, "ens": _2, "fin": _2, "gov": _2, "ind": _2, "intl": _2, "nat": _2, "net": _2, "org": _2, "info": _2, "perso": _2, "tourism": _2, "edunet": _2, "rnrt": _2, "rns": _2, "rnu": _2, "mincom": _2, "agrinet": _2, "defense": _2, "turen": _2 } }, "to": { "$": 1, "succ": { "611": _4, "com": _2, "gov": _2, "net": _2, "org": _2, "edu": _2, "mil": _2, "oya": _4, "vpnplus": _4, "quickconnect": { "$": 0, "succ": { "direct": _4 } }, "nyan": _4 } }, "tr": { "$": 1, "succ": { "av": _2, "bbs": _2, "bel": _2, "biz": _2, "com": _5, "dr": _2, "edu": _2, "gen": _2, "gov": _2, "info": _2, "mil": _2, "k12": _2, "kep": _2, "name": _2, "net": _2, "org": _2, "pol": _2, "tel": _2, "tsk": _2, "tv": _2, "web": _2, "nc": _6 } }, "tt": { "$": 1, "succ": { "co": _2, "com": _2, "org": _2, "net": _2, "biz": _2, "info": _2, "pro": _2, "int": _2, "coop": _2, "jobs": _2, "mobi": _2, "travel": _2, "museum": _2, "aero": _2, "name": _2, "gov": _2, "edu": _2 } }, "tv": { "$": 1, "succ": { "dyndns": _4, "better-than": _4, "on-the-web": _4, "worse-than": _4 } }, "tw": { "$": 1, "succ": { "edu": _2, "gov": _2, "mil": _2, "com": { "$": 1, "succ": { "mymailer": _4 } }, "net": _2, "org": _2, "idv": _2, "game": _2, "ebiz": _2, "club": _2, "xn--zf0ao64a": _2, "網路": _2, "xn--uc0atv": _2, "組織": _2, "xn--czrw28b": _2, "商業": _2, "url": _4, "blogspot": _4, "nym": _4 } }, "tz": { "$": 1, "succ": { "ac": _2, "co": _2, "go": _2, "hotel": _2, "info": _2, "me": _2, "mil": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2, "tv": _2 } }, "ua": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "in": _2, "net": _2, "org": _2, "cherkassy": _2, "cherkasy": _2, "chernigov": _2, "chernihiv": _2, "chernivtsi": _2, "chernovtsy": _2, "ck": _2, "cn": _2, "cr": _2, "crimea": _2, "cv": _2, "dn": _2, "dnepropetrovsk": _2, "dnipropetrovsk": _2, "donetsk": _2, "dp": _2, "if": _2, "ivano-frankivsk": _2, "kh": _2, "kharkiv": _2, "kharkov": _2, "kherson": _2, "khmelnitskiy": _2, "khmelnytskyi": _2, "kiev": _2, "kirovograd": _2, "km": _2, "kr": _2, "krym": _2, "ks": _2, "kv": _2, "kyiv": _2, "lg": _2, "lt": _2, "lugansk": _2, "lutsk": _2, "lv": _2, "lviv": _2, "mk": _2, "mykolaiv": _2, "nikolaev": _2, "od": _2, "odesa": _2, "odessa": _2, "pl": _2, "poltava": _2, "rivne": _2, "rovno": _2, "rv": _2, "sb": _2, "sebastopol": _2, "sevastopol": _2, "sm": _2, "sumy": _2, "te": _2, "ternopil": _2, "uz": _2, "uzhgorod": _2, "vinnica": _2, "vinnytsia": _2, "vn": _2, "volyn": _2, "yalta": _2, "zaporizhzhe": _2, "zaporizhzhia": _2, "zhitomir": _2, "zhytomyr": _2, "zp": _2, "zt": _2, "cc": _4, "inf": _4, "ltd": _4, "biz": _4, "co": _4, "pp": _4, "v": _4 } }, "ug": { "$": 1, "succ": { "co": _2, "or": _2, "ac": _2, "sc": _2, "go": _2, "ne": _2, "com": _2, "org": _2, "blogspot": _4, "nom": _4 } }, "uk": { "$": 1, "succ": { "ac": _2, "co": { "$": 1, "succ": { "bytemark": { "$": 0, "succ": { "dh": _4, "vm": _4 } }, "blogspot": _4, "layershift": _17, "barsy": _4, "barsyonline": _4, "nh-serv": _4, "no-ip": _4, "wellbeingzone": _4, "gwiddle": _4 } }, "gov": { "$": 1, "succ": { "service": _4, "homeoffice": _4 } }, "ltd": _2, "me": _2, "net": _2, "nhs": _2, "org": { "$": 1, "succ": { "glug": _4, "lug": _4, "lugs": _4 } }, "plc": _2, "police": _2, "sch": _8, "conn": _4, "copro": _4, "barsy": _4 } }, "us": { "$": 1, "succ": { "dni": _2, "fed": _2, "isa": _2, "kids": _2, "nsn": _2, "ak": _30, "al": _30, "ar": _30, "as": _30, "az": _30, "ca": _30, "co": _30, "ct": _30, "dc": _30, "de": { "$": 1, "succ": { "k12": _2, "cc": _2, "lib": _4 } }, "fl": _30, "ga": _30, "gu": _30, "hi": _31, "ia": _30, "id": _30, "il": _30, "in": _30, "ks": _30, "ky": _30, "la": _30, "ma": { "$": 1, "succ": { "k12": { "$": 1, "succ": { "pvt": _2, "chtr": _2, "paroch": _2 } }, "cc": _2, "lib": _2 } }, "md": _30, "me": _30, "mi": { "$": 1, "succ": { "k12": _2, "cc": _2, "lib": _2, "ann-arbor": _2, "cog": _2, "dst": _2, "eaton": _2, "gen": _2, "mus": _2, "tec": _2, "washtenaw": _2 } }, "mn": _30, "mo": _30, "ms": _30, "mt": _30, "nc": _30, "nd": _31, "ne": _30, "nh": _30, "nj": _30, "nm": _30, "nv": _30, "ny": _30, "oh": _30, "ok": _30, "or": _30, "pa": _30, "pr": _30, "ri": _31, "sc": _30, "sd": _31, "tn": _30, "tx": _30, "ut": _30, "vi": _30, "vt": _30, "va": _30, "wa": _30, "wi": _30, "wv": { "$": 1, "succ": { "cc": _2 } }, "wy": _30, "cloudns": _4, "drud": _4, "is-by": _4, "land-4-sale": _4, "stuff-4-sale": _4, "graphox": _4, "freeddns": _4, "golffan": _4, "noip": _4, "pointto": _4, "platterp": _4 } }, "uy": { "$": 1, "succ": { "com": _5, "edu": _2, "gub": _2, "mil": _2, "net": _2, "org": _2, "nom": _4 } }, "uz": { "$": 1, "succ": { "co": _2, "com": _2, "net": _2, "org": _2 } }, "va": _2, "vc": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "mil": _2, "edu": _2, "gv": { "$": 2, "succ": { "d": _4 } }, "0e": _4, "nom": _4 } }, "ve": { "$": 1, "succ": { "arts": _2, "co": _2, "com": _2, "e12": _2, "edu": _2, "firm": _2, "gob": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "org": _2, "rec": _2, "store": _2, "tec": _2, "web": _2 } }, "vg": { "$": 1, "succ": { "nom": _4, "at": _4 } }, "vi": { "$": 1, "succ": { "co": _2, "com": _2, "k12": _2, "net": _2, "org": _2 } }, "vn": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "int": _2, "ac": _2, "biz": _2, "info": _2, "name": _2, "pro": _2, "health": _2, "blogspot": _4 } }, "vu": { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2, "blog": _4, "dev": _4, "me": _4, "cn": _4 } }, "wf": _2, "ws": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "advisor": _7, "cloud66": _4, "dyndns": _4, "mypets": _4 } }, "yt": _2, "xn--mgbaam7a8h": _2, "امارات": _2, "xn--y9a3aq": _2, "հայ": _2, "xn--54b7fta0cc": _2, "বাংলা": _2, "xn--90ae": _2, "бг": _2, "xn--90ais": _2, "бел": _2, "xn--fiqs8s": _2, "中国": _2, "xn--fiqz9s": _2, "中國": _2, "xn--lgbbat1ad8j": _2, "الجزائر": _2, "xn--wgbh1c": _2, "مصر": _2, "xn--e1a4c": _2, "ею": _2, "xn--qxa6a": _2, "ευ": _2, "xn--mgbah1a3hjkrd": _2, "موريتانيا": _2, "xn--node": _2, "გე": _2, "xn--qxam": _2, "ελ": _2, "xn--j6w193g": { "$": 1, "succ": { "xn--55qx5d": _2, "xn--wcvs22d": _2, "xn--mxtq1m": _2, "xn--gmqw5a": _2, "xn--od0alg": _2, "xn--uc0atv": _2 } }, "香港": { "$": 1, "succ": { "公司": _2, "教育": _2, "政府": _2, "個人": _2, "網絡": _2, "組織": _2 } }, "xn--2scrj9c": _2, "ಭಾರತ": _2, "xn--3hcrj9c": _2, "ଭାରତ": _2, "xn--45br5cyl": _2, "ভাৰত": _2, "xn--h2breg3eve": _2, "भारतम्": _2, "xn--h2brj9c8c": _2, "भारोत": _2, "xn--mgbgu82a": _2, "ڀارت": _2, "xn--rvc1e0am3e": _2, "ഭാരതം": _2, "xn--h2brj9c": _2, "भारत": _2, "xn--mgbbh1a": _2, "بارت": _2, "xn--mgbbh1a71e": _2, "بھارت": _2, "xn--fpcrj9c3d": _2, "భారత్": _2, "xn--gecrj9c": _2, "ભારત": _2, "xn--s9brj9c": _2, "ਭਾਰਤ": _2, "xn--45brj9c": _2, "ভারত": _2, "xn--xkc2dl3a5ee0h": _2, "இந்தியா": _2, "xn--mgba3a4f16a": _2, "ایران": _2, "xn--mgba3a4fra": _2, "ايران": _2, "xn--mgbtx2b": _2, "عراق": _2, "xn--mgbayh7gpa": _2, "الاردن": _2, "xn--3e0b707e": _2, "한국": _2, "xn--80ao21a": _2, "қаз": _2, "xn--fzc2c9e2c": _2, "ලංකා": _2, "xn--xkc2al3hye2a": _2, "இலங்கை": _2, "xn--mgbc0a9azcg": _2, "المغرب": _2, "xn--d1alf": _2, "мкд": _2, "xn--l1acc": _2, "мон": _2, "xn--mix891f": _2, "澳門": _2, "xn--mix082f": _2, "澳门": _2, "xn--mgbx4cd0ab": _2, "مليسيا": _2, "xn--mgb9awbf": _2, "عمان": _2, "xn--mgbai9azgqp6j": _2, "پاکستان": _2, "xn--mgbai9a5eva00b": _2, "پاكستان": _2, "xn--ygbi2ammx": _2, "فلسطين": _2, "xn--90a3ac": { "$": 1, "succ": { "xn--o1ac": _2, "xn--c1avg": _2, "xn--90azh": _2, "xn--d1at": _2, "xn--o1ach": _2, "xn--80au": _2 } }, "срб": { "$": 1, "succ": { "пр": _2, "орг": _2, "обр": _2, "од": _2, "упр": _2, "ак": _2 } }, "xn--p1ai": _2, "рф": _2, "xn--wgbl6a": _2, "قطر": _2, "xn--mgberp4a5d4ar": _2, "السعودية": _2, "xn--mgberp4a5d4a87g": _2, "السعودیة": _2, "xn--mgbqly7c0a67fbc": _2, "السعودیۃ": _2, "xn--mgbqly7cvafr": _2, "السعوديه": _2, "xn--mgbpl2fh": _2, "سودان": _2, "xn--yfro4i67o": _2, "新加坡": _2, "xn--clchc0ea0b2g2a9gcd": _2, "சிங்கப்பூர்": _2, "xn--ogbpf8fl": _2, "سورية": _2, "xn--mgbtf8fl": _2, "سوريا": _2, "xn--o3cw4h": { "$": 1, "succ": { "xn--12c1fe0br": _2, "xn--12co0c3b4eva": _2, "xn--h3cuzk1di": _2, "xn--o3cyx2a": _2, "xn--m3ch0j3a": _2, "xn--12cfi8ixb8l": _2 } }, "ไทย": { "$": 1, "succ": { "ศึกษา": _2, "ธุรกิจ": _2, "รัฐบาล": _2, "ทหาร": _2, "เน็ต": _2, "องค์กร": _2 } }, "xn--pgbs0dh": _2, "تونس": _2, "xn--kpry57d": _2, "台灣": _2, "xn--kprw13d": _2, "台湾": _2, "xn--nnx388a": _2, "臺灣": _2, "xn--j1amh": _2, "укр": _2, "xn--mgb2ddes": _2, "اليمن": _2, "xxx": _2, "ye": _8, "za": { "$": 0, "succ": { "ac": _2, "agric": _2, "alt": _2, "co": _5, "edu": _2, "gov": _2, "grondar": _2, "law": _2, "mil": _2, "net": _2, "ngo": _2, "nic": _2, "nis": _2, "nom": _2, "org": _2, "school": _2, "tm": _2, "web": _2 } }, "zm": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "mil": _2, "net": _2, "org": _2, "sch": _2 } }, "zw": { "$": 1, "succ": { "ac": _2, "co": _2, "gov": _2, "mil": _2, "org": _2 } }, "aaa": _2, "aarp": _2, "abarth": _2, "abb": _2, "abbott": _2, "abbvie": _2, "abc": _2, "able": _2, "abogado": _2, "abudhabi": _2, "academy": { "$": 1, "succ": { "official": _4 } }, "accenture": _2, "accountant": _2, "accountants": _2, "aco": _2, "actor": _2, "adac": _2, "ads": _2, "adult": _2, "aeg": _2, "aetna": _2, "afamilycompany": _2, "afl": _2, "africa": _2, "agakhan": _2, "agency": _2, "aig": _2, "airbus": _2, "airforce": _2, "airtel": _2, "akdn": _2, "alfaromeo": _2, "alibaba": _2, "alipay": _2, "allfinanz": _2, "allstate": _2, "ally": _2, "alsace": _2, "alstom": _2, "amazon": _2, "americanexpress": _2, "americanfamily": _2, "amex": _2, "amfam": _2, "amica": _2, "amsterdam": _2, "analytics": _2, "android": _2, "anquan": _2, "anz": _2, "aol": _2, "apartments": _2, "app": { "$": 1, "succ": { "wnext": _4, "run": { "$": 2, "succ": { "a": _4 } }, "web": _4, "hasura": _4, "loginline": _4, "netlify": _4, "telebit": _4, "vercel": _4 } }, "apple": _2, "aquarelle": _2, "arab": _2, "aramco": _2, "archi": _2, "army": _2, "art": _2, "arte": _2, "asda": _2, "associates": _2, "athleta": _2, "attorney": _2, "auction": _2, "audi": _2, "audible": _2, "audio": _2, "auspost": _2, "author": _2, "auto": _2, "autos": _2, "avianca": _2, "aws": _2, "axa": _2, "azure": _2, "baby": _2, "baidu": _2, "banamex": _2, "bananarepublic": _2, "band": _2, "bank": _2, "bar": _2, "barcelona": _2, "barclaycard": _2, "barclays": _2, "barefoot": _2, "bargains": _2, "baseball": _2, "basketball": _2, "bauhaus": _2, "bayern": _2, "bbc": _2, "bbt": _2, "bbva": _2, "bcg": _2, "bcn": _2, "beats": _2, "beauty": _2, "beer": _2, "bentley": _2, "berlin": _2, "best": _2, "bestbuy": _2, "bet": _2, "bharti": _2, "bible": _2, "bid": _2, "bike": _2, "bing": _2, "bingo": _2, "bio": _2, "black": _2, "blackfriday": _2, "blockbuster": _2, "blog": _2, "bloomberg": _2, "blue": _2, "bms": _2, "bmw": _2, "bnpparibas": _2, "boats": _2, "boehringer": _2, "bofa": _2, "bom": _2, "bond": _2, "boo": _2, "book": _2, "booking": _2, "bosch": _2, "bostik": _2, "boston": _2, "bot": _2, "boutique": _2, "box": _2, "bradesco": _2, "bridgestone": _2, "broadway": _2, "broker": _2, "brother": _2, "brussels": _2, "budapest": _2, "bugatti": _2, "build": _2, "builders": _2, "business": _10, "buy": _2, "buzz": _2, "bzh": _2, "cab": _2, "cafe": _2, "cal": _2, "call": _2, "calvinklein": _2, "cam": _2, "camera": _2, "camp": _2, "cancerresearch": _2, "canon": _2, "capetown": _2, "capital": _2, "capitalone": _2, "car": _2, "caravan": _2, "cards": _2, "care": _2, "career": _2, "careers": _2, "cars": _2, "casa": { "$": 1, "succ": { "nabu": { "$": 0, "succ": { "ui": _4 } } } }, "case": _2, "caseih": _2, "cash": _2, "casino": _2, "catering": _2, "catholic": _2, "cba": _2, "cbn": _2, "cbre": _2, "cbs": _2, "ceb": _2, "center": _2, "ceo": _2, "cern": _2, "cfa": _2, "cfd": _2, "chanel": _2, "channel": _2, "charity": _2, "chase": _2, "chat": _2, "cheap": _2, "chintai": _2, "christmas": _2, "chrome": _2, "church": _2, "cipriani": _2, "circle": _2, "cisco": _2, "citadel": _2, "citi": _2, "citic": _2, "city": _11, "cityeats": _2, "claims": _2, "cleaning": _2, "click": _2, "clinic": _2, "clinique": _2, "clothing": _2, "cloud": { "$": 1, "succ": { "banzai": _7, "statics": _7, "jele": _4, "linkyard": _4, "magentosite": _7, "perspecta": _4, "vapor": _4, "on-rancher": _7, "sensiosite": _7, "trafficplex": _4, "urown": _4, "voorloper": _4 } }, "club": { "$": 1, "succ": { "cloudns": _4, "jele": _4, "barsy": _4, "pony": _4 } }, "clubmed": _2, "coach": _2, "codes": { "$": 1, "succ": { "owo": _7 } }, "coffee": _2, "college": _2, "cologne": _2, "comcast": _2, "commbank": _2, "community": { "$": 1, "succ": { "ravendb": _4, "myforum": _4 } }, "company": _2, "compare": _2, "computer": _2, "comsec": _2, "condos": _2, "construction": _2, "consulting": _2, "contact": _2, "contractors": _2, "cooking": _2, "cookingchannel": _2, "cool": { "$": 1, "succ": { "de": _4 } }, "corsica": _2, "country": _2, "coupon": _2, "coupons": _2, "courses": _2, "cpa": _2, "credit": _2, "creditcard": _2, "creditunion": _2, "cricket": _2, "crown": _2, "crs": _2, "cruise": _2, "cruises": _2, "csc": _2, "cuisinella": _2, "cymru": _2, "cyou": _2, "dabur": _2, "dad": _2, "dance": _2, "data": _2, "date": _2, "dating": _2, "datsun": _2, "day": _2, "dclk": _2, "dds": _2, "deal": _2, "dealer": _2, "deals": _2, "degree": _2, "delivery": _2, "dell": _2, "deloitte": _2, "delta": _2, "democrat": _2, "dental": _2, "dentist": _2, "desi": _2, "design": { "$": 1, "succ": { "bss": _4 } }, "dev": { "$": 1, "succ": { "lcl": _7, "stg": _7, "workers": _4, "curv": _4, "fly": _4, "iserv": _4, "loginline": _4, "platter-app": _4, "vercel": _4, "webhare": _7 } }, "dhl": _2, "diamonds": _2, "diet": _2, "digital": { "$": 1, "succ": { "cloudapps": { "$": 2, "succ": { "london": _4 } } } }, "direct": _2, "directory": _2, "discount": _2, "discover": _2, "dish": _2, "diy": _2, "dnp": _2, "docs": _2, "doctor": _2, "dog": _2, "domains": _2, "dot": _2, "download": _2, "drive": _2, "dtv": _2, "dubai": _2, "duck": _2, "dunlop": _2, "dupont": _2, "durban": _2, "dvag": _2, "dvr": _2, "earth": { "$": 1, "succ": { "dapps": { "$": 0, "succ": { "*": _4, "bzz": _7 } } } }, "eat": _2, "eco": _2, "edeka": _2, "education": _10, "email": _2, "emerck": _2, "energy": _2, "engineer": _2, "engineering": _2, "enterprises": _2, "epson": _2, "equipment": _2, "ericsson": _2, "erni": _2, "esq": _2, "estate": { "$": 1, "succ": { "compute": _7 } }, "etisalat": _2, "eurovision": _2, "eus": { "$": 1, "succ": { "party": _18 } }, "events": _10, "exchange": _2, "expert": _2, "exposed": _2, "express": _2, "extraspace": _2, "fage": _2, "fail": _2, "fairwinds": _2, "faith": _19, "family": _2, "fan": _2, "fans": _2, "farm": { "$": 1, "succ": { "storj": _4 } }, "farmers": _2, "fashion": { "$": 1, "succ": { "of": _4, "on": _4 } }, "fast": _2, "fedex": _2, "feedback": _2, "ferrari": _2, "ferrero": _2, "fiat": _2, "fidelity": _2, "fido": _2, "film": _2, "final": _2, "finance": _2, "financial": _10, "fire": _2, "firestone": _2, "firmdale": _2, "fish": _2, "fishing": _2, "fit": { "$": 1, "succ": { "ptplus": _4 } }, "fitness": _2, "flickr": _2, "flights": _2, "flir": _2, "florist": _2, "flowers": _2, "fly": _2, "foo": _2, "food": _2, "foodnetwork": _2, "football": { "$": 1, "succ": { "of": _4 } }, "ford": _2, "forex": _2, "forsale": _2, "forum": _2, "foundation": _2, "fox": _2, "free": _2, "fresenius": _2, "frl": _2, "frogans": _2, "frontdoor": _2, "frontier": _2, "ftr": _2, "fujitsu": _2, "fujixerox": _2, "fun": _2, "fund": _2, "furniture": _2, "futbol": _2, "fyi": _2, "gal": _2, "gallery": _2, "gallo": _2, "gallup": _2, "game": _2, "games": _2, "gap": _2, "garden": _2, "gay": _2, "gbiz": _2, "gdn": { "$": 1, "succ": { "cnpy": _4 } }, "gea": _2, "gent": _2, "genting": _2, "george": _2, "ggee": _2, "gift": _2, "gifts": _2, "gives": _2, "giving": _2, "glade": _2, "glass": _2, "gle": _2, "global": _2, "globo": _2, "gmail": _2, "gmbh": _2, "gmo": _2, "gmx": _2, "godaddy": _2, "gold": _2, "goldpoint": _2, "golf": _2, "goo": _2, "goodyear": _2, "goog": { "$": 1, "succ": { "cloud": _4 } }, "google": _2, "gop": _2, "got": _2, "grainger": _2, "graphics": _2, "gratis": _2, "green": _2, "gripe": _2, "grocery": _2, "group": { "$": 1, "succ": { "discourse": _4 } }, "guardian": _2, "gucci": _2, "guge": _2, "guide": _2, "guitars": _2, "guru": _2, "hair": _2, "hamburg": _2, "hangout": _2, "haus": _2, "hbo": _2, "hdfc": _2, "hdfcbank": _2, "health": _2, "healthcare": _2, "help": _2, "helsinki": _2, "here": _2, "hermes": _2, "hgtv": _2, "hiphop": _2, "hisamitsu": _2, "hitachi": _2, "hiv": _2, "hkt": _2, "hockey": _2, "holdings": _2, "holiday": _2, "homedepot": _2, "homegoods": _2, "homes": _2, "homesense": _2, "honda": _2, "horse": _2, "hospital": _2, "host": { "$": 1, "succ": { "cloudaccess": _4, "freesite": _4, "fastvps": _4, "myfast": _4, "jele": _4, "mircloud": _4, "pcloud": _4, "half": _4 } }, "hosting": { "$": 1, "succ": { "opencraft": _4 } }, "hot": _2, "hoteles": _2, "hotels": _2, "hotmail": _2, "house": _2, "how": _2, "hsbc": _2, "hughes": _2, "hyatt": _2, "hyundai": _2, "ibm": _2, "icbc": _2, "ice": _2, "icu": _2, "ieee": _2, "ifm": _2, "ikano": _2, "imamat": _2, "imdb": _2, "immo": _2, "immobilien": _2, "inc": _2, "industries": _2, "infiniti": _2, "ing": _2, "ink": _11, "institute": _2, "insurance": _2, "insure": _2, "intel": _2, "international": _2, "intuit": _2, "investments": _2, "ipiranga": _2, "irish": _2, "ismaili": _2, "ist": _2, "istanbul": _2, "itau": _2, "itv": _2, "iveco": _2, "jaguar": _2, "java": _2, "jcb": _2, "jcp": _2, "jeep": _2, "jetzt": _2, "jewelry": _2, "jio": _2, "jll": _2, "jmp": _2, "jnj": _2, "joburg": _2, "jot": _2, "joy": _2, "jpmorgan": _2, "jprs": _2, "juegos": _2, "juniper": _2, "kaufen": _2, "kddi": _2, "kerryhotels": _2, "kerrylogistics": _2, "kerryproperties": _2, "kfh": _2, "kia": _2, "kim": _2, "kinder": _2, "kindle": _2, "kitchen": _2, "kiwi": _2, "koeln": _2, "komatsu": _2, "kosher": _2, "kpmg": _2, "kpn": _2, "krd": { "$": 1, "succ": { "co": _4, "edu": _4 } }, "kred": _2, "kuokgroup": _2, "kyoto": _2, "lacaixa": _2, "lamborghini": _2, "lamer": _2, "lancaster": _2, "lancia": _2, "land": { "$": 1, "succ": { "static": { "$": 2, "succ": { "dev": _4, "sites": _4 } } } }, "landrover": _2, "lanxess": _2, "lasalle": _2, "lat": _2, "latino": _2, "latrobe": _2, "law": _2, "lawyer": _2, "lds": _2, "lease": _2, "leclerc": _2, "lefrak": _2, "legal": _2, "lego": _2, "lexus": _2, "lgbt": _2, "lidl": _2, "life": _2, "lifeinsurance": _2, "lifestyle": _2, "lighting": _2, "like": _2, "lilly": _2, "limited": _2, "limo": _2, "lincoln": _2, "linde": _2, "link": { "$": 1, "succ": { "cyon": _4, "mypep": _4, "dweb": _7 } }, "lipsy": _2, "live": _2, "living": _2, "lixil": _2, "llc": _2, "llp": _2, "loan": _2, "loans": _2, "locker": _2, "locus": _2, "loft": _2, "lol": _2, "london": { "$": 1, "succ": { "in": _4, "of": _4 } }, "lotte": _2, "lotto": _2, "love": _2, "lpl": _2, "lplfinancial": _2, "ltd": _2, "ltda": _2, "lundbeck": _2, "lupin": _2, "luxe": _2, "luxury": _2, "macys": _2, "madrid": _2, "maif": _2, "maison": _2, "makeup": _2, "man": _2, "management": { "$": 1, "succ": { "router": _4 } }, "mango": _2, "map": _2, "market": _2, "marketing": _2, "markets": _2, "marriott": _2, "marshalls": _2, "maserati": _2, "mattel": _2, "mba": _2, "mckinsey": _2, "med": _2, "media": _2, "meet": _2, "melbourne": _2, "meme": _2, "memorial": _2, "men": _24, "menu": _25, "merckmsd": _2, "metlife": _2, "miami": _2, "microsoft": _2, "mini": _2, "mint": _2, "mit": _2, "mitsubishi": _2, "mlb": _2, "mls": _2, "mma": _2, "mobile": _2, "moda": _2, "moe": _2, "moi": _2, "mom": { "$": 1, "succ": { "and": _4, "for": _4 } }, "monash": _2, "money": _2, "monster": _2, "mormon": _2, "mortgage": _2, "moscow": _2, "moto": _2, "motorcycles": _2, "mov": _2, "movie": _2, "msd": _2, "mtn": _2, "mtr": _2, "mutual": _2, "nab": _2, "nagoya": _2, "nationwide": _2, "natura": _2, "navy": _2, "nba": _2, "nec": _2, "netbank": _2, "netflix": _2, "network": { "$": 1, "succ": { "alces": _7, "co": _4, "arvo": _4, "azimuth": _4 } }, "neustar": _2, "new": _2, "newholland": _2, "news": _2, "next": _2, "nextdirect": _2, "nexus": _2, "nfl": _2, "ngo": _2, "nhk": _2, "nico": _2, "nike": _2, "nikon": _2, "ninja": _2, "nissan": _2, "nissay": _2, "nokia": _2, "northwesternmutual": _2, "norton": _2, "now": _2, "nowruz": _2, "nowtv": _2, "nra": _2, "nrw": _2, "ntt": _2, "nyc": _2, "obi": _2, "observer": _2, "off": _2, "office": _2, "okinawa": _2, "olayan": _2, "olayangroup": _2, "oldnavy": _2, "ollo": _2, "omega": _2, "one": { "$": 1, "succ": { "onred": { "$": 2, "succ": { "staging": _4 } }, "for": _4, "homelink": _4 } }, "ong": _2, "onl": _2, "online": _25, "onyourside": _2, "ooo": _2, "open": _2, "oracle": _2, "orange": _2, "organic": _2, "origins": _2, "osaka": _2, "otsuka": _2, "ott": _2, "ovh": { "$": 1, "succ": { "nerdpol": _4 } }, "page": { "$": 1, "succ": { "pdns": _4, "plesk": _4, "prvcy": _4 } }, "panasonic": _2, "paris": _2, "pars": _2, "partners": _2, "parts": _2, "party": _19, "passagens": _2, "pay": _2, "pccw": _2, "pet": _2, "pfizer": _2, "pharmacy": _2, "phd": _2, "philips": _2, "phone": _2, "photo": _2, "photography": _2, "photos": _2, "physio": _2, "pics": _2, "pictet": _2, "pictures": { "$": 1, "succ": { "1337": _4 } }, "pid": _2, "pin": _2, "ping": _2, "pink": _2, "pioneer": _2, "pizza": _2, "place": _10, "play": _2, "playstation": _2, "plumbing": _2, "plus": _2, "pnc": _2, "pohl": _2, "poker": _2, "politie": _2, "porn": { "$": 1, "succ": { "indie": _4 } }, "pramerica": _2, "praxi": _2, "press": _2, "prime": _2, "prod": _2, "productions": _2, "prof": _2, "progressive": _2, "promo": _2, "properties": _2, "property": _2, "protection": _2, "pru": _2, "prudential": _2, "pub": _25, "pwc": _2, "qpon": _2, "quebec": _2, "quest": _2, "qvc": _2, "racing": _2, "radio": _2, "raid": _2, "read": _2, "realestate": _2, "realtor": _2, "realty": _2, "recipes": _2, "red": _2, "redstone": _2, "redumbrella": _2, "rehab": _2, "reise": _2, "reisen": _2, "reit": _2, "reliance": _2, "ren": _2, "rent": _2, "rentals": _2, "repair": _2, "report": _2, "republican": _2, "rest": _2, "restaurant": _2, "review": _19, "reviews": _2, "rexroth": _2, "rich": _2, "richardli": _2, "ricoh": _2, "ril": _2, "rio": _2, "rip": { "$": 1, "succ": { "clan": _4 } }, "rmit": _2, "rocher": _2, "rocks": { "$": 1, "succ": { "myddns": _4, "lima-city": _4, "webspace": _4 } }, "rodeo": _2, "rogers": _2, "room": _2, "rsvp": _2, "rugby": _2, "ruhr": _2, "run": { "$": 1, "succ": { "hs": _4, "development": _4, "ravendb": _4, "repl": _4 } }, "rwe": _2, "ryukyu": _2, "saarland": _2, "safe": _2, "safety": _2, "sakura": _2, "sale": _24, "salon": _2, "samsclub": _2, "samsung": _2, "sandvik": _2, "sandvikcoromant": _2, "sanofi": _2, "sap": _2, "sarl": _2, "sas": _2, "save": _2, "saxo": _2, "sbi": _2, "sbs": _2, "sca": _2, "scb": _2, "schaeffler": _2, "schmidt": _2, "scholarships": _2, "school": _11, "schule": _2, "schwarz": _2, "science": _19, "scjohnson": _2, "scot": { "$": 1, "succ": { "gov": _4 } }, "search": _2, "seat": _2, "secure": _2, "security": _2, "seek": _2, "select": _2, "sener": _2, "services": { "$": 1, "succ": { "loginline": _4 } }, "ses": _2, "seven": _2, "sew": _2, "sex": _2, "sexy": _2, "sfr": _2, "shangrila": _2, "sharp": _2, "shaw": _2, "shell": _2, "shia": _2, "shiksha": _2, "shoes": _2, "shop": _25, "shopping": _2, "shouji": _2, "show": _2, "showtime": _2, "shriram": _2, "silk": _2, "sina": _2, "singles": _2, "site": { "$": 1, "succ": { "cloudera": _4, "cyon": _4, "fastvps": _4, "jele": _4, "lelux": _4, "loginline": _4, "barsy": _4, "opensocial": _4, "platformsh": _7, "byen": _4, "mintere": _4 } }, "ski": _2, "skin": _2, "sky": _2, "skype": _2, "sling": _2, "smart": _2, "smile": _2, "sncf": _2, "soccer": _2, "social": _2, "softbank": _2, "software": _2, "sohu": _2, "solar": _2, "solutions": _2, "song": _2, "sony": _2, "soy": _2, "spa": _2, "space": { "$": 1, "succ": { "myfast": _4, "linkitools": _4, "uber": _4, "xs4all": _4 } }, "sport": _2, "spot": _2, "spreadbetting": _2, "srl": _2, "stada": _2, "staples": _2, "star": _2, "statebank": _2, "statefarm": _2, "stc": _2, "stcgroup": _2, "stockholm": _2, "storage": _2, "store": { "$": 1, "succ": { "shopware": _4 } }, "stream": _2, "studio": _2, "study": _2, "style": _2, "sucks": _2, "supplies": _2, "supply": _2, "support": _25, "surf": _2, "surgery": _2, "suzuki": _2, "swatch": _2, "swiftcover": _2, "swiss": _2, "sydney": _2, "systems": { "$": 1, "succ": { "knightpoint": _4 } }, "tab": _2, "taipei": _2, "talk": _2, "taobao": _2, "target": _2, "tatamotors": _2, "tatar": _2, "tattoo": _2, "tax": _2, "taxi": _2, "tci": _2, "tdk": _2, "team": { "$": 1, "succ": { "discourse": _4, "jelastic": _4 } }, "tech": _2, "technology": _10, "temasek": _2, "tennis": _2, "teva": _2, "thd": _2, "theater": _2, "theatre": _2, "tiaa": _2, "tickets": _2, "tienda": _2, "tiffany": _2, "tips": _2, "tires": _2, "tirol": _2, "tjmaxx": _2, "tjx": _2, "tkmaxx": _2, "tmall": _2, "today": _2, "tokyo": _2, "tools": _2, "top": { "$": 1, "succ": { "now-dns": _4, "ntdll": _4 } }, "toray": _2, "toshiba": _2, "total": _2, "tours": _2, "town": _2, "toyota": _2, "toys": _2, "trade": _19, "trading": _2, "training": _2, "travel": _2, "travelchannel": _2, "travelers": _2, "travelersinsurance": _2, "trust": _2, "trv": _2, "tube": _2, "tui": _2, "tunes": _2, "tushu": _2, "tvs": _2, "ubank": _2, "ubs": _2, "unicom": _2, "university": _2, "uno": _2, "uol": _2, "ups": _2, "vacations": _2, "vana": _2, "vanguard": _2, "vegas": _2, "ventures": _2, "verisign": _2, "versicherung": _2, "vet": _2, "viajes": _2, "video": _2, "vig": _2, "viking": _2, "villas": _2, "vin": _2, "vip": _2, "virgin": _2, "visa": _2, "vision": _2, "viva": _2, "vivo": _2, "vlaanderen": _2, "vodka": _2, "volkswagen": _2, "volvo": _2, "vote": _2, "voting": _2, "voto": _2, "voyage": _2, "vuelos": _2, "wales": _2, "walmart": _2, "walter": _2, "wang": _2, "wanggou": _2, "watch": _2, "watches": _2, "weather": _2, "weatherchannel": _2, "webcam": _2, "weber": _2, "website": _2, "wed": _2, "wedding": _2, "weibo": _2, "weir": _2, "whoswho": _2, "wien": _2, "wiki": _2, "williamhill": _2, "win": _2, "windows": _2, "wine": _2, "winners": _2, "wme": _2, "wolterskluwer": _2, "woodside": _2, "work": { "$": 1, "succ": { "of": _4, "to": _4 } }, "works": _2, "world": _2, "wow": _2, "wtc": _2, "wtf": _2, "xbox": _2, "xerox": _2, "xfinity": _2, "xihuan": _2, "xin": _2, "xn--11b4c3d": _2, "कॉम": _2, "xn--1ck2e1b": _2, "セール": _2, "xn--1qqw23a": _2, "佛山": _2, "xn--30rr7y": _2, "慈善": _2, "xn--3bst00m": _2, "集团": _2, "xn--3ds443g": _2, "在线": _2, "xn--3oq18vl8pn36a": _2, "大众汽车": _2, "xn--3pxu8k": _2, "点看": _2, "xn--42c2d9a": _2, "คอม": _2, "xn--45q11c": _2, "八卦": _2, "xn--4gbrim": _2, "موقع": _2, "xn--55qw42g": _2, "公益": _2, "xn--55qx5d": _2, "公司": _2, "xn--5su34j936bgsg": _2, "香格里拉": _2, "xn--5tzm5g": _2, "网站": _2, "xn--6frz82g": _2, "移动": _2, "xn--6qq986b3xl": _2, "我爱你": _2, "xn--80adxhks": _2, "москва": _2, "xn--80aqecdr1a": _2, "католик": _2, "xn--80asehdb": _2, "онлайн": _2, "xn--80aswg": _2, "сайт": _2, "xn--8y0a063a": _2, "联通": _2, "xn--9dbq2a": _2, "קום": _2, "xn--9et52u": _2, "时尚": _2, "xn--9krt00a": _2, "微博": _2, "xn--b4w605ferd": _2, "淡马锡": _2, "xn--bck1b9a5dre4c": _2, "ファッション": _2, "xn--c1avg": _2, "орг": _2, "xn--c2br7g": _2, "नेट": _2, "xn--cck2b3b": _2, "ストア": _2, "xn--cckwcxetd": _2, "アマゾン": _2, "xn--cg4bki": _2, "삼성": _2, "xn--czr694b": _2, "商标": _2, "xn--czrs0t": _2, "商店": _2, "xn--czru2d": _2, "商城": _2, "xn--d1acj3b": _2, "дети": _2, "xn--eckvdtc9d": _2, "ポイント": _2, "xn--efvy88h": _2, "新闻": _2, "xn--fct429k": _2, "家電": _2, "xn--fhbei": _2, "كوم": _2, "xn--fiq228c5hs": _2, "中文网": _2, "xn--fiq64b": _2, "中信": _2, "xn--fjq720a": _2, "娱乐": _2, "xn--flw351e": _2, "谷歌": _2, "xn--fzys8d69uvgm": _2, "電訊盈科": _2, "xn--g2xx48c": _2, "购物": _2, "xn--gckr3f0f": _2, "クラウド": _2, "xn--gk3at1e": _2, "通販": _2, "xn--hxt814e": _2, "网店": _2, "xn--i1b6b1a6a2e": _2, "संगठन": _2, "xn--imr513n": _2, "餐厅": _2, "xn--io0a7i": _2, "网络": _2, "xn--j1aef": _2, "ком": _2, "xn--jlq480n2rg": _2, "亚马逊": _2, "xn--jlq61u9w7b": _2, "诺基亚": _2, "xn--jvr189m": _2, "食品": _2, "xn--kcrx77d1x4a": _2, "飞利浦": _2, "xn--kput3i": _2, "手机": _2, "xn--mgba3a3ejt": _2, "ارامكو": _2, "xn--mgba7c0bbn0a": _2, "العليان": _2, "xn--mgbaakc7dvf": _2, "اتصالات": _2, "xn--mgbab2bd": _2, "بازار": _2, "xn--mgbca7dzdo": _2, "ابوظبي": _2, "xn--mgbi4ecexp": _2, "كاثوليك": _2, "xn--mgbt3dhd": _2, "همراه": _2, "xn--mk1bu44c": _2, "닷컴": _2, "xn--mxtq1m": _2, "政府": _2, "xn--ngbc5azd": _2, "شبكة": _2, "xn--ngbe9e0a": _2, "بيتك": _2, "xn--ngbrx": _2, "عرب": _2, "xn--nqv7f": _2, "机构": _2, "xn--nqv7fs00ema": _2, "组织机构": _2, "xn--nyqy26a": _2, "健康": _2, "xn--otu796d": _2, "招聘": _2, "xn--p1acf": _2, "рус": _2, "xn--pssy2u": _2, "大拿": _2, "xn--q9jyb4c": _2, "みんな": _2, "xn--qcka1pmc": _2, "グーグル": _2, "xn--rhqv96g": _2, "世界": _2, "xn--rovu88b": _2, "書籍": _2, "xn--ses554g": _2, "网址": _2, "xn--t60b56a": _2, "닷넷": _2, "xn--tckwe": _2, "コム": _2, "xn--tiq49xqyj": _2, "天主教": _2, "xn--unup4y": _2, "游戏": _2, "xn--vermgensberater-ctb": _2, "vermögensberater": _2, "xn--vermgensberatung-pwb": _2, "vermögensberatung": _2, "xn--vhquv": _2, "企业": _2, "xn--vuq861b": _2, "信息": _2, "xn--w4r85el8fhu5dnra": _2, "嘉里大酒店": _2, "xn--w4rs40l": _2, "嘉里": _2, "xn--xhq521b": _2, "广东": _2, "xn--zfr164b": _2, "政务": _2, "xyz": { "$": 1, "succ": { "blogsite": _4, "fhapp": _4, "crafting": _4, "zapto": _4, "telebit": _7 } }, "yachts": _2, "yahoo": _2, "yamaxun": _2, "yandex": _2, "yodobashi": _2, "yoga": _2, "yokohama": _2, "you": _2, "youtube": _2, "yun": _2, "zappos": _2, "zara": _2, "zero": _2, "zip": _2, "zone": { "$": 1, "succ": { "cloud66": _4, "hs": _4, "triton": _7, "lima": _4 } }, "zuerich": _2 } };
        return rules;
    })();

    function lookupInTrie(parts, trie, index, allowedMask) {
        let result = null;
        let node = trie;
        while (node !== undefined) {
            if ((node.$ & allowedMask) !== 0) {
                result = {
                    index: index + 1,
                    isIcann: node.$ === 1 ,
                    isPrivate: node.$ === 2 ,
                };
            }
            if (index === -1) {
                break;
            }
            const succ = node.succ;
            node = succ && (succ[parts[index]] || succ['*']);
            index -= 1;
        }
        return result;
    }
    function suffixLookup(hostname, options, out) {
        if (fastPathLookup(hostname, options, out) === true) {
            return;
        }
        const hostnameParts = hostname.split('.');
        const allowedMask = (options.allowPrivateDomains === true ? 2  : 0) |
            (options.allowIcannDomains === true ? 1  : 0);
        const exceptionMatch = lookupInTrie(hostnameParts, exceptions, hostnameParts.length - 1, allowedMask);
        if (exceptionMatch !== null) {
            out.isIcann = exceptionMatch.isIcann;
            out.isPrivate = exceptionMatch.isPrivate;
            out.publicSuffix = hostnameParts.slice(exceptionMatch.index + 1).join('.');
            return;
        }
        const rulesMatch = lookupInTrie(hostnameParts, rules, hostnameParts.length - 1, allowedMask);
        if (rulesMatch !== null) {
            out.isIcann = rulesMatch.isIcann;
            out.isPrivate = rulesMatch.isPrivate;
            out.publicSuffix = hostnameParts.slice(rulesMatch.index).join('.');
            return;
        }
        out.isIcann = false;
        out.isPrivate = false;
        out.publicSuffix = hostnameParts[hostnameParts.length - 1];
    }

    const RESULT = getEmptyResult();
    function parse$1(url, options = {}) {
        return parseImpl(url, 5 , suffixLookup, options, getEmptyResult());
    }
    function getHostname(url, options = {}) {
        resetResult(RESULT);
        return parseImpl(url, 0 , suffixLookup, options, RESULT).hostname;
    }
    function getPublicSuffix(url, options = {}) {
        resetResult(RESULT);
        return parseImpl(url, 2 , suffixLookup, options, RESULT).publicSuffix;
    }

    /**
     * This is a helper class that is used specifically to work
     * with domains restrictions.
     *
     * There are two options how you can add a domain restriction:
     * * `$domain` modifier: https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
     * * domains list for the cosmetic rules
     *
     * The only difference between them is that in one case we use `|` as a separator,
     * and in the other case - `,`.
     *
     * Examples:
     * * `||example.org^$domain=example.com|~sub.example.com` -- network rule
     * * `example.com,~sub.example.com##banner` -- cosmetic rule
     */
    var DomainModifier = /** @class */ (function () {
        /**
         * Parses the `domains` string and initializes the object.
         *
         * @param domainsStr Domains string.
         * @param separator Separator — `,` or `|`.
         *
         * @throws An error if the domains string is empty or invalid
         */
        function DomainModifier(domainsStr, separator) {
            if (!domainsStr) {
                throw new SyntaxError('Modifier $domain cannot be empty');
            }
            var permittedDomains = [];
            var restrictedDomains = [];
            var parts = domainsStr.toLowerCase().split(separator);
            for (var i = 0; i < parts.length; i += 1) {
                var domain = parts[i].trim();
                var restricted = false;
                if (domain.startsWith('~')) {
                    restricted = true;
                    domain = domain.substring(1);
                }
                if (domain === '') {
                    throw new SyntaxError("Empty domain specified in \"".concat(domainsStr, "\""));
                }
                if (restricted) {
                    restrictedDomains.push(domain);
                }
                else {
                    permittedDomains.push(domain);
                }
            }
            this.restrictedDomains = restrictedDomains.length > 0 ? restrictedDomains : null;
            this.permittedDomains = permittedDomains.length > 0 ? permittedDomains : null;
        }
        /**
         * isDomainOrSubdomainOfAny checks if `domain` is the same or a subdomain
         * of any of `domains`.
         *
         * @param domain - domain to check
         * @param domains - domains list to check against
         */
        DomainModifier.isDomainOrSubdomainOfAny = function (domain, domains) {
            for (var i = 0; i < domains.length; i += 1) {
                var d = domains[i];
                if (DomainModifier.isWildcardDomain(d)) {
                    if (DomainModifier.matchAsWildcard(d, domain)) {
                        return true;
                    }
                }
                if (domain === d || (domain.endsWith(d) && domain.endsWith(".".concat(d)))) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Checks if domain ends with wildcard
         *
         * @param domain
         */
        DomainModifier.isWildcardDomain = function (domain) {
            return domain.endsWith('.*');
        };
        /**
         * Checks if wildcard matches domain
         *
         * @param wildcard
         * @param domainNameToCheck
         */
        DomainModifier.matchAsWildcard = function (wildcard, domainNameToCheck) {
            var wildcardedDomainToCheck = DomainModifier.genTldWildcard(domainNameToCheck);
            if (wildcardedDomainToCheck) {
                return wildcardedDomainToCheck === wildcard
                    || (wildcardedDomainToCheck.endsWith(wildcard) && wildcardedDomainToCheck.endsWith(".".concat(wildcard)));
            }
            return false;
        };
        /**
         * Generates from domain tld wildcard e.g. google.com -> google.* ; youtube.co.uk -> youtube.*
         *
         * @param {string} domainName
         * @returns {string} string is empty if tld for provided domain name doesn't exists
         */
        DomainModifier.genTldWildcard = function (domainName) {
            var tld = getPublicSuffix(domainName);
            if (tld) {
                // lastIndexOf() is needed not to match the domain, e.g. 'www.chrono24.ch'.
                // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/2312.
                return "".concat(domainName.slice(0, domainName.lastIndexOf(".".concat(tld))), ".*");
            }
            return '';
        };
        return DomainModifier;
    }());
    /**
     * Comma separator
     */
    var COMMA_SEPARATOR = ',';
    /**
     * Pipe separator
     */
    var PIPE_SEPARATOR = '|';

    var _a, _b;
    /**
     * Array of special modifiers allow to check for modifier name more efficient
     * by avoiding Object.values(SpecialModifier) calls in custom type-guard while
     * allowing the usage of 'const enum' for SpecialModifier
     */
    var SpecialModifiers = [
        "replace" /* SpecialModifier.Replace */,
        "removeparam" /* SpecialModifier.Removeparam */,
        "hls" /* SpecialModifier.Hls */,
    ];
    var isSpecialModifierToken = function (token) { return token.type === "specialModifier" /* TokenType.SpecialModifier */; };
    /**
     * TODO (s.atroschenko) git rid of necessity of adding modifier names for simple regexp values (removaparam, hls):
     * use unified 'simple-regexp' pattern instead
     */
    var modifiersPatterns = (_a = {},
        _a["replace" /* SpecialModifier.Replace */] = ["regexp" /* Phase.Regexp */, "replacement" /* Phase.Replacement */, "flags" /* Phase.Flags */],
        _a["removeparam" /* SpecialModifier.Removeparam */] = ["regexp" /* Phase.Regexp */, "flags" /* Phase.Flags */],
        _a["hls" /* SpecialModifier.Hls */] = ["regexp" /* Phase.Regexp */, "flags" /* Phase.Flags */],
        _a);
    /**
     * Extracts modifier's plain value
     */
    var parsePlainValue = function (string, startIndex) {
        var modifierValue = '';
        var modifierEndIndex = -1;
        var chars = [];
        for (var i = startIndex; i < string.length; i += 1) {
            var c = string[i];
            var isLastChar = i === (string.length - 1);
            var isUnescapedChar = i > 0 && !(string[i - 1] === "\\" /* SpecialCharacter.OptionEscape */);
            if ((c === "," /* SpecialCharacter.OptionDelimiter */ && isUnescapedChar) || isLastChar) {
                if (isLastChar) {
                    chars.push(c);
                }
                modifierValue = chars.join('');
                modifierEndIndex = i;
                break;
            }
            else {
                chars.push(c);
            }
        }
        return {
            modifierValue: modifierValue,
            modifierEndIndex: modifierEndIndex,
        };
    };
    /**
     * Extract modifier's regexp(-like) value
     *
     * @throws on invalid special modifier value
     */
    var parseRegexpValue = function (string, startIndex, pattern) {
        var currentPhase;
        var nextPhase = (function () {
            var i = 0;
            return function () {
                if (i < pattern.length) {
                    currentPhase = pattern[i];
                    i += 1;
                    return;
                }
                // Undefined phase indicates that there were more Regexp delimiters
                // than pattern implies and that makes modifier value invalid
                throw new Error('Invalid pattern for regexp modifier value.');
            };
        })();
        var modifierValue = '';
        var modifierEndIndex = -1;
        var chars = [];
        for (var i = startIndex; i < string.length; i += 1) {
            var c = string[i];
            var isLastChar = i === (string.length - 1);
            var isUnescapedChar = i > 0 && !(string[i - 1] === "\\" /* SpecialCharacter.OptionEscape */);
            if (c === "/" /* SpecialCharacter.RegexpDelimiter */ && isUnescapedChar) {
                // Step into the next pattern phase
                nextPhase();
            }
            if ((c === "," /* SpecialCharacter.OptionDelimiter */ && isUnescapedChar) || isLastChar) {
                // Skip unescaped commas that are part of regexp
                if (currentPhase === "regexp" /* Phase.Regexp */) {
                    chars.push(c);
                    continue;
                }
                if (isLastChar) {
                    chars.push(c);
                }
                // Unescaped delimiter and/or last character indicates
                // the end of the modifier value, if current phase is the last one
                if (currentPhase === pattern[pattern.length - 1]) {
                    modifierValue = chars.join('');
                    modifierEndIndex = i;
                    break;
                }
                else {
                    throw new Error('Unexpected options delimiter or end of options string.');
                }
            }
            else {
                chars.push(c);
            }
        }
        return {
            modifierValue: modifierValue,
            modifierEndIndex: modifierEndIndex,
        };
    };
    var modifierValueParsers = (_b = {},
        _b["regexp" /* ModifierValueType.Regexp */] = parseRegexpValue,
        _b["plain" /* ModifierValueType.Plain */] = parsePlainValue,
        _b);
    /**
     * Processes raw tokens by splitting token values by delimiter
     *
     * @param preprocessedTokens array of preprocessed tokens (of TokenType.SpecialModifier | TokenType.Raw type)
     * @param delimiter - delimiter
     * @param escapeCharacter - escape character
     * @param unescape if true, remove escape characters from string
     * @returns array of processed tokens
     */
    var tokenize = function (preprocessedTokens, delimiter, escapeCharacter, unescape) {
        // Split raw tokens
        var nestedProcessedTokens = preprocessedTokens
            .map(function (token) {
            // Modifier tokens are already concrete tokens and are being passed down the pipeline here
            if (isSpecialModifierToken(token)) {
                return token;
            }
            var tokenValue = token.value;
            var tokens = [];
            var chars = [];
            var makeToken = function (type) {
                tokens.push({
                    type: type,
                    value: chars.join(''),
                });
                chars = [];
            };
            for (var i = 0; i < tokenValue.length; i += 1) {
                var c = tokenValue[i];
                if (c === delimiter) {
                    var isEscaped = i > 0 && tokenValue[i - 1] === escapeCharacter;
                    if (isEscaped) {
                        if (unescape) {
                            chars.splice(chars.length - 1, 1);
                        }
                        chars.push(c);
                    }
                    else {
                        // Don't make token with '' value
                        // when raw token starts with a delimiter
                        if (chars.length !== 0) {
                            makeToken("string" /* TokenType.String */);
                        }
                        chars.push(c);
                        makeToken("delim" /* TokenType.Delimiter */);
                    }
                }
                else {
                    chars.push(c);
                    // Last character case
                    if (i === (tokenValue.length - 1)) {
                        makeToken("string" /* TokenType.String */);
                    }
                }
            }
            return tokens;
        });
        // Flatten the result
        var processedTokens = [];
        for (var i = 0; i < nestedProcessedTokens.length; i += 1) {
            var currentVal = nestedProcessedTokens[i];
            if (Array.isArray(currentVal)) {
                processedTokens.push.apply(processedTokens, currentVal);
            }
            else {
                processedTokens.push(currentVal);
            }
        }
        return processedTokens;
    };
    /**
     * Converts arrays of tokens into array of their values
     *
     * @param tokens array of arbitrary tokens
     * @returns array of tokens' values
     */
    var makeWords = function (tokens) {
        var words = [];
        for (var i = 0; i < tokens.length; i += 1) {
            var token = tokens[i];
            if (token.type !== "delim" /* TokenType.Delimiter */) {
                words.push(token.value);
            }
        }
        return words;
    };
    /**
     * Parses special modifier value
     *
     * @param modifierName name of modifier to be parsed
     * @param string options string
     * @returns object with Modifier token value and next index to keep iterating from
     */
    function parseSpecialModifier(modifierName, string) {
        var tokenValue = "".concat(modifierName).concat("=" /* SpecialCharacter.ModifierValueMarker */);
        var modifierValueStartIndex = string.indexOf(tokenValue) + tokenValue.length;
        // Define modifier value type
        var valueType = string[modifierValueStartIndex] === "/" /* SpecialCharacter.RegexpDelimiter */
            ? "regexp" /* ModifierValueType.Regexp */
            : "plain" /* ModifierValueType.Plain */;
        // Pick parser for specific type of modifier value
        var parser = modifierValueParsers[valueType];
        // Get pattern of current modifier
        var pattern = modifiersPatterns[modifierName];
        var _a = parser(string, modifierValueStartIndex, pattern), modifierValue = _a.modifierValue, modifierEndIndex = _a.modifierEndIndex;
        if (modifierEndIndex === -1) {
            throw new Error("Invalid $".concat(modifierName, " modifier value."));
        }
        tokenValue += modifierValue;
        var nextIndex = modifierEndIndex;
        return {
            tokenValue: tokenValue,
            nextIndex: nextIndex,
        };
    }
    /**
     * Converts options string into array of Raw and Modifier tokens
     *
     * @param string options string
     * @returns array of preprocessed tokens
     */
    function splitBySpecialModifierTokens(string) {
        var tokens = [];
        var chars = [];
        var makeToken = function (tokenType, tokenValue) {
            tokens.push({
                type: tokenType,
                value: tokenValue,
            });
            chars = [];
        };
        for (var i = 0; i < string.length; i += 1) {
            var c = string[i];
            var isUnescapedChar = i > 0 && !(string[i - 1] === "\\" /* SpecialCharacter.OptionEscape */);
            if (c === "=" /* SpecialCharacter.ModifierValueMarker */ && isUnescapedChar) {
                // Parse current chars array to get modifier name
                // Assume that modifier name is everything after last ',' and before current '='
                var charsStr = chars.join('');
                var lastCommaIndex = charsStr.lastIndexOf("," /* SpecialCharacter.OptionDelimiter */, i);
                // Assertion is used to avoid type-guard for SpecialModifier, making it faster,
                // and reduce call stack size
                var modifierName = charsStr.substring(lastCommaIndex + 1);
                // Check if this is modifier that requires custom parsing logic
                if (!SpecialModifiers.includes(modifierName)) {
                    chars.push(c);
                    // Last character case
                    if (i === (string.length - 1)) {
                        makeToken("raw" /* TokenType.Raw */, charsStr);
                    }
                    continue;
                }
                // Remove modifier name from char stack,
                // make token from whats left and empty chars
                makeToken("raw" /* TokenType.Raw */, charsStr.substring(0, charsStr.lastIndexOf(modifierName)));
                // Extract predefined token value and next iteration index
                // Token value includes both name, separator('=') and value of modifier
                var _a = parseSpecialModifier(modifierName, string), tokenValue = _a.tokenValue, nextIndex = _a.nextIndex;
                makeToken("specialModifier" /* TokenType.SpecialModifier */, tokenValue);
                i = nextIndex;
            }
            else {
                chars.push(c);
                // Last character case
                if (i === (string.length - 1)) {
                    makeToken("raw" /* TokenType.Raw */, chars.join(''));
                }
            }
        }
        return tokens;
    }
    /**
     * Splits options string into array of modifier=value pairs
     *
     * @param string - string to split
     * @param unescape - if true, remove escape characters from string
     * @return array of string parts
     * @throws on invalid special modifier value
     */
    function parseOptionsString(string, unescape) {
        if (unescape === void 0) { unescape = true; }
        if (!string) {
            return [];
        }
        if (string.startsWith("," /* SpecialCharacter.OptionDelimiter */)) {
            // eslint-disable-next-line no-param-reassign
            string = string.substring(1);
        }
        /**
         * Extract modifier tokens for modifiers that require custom parsing
         * https://github.com/AdguardTeam/tsurlfilter/issues/79
         */
        var preprocessedTokens = splitBySpecialModifierTokens(string);
        /**
         * Split raw tokens by delimiter
         */
        var tokens = tokenize(preprocessedTokens, "," /* SpecialCharacter.OptionDelimiter */, "\\" /* SpecialCharacter.OptionEscape */, unescape);
        /**
         * Join tokens into words
         */
        return makeWords(tokens);
    }

    /**
     * Replace modifier class
     */
    var ReplaceModifier = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param value
         */
        function ReplaceModifier(value) {
            var parsed = ReplaceModifier.parseReplaceOption(value);
            this.replaceOption = parsed.optionText;
            this.replaceApply = parsed.apply;
        }
        /**
         *
         * @param option
         */
        ReplaceModifier.parseReplaceOption = function (option) {
            if (!option) {
                return {
                    apply: function (x) { return x; },
                    optionText: '',
                };
            }
            var parts = splitByDelimiterWithEscapeCharacter(option, '/', '\\', true);
            var modifiers = (parts[2] || '');
            if (modifiers.indexOf('g') < 0) {
                modifiers += 'g';
            }
            var pattern = new RegExp(parts[0], modifiers);
            // unescape replacement alias
            var replacement = parts[1].replace(/\\\$/g, '$');
            replacement = SimpleRegex.unescapeSpecials(replacement);
            var apply = function (input) { return input.replace(pattern, replacement); };
            return {
                apply: apply,
                optionText: option,
            };
        };
        /**
         * Replace content
         */
        ReplaceModifier.prototype.getValue = function () {
            return this.replaceOption;
        };
        /**
         * Replace apply function
         */
        ReplaceModifier.prototype.getApplyFunc = function () {
            return this.replaceApply;
        };
        return ReplaceModifier;
    }());

    /**
     * Csp modifier class
     */
    var CspModifier = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param value
         * @param isAllowlist
         */
        function CspModifier(value, isAllowlist) {
            this.cspDirective = value;
            this.isAllowlist = isAllowlist;
            this.validateCspDirective();
        }
        /**
         * Csp directive
         */
        CspModifier.prototype.getValue = function () {
            return this.cspDirective;
        };
        /**
         * Validates CSP rule
         */
        CspModifier.prototype.validateCspDirective = function () {
            /**
             * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/685
             * CSP directive may be empty in case of allowlist rule,
             * it means to disable all $csp rules matching the allowlist rule
             */
            if (!this.isAllowlist && !this.cspDirective) {
                throw new Error('Invalid $CSP rule: CSP directive must not be empty');
            }
            if (this.cspDirective) {
                /**
                 * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/685#issue-228287090
                 * Forbids report-to and report-uri directives
                 */
                var cspDirective = this.cspDirective.toLowerCase();
                if (cspDirective.indexOf('report-') >= 0) {
                    throw new Error("Forbidden CSP directive: ".concat(cspDirective));
                }
            }
        };
        return CspModifier;
    }());

    /**
     * Cookie modifier class
     *
     * Learn more about it here:
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/961
     */
    var CookieModifier = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param value
         */
        function CookieModifier(value) {
            // Save the source text of the option modifier
            this.optionValue = value || '';
            this.regex = null;
            this.cookieName = null;
            this.sameSite = null;
            this.maxAge = null;
            // Parse cookie name/regex
            var parts = this.optionValue.split(/;/);
            if (parts.length < 1) {
                throw new Error("Cannot parse ".concat(this.optionValue));
            }
            var cookieName = parts[0];
            if (cookieName.startsWith('/') && cookieName.endsWith('/')) {
                var pattern = cookieName.substring(1, cookieName.length - 1);
                // Save regex to be used further for matching cookies
                this.regex = new RegExp(pattern);
            }
            else {
                // Match by cookie name
                this.cookieName = cookieName;
            }
            // Parse other cookie options
            if (parts.length > 1) {
                for (var i = 1; i < parts.length; i += 1) {
                    var nameValue = parts[i].split('=');
                    var optionName = nameValue[0];
                    var optionValue = nameValue[1];
                    if (optionName === CookieModifier.MAX_AGE) {
                        this.maxAge = parseInt(optionValue, 10);
                    }
                    else if (optionName === CookieModifier.SAME_SITE) {
                        this.sameSite = optionValue;
                    }
                    else {
                        throw new Error("Unknown $cookie option: ".concat(optionName));
                    }
                }
            }
        }
        /**
         * Modifier value
         */
        CookieModifier.prototype.getValue = function () {
            return this.optionValue;
        };
        /**
         * First cookie name
         */
        CookieModifier.prototype.getCookieName = function () {
            return this.cookieName;
        };
        /**
         * Max age cookie value
         */
        CookieModifier.prototype.getMaxAge = function () {
            return this.maxAge;
        };
        /**
         * Same site cookie value
         */
        CookieModifier.prototype.getSameSite = function () {
            return this.sameSite;
        };
        /**
         * Checks if cookie with the specified name matches this option
         *
         * @param {string} name Cookie name
         * @return {boolean} true if it does
         */
        CookieModifier.prototype.matches = function (name) {
            if (!name) {
                return false;
            }
            if (this.regex) {
                return this.regex.test(name);
            }
            if (this.cookieName) {
                return this.cookieName === name;
            }
            // Empty regex and cookieName means that we must match all cookies
            return true;
        };
        /**
         * Checks if cookie rule has an empty $cookie option
         *
         * @return {boolean} True if $cookie option is empty
         */
        CookieModifier.prototype.isEmpty = function () {
            return !this.regex && !this.cookieName;
        };
        /**
         * Cookie name maxAge
         */
        CookieModifier.MAX_AGE = 'maxAge';
        /**
         * Cookie name sameSite
         */
        CookieModifier.SAME_SITE = 'sameSite';
        return CookieModifier;
    }());

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    var scriptlets_umd = {exports: {}};

    (function (factory) {
        factory();
    })((function () {
        function attachDependencies(scriptlet) {
          var _scriptlet$injections = scriptlet.injections,
            injections = _scriptlet$injections === void 0 ? [] : _scriptlet$injections;
          return injections.reduce(function (accum, dep) {
            return "".concat(accum, "\n").concat(dep.toString());
          }, scriptlet.toString());
        }
        function addCall(scriptlet, code) {
          return "".concat(code, "\n    const updatedArgs = args ? [].concat(source).concat(args) : [source];\n    try {\n        ").concat(scriptlet.name, ".apply(this, updatedArgs);\n    } catch (e) {\n        console.log(e);\n    }");
        }
        function passSourceAndProps(source, code) {
          var redirect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var sourceString = JSON.stringify(source);
          var argsString = source.args ? "[".concat(source.args.map(function (arg) {
            return JSON.stringify(arg);
          }), "]") : undefined;
          var params = argsString ? "".concat(sourceString, ", ").concat(argsString) : sourceString;
          if (redirect) {
            return "(function(source, args){\n".concat(code, "\n})(").concat(params, ");");
          }
          return "(".concat(code, ")(").concat(params, ");");
        }
        function wrapInNonameFunc(code) {
          return "function(source, args){\n".concat(code, "\n}");
        }
        var isEmptyObject = function isEmptyObject(obj) {
          return Object.keys(obj).length === 0 && !obj.prototype;
        };
        var safeGetDescriptor = function safeGetDescriptor(obj, prop) {
          var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
          if (descriptor && descriptor.configurable) {
            return descriptor;
          }
          return null;
        };
        function setPropertyAccess(object, property, descriptor) {
          var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
          if (currentDescriptor && !currentDescriptor.configurable) {
            return false;
          }
          Object.defineProperty(object, property, descriptor);
          return true;
        }
        var nativeIsNaN = function nativeIsNaN(num) {
          var native = Number.isNaN || window.isNaN;
          return native(num);
        };
        var nativeIsFinite = function nativeIsFinite(num) {
          var native = Number.isFinite || window.isFinite;
          return native(num);
        };
        var getNumberFromString = function getNumberFromString(rawString) {
          var parsedDelay = parseInt(rawString, 10);
          var validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
          return validDelay;
        };
        function getRandomIntInclusive(min, max) {
          min = Math.ceil(min);
          max = Math.floor(max);
          return Math.floor(Math.random() * (max - min + 1) + min);
        }
        var replaceAll = function replaceAll(input, substr, newSubstr) {
          return input.split(substr).join(newSubstr);
        };
        var escapeRegExp = function escapeRegExp(str) {
          return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        };
        var toRegExp = function toRegExp() {
          var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          var DEFAULT_VALUE = '.?';
          var FORWARD_SLASH = '/';
          if (input === '') {
            return new RegExp(DEFAULT_VALUE);
          }
          var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
          var flagsPart = input.substring(delimiterIndex + 1);
          var regExpPart = input.substring(0, delimiterIndex + 1);
          var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
              return false;
            }
            try {
              new RegExp('', flag);
              return true;
            } catch (ex) {
              return false;
            }
          };
          var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH)
            && !regExpStr.endsWith('\\/') && isValidRegExpFlag(flagsStr)) {
              return flagsStr;
            }
            return '';
          };
          var flags = getRegExpFlags(regExpPart, flagsPart);
          if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
          }
          var escaped = input
          .replace(/\\'/g, '\'').replace(/\\"/g, '"')
          .replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          return new RegExp(escaped);
        };
        var isValidStrPattern = function isValidStrPattern(input) {
          var FORWARD_SLASH = '/';
          var str = escapeRegExp(input);
          if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
          }
          var isValid;
          try {
            isValid = new RegExp(str);
            isValid = true;
          } catch (e) {
            isValid = false;
          }
          return isValid;
        };
        var getBeforeRegExp = function getBeforeRegExp(str, rx) {
          var index = str.search(rx);
          return str.substring(0, index);
        };
        var substringAfter$1 = function substringAfter(str, separator) {
          if (!str) {
            return str;
          }
          var index = str.indexOf(separator);
          return index < 0 ? '' : str.substring(index + separator.length);
        };
        var substringBefore = function substringBefore(str, separator) {
          if (!str || !separator) {
            return str;
          }
          var index = str.indexOf(separator);
          return index < 0 ? str : str.substring(0, index);
        };
        var wrapInSingleQuotes = function wrapInSingleQuotes(str) {
          if (str[0] === '\'' && str[str.length - 1] === '\'' || str[0] === '"' && str[str.length - 1] === '"') {
            str = str.substring(1, str.length - 1);
          }
          str = str.replace(/\'/g, '"');
          return "'".concat(str, "'");
        };
        var getStringInBraces = function getStringInBraces(str) {
          var firstIndex = str.indexOf('(');
          var lastIndex = str.lastIndexOf(')');
          return str.substring(firstIndex + 1, lastIndex);
        };
        var convertRtcConfigToString = function convertRtcConfigToString(config) {
          var UNDEF_STR = 'undefined';
          var str = UNDEF_STR;
          if (config === null) {
            str = 'null';
          } else if (config instanceof Object) {
            var SERVERS_PROP_NAME = 'iceServers';
            var URLS_PROP_NAME = 'urls';
            if (Object.prototype.hasOwnProperty.call(config, SERVERS_PROP_NAME) && config[SERVERS_PROP_NAME] && Object.prototype.hasOwnProperty.call(config[SERVERS_PROP_NAME][0], URLS_PROP_NAME) && !!config[SERVERS_PROP_NAME][0][URLS_PROP_NAME]) {
              str = config[SERVERS_PROP_NAME][0][URLS_PROP_NAME].toString();
            }
          }
          return str;
        };
        var isValidMatchStr = function isValidMatchStr(match) {
          var INVERT_MARKER = '!';
          var str = match;
          if (match !== null && match !== void 0 && match.startsWith(INVERT_MARKER)) {
            str = match.slice(1);
          }
          return isValidStrPattern(str);
        };
        var isValidMatchNumber = function isValidMatchNumber(match) {
          var INVERT_MARKER = '!';
          var str = match;
          if (match !== null && match !== void 0 && match.startsWith(INVERT_MARKER)) {
            str = match.slice(1);
          }
          var num = parseFloat(str);
          return !nativeIsNaN(num) && nativeIsFinite(num);
        };
        var parseMatchArg = function parseMatchArg(match) {
          var INVERT_MARKER = '!';
          var isInvertedMatch = match ? match === null || match === void 0 ? void 0 : match.startsWith(INVERT_MARKER) : false;
          var matchValue = isInvertedMatch ? match.slice(1) : match;
          var matchRegexp = toRegExp(matchValue);
          return {
            isInvertedMatch,
            matchRegexp,
            matchValue
          };
        };
        var parseDelayArg = function parseDelayArg(delay) {
          var INVERT_MARKER = '!';
          var isInvertedDelayMatch = delay === null || delay === void 0 ? void 0 : delay.startsWith(INVERT_MARKER);
          var delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;
          var parsedDelay = parseInt(delayValue, 10);
          var delayMatch = nativeIsNaN(parsedDelay) ? null : parsedDelay;
          return {
            isInvertedDelayMatch,
            delayMatch
          };
        };
        var objectToString = function objectToString(obj) {
          if (!obj || typeof obj !== 'object') {
            return String(obj);
          }
          return isEmptyObject(obj) ? '{}' : Object.entries(obj).map(function (pair) {
            var key = pair[0];
            var value = pair[1];
            var recordValueStr = value;
            if (value instanceof Object) {
              recordValueStr = "{ ".concat(objectToString(value), " }");
            }
            return "".concat(key, ":\"").concat(recordValueStr, "\"");
          }).join(' ');
        };
        var convertTypeToString = function convertTypeToString(value) {
          var output;
          if (typeof value === 'undefined') {
            output = 'undefined';
          } else if (typeof value === 'object') {
            if (value === null) {
              output = 'null';
            } else {
              output = objectToString(value);
            }
          } else {
            output = value.toString();
          }
          return output;
        };
        function getRandomStrByLength(length) {
          var result = '';
          var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+=~';
          var charactersLength = characters.length;
          for (var i = 0; i < length; i += 1) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
          }
          return result;
        }
        function generateRandomResponse(customResponseText) {
          var customResponse = customResponseText;
          if (customResponse === 'true') {
            customResponse = Math.random().toString(36).slice(-10);
            return customResponse;
          }
          customResponse = customResponse.replace('length:', '');
          var rangeRegex = /^\d+-\d+$/;
          if (!rangeRegex.test(customResponse)) {
            return null;
          }
          var rangeMin = getNumberFromString(customResponse.split('-')[0]);
          var rangeMax = getNumberFromString(customResponse.split('-')[1]);
          if (!nativeIsFinite(rangeMin) || !nativeIsFinite(rangeMax)) {
            return null;
          }
          if (rangeMin > rangeMax) {
            var temp = rangeMin;
            rangeMin = rangeMax;
            rangeMax = temp;
          }
          var LENGTH_RANGE_LIMIT = 500 * 1000;
          if (rangeMax > LENGTH_RANGE_LIMIT) {
            return null;
          }
          var length = getRandomIntInclusive(rangeMin, rangeMax);
          customResponse = getRandomStrByLength(length);
          return customResponse;
        }
        function inferValue(value) {
          if (value === 'undefined') {
            return undefined;
          }
          if (value === 'false') {
            return false;
          }
          if (value === 'true') {
            return true;
          }
          if (value === 'null') {
            return null;
          }
          if (value === 'NaN') {
            return NaN;
          }
          var MAX_ALLOWED_NUM = 32767;
          var numVal = Number(value);
          if (!nativeIsNaN(numVal)) {
            if (Math.abs(numVal) > MAX_ALLOWED_NUM) {
              throw new Error('number values bigger than 32767 are not allowed');
            }
            return numVal;
          }
          var errorMessage = "'".concat(value, "' value type can't be inferred");
          try {
            var parsableVal = JSON.parse(value);
            if (parsableVal instanceof Object || typeof parsableVal === 'string') {
              return parsableVal;
            }
          } catch (e) {
            errorMessage += ": ".concat(e);
          }
          throw new TypeError(errorMessage);
        }
        function iterateWithTransitions(iterable, transitions, init, args) {
          var state = init || Object.keys(transitions)[0];
          for (var i = 0; i < iterable.length; i += 1) {
            state = transitions[state](iterable, i, args);
          }
          return state;
        }
        var ADG_SCRIPTLET_MASK = '#//scriptlet';
        var wordSaver = function wordSaver() {
          var str = '';
          var strings = [];
          var saveSymb = function saveSymb(s) {
            str += s;
            return str;
          };
          var saveStr = function saveStr() {
            strings.push(str);
            str = '';
          };
          var getAll = function getAll() {
            return [...strings];
          };
          return {
            saveSymb,
            saveStr,
            getAll
          };
        };
        var substringAfter = function substringAfter(str, separator) {
          if (!str) {
            return str;
          }
          var index = str.indexOf(separator);
          return index < 0 ? '' : str.substring(index + separator.length);
        };
        var parseRule = function parseRule(ruleText) {
          ruleText = substringAfter(ruleText, ADG_SCRIPTLET_MASK);
          var opened = function opened(rule, index, _ref) {
            var sep = _ref.sep;
            var char = rule[index];
            var transition;
            switch (char) {
              case ' ':
              case '(':
              case ',':
                {
                  transition = "opened";
                  break;
                }
              case '\'':
              case '"':
                {
                  sep.symb = char;
                  transition = "param";
                  break;
                }
              case ')':
                {
                  transition = index === rule.length - 1 ? "closed" : "opened";
                  break;
                }
              default:
                {
                  throw new Error('The rule is not a scriptlet');
                }
            }
            return transition;
          };
          var param = function param(rule, index, _ref2) {
            var saver = _ref2.saver,
              sep = _ref2.sep;
            var char = rule[index];
            switch (char) {
              case '\'':
              case '"':
                {
                  var preIndex = index - 1;
                  var before = rule[preIndex];
                  if (char === sep.symb && before !== '\\') {
                    sep.symb = null;
                    saver.saveStr();
                    return "opened";
                  }
                }
              default:
                {
                  saver.saveSymb(char);
                  return "param";
                }
            }
          };
          var transitions = {
            ["opened"]: opened,
            ["param"]: param,
            ["closed"]: function () {}
          };
          var sep = {
            symb: null
          };
          var saver = wordSaver();
          var state = iterateWithTransitions(ruleText, transitions, "opened", {
            sep,
            saver
          });
          if (state !== "closed") {
            throw new Error("Invalid scriptlet rule ".concat(ruleText));
          }
          var args = saver.getAll();
          return {
            name: args[0],
            args: args.slice(1)
          };
        };
        var validateType = function validateType(type) {
          return typeof type !== 'undefined';
        };
        var validateListener = function validateListener(listener) {
          return typeof listener !== 'undefined' && (typeof listener === 'function' || typeof listener === 'object'
          && listener !== null && 'handleEvent' in listener && typeof listener.handleEvent === 'function');
        };
        var listenerToString = function listenerToString(listener) {
          return typeof listener === 'function' ? listener.toString() : listener.handleEvent.toString();
        };
        var shouldMatchAnyDelay = function shouldMatchAnyDelay(delay) {
          return delay === '*';
        };
        var getMatchDelay = function getMatchDelay(delay) {
          var DEFAULT_DELAY = 1000;
          var parsedDelay = parseInt(delay, 10);
          var delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY
          : parsedDelay;
          return delayMatch;
        };
        var isDelayMatched = function isDelayMatched(inputDelay, realDelay) {
          return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);
        };
        var getBoostMultiplier = function getBoostMultiplier(boost) {
          var DEFAULT_MULTIPLIER = 0.05;
          var MIN_MULTIPLIER = 0.001;
          var MAX_MULTIPLIER = 50;
          var parsedBoost = parseFloat(boost);
          var boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER
          : parsedBoost;
          if (boostMultiplier < MIN_MULTIPLIER) {
            boostMultiplier = MIN_MULTIPLIER;
          }
          if (boostMultiplier > MAX_MULTIPLIER) {
            boostMultiplier = MAX_MULTIPLIER;
          }
          return boostMultiplier;
        };
        var flatten = function flatten(input) {
          var stack = [];
          input.forEach(function (el) {
            return stack.push(el);
          });
          var res = [];
          while (stack.length) {
            var next = stack.pop();
            if (Array.isArray(next)) {
              next.forEach(function (el) {
                return stack.push(el);
              });
            } else {
              res.push(next);
            }
          }
          return res.reverse();
        };
        var isExisting = function isExisting(item) {
          return !!item;
        };
        var nodeListToArray = function nodeListToArray(nodeList) {
          var nodes = [];
          for (var i = 0; i < nodeList.length; i += 1) {
            nodes.push(nodeList[i]);
          }
          return nodes;
        };
        var isValidCookiePath = function isValidCookiePath(rawPath) {
          return rawPath === '/' || rawPath === 'none';
        };
        var getCookiePath = function getCookiePath(rawPath) {
          if (rawPath === '/') {
            return 'path=/';
          }
          return '';
        };
        var concatCookieNameValuePath = function concatCookieNameValuePath(rawName, rawValue, rawPath) {
          var shouldEncode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
          var COOKIE_BREAKER = ';';
          if (!shouldEncode && (rawName.includes(COOKIE_BREAKER) || "".concat(rawValue).includes(COOKIE_BREAKER))) {
            return null;
          }
          var name = shouldEncode ? encodeURIComponent(rawName) : rawName;
          var value = shouldEncode ? encodeURIComponent(rawValue) : rawValue;
          return "".concat(name, "=").concat(value, "; ").concat(getCookiePath(rawPath), ";");
        };
        var getLimitedCookieValue = function getLimitedCookieValue(value) {
          if (!value) {
            return null;
          }
          var allowedCookieValues = new Set(['true', 'false', 'yes', 'y', 'no', 'n', 'ok', 'on', 'off', 'accept', 'accepted', 'notaccepted', 'reject', 'rejected', 'allow', 'allowed', 'disallow', 'deny', 'enable', 'enabled', 'disable', 'disabled']);
          var validValue;
          if (allowedCookieValues.has(value.toLowerCase())) {
            validValue = value;
          } else if (/^\d+$/.test(value)) {
            validValue = parseFloat(value);
            if (nativeIsNaN(validValue)) {
              return null;
            }
            if (Math.abs(validValue) < 0 || Math.abs(validValue) > 15) {
              return null;
            }
          } else {
            return null;
          }
          return validValue;
        };
        var parseCookieString = function parseCookieString(cookieString) {
          var COOKIE_DELIMITER = '=';
          var COOKIE_PAIRS_DELIMITER = ';';
          var cookieChunks = cookieString.split(COOKIE_PAIRS_DELIMITER);
          var cookieData = {};
          cookieChunks.forEach(function (singleCookie) {
            var cookieKey;
            var cookieValue = '';
            var delimiterIndex = singleCookie.indexOf(COOKIE_DELIMITER);
            if (delimiterIndex === -1) {
              cookieKey = singleCookie.trim();
            } else {
              cookieKey = singleCookie.slice(0, delimiterIndex).trim();
              cookieValue = singleCookie.slice(delimiterIndex + 1);
            }
            cookieData[cookieKey] = cookieValue || null;
          });
          return cookieData;
        };
        var isCookieSetWithValue = function isCookieSetWithValue(cookieString, name, value) {
          return cookieString.split(';').some(function (cookieStr) {
            var pos = cookieStr.indexOf('=');
            if (pos === -1) {
              return false;
            }
            var cookieName = cookieStr.slice(0, pos).trim();
            var cookieValue = cookieStr.slice(pos + 1).trim();
            return name === cookieName && value === cookieValue;
          });
        };
        var getTrustedCookieOffsetMs = function getTrustedCookieOffsetMs(offsetExpiresSec) {
          var ONE_YEAR_EXPIRATION_KEYWORD = '1year';
          var ONE_DAY_EXPIRATION_KEYWORD = '1day';
          var MS_IN_SEC = 1000;
          var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
          var SECONDS_IN_DAY = 24 * 60 * 60;
          var parsedSec;
          if (offsetExpiresSec === ONE_YEAR_EXPIRATION_KEYWORD) {
            parsedSec = SECONDS_IN_YEAR;
          } else if (offsetExpiresSec === ONE_DAY_EXPIRATION_KEYWORD) {
            parsedSec = SECONDS_IN_DAY;
          } else {
            parsedSec = Number.parseInt(offsetExpiresSec, 10);
            if (Number.isNaN(parsedSec)) {
              return null;
            }
          }
          return parsedSec * MS_IN_SEC;
        };
        var noopFunc = function noopFunc() {};
        var noopCallbackFunc = function noopCallbackFunc() {
          return noopFunc;
        };
        var noopNull = function noopNull() {
          return null;
        };
        var trueFunc = function trueFunc() {
          return true;
        };
        var falseFunc = function falseFunc() {
          return false;
        };
        function noopThis() {
          return this;
        }
        var noopStr = function noopStr() {
          return '';
        };
        var noopArray = function noopArray() {
          return [];
        };
        var noopObject = function noopObject() {
          return {};
        };
        var throwFunc = function throwFunc() {
          throw new Error();
        };
        var noopPromiseReject = function noopPromiseReject() {
          return Promise.reject();
        };
        var noopPromiseResolve = function noopPromiseResolve() {
          var responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '{}';
          var responseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          var responseType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';
          if (typeof Response === 'undefined') {
            return;
          }
          var response = new Response(responseBody, {
            status: 200,
            statusText: 'OK'
          });
          Object.defineProperties(response, {
            url: {
              value: responseUrl
            },
            type: {
              value: responseType
            }
          });
          if (responseType === 'opaque') {
            Object.defineProperties(response, {
              body: {
                value: null
              },
              status: {
                value: 0
              },
              statusText: {
                value: ''
              }
            });
          }
          return Promise.resolve(response);
        };
        var shouldAbortInlineOrInjectedScript = function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
          var INLINE_SCRIPT_STRING = 'inlineScript';
          var INJECTED_SCRIPT_STRING = 'injectedScript';
          var INJECTED_SCRIPT_MARKER = '<anonymous>';
          var isInlineScript = function isInlineScript(match) {
            return match.includes(INLINE_SCRIPT_STRING);
          };
          var isInjectedScript = function isInjectedScript(match) {
            return match.includes(INJECTED_SCRIPT_STRING);
          };
          if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
            return false;
          }
          var documentURL = window.location.href;
          var pos = documentURL.indexOf('#');
          if (pos !== -1) {
            documentURL = documentURL.slice(0, pos);
          }
          var stackSteps = stackTrace.split('\n').slice(2).map(function (line) {
            return line.trim();
          });
          var stackLines = stackSteps.map(function (line) {
            var stack;
            var getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
            if (getStackTraceURL) {
              var _stackURL, _stackURL2;
              var stackURL = getStackTraceURL[2];
              if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith('(')) {
                stackURL = stackURL.slice(1);
              }
              if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                var _stackFunction;
                stackURL = INJECTED_SCRIPT_STRING;
                var stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
                if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith('at')) {
                  stackFunction = stackFunction.slice(2).trim();
                }
                stack = "".concat(stackFunction, " ").concat(stackURL).trim();
              } else {
                stack = stackURL;
              }
            } else {
              stack = line;
            }
            return stack;
          });
          if (stackLines) {
            for (var index = 0; index < stackLines.length; index += 1) {
              if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
                return true;
              }
              if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING)) {
                return true;
              }
            }
          }
          return false;
        };
        var findHostElements = function findHostElements(rootElement) {
          var hosts = [];
          if (rootElement) {
            var domElems = rootElement.querySelectorAll('*');
            domElems.forEach(function (el) {
              if (el.shadowRoot) {
                hosts.push(el);
              }
            });
          }
          return hosts;
        };
        var pierceShadowDom = function pierceShadowDom(selector, hostElements) {
          var targets = [];
          var innerHostsAcc = [];
          hostElements.forEach(function (host) {
            var simpleElems = host.querySelectorAll(selector);
            targets = targets.concat([].slice.call(simpleElems));
            var shadowRootElem = host.shadowRoot;
            var shadowChildren = shadowRootElem.querySelectorAll(selector);
            targets = targets.concat([].slice.call(shadowChildren));
            innerHostsAcc.push(findHostElements(shadowRootElem));
          });
          var innerHosts = flatten(innerHostsAcc);
          return {
            targets,
            innerHosts
          };
        };
        var isValidCallback = function isValidCallback(callback) {
          return callback instanceof Function
          || typeof callback === 'string';
        };
        var parseRawDelay = function parseRawDelay(delay) {
          var parsedDelay = Math.floor(parseInt(delay, 10));
          return typeof parsedDelay === 'number' && !nativeIsNaN(parsedDelay) ? parsedDelay : delay;
        };
        var isPreventionNeeded = function isPreventionNeeded(_ref) {
          var callback = _ref.callback,
            delay = _ref.delay,
            matchCallback = _ref.matchCallback,
            matchDelay = _ref.matchDelay;
          if (!isValidCallback(callback)) {
            return false;
          }
          if (!isValidMatchStr(matchCallback) || matchDelay && !isValidMatchNumber(matchDelay)) {
            return false;
          }
          var _parseMatchArg = parseMatchArg(matchCallback),
            isInvertedMatch = _parseMatchArg.isInvertedMatch,
            matchRegexp = _parseMatchArg.matchRegexp;
          var _parseDelayArg = parseDelayArg(matchDelay),
            isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,
            delayMatch = _parseDelayArg.delayMatch;
          var parsedDelay = parseRawDelay(delay);
          var shouldPrevent = false;
          var callbackStr = String(callback);
          if (delayMatch === null) {
            shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch;
          } else if (!matchCallback) {
            shouldPrevent = parsedDelay === delayMatch !== isInvertedDelayMatch;
          } else {
            shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch && parsedDelay === delayMatch !== isInvertedDelayMatch;
          }
          return shouldPrevent;
        };
        var handleOldReplacement = function handleOldReplacement(replacement) {
          var result;
          if (!replacement) {
            result = noopFunc;
          } else if (replacement === 'trueFunc') {
            result = trueFunc;
          } else if (replacement.includes('=')) {
            var isProp = replacement.startsWith('{') && replacement.endsWith('}');
            if (isProp) {
              var propertyPart = replacement.slice(1, -1);
              var propertyName = substringBefore(propertyPart, '=');
              var propertyValue = substringAfter$1(propertyPart, '=');
              if (propertyValue === 'noopFunc') {
                result = {};
                result[propertyName] = noopFunc;
              }
            }
          }
          return result;
        };
        var createDecoy = function createDecoy(args) {
          var UrlPropNameOf = function (UrlPropNameOf) {
            UrlPropNameOf["Object"] = "data";
            UrlPropNameOf["Iframe"] = "src";
            return UrlPropNameOf;
          }({});
          var replacement = args.replacement,
            url = args.url,
            delay = args.delay;
          var tag;
          if (replacement === 'obj') {
            tag = "object";
          } else {
            tag = "iframe";
          }
          var decoy = document.createElement(tag);
          if (decoy instanceof HTMLObjectElement) {
            decoy[UrlPropNameOf.Object] = url;
          } else if (decoy instanceof HTMLIFrameElement) {
            decoy[UrlPropNameOf.Iframe] = url;
          }
          decoy.style.setProperty('height', '1px', 'important');
          decoy.style.setProperty('position', 'fixed', 'important');
          decoy.style.setProperty('top', '-1px', 'important');
          decoy.style.setProperty('width', '1px', 'important');
          document.body.appendChild(decoy);
          setTimeout(function () {
            return decoy.remove();
          }, delay * 1000);
          return decoy;
        };
        var getPreventGetter = function getPreventGetter(nativeGetter) {
          var preventGetter = function preventGetter(target, prop) {
            if (prop && prop === 'closed') {
              return false;
            }
            if (typeof nativeGetter === 'function') {
              return noopFunc;
            }
            return prop && target[prop];
          };
          return preventGetter;
        };
        var hit = function hit(source) {
          if (source.verbose !== true) {
            return;
          }
          try {
            var log = console.log.bind(console);
            var trace = console.trace.bind(console);
            var prefix = source.ruleText || '';
            if (source.domainName) {
              var AG_SCRIPTLET_MARKER = '#%#//';
              var UBO_SCRIPTLET_MARKER = '##+js';
              var ruleStartIndex;
              if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
              } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
              }
              var rulePart = source.ruleText.slice(ruleStartIndex);
              prefix = "".concat(source.domainName).concat(rulePart);
            }
            log("".concat(prefix, " trace start"));
            if (trace) {
              trace();
            }
            log("".concat(prefix, " trace end"));
          } catch (e) {
          }
          if (typeof window.__debug === 'function') {
            window.__debug(source);
          }
        };
        function getWildcardPropertyInChain(base, chain) {
          var lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
          var pos = chain.indexOf('.');
          if (pos === -1) {
            if (chain === '*' || chain === '[]') {
              for (var key in base) {
                if (Object.prototype.hasOwnProperty.call(base, key)) {
                  output.push({
                    base,
                    prop: key
                  });
                }
              }
            } else {
              output.push({
                base,
                prop: chain
              });
            }
            return output;
          }
          var prop = chain.slice(0, pos);
          var shouldLookThrough = prop === '[]' && Array.isArray(base) || prop === '*' && base instanceof Object;
          if (shouldLookThrough) {
            var nextProp = chain.slice(pos + 1);
            var baseKeys = Object.keys(base);
            baseKeys.forEach(function (key) {
              var item = base[key];
              getWildcardPropertyInChain(item, nextProp, lookThrough, output);
            });
          }
          if (Array.isArray(base)) {
            base.forEach(function (key) {
              var nextBase = key;
              if (nextBase !== undefined) {
                getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
              }
            });
          }
          var nextBase = base[prop];
          chain = chain.slice(pos + 1);
          if (nextBase !== undefined) {
            getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
          }
          return output;
        }
        var logMessage = function logMessage(source, message) {
          var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
          var name = source.name,
            verbose = source.verbose;
          if (!forced && !verbose) {
            return;
          }
          var nativeConsole = console.log;
          if (!convertMessageToString) {
            nativeConsole("".concat(name, ":"), message);
            return;
          }
          nativeConsole("".concat(name, ": ").concat(message));
        };
        var getNativeRegexpTest = function getNativeRegexpTest() {
          var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, 'test');
          var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
          if (descriptor && typeof descriptor.value === 'function') {
            return nativeRegexTest;
          }
          throw new Error('RegExp.prototype.test is not a function');
        };
        var matchStackTrace = function matchStackTrace(stackMatch, stackTrace) {
          if (!stackMatch || stackMatch === '') {
            return true;
          }
          if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
            return true;
          }
          var stackRegexp = toRegExp(stackMatch);
          var refinedStackTrace = stackTrace.split('\n').slice(2)
          .map(function (line) {
            return line.trim();
          })
          .join('\n');
          return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
        };
        function isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
          if (!root) {
            return false;
          }
          var nativeStringify = nativeObjects.nativeStringify;
          var shouldProcess;
          if (prunePaths.length === 0 && requiredPaths.length > 0) {
            var rootString = nativeStringify(root);
            var matchRegex = toRegExp(requiredPaths.join(''));
            var shouldLog = matchRegex.test(rootString);
            if (shouldLog) {
              logMessage(source, "".concat(window.location.hostname, "\n").concat(nativeStringify(root, null, 2), "\nStack trace:\n").concat(new Error().stack), true);
              if (root && typeof root === 'object') {
                logMessage(source, root, true, false);
              }
              shouldProcess = false;
              return shouldProcess;
            }
          }
          if (stack && !matchStackTrace(stack, new Error().stack || '')) {
            shouldProcess = false;
            return shouldProcess;
          }
          var wildcardSymbols = ['.*.', '*.', '.*', '.[].', '[].', '.[]'];
          var _loop = function _loop() {
            var requiredPath = requiredPaths[i];
            var lastNestedPropName = requiredPath.split('.').pop();
            var hasWildcard = wildcardSymbols.some(function (symbol) {
              return requiredPath.includes(symbol);
            });
            var details = getWildcardPropertyInChain(root, requiredPath, hasWildcard);
            if (!details.length) {
              shouldProcess = false;
              return {
                v: shouldProcess
              };
            }
            shouldProcess = !hasWildcard;
            for (var j = 0; j < details.length; j += 1) {
              var hasRequiredProp = typeof lastNestedPropName === 'string' && details[j].base[lastNestedPropName] !== undefined;
              if (hasWildcard) {
                shouldProcess = hasRequiredProp || shouldProcess;
              } else {
                shouldProcess = hasRequiredProp && shouldProcess;
              }
            }
          };
          for (var i = 0; i < requiredPaths.length; i += 1) {
            var _ret = _loop();
            if (typeof _ret === "object") return _ret.v;
          }
          return shouldProcess;
        }
        var jsonPruner = function jsonPruner(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
          var nativeStringify = nativeObjects.nativeStringify;
          if (prunePaths.length === 0 && requiredPaths.length === 0) {
            logMessage(source, "".concat(window.location.hostname, "\n").concat(nativeStringify(root, null, 2), "\nStack trace:\n").concat(new Error().stack), true);
            if (root && typeof root === 'object') {
              logMessage(source, root, true, false);
            }
            return root;
          }
          try {
            if (isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) === false) {
              return root;
            }
            prunePaths.forEach(function (path) {
              var ownerObjArr = getWildcardPropertyInChain(root, path, true);
              ownerObjArr.forEach(function (ownerObj) {
                if (ownerObj !== undefined && ownerObj.base) {
                  delete ownerObj.base[ownerObj.prop];
                  hit(source);
                }
              });
            });
          } catch (e) {
            logMessage(source, e);
          }
          return root;
        };
        var getPrunePath = function getPrunePath(props) {
          var validPropsString = typeof props === 'string' && props !== undefined && props !== '';
          return validPropsString ? props.split(/ +/) : [];
        };
        var modifyResponse = function modifyResponse(origResponse) {
          var _origResponse$headers;
          var replacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            body: '{}'
          };
          var headers = {};
          origResponse === null || origResponse === void 0 ? void 0 : (_origResponse$headers = origResponse.headers) === null || _origResponse$headers === void 0 ? void 0 : _origResponse$headers.forEach(function (value, key) {
            headers[key] = value;
          });
          var modifiedResponse = new Response(replacement.body, {
            status: origResponse.status,
            statusText: origResponse.statusText,
            headers
          });
          Object.defineProperties(modifiedResponse, {
            url: {
              value: origResponse.url
            },
            type: {
              value: replacement.type || origResponse.type
            }
          });
          return modifiedResponse;
        };
        var getRequestProps = function getRequestProps() {
          return ['url', 'method', 'headers', 'body', 'credentials', 'cache', 'redirect', 'referrer', 'referrerPolicy', 'integrity', 'keepalive', 'signal', 'mode'];
        };
        var getRequestData = function getRequestData(request) {
          var requestInitOptions = getRequestProps();
          var entries = requestInitOptions.map(function (key) {
            var value = request[key];
            return [key, value];
          });
          return Object.fromEntries(entries);
        };
        var getFetchData = function getFetchData(args, nativeRequestClone) {
          var fetchPropsObj = {};
          var resource = args[0];
          var fetchUrl;
          var fetchInit;
          if (resource instanceof Request) {
            var realData = nativeRequestClone.call(resource);
            var requestData = getRequestData(realData);
            fetchUrl = requestData.url;
            fetchInit = requestData;
          } else {
            fetchUrl = resource;
            fetchInit = args[1];
          }
          fetchPropsObj.url = fetchUrl;
          if (fetchInit instanceof Object) {
            var props = Object.keys(fetchInit);
            props.forEach(function (prop) {
              fetchPropsObj[prop] = fetchInit[prop];
            });
          }
          return fetchPropsObj;
        };
        var getXhrData = function getXhrData(method, url, async, user, password) {
          return {
            method,
            url,
            async,
            user,
            password
          };
        };
        var parseMatchProps = function parseMatchProps(propsToMatchStr) {
          var PROPS_DIVIDER = ' ';
          var PAIRS_MARKER = ':';
          var isRequestProp = function isRequestProp(prop) {
            return getRequestProps().includes(prop);
          };
          var propsObj = {};
          var props = propsToMatchStr.split(PROPS_DIVIDER);
          props.forEach(function (prop) {
            var dividerInd = prop.indexOf(PAIRS_MARKER);
            var key = prop.slice(0, dividerInd);
            if (isRequestProp(key)) {
              var value = prop.slice(dividerInd + 1);
              propsObj[key] = value;
            } else {
              propsObj.url = prop;
            }
          });
          return propsObj;
        };
        var isValidParsedData = function isValidParsedData(data) {
          return Object.values(data).every(function (value) {
            return isValidStrPattern(value);
          });
        };
        var getMatchPropsData = function getMatchPropsData(data) {
          var matchData = {};
          var dataKeys = Object.keys(data);
          dataKeys.forEach(function (key) {
            matchData[key] = toRegExp(data[key]);
          });
          return matchData;
        };
        var setStorageItem = function setStorageItem(source, storage, key, value) {
          try {
            storage.setItem(key, value);
          } catch (e) {
            var message = "Unable to set sessionStorage item due to: ".concat(e.message);
            logMessage(source, message);
          }
        };
        var removeStorageItem = function removeStorageItem(source, storage, key) {
          try {
            if (key.startsWith('/') && (key.endsWith('/') || key.endsWith('/i')) && isValidStrPattern(key)) {
              var regExpKey = toRegExp(key);
              var storageKeys = Object.keys(storage);
              storageKeys.forEach(function (storageKey) {
                if (regExpKey.test(storageKey)) {
                  storage.removeItem(storageKey);
                }
              });
            } else {
              storage.removeItem(key);
            }
          } catch (e) {
            var message = "Unable to remove storage item due to: ".concat(e.message);
            logMessage(source, message);
          }
        };
        var getLimitedStorageItemValue = function getLimitedStorageItemValue(value) {
          if (typeof value !== 'string') {
            throw new Error('Invalid value');
          }
          var allowedStorageValues = new Set(['undefined', 'false', 'true', 'null', '', 'yes', 'no', 'on', 'off']);
          var validValue;
          if (allowedStorageValues.has(value.toLowerCase())) {
            validValue = value;
          } else if (value === 'emptyArr') {
            validValue = '[]';
          } else if (value === 'emptyObj') {
            validValue = '{}';
          } else if (/^\d+$/.test(value)) {
            validValue = parseFloat(value);
            if (nativeIsNaN(validValue)) {
              throw new Error('Invalid value');
            }
            if (Math.abs(validValue) > 32767) {
              throw new Error('Invalid value');
            }
          } else if (value === '$remove$') {
            validValue = '$remove$';
          } else {
            throw new Error('Invalid value');
          }
          return validValue;
        };
        function createOnErrorHandler(rid) {
          var nativeOnError = window.onerror;
          return function onError(error) {
            if (typeof error === 'string' && error.includes(rid)) {
              return true;
            }
            if (nativeOnError instanceof Function) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              return nativeOnError.apply(window, [error, ...args]);
            }
            return false;
          };
        }
        function randomId() {
          return Math.random().toString(36).slice(2, 9);
        }
        function getDescriptorAddon() {
          return {
            isAbortingSuspended: false,
            isolateCallback(cb) {
              this.isAbortingSuspended = true;
              try {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                var result = cb(...args);
                this.isAbortingSuspended = false;
                return result;
              } catch (_unused) {
                var rid = randomId();
                this.isAbortingSuspended = false;
                throw new ReferenceError(rid);
              }
            }
          };
        }
        function getPropertyInChain(base, chain) {
          var pos = chain.indexOf('.');
          if (pos === -1) {
            return {
              base,
              prop: chain
            };
          }
          var prop = chain.slice(0, pos);
          if (base === null) {
            return {
              base,
              prop,
              chain
            };
          }
          var nextBase = base[prop];
          chain = chain.slice(pos + 1);
          if ((base instanceof Object || typeof base === 'object') && isEmptyObject(base)) {
            return {
              base,
              prop,
              chain
            };
          }
          if (nextBase === null) {
            return {
              base,
              prop,
              chain
            };
          }
          if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
          }
          Object.defineProperty(base, prop, {
            configurable: true
          });
          return {
            base,
            prop,
            chain
          };
        }
        var matchRequestProps = function matchRequestProps(source, propsToMatch, requestData) {
          if (propsToMatch === '' || propsToMatch === '*') {
            return true;
          }
          var isMatched;
          var parsedData = parseMatchProps(propsToMatch);
          if (!isValidParsedData(parsedData)) {
            logMessage(source, "Invalid parameter: ".concat(propsToMatch));
            isMatched = false;
          } else {
            var matchData = getMatchPropsData(parsedData);
            var matchKeys = Object.keys(matchData);
            isMatched = matchKeys.every(function (matchKey) {
              var matchValue = matchData[matchKey];
              var dataValue = requestData[matchKey];
              return Object.prototype.hasOwnProperty.call(requestData, matchKey) && typeof dataValue === 'string' && (matchValue === null || matchValue === void 0 ? void 0 : matchValue.test(dataValue));
            });
          }
          return isMatched;
        };
        var throttle = function throttle(cb, delay) {
          var wait = false;
          var savedArgs;
          var wrapper = function wrapper() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (wait) {
              savedArgs = args;
              return;
            }
            cb(...args);
            wait = true;
            setTimeout(function () {
              wait = false;
              if (savedArgs) {
                wrapper(...savedArgs);
                savedArgs = null;
              }
            }, delay);
          };
          return wrapper;
        };
        var observeDOMChanges = function observeDOMChanges(callback) {
          var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          var THROTTLE_DELAY_MS = 20;
          var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
          var connect = function connect() {
            if (attrsToObserve.length > 0) {
              observer.observe(document.documentElement, {
                childList: true,
                subtree: true,
                attributes: observeAttrs,
                attributeFilter: attrsToObserve
              });
            } else {
              observer.observe(document.documentElement, {
                childList: true,
                subtree: true,
                attributes: observeAttrs
              });
            }
          };
          var disconnect = function disconnect() {
            observer.disconnect();
          };
          function callbackWrapper() {
            disconnect();
            callback();
            connect();
          }
          connect();
        };
        var getAddedNodes = function getAddedNodes(mutations) {
          var nodes = [];
          for (var i = 0; i < mutations.length; i += 1) {
            var addedNodes = mutations[i].addedNodes;
            for (var j = 0; j < addedNodes.length; j += 1) {
              nodes.push(addedNodes[j]);
            }
          }
          return nodes;
        };
        var observeDocumentWithTimeout = function observeDocumentWithTimeout(callback, options) {
          var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10000;
          var documentObserver = new MutationObserver(function (mutations, observer) {
            observer.disconnect();
            callback(mutations, observer);
            observer.observe(document.documentElement, options);
          });
          documentObserver.observe(document.documentElement, options);
          if (typeof timeout === 'number') {
            setTimeout(function () {
              return documentObserver.disconnect();
            }, timeout);
          }
        };
        var parseFlags = function parseFlags(flags) {
          var FLAGS_DIVIDER = ' ';
          var ASAP_FLAG = 'asap';
          var COMPLETE_FLAG = 'complete';
          var STAY_FLAG = 'stay';
          var VALID_FLAGS = [STAY_FLAG, ASAP_FLAG, COMPLETE_FLAG];
          var passedFlags = flags.trim().split(FLAGS_DIVIDER).filter(function (f) {
            return VALID_FLAGS.includes(f);
          });
          return {
            ASAP: ASAP_FLAG,
            COMPLETE: COMPLETE_FLAG,
            STAY: STAY_FLAG,
            hasFlag(flag) {
              return passedFlags.includes(flag);
            }
          };
        };
        var parseKeywordValue = function parseKeywordValue(rawValue) {
          var NOW_VALUE_KEYWORD = '$now$';
          var CURRENT_DATE_KEYWORD = '$currentDate$';
          var parsedValue = rawValue;
          if (rawValue === NOW_VALUE_KEYWORD) {
            parsedValue = Date.now().toString();
          } else if (rawValue === CURRENT_DATE_KEYWORD) {
            parsedValue = Date();
          }
          return parsedValue;
        };
        var hijackAttachShadow = function hijackAttachShadow(context, hostSelector, callback) {
          var handlerWrapper = function handlerWrapper(target, thisArg, args) {
            var shadowRoot = Reflect.apply(target, thisArg, args);
            if (thisArg && thisArg.matches(hostSelector || '*')) {
              callback(shadowRoot);
            }
            return shadowRoot;
          };
          var attachShadowHandler = {
            apply: handlerWrapper
          };
          context.Element.prototype.attachShadow = new Proxy(context.Element.prototype.attachShadow, attachShadowHandler);
        };
        var handleExistingNodes = function handleExistingNodes(selector, handler) {
          var nodeList = document.querySelectorAll(selector);
          var nodes = nodeListToArray(nodeList);
          handler(nodes);
        };
        var handleMutations = function handleMutations(mutations, handler) {
          var addedNodes = getAddedNodes(mutations);
          handler(addedNodes);
        };
        var isTargetNode = function isTargetNode(node, nodeNameMatch, textContentMatch) {
          var nodeName = node.nodeName,
            textContent = node.textContent;
          var nodeNameLowerCase = nodeName.toLowerCase();
          return textContent !== null && textContent !== '' && (nodeNameMatch instanceof RegExp ? nodeNameMatch.test(nodeNameLowerCase) : nodeNameMatch === nodeNameLowerCase) && (textContentMatch instanceof RegExp ? textContentMatch.test(textContent) : textContent.includes(textContentMatch));
        };
        var replaceNodeText = function replaceNodeText(source, node, pattern, replacement) {
          var textContent = node.textContent;
          if (textContent) {
            node.textContent = textContent.replace(pattern, replacement);
            hit(source);
          }
        };
        var parseNodeTextParams = function parseNodeTextParams(nodeName, textMatch) {
          var pattern = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var REGEXP_START_MARKER = '/';
          var isStringNameMatch = !(nodeName.startsWith(REGEXP_START_MARKER) && nodeName.endsWith(REGEXP_START_MARKER));
          var selector = isStringNameMatch ? nodeName : '*';
          var nodeNameMatch = isStringNameMatch ? nodeName : toRegExp(nodeName);
          var textContentMatch = !textMatch.startsWith(REGEXP_START_MARKER) ? textMatch : toRegExp(textMatch);
          var patternMatch;
          if (pattern) {
            patternMatch = !pattern.startsWith(REGEXP_START_MARKER) ? pattern : toRegExp(pattern);
          }
          return {
            selector,
            nodeNameMatch,
            textContentMatch,
            patternMatch
          };
        };
        function trustedClickElement$1(source, selectors) {
          var extraMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
          var delay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NaN;
          if (!selectors) {
            return;
          }
          var OBSERVER_TIMEOUT_MS = 10000;
          var THROTTLE_DELAY_MS = 20;
          var STATIC_CLICK_DELAY_MS = 150;
          var COOKIE_MATCH_MARKER = 'cookie:';
          var LOCAL_STORAGE_MATCH_MARKER = 'localStorage:';
          var SELECTORS_DELIMITER = ',';
          var COOKIE_STRING_DELIMITER = ';';
          var EXTRA_MATCH_DELIMITER = /(,\s*){1}(?=!?cookie:|!?localStorage:)/;
          var sleep = function sleep(delayMs) {
            return new Promise(function (resolve) {
              return setTimeout(resolve, delayMs);
            });
          };
          var parsedDelay;
          if (delay) {
            parsedDelay = parseInt(delay, 10);
            var isValidDelay = !Number.isNaN(parsedDelay) || parsedDelay < OBSERVER_TIMEOUT_MS;
            if (!isValidDelay) {
              var message = "Passed delay '".concat(delay, "' is invalid or bigger than ").concat(OBSERVER_TIMEOUT_MS, " ms");
              logMessage(source, message);
              return;
            }
          }
          var canClick = !parsedDelay;
          var cookieMatches = [];
          var localStorageMatches = [];
          var isInvertedMatchCookie = false;
          var isInvertedMatchLocalStorage = false;
          if (extraMatch) {
            var parsedExtraMatch = extraMatch.split(EXTRA_MATCH_DELIMITER).map(function (matchStr) {
              return matchStr.trim();
            });
            parsedExtraMatch.forEach(function (matchStr) {
              if (matchStr.includes(COOKIE_MATCH_MARKER)) {
                var _parseMatchArg = parseMatchArg(matchStr),
                  isInvertedMatch = _parseMatchArg.isInvertedMatch,
                  matchValue = _parseMatchArg.matchValue;
                isInvertedMatchCookie = isInvertedMatch;
                var cookieMatch = matchValue.replace(COOKIE_MATCH_MARKER, '');
                cookieMatches.push(cookieMatch);
              }
              if (matchStr.includes(LOCAL_STORAGE_MATCH_MARKER)) {
                var _parseMatchArg2 = parseMatchArg(matchStr),
                  _isInvertedMatch = _parseMatchArg2.isInvertedMatch,
                  _matchValue = _parseMatchArg2.matchValue;
                isInvertedMatchLocalStorage = _isInvertedMatch;
                var localStorageMatch = _matchValue.replace(LOCAL_STORAGE_MATCH_MARKER, '');
                localStorageMatches.push(localStorageMatch);
              }
            });
          }
          if (cookieMatches.length > 0) {
            var parsedCookieMatches = parseCookieString(cookieMatches.join(COOKIE_STRING_DELIMITER));
            var parsedCookies = parseCookieString(document.cookie);
            var cookieKeys = Object.keys(parsedCookies);
            if (cookieKeys.length === 0) {
              return;
            }
            var cookiesMatched = Object.keys(parsedCookieMatches).every(function (key) {
              var valueMatch = parsedCookieMatches[key] ? toRegExp(parsedCookieMatches[key]) : null;
              var keyMatch = toRegExp(key);
              return cookieKeys.some(function (key) {
                var keysMatched = keyMatch.test(key);
                if (!keysMatched) {
                  return false;
                }
                if (!valueMatch) {
                  return true;
                }
                return valueMatch.test(parsedCookies[key]);
              });
            });
            var shouldRun = cookiesMatched !== isInvertedMatchCookie;
            if (!shouldRun) {
              return;
            }
          }
          if (localStorageMatches.length > 0) {
            var localStorageMatched = localStorageMatches.every(function (str) {
              var itemValue = window.localStorage.getItem(str);
              return itemValue || itemValue === '';
            });
            var _shouldRun = localStorageMatched !== isInvertedMatchLocalStorage;
            if (!_shouldRun) {
              return;
            }
          }
          var selectorsSequence = selectors.split(SELECTORS_DELIMITER).map(function (selector) {
            return selector.trim();
          });
          var createElementObj = function createElementObj(element) {
            return {
              element: element || null,
              clicked: false
            };
          };
          var elementsSequence = Array(selectorsSequence.length).fill(createElementObj());
          var clickElementsBySequence = async function clickElementsBySequence() {
            for (var i = 0; i < elementsSequence.length; i += 1) {
              var elementObj = elementsSequence[i];
              if (i >= 1) {
                await sleep(STATIC_CLICK_DELAY_MS);
              }
              if (!elementObj.element) {
                break;
              }
              if (!elementObj.clicked) {
                elementObj.element.click();
                elementObj.clicked = true;
              }
            }
            var allElementsClicked = elementsSequence.every(function (elementObj) {
              return elementObj.clicked === true;
            });
            if (allElementsClicked) {
              hit(source);
            }
          };
          var handleElement = function handleElement(element, i) {
            var elementObj = createElementObj(element);
            elementsSequence[i] = elementObj;
            if (canClick) {
              clickElementsBySequence();
            }
          };
          var findElements = function findElements(mutations, observer) {
            var fulfilledSelectors = [];
            selectorsSequence.forEach(function (selector, i) {
              if (!selector) {
                return;
              }
              var element = document.querySelector(selector);
              if (!element) {
                return;
              }
              handleElement(element, i);
              fulfilledSelectors.push(selector);
            });
            selectorsSequence = selectorsSequence.map(function (selector) {
              return fulfilledSelectors.includes(selector) ? null : selector;
            });
            var allSelectorsFulfilled = selectorsSequence.every(function (selector) {
              return selector === null;
            });
            if (allSelectorsFulfilled) {
              observer.disconnect();
            }
          };
          var observer = new MutationObserver(throttle(findElements, THROTTLE_DELAY_MS));
          observer.observe(document.documentElement, {
            attributes: true,
            childList: true,
            subtree: true
          });
          if (parsedDelay) {
            setTimeout(function () {
              clickElementsBySequence();
              canClick = true;
            }, parsedDelay);
          }
          setTimeout(function () {
            return observer.disconnect();
          }, OBSERVER_TIMEOUT_MS);
        }
        trustedClickElement$1.names = ['trusted-click-element'
        ];
        trustedClickElement$1.injections = [hit, toRegExp, parseCookieString, throttle, logMessage, parseMatchArg];
        function abortOnPropertyRead$1(source, property) {
          if (!property) {
            return;
          }
          var rid = randomId();
          var abort = function abort() {
            hit(source);
            throw new ReferenceError(rid);
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
              chain = chainInfo.chain;
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            setPropertyAccess(base, prop, {
              get: abort,
              set: function set() {}
            });
          };
          setChainPropAccess(window, property);
          window.onerror = createOnErrorHandler(rid).bind();
        }
        abortOnPropertyRead$1.names = ['abort-on-property-read',
        'abort-on-property-read.js', 'ubo-abort-on-property-read.js', 'aopr.js', 'ubo-aopr.js', 'ubo-abort-on-property-read', 'ubo-aopr', 'abp-abort-on-property-read'];
        abortOnPropertyRead$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, isEmptyObject];
        function abortOnPropertyWrite$1(source, property) {
          if (!property) {
            return;
          }
          var rid = randomId();
          var abort = function abort() {
            hit(source);
            throw new ReferenceError(rid);
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
              chain = chainInfo.chain;
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            setPropertyAccess(base, prop, {
              set: abort
            });
          };
          setChainPropAccess(window, property);
          window.onerror = createOnErrorHandler(rid).bind();
        }
        abortOnPropertyWrite$1.names = ['abort-on-property-write',
        'abort-on-property-write.js', 'ubo-abort-on-property-write.js', 'aopw.js', 'ubo-aopw.js', 'ubo-abort-on-property-write', 'ubo-aopw', 'abp-abort-on-property-write'];
        abortOnPropertyWrite$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, isEmptyObject];
        function preventSetTimeout$1(source, matchCallback, matchDelay) {
          var shouldLog = typeof matchCallback === 'undefined' && typeof matchDelay === 'undefined';
          var handlerWrapper = function handlerWrapper(target, thisArg, args) {
            var callback = args[0];
            var delay = args[1];
            var shouldPrevent = false;
            if (shouldLog) {
              hit(source);
              logMessage(source, "setTimeout(".concat(String(callback), ", ").concat(delay, ")"), true);
            } else {
              shouldPrevent = isPreventionNeeded({
                callback,
                delay,
                matchCallback,
                matchDelay
              });
            }
            if (shouldPrevent) {
              hit(source);
              args[0] = noopFunc;
            }
            return target.apply(thisArg, args);
          };
          var setTimeoutHandler = {
            apply: handlerWrapper
          };
          window.setTimeout = new Proxy(window.setTimeout, setTimeoutHandler);
        }
        preventSetTimeout$1.names = ['prevent-setTimeout',
        'no-setTimeout-if.js',
        'ubo-no-setTimeout-if.js', 'nostif.js',
        'ubo-nostif.js', 'ubo-no-setTimeout-if', 'ubo-nostif',
        'setTimeout-defuser.js', 'ubo-setTimeout-defuser.js', 'ubo-setTimeout-defuser', 'std.js', 'ubo-std.js', 'ubo-std'];
        preventSetTimeout$1.injections = [hit, noopFunc, isPreventionNeeded, logMessage,
        parseMatchArg, parseDelayArg, toRegExp, nativeIsNaN, isValidCallback, isValidMatchStr, escapeRegExp, isValidStrPattern, nativeIsFinite, isValidMatchNumber, parseRawDelay];
        function preventSetInterval$1(source, matchCallback, matchDelay) {
          var shouldLog = typeof matchCallback === 'undefined' && typeof matchDelay === 'undefined';
          var handlerWrapper = function handlerWrapper(target, thisArg, args) {
            var callback = args[0];
            var delay = args[1];
            var shouldPrevent = false;
            if (shouldLog) {
              hit(source);
              logMessage(source, "setInterval(".concat(String(callback), ", ").concat(delay, ")"), true);
            } else {
              shouldPrevent = isPreventionNeeded({
                callback,
                delay,
                matchCallback,
                matchDelay
              });
            }
            if (shouldPrevent) {
              hit(source);
              args[0] = noopFunc;
            }
            return target.apply(thisArg, args);
          };
          var setIntervalHandler = {
            apply: handlerWrapper
          };
          window.setInterval = new Proxy(window.setInterval, setIntervalHandler);
        }
        preventSetInterval$1.names = ['prevent-setInterval',
        'no-setInterval-if.js',
        'ubo-no-setInterval-if.js', 'setInterval-defuser.js',
        'ubo-setInterval-defuser.js', 'nosiif.js',
        'ubo-nosiif.js', 'sid.js',
        'ubo-sid.js', 'ubo-no-setInterval-if', 'ubo-setInterval-defuser', 'ubo-nosiif', 'ubo-sid'];
        preventSetInterval$1.injections = [hit, noopFunc, isPreventionNeeded, logMessage,
        toRegExp, nativeIsNaN, parseMatchArg, parseDelayArg, isValidCallback, isValidMatchStr, isValidStrPattern, escapeRegExp, nativeIsFinite, isValidMatchNumber, parseRawDelay];
        function preventWindowOpen$1(source) {
          var match = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '*';
          var delay = arguments.length > 2 ? arguments[2] : undefined;
          var replacement = arguments.length > 3 ? arguments[3] : undefined;
          var nativeOpen = window.open;
          var isNewSyntax = match !== '0' && match !== '1';
          var oldOpenWrapper = function oldOpenWrapper(str) {
            match = Number(match) > 0;
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            if (!isValidStrPattern(delay)) {
              logMessage(source, "Invalid parameter: ".concat(delay));
              return nativeOpen.apply(window, [str, ...args]);
            }
            var searchRegexp = toRegExp(delay);
            if (match !== searchRegexp.test(str)) {
              return nativeOpen.apply(window, [str, ...args]);
            }
            hit(source);
            return handleOldReplacement(replacement);
          };
          var newOpenWrapper = function newOpenWrapper(url) {
            var shouldLog = replacement && replacement.includes('log');
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            if (shouldLog) {
              var argsStr = args && args.length > 0 ? ", ".concat(args.join(', ')) : '';
              var message = "".concat(url).concat(argsStr);
              logMessage(source, message, true);
              hit(source);
            }
            var shouldPrevent = false;
            if (match === '*') {
              shouldPrevent = true;
            } else if (isValidMatchStr(match)) {
              var _parseMatchArg = parseMatchArg(match),
                isInvertedMatch = _parseMatchArg.isInvertedMatch,
                matchRegexp = _parseMatchArg.matchRegexp;
              shouldPrevent = matchRegexp.test(url) !== isInvertedMatch;
            } else {
              logMessage(source, "Invalid parameter: ".concat(match));
              shouldPrevent = false;
            }
            if (shouldPrevent) {
              var parsedDelay = parseInt(delay, 10);
              var result;
              if (nativeIsNaN(parsedDelay)) {
                result = noopNull();
              } else {
                var decoyArgs = {
                  replacement,
                  url,
                  delay: parsedDelay
                };
                var decoy = createDecoy(decoyArgs);
                var popup = decoy.contentWindow;
                if (typeof popup === 'object' && popup !== null) {
                  Object.defineProperty(popup, 'closed', {
                    value: false
                  });
                  Object.defineProperty(popup, 'opener', {
                    value: window
                  });
                  Object.defineProperty(popup, 'frameElement', {
                    value: null
                  });
                } else {
                  var nativeGetter = decoy.contentWindow && decoy.contentWindow.get;
                  Object.defineProperty(decoy, 'contentWindow', {
                    get: getPreventGetter(nativeGetter)
                  });
                  popup = decoy.contentWindow;
                }
                result = popup;
              }
              hit(source);
              return result;
            }
            return nativeOpen.apply(window, [url, ...args]);
          };
          window.open = isNewSyntax ? newOpenWrapper : oldOpenWrapper;
          window.open.toString = nativeOpen.toString.bind(nativeOpen);
        }
        preventWindowOpen$1.names = ['prevent-window-open',
        'window.open-defuser.js', 'ubo-window.open-defuser.js', 'ubo-window.open-defuser', 'nowoif.js', 'ubo-nowoif.js', 'ubo-nowoif', 'no-window-open-if.js', 'ubo-no-window-open-if.js', 'ubo-no-window-open-if'];
        preventWindowOpen$1.injections = [hit, isValidStrPattern, escapeRegExp, isValidMatchStr, toRegExp, nativeIsNaN, parseMatchArg, handleOldReplacement, createDecoy, getPreventGetter, noopNull, logMessage, noopFunc, trueFunc, substringBefore, substringAfter$1];
        function abortCurrentInlineScript$1(source, property, search) {
          var searchRegexp = toRegExp(search);
          var rid = randomId();
          var SRC_DATA_MARKER = 'data:text/javascript;base64,';
          var getCurrentScript = function getCurrentScript() {
            if ('currentScript' in document) {
              return document.currentScript;
            }
            var scripts = document.getElementsByTagName('script');
            return scripts[scripts.length - 1];
          };
          var ourScript = getCurrentScript();
          var abort = function abort() {
            var _scriptEl$src;
            var scriptEl = getCurrentScript();
            if (!scriptEl) {
              return;
            }
            var content = scriptEl.textContent;
            try {
              var textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
              content = textContentGetter.call(scriptEl);
            } catch (e) {}
            if (content.length === 0 && typeof scriptEl.src !== 'undefined' && (_scriptEl$src = scriptEl.src) !== null && _scriptEl$src !== void 0 && _scriptEl$src.startsWith(SRC_DATA_MARKER)) {
              var encodedContent = scriptEl.src.slice(SRC_DATA_MARKER.length);
              content = window.atob(encodedContent);
            }
            if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
              hit(source);
              throw new ReferenceError(rid);
            }
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
              chain = chainInfo.chain;
            if (base instanceof Object === false && base === null) {
              var props = property.split('.');
              var propIndex = props.indexOf(prop);
              var baseName = props[propIndex - 1];
              var message = "The scriptlet had been executed before the ".concat(baseName, " was loaded.");
              logMessage(source, message);
              return;
            }
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            var currentValue = base[prop];
            var origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
            if (origDescriptor instanceof Object === false || origDescriptor.get instanceof Function === false) {
              currentValue = base[prop];
              origDescriptor = undefined;
            }
            var descriptorWrapper = Object.assign(getDescriptorAddon(), {
              currentValue,
              get() {
                if (!this.isAbortingSuspended) {
                  this.isolateCallback(abort);
                }
                if (origDescriptor instanceof Object) {
                  return origDescriptor.get.call(base);
                }
                return this.currentValue;
              },
              set(newValue) {
                if (!this.isAbortingSuspended) {
                  this.isolateCallback(abort);
                }
                if (origDescriptor instanceof Object) {
                  origDescriptor.set.call(base, newValue);
                } else {
                  this.currentValue = newValue;
                }
              }
            });
            setPropertyAccess(base, prop, {
              get() {
                return descriptorWrapper.get.call(descriptorWrapper);
              },
              set(newValue) {
                descriptorWrapper.set.call(descriptorWrapper, newValue);
              }
            });
          };
          setChainPropAccess(window, property);
          window.onerror = createOnErrorHandler(rid).bind();
        }
        abortCurrentInlineScript$1.names = ['abort-current-inline-script',
        'abort-current-script.js', 'ubo-abort-current-script.js', 'acs.js', 'ubo-acs.js',
        'ubo-abort-current-script', 'ubo-acs',
        'abort-current-inline-script.js', 'ubo-abort-current-inline-script.js', 'acis.js', 'ubo-acis.js', 'ubo-abort-current-inline-script', 'ubo-acis', 'abp-abort-current-inline-script'];
        abortCurrentInlineScript$1.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, createOnErrorHandler, hit, logMessage, isEmptyObject, getDescriptorAddon];
        function setConstant$1(source, property, value) {
          var stack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
          var valueWrapper = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
          var setProxyTrap = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
          var uboAliases = ['set-constant.js', 'ubo-set-constant.js', 'set.js', 'ubo-set.js', 'ubo-set-constant', 'ubo-set'];
          if (uboAliases.includes(source.name)) {
            if (stack.length !== 1 && !getNumberFromString(stack)) {
              valueWrapper = stack;
            }
            stack = undefined;
          }
          if (!property || !matchStackTrace(stack, new Error().stack)) {
            return;
          }
          var isProxyTrapSet = false;
          var emptyArr = noopArray();
          var emptyObj = noopObject();
          var constantValue;
          if (value === 'undefined') {
            constantValue = undefined;
          } else if (value === 'false') {
            constantValue = false;
          } else if (value === 'true') {
            constantValue = true;
          } else if (value === 'null') {
            constantValue = null;
          } else if (value === 'emptyArr') {
            constantValue = emptyArr;
          } else if (value === 'emptyObj') {
            constantValue = emptyObj;
          } else if (value === 'noopFunc') {
            constantValue = noopFunc;
          } else if (value === 'noopCallbackFunc') {
            constantValue = noopCallbackFunc;
          } else if (value === 'trueFunc') {
            constantValue = trueFunc;
          } else if (value === 'falseFunc') {
            constantValue = falseFunc;
          } else if (value === 'throwFunc') {
            constantValue = throwFunc;
          } else if (value === 'noopPromiseResolve') {
            constantValue = noopPromiseResolve;
          } else if (value === 'noopPromiseReject') {
            constantValue = noopPromiseReject;
          } else if (/^\d+$/.test(value)) {
            constantValue = parseFloat(value);
            if (nativeIsNaN(constantValue)) {
              return;
            }
            if (Math.abs(constantValue) > 32767) {
              return;
            }
          } else if (value === '-1') {
            constantValue = -1;
          } else if (value === '') {
            constantValue = '';
          } else if (value === 'yes') {
            constantValue = 'yes';
          } else if (value === 'no') {
            constantValue = 'no';
          } else {
            return;
          }
          var valueWrapperNames = ['asFunction', 'asCallback', 'asResolved', 'asRejected'];
          if (valueWrapperNames.includes(valueWrapper)) {
            var valueWrappersMap = {
              asFunction(v) {
                return function () {
                  return v;
                };
              },
              asCallback(v) {
                return function () {
                  return function () {
                    return v;
                  };
                };
              },
              asResolved(v) {
                return Promise.resolve(v);
              },
              asRejected(v) {
                return Promise.reject(v);
              }
            };
            constantValue = valueWrappersMap[valueWrapper](constantValue);
          }
          var canceled = false;
          var mustCancel = function mustCancel(value) {
            if (canceled) {
              return canceled;
            }
            canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue && value !== null;
            return canceled;
          };
          var trapProp = function trapProp(base, prop, configurable, handler) {
            if (!handler.init(base[prop])) {
              return false;
            }
            var origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
            var prevSetter;
            if (origDescriptor instanceof Object) {
              if (!origDescriptor.configurable) {
                var message = "Property '".concat(prop, "' is not configurable");
                logMessage(source, message);
                return false;
              }
              if (base[prop]) {
                base[prop] = constantValue;
              }
              if (origDescriptor.set instanceof Function) {
                prevSetter = origDescriptor.set;
              }
            }
            Object.defineProperty(base, prop, {
              configurable,
              get() {
                return handler.get();
              },
              set(a) {
                if (prevSetter !== undefined) {
                  prevSetter(a);
                }
                if (a instanceof Object) {
                  var propertiesToCheck = property.split('.').slice(1);
                  if (setProxyTrap && !isProxyTrapSet) {
                    isProxyTrapSet = true;
                    a = new Proxy(a, {
                      get: function get(target, propertyKey, val) {
                        propertiesToCheck.reduce(function (object, currentProp, index, array) {
                          var currentObj = object === null || object === void 0 ? void 0 : object[currentProp];
                          if (currentObj && index === array.length - 1 && currentObj !== constantValue) {
                            object[currentProp] = constantValue;
                          }
                          return currentObj || object;
                        }, target);
                        return Reflect.get(target, propertyKey, val);
                      }
                    });
                  }
                }
                handler.set(a);
              }
            });
            return true;
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
              chain = chainInfo.chain;
            var inChainPropHandler = {
              factValue: undefined,
              init(a) {
                this.factValue = a;
                return true;
              },
              get() {
                return this.factValue;
              },
              set(a) {
                if (this.factValue === a) {
                  return;
                }
                this.factValue = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              }
            };
            var endPropHandler = {
              init(a) {
                if (mustCancel(a)) {
                  return false;
                }
                return true;
              },
              get() {
                return constantValue;
              },
              set(a) {
                if (!mustCancel(a)) {
                  return;
                }
                constantValue = a;
              }
            };
            if (!chain) {
              var isTrapped = trapProp(base, prop, false, endPropHandler);
              if (isTrapped) {
                hit(source);
              }
              return;
            }
            if (base !== undefined && base[prop] === null) {
              trapProp(base, prop, true, inChainPropHandler);
              return;
            }
            if ((base instanceof Object || typeof base === 'object') && isEmptyObject(base)) {
              trapProp(base, prop, true, inChainPropHandler);
            }
            var propValue = owner[prop];
            if (propValue instanceof Object || typeof propValue === 'object' && propValue !== null) {
              setChainPropAccess(propValue, chain);
            }
            trapProp(base, prop, true, inChainPropHandler);
          };
          setChainPropAccess(window, property);
        }
        setConstant$1.names = ['set-constant',
        'set-constant.js', 'ubo-set-constant.js', 'set.js', 'ubo-set.js', 'ubo-set-constant', 'ubo-set', 'abp-override-property-read'];
        setConstant$1.injections = [hit, logMessage, getNumberFromString, noopArray, noopObject, noopFunc, noopCallbackFunc, trueFunc, falseFunc, throwFunc, noopPromiseReject, noopPromiseResolve, getPropertyInChain, matchStackTrace, nativeIsNaN, isEmptyObject,
        shouldAbortInlineOrInjectedScript, getNativeRegexpTest, setPropertyAccess, toRegExp];
        function removeCookie$1(source, match) {
          var matchRegexp = toRegExp(match);
          var removeCookieFromHost = function removeCookieFromHost(cookieName, hostName) {
            var cookieSpec = "".concat(cookieName, "=");
            var domain1 = "; domain=".concat(hostName);
            var domain2 = "; domain=.".concat(hostName);
            var path = '; path=/';
            var expiration = '; expires=Thu, 01 Jan 1970 00:00:00 GMT';
            document.cookie = cookieSpec + expiration;
            document.cookie = cookieSpec + domain1 + expiration;
            document.cookie = cookieSpec + domain2 + expiration;
            document.cookie = cookieSpec + path + expiration;
            document.cookie = cookieSpec + domain1 + path + expiration;
            document.cookie = cookieSpec + domain2 + path + expiration;
            hit(source);
          };
          var rmCookie = function rmCookie() {
            document.cookie.split(';').forEach(function (cookieStr) {
              var pos = cookieStr.indexOf('=');
              if (pos === -1) {
                return;
              }
              var cookieName = cookieStr.slice(0, pos).trim();
              if (!matchRegexp.test(cookieName)) {
                return;
              }
              var hostParts = document.location.hostname.split('.');
              for (var i = 0; i <= hostParts.length - 1; i += 1) {
                var hostName = hostParts.slice(i).join('.');
                if (hostName) {
                  removeCookieFromHost(cookieName, hostName);
                }
              }
            });
          };
          rmCookie();
          window.addEventListener('beforeunload', rmCookie);
        }
        removeCookie$1.names = ['remove-cookie',
        'cookie-remover.js', 'ubo-cookie-remover.js', 'ubo-cookie-remover', 'remove-cookie.js', 'ubo-remove-cookie.js', 'ubo-remove-cookie', 'abp-cookie-remover'];
        removeCookie$1.injections = [toRegExp, hit];
        function preventAddEventListener$1(source, typeSearch, listenerSearch) {
          var typeSearchRegexp = toRegExp(typeSearch);
          var listenerSearchRegexp = toRegExp(listenerSearch);
          var nativeAddEventListener = window.EventTarget.prototype.addEventListener;
          function addEventListenerWrapper(type, listener) {
            var _this$constructor;
            var shouldPrevent = false;
            if (validateType(type) && validateListener(listener)) {
              shouldPrevent = typeSearchRegexp.test(type.toString()) && listenerSearchRegexp.test(listenerToString(listener));
            }
            if (shouldPrevent) {
              hit(source);
              return undefined;
            }
            var context = this;
            if (this && ((_this$constructor = this.constructor) === null || _this$constructor === void 0 ? void 0 : _this$constructor.name) === 'Window' && this !== window) {
              context = window;
            }
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            return nativeAddEventListener.apply(context, [type, listener, ...args]);
          }
          var descriptor = {
            configurable: true,
            set: function set() {},
            get: function get() {
              return addEventListenerWrapper;
            }
          };
          Object.defineProperty(window.EventTarget.prototype, 'addEventListener', descriptor);
          Object.defineProperty(window, 'addEventListener', descriptor);
          Object.defineProperty(document, 'addEventListener', descriptor);
        }
        preventAddEventListener$1.names = ['prevent-addEventListener',
        'addEventListener-defuser.js', 'ubo-addEventListener-defuser.js', 'aeld.js', 'ubo-aeld.js', 'ubo-addEventListener-defuser', 'ubo-aeld', 'abp-prevent-listener'];
        preventAddEventListener$1.injections = [hit, toRegExp, validateType, validateListener, listenerToString];
        function preventBab$2(source) {
          var nativeSetTimeout = window.setTimeout;
          var babRegex = /\.bab_elementid.$/;
          var timeoutWrapper = function timeoutWrapper(callback) {
            if (typeof callback !== 'string' || !babRegex.test(callback)) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              return nativeSetTimeout.apply(window, [callback, ...args]);
            }
            hit(source);
          };
          window.setTimeout = timeoutWrapper;
          var signatures = [['blockadblock'], ['babasbm'], [/getItem\('babn'\)/], ['getElementById', 'String.fromCharCode', 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', 'charAt', 'DOMContentLoaded', 'AdBlock', 'addEventListener', 'doScroll', 'fromCharCode', '<<2|r>>4', 'sessionStorage', 'clientWidth', 'localStorage', 'Math', 'random']];
          var check = function check(str) {
            if (typeof str !== 'string') {
              return false;
            }
            for (var i = 0; i < signatures.length; i += 1) {
              var tokens = signatures[i];
              var match = 0;
              for (var j = 0; j < tokens.length; j += 1) {
                var token = tokens[j];
                var found = token instanceof RegExp ? token.test(str) : str.includes(token);
                if (found) {
                  match += 1;
                }
              }
              if (match / tokens.length >= 0.8) {
                return true;
              }
            }
            return false;
          };
          var nativeEval = window.eval;
          var evalWrapper = function evalWrapper(str) {
            if (!check(str)) {
              return nativeEval(str);
            }
            hit(source);
            var bodyEl = document.body;
            if (bodyEl) {
              bodyEl.style.removeProperty('visibility');
            }
            var el = document.getElementById('babasbmsgx');
            if (el) {
              el.parentNode.removeChild(el);
            }
          };
          window.eval = evalWrapper.bind(window);
        }
        preventBab$2.names = ['prevent-bab'
        ];
        preventBab$2.injections = [hit];
        function nowebrtc$1(source) {
          var propertyName = '';
          if (window.RTCPeerConnection) {
            propertyName = 'RTCPeerConnection';
          } else if (window.webkitRTCPeerConnection) {
            propertyName = 'webkitRTCPeerConnection';
          }
          if (propertyName === '') {
            return;
          }
          var rtcReplacement = function rtcReplacement(config) {
            var message = "Document tried to create an RTCPeerConnection: ".concat(convertRtcConfigToString(config));
            logMessage(source, message);
            hit(source);
          };
          rtcReplacement.prototype = {
            close: noopFunc,
            createDataChannel: noopFunc,
            createOffer: noopFunc,
            setRemoteDescription: noopFunc
          };
          var rtc = window[propertyName];
          window[propertyName] = rtcReplacement;
          if (rtc.prototype) {
            rtc.prototype.createDataChannel = function (a, b) {
              return {
                close: noopFunc,
                send: noopFunc
              };
            }.bind(null);
          }
        }
        nowebrtc$1.names = ['nowebrtc',
        'nowebrtc.js', 'ubo-nowebrtc.js', 'ubo-nowebrtc'];
        nowebrtc$1.injections = [hit, noopFunc, logMessage, convertRtcConfigToString];
        function logAddEventListener$1(source) {
          var nativeAddEventListener = window.EventTarget.prototype.addEventListener;
          function addEventListenerWrapper(type, listener) {
            var _this$constructor;
            if (validateType(type) && validateListener(listener)) {
              var message = "addEventListener(\"".concat(type, "\", ").concat(listenerToString(listener), ")");
              logMessage(source, message, true);
              hit(source);
            } else {
              var _message = "Invalid event type or listener passed to addEventListener:\n        type: ".concat(convertTypeToString(type), "\n        listener: ").concat(convertTypeToString(listener));
              logMessage(source, _message, true);
            }
            var context = this;
            if (this && ((_this$constructor = this.constructor) === null || _this$constructor === void 0 ? void 0 : _this$constructor.name) === 'Window' && this !== window) {
              context = window;
            }
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            return nativeAddEventListener.apply(context, [type, listener, ...args]);
          }
          var descriptor = {
            configurable: true,
            set: function set() {},
            get: function get() {
              return addEventListenerWrapper;
            }
          };
          Object.defineProperty(window.EventTarget.prototype, 'addEventListener', descriptor);
          Object.defineProperty(window, 'addEventListener', descriptor);
          Object.defineProperty(document, 'addEventListener', descriptor);
        }
        logAddEventListener$1.names = ['log-addEventListener',
        'addEventListener-logger.js', 'ubo-addEventListener-logger.js', 'aell.js', 'ubo-aell.js', 'ubo-addEventListener-logger', 'ubo-aell'];
        logAddEventListener$1.injections = [hit, validateType, validateListener, listenerToString, convertTypeToString, logMessage, objectToString, isEmptyObject];
        function logEval$1(source) {
          var nativeEval = window.eval;
          function evalWrapper(str) {
            hit(source);
            logMessage(source, "eval(\"".concat(str, "\")"), true);
            return nativeEval(str);
          }
          window.eval = evalWrapper;
          var nativeFunction = window.Function;
          function FunctionWrapper() {
            hit(source);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            logMessage(source, "new Function(".concat(args.join(', '), ")"), true);
            return nativeFunction.apply(this, [...args]);
          }
          FunctionWrapper.prototype = Object.create(nativeFunction.prototype);
          FunctionWrapper.prototype.constructor = FunctionWrapper;
          window.Function = FunctionWrapper;
        }
        logEval$1.names = ['log-eval'];
        logEval$1.injections = [hit, logMessage];
        function log$1() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          console.log(args);
        }
        log$1.names = ['log', 'abp-log'];
        function noeval$1(source) {
          window.eval = function evalWrapper(s) {
            hit(source);
            logMessage(source, "AdGuard has prevented eval:\n".concat(s), true);
          }.bind();
        }
        noeval$1.names = ['noeval',
        'noeval.js', 'silent-noeval.js', 'ubo-noeval.js', 'ubo-silent-noeval.js', 'ubo-noeval', 'ubo-silent-noeval'];
        noeval$1.injections = [hit, logMessage];
        function preventEvalIf$1(source, search) {
          var searchRegexp = toRegExp(search);
          var nativeEval = window.eval;
          window.eval = function (payload) {
            if (!searchRegexp.test(payload.toString())) {
              return nativeEval.call(window, payload);
            }
            hit(source);
            return undefined;
          }.bind(window);
        }
        preventEvalIf$1.names = ['prevent-eval-if',
        'noeval-if.js', 'ubo-noeval-if.js', 'ubo-noeval-if'];
        preventEvalIf$1.injections = [toRegExp, hit];
        function preventFab$1(source) {
          hit(source);
          var Fab = function Fab() {};
          Fab.prototype.check = noopFunc;
          Fab.prototype.clearEvent = noopFunc;
          Fab.prototype.emitEvent = noopFunc;
          Fab.prototype.on = function (a, b) {
            if (!a) {
              b();
            }
            return this;
          };
          Fab.prototype.onDetected = noopThis;
          Fab.prototype.onNotDetected = function (a) {
            a();
            return this;
          };
          Fab.prototype.setOption = noopFunc;
          Fab.prototype.options = {
            set: noopFunc,
            get: noopFunc
          };
          var fab = new Fab();
          var getSetFab = {
            get() {
              return Fab;
            },
            set() {}
          };
          var getsetfab = {
            get() {
              return fab;
            },
            set() {}
          };
          if (Object.prototype.hasOwnProperty.call(window, 'FuckAdBlock')) {
            window.FuckAdBlock = Fab;
          } else {
            Object.defineProperty(window, 'FuckAdBlock', getSetFab);
          }
          if (Object.prototype.hasOwnProperty.call(window, 'BlockAdBlock')) {
            window.BlockAdBlock = Fab;
          } else {
            Object.defineProperty(window, 'BlockAdBlock', getSetFab);
          }
          if (Object.prototype.hasOwnProperty.call(window, 'SniffAdBlock')) {
            window.SniffAdBlock = Fab;
          } else {
            Object.defineProperty(window, 'SniffAdBlock', getSetFab);
          }
          if (Object.prototype.hasOwnProperty.call(window, 'fuckAdBlock')) {
            window.fuckAdBlock = fab;
          } else {
            Object.defineProperty(window, 'fuckAdBlock', getsetfab);
          }
          if (Object.prototype.hasOwnProperty.call(window, 'blockAdBlock')) {
            window.blockAdBlock = fab;
          } else {
            Object.defineProperty(window, 'blockAdBlock', getsetfab);
          }
          if (Object.prototype.hasOwnProperty.call(window, 'sniffAdBlock')) {
            window.sniffAdBlock = fab;
          } else {
            Object.defineProperty(window, 'sniffAdBlock', getsetfab);
          }
        }
        preventFab$1.names = ['prevent-fab-3.2.0',
        'nofab.js', 'ubo-nofab.js', 'fuckadblock.js-3.2.0', 'ubo-fuckadblock.js-3.2.0', 'ubo-nofab'];
        preventFab$1.injections = [hit, noopFunc, noopThis];
        function setPopadsDummy$1(source) {
          delete window.PopAds;
          delete window.popns;
          Object.defineProperties(window, {
            PopAds: {
              get: function get() {
                hit(source);
                return {};
              }
            },
            popns: {
              get: function get() {
                hit(source);
                return {};
              }
            }
          });
        }
        setPopadsDummy$1.names = ['set-popads-dummy',
        'popads-dummy.js', 'ubo-popads-dummy.js', 'ubo-popads-dummy'];
        setPopadsDummy$1.injections = [hit];
        function preventPopadsNet$1(source) {
          var rid = randomId();
          var throwError = function throwError() {
            throw new ReferenceError(rid);
          };
          delete window.PopAds;
          delete window.popns;
          Object.defineProperties(window, {
            PopAds: {
              set: throwError
            },
            popns: {
              set: throwError
            }
          });
          window.onerror = createOnErrorHandler(rid).bind();
          hit(source);
        }
        preventPopadsNet$1.names = ['prevent-popads-net',
        'popads.net.js', 'ubo-popads.net.js', 'ubo-popads.net'];
        preventPopadsNet$1.injections = [createOnErrorHandler, randomId, hit];
        function preventAdfly$1(source) {
          var isDigit = function isDigit(data) {
            return /^\d$/.test(data);
          };
          var handler = function handler(encodedURL) {
            var evenChars = '';
            var oddChars = '';
            for (var i = 0; i < encodedURL.length; i += 1) {
              if (i % 2 === 0) {
                evenChars += encodedURL.charAt(i);
              } else {
                oddChars = encodedURL.charAt(i) + oddChars;
              }
            }
            var data = (evenChars + oddChars).split('');
            for (var _i = 0; _i < data.length; _i += 1) {
              if (isDigit(data[_i])) {
                for (var ii = _i + 1; ii < data.length; ii += 1) {
                  if (isDigit(data[ii])) {
                    var temp = parseInt(data[_i], 10) ^ parseInt(data[ii], 10);
                    if (temp < 10) {
                      data[_i] = temp.toString();
                    }
                    _i = ii;
                    break;
                  }
                }
              }
            }
            data = data.join('');
            var decodedURL = window.atob(data).slice(16, -16);
            if (window.stop) {
              window.stop();
            }
            window.onbeforeunload = null;
            window.location.href = decodedURL;
          };
          var val;
          var applyHandler = true;
          var result = setPropertyAccess(window, 'ysmm', {
            configurable: false,
            set: function set(value) {
              if (applyHandler) {
                applyHandler = false;
                try {
                  if (typeof value === 'string') {
                    handler(value);
                  }
                } catch (err) {}
              }
              val = value;
            },
            get: function get() {
              return val;
            }
          });
          if (result) {
            hit(source);
          } else {
            logMessage(source, 'Failed to set up prevent-adfly scriptlet');
          }
        }
        preventAdfly$1.names = ['prevent-adfly',
        'adfly-defuser.js', 'ubo-adfly-defuser.js', 'ubo-adfly-defuser'];
        preventAdfly$1.injections = [setPropertyAccess, hit, logMessage];
        function debugOnPropertyRead$1(source, property) {
          if (!property) {
            return;
          }
          var rid = randomId();
          var abort = function abort() {
            hit(source);
            debugger;
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
              chain = chainInfo.chain;
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            setPropertyAccess(base, prop, {
              get: abort,
              set: noopFunc
            });
          };
          setChainPropAccess(window, property);
          window.onerror = createOnErrorHandler(rid).bind();
        }
        debugOnPropertyRead$1.names = ['debug-on-property-read'];
        debugOnPropertyRead$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, noopFunc, isEmptyObject];
        function debugOnPropertyWrite$1(source, property) {
          if (!property) {
            return;
          }
          var rid = randomId();
          var abort = function abort() {
            hit(source);
            debugger;
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
              chain = chainInfo.chain;
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            setPropertyAccess(base, prop, {
              set: abort
            });
          };
          setChainPropAccess(window, property);
          window.onerror = createOnErrorHandler(rid).bind();
        }
        debugOnPropertyWrite$1.names = ['debug-on-property-write'];
        debugOnPropertyWrite$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, isEmptyObject];
        function debugCurrentInlineScript$1(source, property, search) {
          var searchRegexp = toRegExp(search);
          var rid = randomId();
          var getCurrentScript = function getCurrentScript() {
            if ('currentScript' in document) {
              return document.currentScript;
            }
            var scripts = document.getElementsByTagName('script');
            return scripts[scripts.length - 1];
          };
          var ourScript = getCurrentScript();
          var abort = function abort() {
            var scriptEl = getCurrentScript();
            if (!scriptEl) {
              return;
            }
            var content = scriptEl.textContent;
            try {
              var textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
              content = textContentGetter.call(scriptEl);
            } catch (e) {}
            if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
              hit(source);
              debugger;
            }
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
              chain = chainInfo.chain;
            if (base instanceof Object === false && base === null) {
              var props = property.split('.');
              var propIndex = props.indexOf(prop);
              var baseName = props[propIndex - 1];
              var message = "The scriptlet had been executed before the ".concat(baseName, " was loaded.");
              logMessage(message, source.verbose);
              return;
            }
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            var currentValue = base[prop];
            setPropertyAccess(base, prop, {
              set: function set(value) {
                abort();
                currentValue = value;
              },
              get: function get() {
                abort();
                return currentValue;
              }
            });
          };
          setChainPropAccess(window, property);
          window.onerror = createOnErrorHandler(rid).bind();
        }
        debugCurrentInlineScript$1.names = ['debug-current-inline-script'];
        debugCurrentInlineScript$1.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, createOnErrorHandler, hit, logMessage, isEmptyObject];
        function removeAttr$1(source, attrs, selector) {
          var applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'asap stay';
          if (!attrs) {
            return;
          }
          attrs = attrs.split(/\s*\|\s*/);
          if (!selector) {
            selector = "[".concat(attrs.join('],['), "]");
          }
          var rmattr = function rmattr() {
            var nodes = [];
            try {
              nodes = [].slice.call(document.querySelectorAll(selector));
            } catch (e) {
              logMessage(source, "Invalid selector arg: '".concat(selector, "'"));
            }
            var removed = false;
            nodes.forEach(function (node) {
              attrs.forEach(function (attr) {
                node.removeAttribute(attr);
                removed = true;
              });
            });
            if (removed) {
              hit(source);
            }
          };
          var flags = parseFlags(applying);
          var run = function run() {
            rmattr();
            if (!flags.hasFlag(flags.STAY)) {
              return;
            }
            observeDOMChanges(rmattr, true);
          };
          if (flags.hasFlag(flags.ASAP)) {
            if (document.readyState === 'loading') {
              window.addEventListener('DOMContentLoaded', rmattr, {
                once: true
              });
            } else {
              rmattr();
            }
          }
          if (document.readyState !== 'complete' && flags.hasFlag(flags.COMPLETE)) {
            window.addEventListener('load', run, {
              once: true
            });
          } else if (flags.hasFlag(flags.STAY)) {
            if (!applying.includes(' ')) {
              rmattr();
            }
            observeDOMChanges(rmattr, true);
          }
        }
        removeAttr$1.names = ['remove-attr',
        'remove-attr.js', 'ubo-remove-attr.js', 'ra.js', 'ubo-ra.js', 'ubo-remove-attr', 'ubo-ra'];
        removeAttr$1.injections = [hit, observeDOMChanges, parseFlags, logMessage,
        throttle];
        function setAttr$1(source, selector, attr) {
          var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
          if (!selector || !attr) {
            return;
          }
          var allowedValues = ['true', 'false'];
          if (value.length !== 0 && (nativeIsNaN(parseInt(value, 10)) || parseInt(value, 10) < 0 || parseInt(value, 10) > 32767) && !allowedValues.includes(value.toLowerCase())) {
            return;
          }
          var setAttr = function setAttr() {
            var nodes = [].slice.call(document.querySelectorAll(selector));
            var set = false;
            nodes.forEach(function (node) {
              node.setAttribute(attr, value);
              set = true;
            });
            if (set) {
              hit(source);
            }
          };
          setAttr();
          observeDOMChanges(setAttr, true);
        }
        setAttr$1.names = ['set-attr',
        'set-attr.js', 'ubo-set-attr.js', 'ubo-set-attr'];
        setAttr$1.injections = [hit, observeDOMChanges, nativeIsNaN,
        throttle];
        function removeClass$1(source, classNames, selector) {
          var applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'asap stay';
          if (!classNames) {
            return;
          }
          classNames = classNames.split(/\s*\|\s*/);
          var selectors = [];
          if (!selector) {
            selectors = classNames.map(function (className) {
              return ".".concat(className);
            });
          }
          var removeClassHandler = function removeClassHandler() {
            var nodes = new Set();
            if (selector) {
              var foundNodes = [];
              try {
                foundNodes = [].slice.call(document.querySelectorAll(selector));
              } catch (e) {
                logMessage(source, "Invalid selector arg: '".concat(selector, "'"));
              }
              foundNodes.forEach(function (n) {
                return nodes.add(n);
              });
            } else if (selectors.length > 0) {
              selectors.forEach(function (s) {
                var elements = document.querySelectorAll(s);
                for (var i = 0; i < elements.length; i += 1) {
                  var element = elements[i];
                  nodes.add(element);
                }
              });
            }
            var removed = false;
            nodes.forEach(function (node) {
              classNames.forEach(function (className) {
                if (node.classList.contains(className)) {
                  node.classList.remove(className);
                  removed = true;
                }
              });
            });
            if (removed) {
              hit(source);
            }
          };
          var CLASS_ATTR_NAME = ['class'];
          var flags = parseFlags(applying);
          var run = function run() {
            removeClassHandler();
            if (!flags.hasFlag(flags.STAY)) {
              return;
            }
            observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
          };
          if (flags.hasFlag(flags.ASAP)) {
            if (document.readyState === 'loading') {
              window.addEventListener('DOMContentLoaded', removeClassHandler, {
                once: true
              });
            } else {
              removeClassHandler();
            }
          }
          if (document.readyState !== 'complete' && flags.hasFlag(flags.COMPLETE)) {
            window.addEventListener('load', run, {
              once: true
            });
          } else if (flags.hasFlag(flags.STAY)) {
            if (!applying.includes(' ')) {
              removeClassHandler();
            }
            observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
          }
        }
        removeClass$1.names = ['remove-class',
        'remove-class.js', 'ubo-remove-class.js', 'rc.js', 'ubo-rc.js', 'ubo-remove-class', 'ubo-rc'];
        removeClass$1.injections = [hit, logMessage, observeDOMChanges, parseFlags,
        throttle];
        function disableNewtabLinks$1(source) {
          document.addEventListener('click', function (ev) {
            var target = ev.target;
            while (target !== null) {
              if (target.localName === 'a' && target.hasAttribute('target')) {
                ev.stopPropagation();
                ev.preventDefault();
                hit(source);
                break;
              }
              target = target.parentNode;
            }
          });
        }
        disableNewtabLinks$1.names = ['disable-newtab-links',
        'disable-newtab-links.js', 'ubo-disable-newtab-links.js', 'ubo-disable-newtab-links'];
        disableNewtabLinks$1.injections = [hit];
        function adjustSetInterval$1(source, matchCallback, matchDelay, boost) {
          var nativeSetInterval = window.setInterval;
          var matchRegexp = toRegExp(matchCallback);
          var intervalWrapper = function intervalWrapper(callback, delay) {
            if (!isValidCallback(callback)) {
              var message = "Scriptlet can't be applied because of invalid callback: '".concat(String(callback), "'");
              logMessage(source, message);
            } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
              delay *= getBoostMultiplier(boost);
              hit(source);
            }
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            return nativeSetInterval.apply(window, [callback, delay, ...args]);
          };
          window.setInterval = intervalWrapper;
        }
        adjustSetInterval$1.names = ['adjust-setInterval',
        'nano-setInterval-booster.js', 'ubo-nano-setInterval-booster.js', 'nano-sib.js', 'ubo-nano-sib.js', 'adjust-setInterval.js', 'ubo-adjust-setInterval.js', 'ubo-nano-setInterval-booster', 'ubo-nano-sib', 'ubo-adjust-setInterval'];
        adjustSetInterval$1.injections = [hit, isValidCallback, toRegExp, getBoostMultiplier, isDelayMatched, logMessage,
        nativeIsNaN, nativeIsFinite, getMatchDelay, shouldMatchAnyDelay];
        function adjustSetTimeout$1(source, matchCallback, matchDelay, boost) {
          var nativeSetTimeout = window.setTimeout;
          var matchRegexp = toRegExp(matchCallback);
          var timeoutWrapper = function timeoutWrapper(callback, delay) {
            if (!isValidCallback(callback)) {
              var message = "Scriptlet can't be applied because of invalid callback: '".concat(String(callback), "'");
              logMessage(source, message);
            } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
              delay *= getBoostMultiplier(boost);
              hit(source);
            }
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            return nativeSetTimeout.apply(window, [callback, delay, ...args]);
          };
          window.setTimeout = timeoutWrapper;
        }
        adjustSetTimeout$1.names = ['adjust-setTimeout',
        'adjust-setTimeout.js', 'ubo-adjust-setTimeout.js', 'nano-setTimeout-booster.js', 'ubo-nano-setTimeout-booster.js', 'nano-stb.js', 'ubo-nano-stb.js', 'ubo-adjust-setTimeout', 'ubo-nano-setTimeout-booster', 'ubo-nano-stb'];
        adjustSetTimeout$1.injections = [hit, isValidCallback, toRegExp, getBoostMultiplier, isDelayMatched, logMessage,
        nativeIsNaN, nativeIsFinite, getMatchDelay, shouldMatchAnyDelay];
        function dirString$1(source, times) {
          var _console = console,
            dir = _console.dir;
          function dirWrapper(object) {
            if (typeof dir === 'function') {
              dir.call(this, object);
            }
            hit(source);
          }
          console.dir = dirWrapper;
        }
        dirString$1.names = ['dir-string'];
        dirString$1.injections = [hit];
        function jsonPrune$1(source, propsToRemove, requiredInitialProps) {
          var stack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
          var prunePaths = getPrunePath(propsToRemove);
          var requiredPaths = getPrunePath(requiredInitialProps);
          var nativeObjects = {
            nativeStringify: window.JSON.stringify
          };
          var nativeJSONParse = JSON.parse;
          var jsonParseWrapper = function jsonParseWrapper() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var root = nativeJSONParse.apply(JSON, args);
            return jsonPruner(source, root, prunePaths, requiredPaths, stack, nativeObjects);
          };
          jsonParseWrapper.toString = nativeJSONParse.toString.bind(nativeJSONParse);
          JSON.parse = jsonParseWrapper;
          var nativeResponseJson = Response.prototype.json;
          var responseJsonWrapper = function responseJsonWrapper() {
            var promise = nativeResponseJson.apply(this);
            return promise.then(function (obj) {
              return jsonPruner(source, obj, prunePaths, requiredPaths, stack, nativeObjects);
            });
          };
          if (typeof Response === 'undefined') {
            return;
          }
          Response.prototype.json = responseJsonWrapper;
        }
        jsonPrune$1.names = ['json-prune',
        'json-prune.js', 'ubo-json-prune.js', 'ubo-json-prune', 'abp-json-prune'];
        jsonPrune$1.injections = [hit, matchStackTrace, getWildcardPropertyInChain, logMessage, isPruningNeeded, jsonPruner, getPrunePath,
        toRegExp, getNativeRegexpTest, shouldAbortInlineOrInjectedScript];
        function preventRequestAnimationFrame$1(source, match) {
          var nativeRequestAnimationFrame = window.requestAnimationFrame;
          var shouldLog = typeof match === 'undefined';
          var _parseMatchArg = parseMatchArg(match),
            isInvertedMatch = _parseMatchArg.isInvertedMatch,
            matchRegexp = _parseMatchArg.matchRegexp;
          var rafWrapper = function rafWrapper(callback) {
            var shouldPrevent = false;
            if (shouldLog) {
              hit(source);
              logMessage(source, "requestAnimationFrame(".concat(String(callback), ")"), true);
            } else if (isValidCallback(callback) && isValidStrPattern(match)) {
              shouldPrevent = matchRegexp.test(callback.toString()) !== isInvertedMatch;
            }
            if (shouldPrevent) {
              hit(source);
              return nativeRequestAnimationFrame(noopFunc);
            }
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return nativeRequestAnimationFrame.apply(window, [callback, ...args]);
          };
          window.requestAnimationFrame = rafWrapper;
        }
        preventRequestAnimationFrame$1.names = ['prevent-requestAnimationFrame',
        'no-requestAnimationFrame-if.js', 'ubo-no-requestAnimationFrame-if.js', 'norafif.js', 'ubo-norafif.js', 'ubo-no-requestAnimationFrame-if', 'ubo-norafif'];
        preventRequestAnimationFrame$1.injections = [hit, noopFunc, parseMatchArg, isValidStrPattern, isValidCallback, logMessage,
        escapeRegExp, toRegExp];
        function setCookie$1(source, name, value) {
          var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';
          var validValue = getLimitedCookieValue(value);
          if (validValue === null) {
            logMessage(source, "Invalid cookie value: '".concat(validValue, "'"));
            return;
          }
          if (!isValidCookiePath(path)) {
            logMessage(source, "Invalid cookie path: '".concat(path, "'"));
            return;
          }
          var cookieToSet = concatCookieNameValuePath(name, validValue, path);
          if (!cookieToSet) {
            logMessage(source, 'Invalid cookie name or value');
            return;
          }
          hit(source);
          document.cookie = cookieToSet;
        }
        setCookie$1.names = ['set-cookie',
        'set-cookie.js', 'ubo-set-cookie.js', 'ubo-set-cookie'];
        setCookie$1.injections = [hit, logMessage, nativeIsNaN, isCookieSetWithValue, getLimitedCookieValue, concatCookieNameValuePath, isValidCookiePath, getCookiePath];
        function setCookieReload$1(source, name, value) {
          var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';
          if (isCookieSetWithValue(document.cookie, name, value)) {
            return;
          }
          var validValue = getLimitedCookieValue(value);
          if (validValue === null) {
            logMessage(source, "Invalid cookie value: '".concat(value, "'"));
            return;
          }
          if (!isValidCookiePath(path)) {
            logMessage(source, "Invalid cookie path: '".concat(path, "'"));
            return;
          }
          var cookieToSet = concatCookieNameValuePath(name, validValue, path);
          if (!cookieToSet) {
            logMessage(source, 'Invalid cookie name or value');
            return;
          }
          document.cookie = cookieToSet;
          hit(source);
          if (isCookieSetWithValue(document.cookie, name, value)) {
            window.location.reload();
          }
        }
        setCookieReload$1.names = ['set-cookie-reload'];
        setCookieReload$1.injections = [hit, logMessage, nativeIsNaN, isCookieSetWithValue, getLimitedCookieValue, concatCookieNameValuePath, isValidCookiePath, getCookiePath];
        function hideInShadowDom$1(source, selector, baseSelector) {
          if (!Element.prototype.attachShadow) {
            return;
          }
          var hideElement = function hideElement(targetElement) {
            var DISPLAY_NONE_CSS = 'display:none!important;';
            targetElement.style.cssText = DISPLAY_NONE_CSS;
          };
          var hideHandler = function hideHandler() {
            var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
            var _loop = function _loop() {
              var isHidden = false;
              var _pierceShadowDom = pierceShadowDom(selector, hostElements),
                targets = _pierceShadowDom.targets,
                innerHosts = _pierceShadowDom.innerHosts;
              targets.forEach(function (targetEl) {
                hideElement(targetEl);
                isHidden = true;
              });
              if (isHidden) {
                hit(source);
              }
              hostElements = innerHosts;
            };
            while (hostElements.length !== 0) {
              _loop();
            }
          };
          hideHandler();
          observeDOMChanges(hideHandler, true);
        }
        hideInShadowDom$1.names = ['hide-in-shadow-dom'];
        hideInShadowDom$1.injections = [hit, observeDOMChanges, findHostElements, pierceShadowDom,
        flatten, throttle];
        function removeInShadowDom$1(source, selector, baseSelector) {
          if (!Element.prototype.attachShadow) {
            return;
          }
          var removeElement = function removeElement(targetElement) {
            targetElement.remove();
          };
          var removeHandler = function removeHandler() {
            var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
            var _loop = function _loop() {
              var isRemoved = false;
              var _pierceShadowDom = pierceShadowDom(selector, hostElements),
                targets = _pierceShadowDom.targets,
                innerHosts = _pierceShadowDom.innerHosts;
              targets.forEach(function (targetEl) {
                removeElement(targetEl);
                isRemoved = true;
              });
              if (isRemoved) {
                hit(source);
              }
              hostElements = innerHosts;
            };
            while (hostElements.length !== 0) {
              _loop();
            }
          };
          removeHandler();
          observeDOMChanges(removeHandler, true);
        }
        removeInShadowDom$1.names = ['remove-in-shadow-dom'];
        removeInShadowDom$1.injections = [hit, observeDOMChanges, findHostElements, pierceShadowDom,
        flatten, throttle];
        function preventFetch$1(source, propsToMatch) {
          var responseBody = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'emptyObj';
          var responseType = arguments.length > 3 ? arguments[3] : undefined;
          if (typeof fetch === 'undefined' || typeof Proxy === 'undefined' || typeof Response === 'undefined') {
            return;
          }
          var nativeRequestClone = Request.prototype.clone;
          var strResponseBody;
          if (responseBody === '' || responseBody === 'emptyObj') {
            strResponseBody = '{}';
          } else if (responseBody === 'emptyArr') {
            strResponseBody = '[]';
          } else if (responseBody === 'emptyStr') {
            strResponseBody = '';
          } else {
            logMessage(source, "Invalid responseBody parameter: '".concat(responseBody, "'"));
            return;
          }
          var isResponseTypeSpecified = typeof responseType !== 'undefined';
          var isResponseTypeSupported = function isResponseTypeSupported(responseType) {
            var SUPPORTED_TYPES = ['default', 'opaque'];
            return SUPPORTED_TYPES.includes(responseType);
          };
          if (isResponseTypeSpecified && !isResponseTypeSupported(responseType)) {
            logMessage(source, "Invalid responseType parameter: '".concat(responseType, "'"));
            return;
          }
          var handlerWrapper = async function handlerWrapper(target, thisArg, args) {
            var shouldPrevent = false;
            var fetchData = getFetchData(args, nativeRequestClone);
            if (typeof propsToMatch === 'undefined') {
              logMessage(source, "fetch( ".concat(objectToString(fetchData), " )"), true);
              hit(source);
              return Reflect.apply(target, thisArg, args);
            }
            shouldPrevent = matchRequestProps(source, propsToMatch, fetchData);
            if (shouldPrevent) {
              hit(source);
              try {
                var origResponse = await Reflect.apply(target, thisArg, args);
                if (!origResponse.ok) {
                  return noopPromiseResolve(strResponseBody, fetchData.url, responseType);
                }
                return modifyResponse(origResponse, {
                  body: strResponseBody,
                  type: responseType
                });
              } catch (ex) {
                return noopPromiseResolve(strResponseBody, fetchData.url, responseType);
              }
            }
            return Reflect.apply(target, thisArg, args);
          };
          var fetchHandler = {
            apply: handlerWrapper
          };
          fetch = new Proxy(fetch, fetchHandler);
        }
        preventFetch$1.names = ['prevent-fetch',
        'no-fetch-if.js', 'ubo-no-fetch-if.js', 'ubo-no-fetch-if'];
        preventFetch$1.injections = [hit, getFetchData, objectToString, matchRequestProps, logMessage, noopPromiseResolve, modifyResponse, toRegExp, isValidStrPattern, escapeRegExp, isEmptyObject, getRequestData, getRequestProps, parseMatchProps, isValidParsedData, getMatchPropsData];
        function setLocalStorageItem$1(source, key, value) {
          if (typeof key === 'undefined') {
            logMessage(source, 'Item key should be specified.');
            return;
          }
          var validValue;
          try {
            validValue = getLimitedStorageItemValue(value);
          } catch (_unused) {
            logMessage(source, "Invalid storage item value: '".concat(value, "'"));
            return;
          }
          var _window = window,
            localStorage = _window.localStorage;
          if (validValue === '$remove$') {
            removeStorageItem(source, localStorage, key);
          } else {
            setStorageItem(source, localStorage, key, validValue);
          }
          hit(source);
        }
        setLocalStorageItem$1.names = ['set-local-storage-item',
        'set-local-storage-item.js', 'ubo-set-local-storage-item.js', 'ubo-set-local-storage-item'];
        setLocalStorageItem$1.injections = [hit, logMessage, nativeIsNaN, setStorageItem, removeStorageItem, getLimitedStorageItemValue,
        isValidStrPattern, toRegExp, escapeRegExp];
        function setSessionStorageItem$1(source, key, value) {
          if (typeof key === 'undefined') {
            logMessage(source, 'Item key should be specified.');
            return;
          }
          var validValue;
          try {
            validValue = getLimitedStorageItemValue(value);
          } catch (_unused) {
            logMessage(source, "Invalid storage item value: '".concat(value, "'"));
            return;
          }
          var _window = window,
            sessionStorage = _window.sessionStorage;
          if (validValue === '$remove$') {
            removeStorageItem(source, sessionStorage, key);
          } else {
            setStorageItem(source, sessionStorage, key, validValue);
          }
          hit(source);
        }
        setSessionStorageItem$1.names = ['set-session-storage-item',
        'set-session-storage-item.js', 'ubo-set-session-storage-item.js', 'ubo-set-session-storage-item'];
        setSessionStorageItem$1.injections = [hit, logMessage, nativeIsNaN, setStorageItem, removeStorageItem, getLimitedStorageItemValue,
        isValidStrPattern, toRegExp, escapeRegExp];
        function abortOnStackTrace$1(source, property, stack) {
          if (!property || !stack) {
            return;
          }
          var rid = randomId();
          var abort = function abort() {
            hit(source);
            throw new ReferenceError(rid);
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
              chain = chainInfo.chain;
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            if (!stack.match(/^(inlineScript|injectedScript)$/) && !isValidStrPattern(stack)) {
              logMessage(source, "Invalid parameter: ".concat(stack));
              return;
            }
            var descriptorWrapper = Object.assign(getDescriptorAddon(), {
              value: base[prop],
              get() {
                if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
                  abort();
                }
                return this.value;
              },
              set(newValue) {
                if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
                  abort();
                }
                this.value = newValue;
              }
            });
            setPropertyAccess(base, prop, {
              get() {
                return descriptorWrapper.get.call(descriptorWrapper);
              },
              set(newValue) {
                descriptorWrapper.set.call(descriptorWrapper, newValue);
              }
            });
          };
          setChainPropAccess(window, property);
          window.onerror = createOnErrorHandler(rid).bind();
        }
        abortOnStackTrace$1.names = ['abort-on-stack-trace',
        'abort-on-stack-trace.js', 'ubo-abort-on-stack-trace.js', 'aost.js', 'ubo-aost.js', 'ubo-abort-on-stack-trace', 'ubo-aost', 'abp-abort-on-stack-trace'];
        abortOnStackTrace$1.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, isValidStrPattern, escapeRegExp, matchStackTrace, getDescriptorAddon, logMessage, toRegExp, isEmptyObject, getNativeRegexpTest, shouldAbortInlineOrInjectedScript];
        function logOnStacktrace$1(source, property) {
          if (!property) {
            return;
          }
          var refineStackTrace = function refineStackTrace(stackString) {
            var stackSteps = stackString.split('\n').slice(2).map(function (line) {
              return line.replace(/ {4}at /, '');
            });
            var logInfoArray = stackSteps.map(function (line) {
              var funcName;
              var funcFullPath;
              var reg = /\(([^\)]+)\)/;
              var regFirefox = /(.*?@)(\S+)(:\d+):\d+\)?$/;
              if (line.match(reg)) {
                funcName = line.split(' ').slice(0, -1).join(' ');
                funcFullPath = line.match(reg)[1];
              } else if (line.match(regFirefox)) {
                funcName = line.split('@').slice(0, -1).join(' ');
                funcFullPath = line.match(regFirefox)[2];
              } else {
                funcName = 'function name is not available';
                funcFullPath = line;
              }
              return [funcName, funcFullPath];
            });
            var logInfoObject = {};
            logInfoArray.forEach(function (pair) {
              logInfoObject[pair[0]] = pair[1];
            });
            return logInfoObject;
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
              chain = chainInfo.chain;
            if (chain) {
              var setter = function setter(a) {
                base = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              };
              Object.defineProperty(owner, prop, {
                get: function get() {
                  return base;
                },
                set: setter
              });
              return;
            }
            var value = base[prop];
            setPropertyAccess(base, prop, {
              get() {
                hit(source);
                logMessage(source, "Get ".concat(prop), true);
                console.table(refineStackTrace(new Error().stack));
                return value;
              },
              set(newValue) {
                hit(source);
                logMessage(source, "Set ".concat(prop), true);
                console.table(refineStackTrace(new Error().stack));
                value = newValue;
              }
            });
          };
          setChainPropAccess(window, property);
        }
        logOnStacktrace$1.names = ['log-on-stack-trace'];
        logOnStacktrace$1.injections = [getPropertyInChain, setPropertyAccess, hit, logMessage, isEmptyObject];
        function preventXHR$1(source, propsToMatch, customResponseText) {
          if (typeof Proxy === 'undefined') {
            return;
          }
          var nativeOpen = window.XMLHttpRequest.prototype.open;
          var nativeSend = window.XMLHttpRequest.prototype.send;
          var nativeGetResponseHeader = window.XMLHttpRequest.prototype.getResponseHeader;
          var nativeGetAllResponseHeaders = window.XMLHttpRequest.prototype.getAllResponseHeaders;
          var xhrData;
          var modifiedResponse = '';
          var modifiedResponseText = '';
          var openWrapper = function openWrapper(target, thisArg, args) {
            xhrData = getXhrData.apply(null, args);
            if (typeof propsToMatch === 'undefined') {
              logMessage(source, "xhr( ".concat(objectToString(xhrData), " )"), true);
              hit(source);
            } else if (matchRequestProps(source, propsToMatch, xhrData)) {
              thisArg.shouldBePrevented = true;
              thisArg.xhrData = xhrData;
            }
            if (thisArg.shouldBePrevented) {
              thisArg.collectedHeaders = [];
              var setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
                thisArg.collectedHeaders.push(args);
                return Reflect.apply(target, thisArg, args);
              };
              var setRequestHeaderHandler = {
                apply: setRequestHeaderWrapper
              };
              thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
            }
            return Reflect.apply(target, thisArg, args);
          };
          var sendWrapper = function sendWrapper(target, thisArg, args) {
            if (!thisArg.shouldBePrevented) {
              return Reflect.apply(target, thisArg, args);
            }
            if (thisArg.responseType === 'blob') {
              modifiedResponse = new Blob();
            }
            if (thisArg.responseType === 'arraybuffer') {
              modifiedResponse = new ArrayBuffer();
            }
            if (customResponseText) {
              var randomText = generateRandomResponse(customResponseText);
              if (randomText) {
                modifiedResponseText = randomText;
              } else {
                logMessage(source, "Invalid randomize parameter: '".concat(customResponseText, "'"));
              }
            }
            var forgedRequest = new XMLHttpRequest();
            forgedRequest.addEventListener('readystatechange', function () {
              if (forgedRequest.readyState !== 4) {
                return;
              }
              var readyState = forgedRequest.readyState,
                responseURL = forgedRequest.responseURL,
                responseXML = forgedRequest.responseXML,
                statusText = forgedRequest.statusText;
              Object.defineProperties(thisArg, {
                readyState: {
                  value: readyState,
                  writable: false
                },
                statusText: {
                  value: statusText,
                  writable: false
                },
                responseURL: {
                  value: responseURL || thisArg.xhrData.url,
                  writable: false
                },
                responseXML: {
                  value: responseXML,
                  writable: false
                },
                status: {
                  value: 200,
                  writable: false
                },
                response: {
                  value: modifiedResponse,
                  writable: false
                },
                responseText: {
                  value: modifiedResponseText,
                  writable: false
                }
              });
              setTimeout(function () {
                var stateEvent = new Event('readystatechange');
                thisArg.dispatchEvent(stateEvent);
                var loadEvent = new Event('load');
                thisArg.dispatchEvent(loadEvent);
                var loadEndEvent = new Event('loadend');
                thisArg.dispatchEvent(loadEndEvent);
              }, 1);
              hit(source);
            });
            nativeOpen.apply(forgedRequest, [thisArg.xhrData.method, thisArg.xhrData.url]);
            thisArg.collectedHeaders.forEach(function (header) {
              var name = header[0];
              var value = header[1];
              forgedRequest.setRequestHeader(name, value);
            });
            try {
              nativeSend.call(forgedRequest, args);
            } catch (_unused) {
              return Reflect.apply(target, thisArg, args);
            }
            return undefined;
          };
          var getHeaderWrapper = function getHeaderWrapper(target, thisArg, args) {
            if (!thisArg.shouldBePrevented) {
              return nativeGetResponseHeader.apply(thisArg, args);
            }
            if (!thisArg.collectedHeaders.length) {
              return null;
            }
            var searchHeaderName = args[0].toLowerCase();
            var matchedHeader = thisArg.collectedHeaders.find(function (header) {
              var headerName = header[0].toLowerCase();
              return headerName === searchHeaderName;
            });
            return matchedHeader ? matchedHeader[1] : null;
          };
          var getAllHeadersWrapper = function getAllHeadersWrapper(target, thisArg) {
            if (!thisArg.shouldBePrevented) {
              return nativeGetAllResponseHeaders.call(thisArg);
            }
            if (!thisArg.collectedHeaders.length) {
              return '';
            }
            var allHeadersStr = thisArg.collectedHeaders.map(function (header) {
              var headerName = header[0];
              var headerValue = header[1];
              return "".concat(headerName.toLowerCase(), ": ").concat(headerValue);
            }).join('\r\n');
            return allHeadersStr;
          };
          var openHandler = {
            apply: openWrapper
          };
          var sendHandler = {
            apply: sendWrapper
          };
          var getHeaderHandler = {
            apply: getHeaderWrapper
          };
          var getAllHeadersHandler = {
            apply: getAllHeadersWrapper
          };
          XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
          XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
          XMLHttpRequest.prototype.getResponseHeader = new Proxy(XMLHttpRequest.prototype.getResponseHeader, getHeaderHandler);
          XMLHttpRequest.prototype.getAllResponseHeaders = new Proxy(XMLHttpRequest.prototype.getAllResponseHeaders, getAllHeadersHandler);
        }
        preventXHR$1.names = ['prevent-xhr',
        'no-xhr-if.js', 'ubo-no-xhr-if.js', 'ubo-no-xhr-if'];
        preventXHR$1.injections = [hit, objectToString, generateRandomResponse, matchRequestProps, getXhrData, logMessage, toRegExp, isValidStrPattern, escapeRegExp, isEmptyObject, getNumberFromString, nativeIsFinite, nativeIsNaN, parseMatchProps, isValidParsedData, getMatchPropsData, getRequestProps, getRandomIntInclusive, getRandomStrByLength];
        function forceWindowClose$1(source) {
          var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          if (typeof window.close !== 'function') {
            var message = 'window.close() is not a function so \'close-window\' scriptlet is unavailable';
            logMessage(source, message);
            return;
          }
          var closeImmediately = function closeImmediately() {
            try {
              hit(source);
              window.close();
            } catch (e) {
              logMessage(source, e);
            }
          };
          var closeByExtension = function closeByExtension() {
            var extCall = function extCall() {
              dispatchEvent(new Event('adguard:scriptlet-close-window'));
            };
            window.addEventListener('adguard:subscribed-to-close-window', extCall, {
              once: true
            });
            setTimeout(function () {
              window.removeEventListener('adguard:subscribed-to-close-window', extCall, {
                once: true
              });
            }, 5000);
          };
          var shouldClose = function shouldClose() {
            if (path === '') {
              return true;
            }
            var pathRegexp = toRegExp(path);
            var currentPath = "".concat(window.location.pathname).concat(window.location.search);
            return pathRegexp.test(currentPath);
          };
          if (shouldClose()) {
            closeImmediately();
            if (navigator.userAgent.includes('Chrome')) {
              closeByExtension();
            }
          }
        }
        forceWindowClose$1.names = ['close-window',
        'window-close-if.js', 'ubo-window-close-if.js', 'ubo-window-close-if', 'close-window.js', 'ubo-close-window.js', 'ubo-close-window'];
        forceWindowClose$1.injections = [hit, toRegExp, logMessage];
        function preventRefresh$1(source, delaySec) {
          var getMetaElements = function getMetaElements() {
            var metaNodes = [];
            try {
              metaNodes = document.querySelectorAll('meta[http-equiv="refresh" i][content]');
            } catch (e) {
              try {
                metaNodes = document.querySelectorAll('meta[http-equiv="refresh"][content]');
              } catch (e) {
                logMessage(source, e);
              }
            }
            return Array.from(metaNodes);
          };
          var getMetaContentDelay = function getMetaContentDelay(metaElements) {
            var delays = metaElements.map(function (meta) {
              var contentString = meta.getAttribute('content');
              if (contentString.length === 0) {
                return null;
              }
              var contentDelay;
              var limiterIndex = contentString.indexOf(';');
              if (limiterIndex !== -1) {
                var delaySubstring = contentString.substring(0, limiterIndex);
                contentDelay = getNumberFromString(delaySubstring);
              } else {
                contentDelay = getNumberFromString(contentString);
              }
              return contentDelay;
            }).filter(function (delay) {
              return delay !== null;
            });
            if (!delays.length) {
              return null;
            }
            var minDelay = delays.reduce(function (a, b) {
              return Math.min(a, b);
            });
            return minDelay;
          };
          var stop = function stop() {
            var metaElements = getMetaElements();
            if (metaElements.length === 0) {
              return;
            }
            var secondsToRun = getNumberFromString(delaySec);
            if (secondsToRun === null) {
              secondsToRun = getMetaContentDelay(metaElements);
            }
            if (secondsToRun === null) {
              return;
            }
            var delayMs = secondsToRun * 1000;
            setTimeout(function () {
              window.stop();
              hit(source);
            }, delayMs);
          };
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', stop, {
              once: true
            });
          } else {
            stop();
          }
        }
        preventRefresh$1.names = ['prevent-refresh',
        'prevent-refresh.js', 'refresh-defuser.js', 'refresh-defuser',
        'ubo-prevent-refresh.js', 'ubo-prevent-refresh', 'ubo-refresh-defuser.js', 'ubo-refresh-defuser'];
        preventRefresh$1.injections = [hit, getNumberFromString, logMessage, nativeIsNaN];
        function preventElementSrcLoading$1(source, tagName, match) {
          if (typeof Proxy === 'undefined' || typeof Reflect === 'undefined') {
            return;
          }
          var srcMockData = {
            script: 'data:text/javascript;base64,KCk9Pnt9',
            img: 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',
            iframe: 'data:text/html;base64, PGRpdj48L2Rpdj4=',
            link: 'data:text/plain;base64,'
          };
          var instance;
          if (tagName === 'script') {
            instance = HTMLScriptElement;
          } else if (tagName === 'img') {
            instance = HTMLImageElement;
          } else if (tagName === 'iframe') {
            instance = HTMLIFrameElement;
          } else if (tagName === 'link') {
            instance = HTMLLinkElement;
          } else {
            return;
          }
          var hasTrustedTypes = window.trustedTypes && typeof window.trustedTypes.createPolicy === 'function';
          var policy;
          if (hasTrustedTypes) {
            policy = window.trustedTypes.createPolicy('AGPolicy', {
              createScriptURL: function createScriptURL(arg) {
                return arg;
              }
            });
          }
          var SOURCE_PROPERTY_NAME = tagName === 'link' ? 'href' : 'src';
          var ONERROR_PROPERTY_NAME = 'onerror';
          var searchRegexp = toRegExp(match);
          var setMatchedAttribute = function setMatchedAttribute(elem) {
            return elem.setAttribute(source.name, 'matched');
          };
          var setAttributeWrapper = function setAttributeWrapper(target, thisArg, args) {
            if (!args[0] || !args[1]) {
              return Reflect.apply(target, thisArg, args);
            }
            var nodeName = thisArg.nodeName.toLowerCase();
            var attrName = args[0].toLowerCase();
            var attrValue = args[1];
            var isMatched = attrName === SOURCE_PROPERTY_NAME && tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(attrValue);
            if (!isMatched) {
              return Reflect.apply(target, thisArg, args);
            }
            hit(source);
            setMatchedAttribute(thisArg);
            return Reflect.apply(target, thisArg, [attrName, srcMockData[nodeName]]);
          };
          var setAttributeHandler = {
            apply: setAttributeWrapper
          };
          instance.prototype.setAttribute = new Proxy(Element.prototype.setAttribute, setAttributeHandler);
          var origSrcDescriptor = safeGetDescriptor(instance.prototype, SOURCE_PROPERTY_NAME);
          if (!origSrcDescriptor) {
            return;
          }
          Object.defineProperty(instance.prototype, SOURCE_PROPERTY_NAME, {
            enumerable: true,
            configurable: true,
            get() {
              return origSrcDescriptor.get.call(this);
            },
            set(urlValue) {
              var nodeName = this.nodeName.toLowerCase();
              var isMatched = tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(urlValue);
              if (!isMatched) {
                origSrcDescriptor.set.call(this, urlValue);
                return true;
              }
              if (policy && urlValue instanceof TrustedScriptURL) {
                var trustedSrc = policy.createScriptURL(urlValue);
                origSrcDescriptor.set.call(this, trustedSrc);
                hit(source);
                return;
              }
              setMatchedAttribute(this);
              origSrcDescriptor.set.call(this, srcMockData[nodeName]);
              hit(source);
            }
          });
          var origOnerrorDescriptor = safeGetDescriptor(HTMLElement.prototype, ONERROR_PROPERTY_NAME);
          if (!origOnerrorDescriptor) {
            return;
          }
          Object.defineProperty(HTMLElement.prototype, ONERROR_PROPERTY_NAME, {
            enumerable: true,
            configurable: true,
            get() {
              return origOnerrorDescriptor.get.call(this);
            },
            set(cb) {
              var isMatched = this.getAttribute(source.name) === 'matched';
              if (!isMatched) {
                origOnerrorDescriptor.set.call(this, cb);
                return true;
              }
              origOnerrorDescriptor.set.call(this, noopFunc);
              return true;
            }
          });
          var addEventListenerWrapper = function addEventListenerWrapper(target, thisArg, args) {
            if (!args[0] || !args[1] || !thisArg) {
              return Reflect.apply(target, thisArg, args);
            }
            var eventName = args[0];
            var isMatched = typeof thisArg.getAttribute === 'function' && thisArg.getAttribute(source.name) === 'matched' && eventName === 'error';
            if (isMatched) {
              return Reflect.apply(target, thisArg, [eventName, noopFunc]);
            }
            return Reflect.apply(target, thisArg, args);
          };
          var addEventListenerHandler = {
            apply: addEventListenerWrapper
          };
          EventTarget.prototype.addEventListener = new Proxy(EventTarget.prototype.addEventListener, addEventListenerHandler);
          var preventInlineOnerror = function preventInlineOnerror(tagName, src) {
            window.addEventListener('error', function (event) {
              if (!event.target || !event.target.nodeName || event.target.nodeName.toLowerCase() !== tagName || !event.target.src || !src.test(event.target.src)) {
                return;
              }
              hit(source);
              if (typeof event.target.onload === 'function') {
                event.target.onerror = event.target.onload;
                return;
              }
              event.target.onerror = noopFunc;
            }, true);
          };
          preventInlineOnerror(tagName, searchRegexp);
        }
        preventElementSrcLoading$1.names = ['prevent-element-src-loading'];
        preventElementSrcLoading$1.injections = [hit, toRegExp, safeGetDescriptor, noopFunc];
        function noTopics$1(source) {
          var TOPICS_PROPERTY_NAME = 'browsingTopics';
          if (Document instanceof Object === false) {
            return;
          }
          if (!Object.prototype.hasOwnProperty.call(Document.prototype, TOPICS_PROPERTY_NAME) || Document.prototype[TOPICS_PROPERTY_NAME] instanceof Function === false) {
            return;
          }
          Document.prototype[TOPICS_PROPERTY_NAME] = function () {
            return noopPromiseResolve('[]');
          };
          hit(source);
        }
        noTopics$1.names = ['no-topics'];
        noTopics$1.injections = [hit, noopPromiseResolve];
        function trustedReplaceXhrResponse$1(source) {
          var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
          var propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
          if (typeof Proxy === 'undefined') {
            return;
          }
          if (pattern === '' && replacement !== '') {
            var message = 'Pattern argument should not be empty string.';
            logMessage(source, message);
            return;
          }
          var shouldLog = pattern === '' && replacement === '';
          var nativeOpen = window.XMLHttpRequest.prototype.open;
          var nativeSend = window.XMLHttpRequest.prototype.send;
          var xhrData;
          var openWrapper = function openWrapper(target, thisArg, args) {
            xhrData = getXhrData.apply(null, args);
            if (shouldLog) {
              var _message = "xhr( ".concat(objectToString(xhrData), " )");
              logMessage(source, _message, true);
              hit(source);
              return Reflect.apply(target, thisArg, args);
            }
            if (matchRequestProps(source, propsToMatch, xhrData)) {
              thisArg.shouldBePrevented = true;
              thisArg.headersReceived = !!thisArg.headersReceived;
            }
            if (thisArg.shouldBePrevented && !thisArg.headersReceived) {
              thisArg.headersReceived = true;
              thisArg.collectedHeaders = [];
              var setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
                thisArg.collectedHeaders.push(args);
                return Reflect.apply(target, thisArg, args);
              };
              var setRequestHeaderHandler = {
                apply: setRequestHeaderWrapper
              };
              thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
            }
            return Reflect.apply(target, thisArg, args);
          };
          var sendWrapper = function sendWrapper(target, thisArg, args) {
            if (!thisArg.shouldBePrevented) {
              return Reflect.apply(target, thisArg, args);
            }
            var forgedRequest = new XMLHttpRequest();
            forgedRequest.addEventListener('readystatechange', function () {
              if (forgedRequest.readyState !== 4) {
                return;
              }
              var readyState = forgedRequest.readyState,
                response = forgedRequest.response,
                responseText = forgedRequest.responseText,
                responseURL = forgedRequest.responseURL,
                responseXML = forgedRequest.responseXML,
                status = forgedRequest.status,
                statusText = forgedRequest.statusText;
              var content = responseText || response;
              if (typeof content !== 'string') {
                return;
              }
              var patternRegexp = pattern === '*' ? /(\n|.)*/ : toRegExp(pattern);
              var modifiedContent = content.replace(patternRegexp, replacement);
              Object.defineProperties(thisArg, {
                readyState: {
                  value: readyState,
                  writable: false
                },
                responseURL: {
                  value: responseURL,
                  writable: false
                },
                responseXML: {
                  value: responseXML,
                  writable: false
                },
                status: {
                  value: status,
                  writable: false
                },
                statusText: {
                  value: statusText,
                  writable: false
                },
                response: {
                  value: modifiedContent,
                  writable: false
                },
                responseText: {
                  value: modifiedContent,
                  writable: false
                }
              });
              setTimeout(function () {
                var stateEvent = new Event('readystatechange');
                thisArg.dispatchEvent(stateEvent);
                var loadEvent = new Event('load');
                thisArg.dispatchEvent(loadEvent);
                var loadEndEvent = new Event('loadend');
                thisArg.dispatchEvent(loadEndEvent);
              }, 1);
              hit(source);
            });
            nativeOpen.apply(forgedRequest, [xhrData.method, xhrData.url]);
            thisArg.collectedHeaders.forEach(function (header) {
              var name = header[0];
              var value = header[1];
              forgedRequest.setRequestHeader(name, value);
            });
            thisArg.collectedHeaders = [];
            try {
              nativeSend.call(forgedRequest, args);
            } catch (_unused) {
              return Reflect.apply(target, thisArg, args);
            }
            return undefined;
          };
          var openHandler = {
            apply: openWrapper
          };
          var sendHandler = {
            apply: sendWrapper
          };
          XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
          XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
        }
        trustedReplaceXhrResponse$1.names = ['trusted-replace-xhr-response'
        ];
        trustedReplaceXhrResponse$1.injections = [hit, logMessage, toRegExp, objectToString, matchRequestProps, getXhrData, getMatchPropsData, getRequestProps, isValidParsedData, parseMatchProps, isValidStrPattern, escapeRegExp, isEmptyObject];
        function xmlPrune$1(source, propsToRemove) {
          var optionalProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
          var urlToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
          if (typeof Reflect === 'undefined' || typeof fetch === 'undefined' || typeof Proxy === 'undefined' || typeof Response === 'undefined') {
            return;
          }
          var shouldPruneResponse = false;
          var urlMatchRegexp = toRegExp(urlToMatch);
          var XPATH_MARKER = 'xpath(';
          var isXpath = propsToRemove && propsToRemove.startsWith(XPATH_MARKER);
          var getXPathElements = function getXPathElements(contextNode) {
            var matchedElements = [];
            try {
              var elementsToRemove = propsToRemove.slice(XPATH_MARKER.length, -1);
              var xpathResult = contextNode.evaluate(elementsToRemove, contextNode, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
              for (var i = 0; i < xpathResult.snapshotLength; i += 1) {
                matchedElements.push(xpathResult.snapshotItem(i));
              }
            } catch (ex) {
              var message = "Invalid XPath parameter: ".concat(propsToRemove, "\n").concat(ex);
              logMessage(source, message);
            }
            return matchedElements;
          };
          var xPathPruning = function xPathPruning(xPathElements) {
            xPathElements.forEach(function (element) {
              if (element.nodeType === 1) {
                element.remove();
              } else if (element.nodeType === 2) {
                element.ownerElement.removeAttribute(element.nodeName);
              }
            });
          };
          var isXML = function isXML(text) {
            if (typeof text === 'string') {
              var trimmedText = text.trim();
              if (trimmedText.startsWith('<') && trimmedText.endsWith('>')) {
                return true;
              }
            }
            return false;
          };
          var createXMLDocument = function createXMLDocument(text) {
            var xmlParser = new DOMParser();
            var xmlDocument = xmlParser.parseFromString(text, 'text/xml');
            return xmlDocument;
          };
          var isPruningNeeded = function isPruningNeeded(response, propsToRemove) {
            if (!isXML(response)) {
              return false;
            }
            var docXML = createXMLDocument(response);
            return isXpath ? getXPathElements(docXML) : !!docXML.querySelector(propsToRemove);
          };
          var pruneXML = function pruneXML(text) {
            if (!isXML(text)) {
              shouldPruneResponse = false;
              return text;
            }
            var xmlDoc = createXMLDocument(text);
            var errorNode = xmlDoc.querySelector('parsererror');
            if (errorNode) {
              return text;
            }
            if (optionalProp !== '' && xmlDoc.querySelector(optionalProp) === null) {
              shouldPruneResponse = false;
              return text;
            }
            var elements = isXpath ? getXPathElements(xmlDoc) : xmlDoc.querySelectorAll(propsToRemove);
            if (!elements.length) {
              shouldPruneResponse = false;
              return text;
            }
            if (isXpath) {
              xPathPruning(elements);
            } else {
              elements.forEach(function (elem) {
                elem.remove();
              });
            }
            var serializer = new XMLSerializer();
            text = serializer.serializeToString(xmlDoc);
            return text;
          };
          var nativeOpen = window.XMLHttpRequest.prototype.open;
          var nativeSend = window.XMLHttpRequest.prototype.send;
          var xhrData;
          var openWrapper = function openWrapper(target, thisArg, args) {
            xhrData = getXhrData.apply(null, args);
            if (matchRequestProps(source, urlToMatch, xhrData)) {
              thisArg.shouldBePruned = true;
            }
            if (thisArg.shouldBePruned) {
              thisArg.collectedHeaders = [];
              var setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
                thisArg.collectedHeaders.push(args);
                return Reflect.apply(target, thisArg, args);
              };
              var setRequestHeaderHandler = {
                apply: setRequestHeaderWrapper
              };
              thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
            }
            return Reflect.apply(target, thisArg, args);
          };
          var sendWrapper = function sendWrapper(target, thisArg, args) {
            var allowedResponseTypeValues = ['', 'text'];
            if (!thisArg.shouldBePruned || !allowedResponseTypeValues.includes(thisArg.responseType)) {
              return Reflect.apply(target, thisArg, args);
            }
            var forgedRequest = new XMLHttpRequest();
            forgedRequest.addEventListener('readystatechange', function () {
              if (forgedRequest.readyState !== 4) {
                return;
              }
              var readyState = forgedRequest.readyState,
                response = forgedRequest.response,
                responseText = forgedRequest.responseText,
                responseURL = forgedRequest.responseURL,
                responseXML = forgedRequest.responseXML,
                status = forgedRequest.status,
                statusText = forgedRequest.statusText;
              var content = responseText || response;
              if (typeof content !== 'string') {
                return;
              }
              if (!propsToRemove) {
                if (isXML(response)) {
                  var message = "XMLHttpRequest.open() URL: ".concat(responseURL, "\nresponse: ").concat(response);
                  logMessage(source, message);
                  logMessage(source, createXMLDocument(response), true, false);
                }
              } else {
                shouldPruneResponse = isPruningNeeded(response, propsToRemove);
              }
              var responseContent = shouldPruneResponse ? pruneXML(response) : response;
              Object.defineProperties(thisArg, {
                readyState: {
                  value: readyState,
                  writable: false
                },
                responseURL: {
                  value: responseURL,
                  writable: false
                },
                responseXML: {
                  value: responseXML,
                  writable: false
                },
                status: {
                  value: status,
                  writable: false
                },
                statusText: {
                  value: statusText,
                  writable: false
                },
                response: {
                  value: responseContent,
                  writable: false
                },
                responseText: {
                  value: responseContent,
                  writable: false
                }
              });
              setTimeout(function () {
                var stateEvent = new Event('readystatechange');
                thisArg.dispatchEvent(stateEvent);
                var loadEvent = new Event('load');
                thisArg.dispatchEvent(loadEvent);
                var loadEndEvent = new Event('loadend');
                thisArg.dispatchEvent(loadEndEvent);
              }, 1);
              hit(source);
            });
            nativeOpen.apply(forgedRequest, [xhrData.method, xhrData.url]);
            thisArg.collectedHeaders.forEach(function (header) {
              var name = header[0];
              var value = header[1];
              forgedRequest.setRequestHeader(name, value);
            });
            thisArg.collectedHeaders = [];
            try {
              nativeSend.call(forgedRequest, args);
            } catch (_unused) {
              return Reflect.apply(target, thisArg, args);
            }
            return undefined;
          };
          var openHandler = {
            apply: openWrapper
          };
          var sendHandler = {
            apply: sendWrapper
          };
          XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
          XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
          var nativeFetch = window.fetch;
          var fetchWrapper = async function fetchWrapper(target, thisArg, args) {
            var fetchURL = args[0] instanceof Request ? args[0].url : args[0];
            if (typeof fetchURL !== 'string' || fetchURL.length === 0) {
              return Reflect.apply(target, thisArg, args);
            }
            if (urlMatchRegexp.test(fetchURL)) {
              var response = await nativeFetch(...args);
              var clonedResponse = response.clone();
              var responseText = await response.text();
              shouldPruneResponse = isPruningNeeded(responseText, propsToRemove);
              if (!shouldPruneResponse) {
                var message = "fetch URL: ".concat(fetchURL, "\nresponse text: ").concat(responseText);
                logMessage(source, message);
                logMessage(source, createXMLDocument(responseText), true, false);
                return clonedResponse;
              }
              var prunedText = pruneXML(responseText);
              if (shouldPruneResponse) {
                hit(source);
                return new Response(prunedText, {
                  status: response.status,
                  statusText: response.statusText,
                  headers: response.headers
                });
              }
              return clonedResponse;
            }
            return Reflect.apply(target, thisArg, args);
          };
          var fetchHandler = {
            apply: fetchWrapper
          };
          window.fetch = new Proxy(window.fetch, fetchHandler);
        }
        xmlPrune$1.names = ['xml-prune',
        'xml-prune.js', 'ubo-xml-prune.js', 'ubo-xml-prune'];
        xmlPrune$1.injections = [hit, logMessage, toRegExp, getXhrData, objectToString, matchRequestProps, getMatchPropsData, getRequestProps, isValidParsedData, parseMatchProps, isValidStrPattern, escapeRegExp, isEmptyObject];
        function m3uPrune$1(source, propsToRemove) {
          var urlToMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
          if (typeof Reflect === 'undefined' || typeof fetch === 'undefined' || typeof Proxy === 'undefined' || typeof Response === 'undefined') {
            return;
          }
          var shouldPruneResponse = false;
          var urlMatchRegexp = toRegExp(urlToMatch);
          var SEGMENT_MARKER = '#';
          var AD_MARKER = {
            ASSET: '#EXT-X-ASSET:',
            CUE: '#EXT-X-CUE:',
            CUE_IN: '#EXT-X-CUE-IN',
            DISCONTINUITY: '#EXT-X-DISCONTINUITY',
            EXTINF: '#EXTINF',
            EXTM3U: '#EXTM3U',
            SCTE35: '#EXT-X-SCTE35:'
          };
          var COMCAST_AD_MARKER = {
            AD: '-AD-',
            VAST: '-VAST-',
            VMAP_AD: '-VMAP-AD-',
            VMAP_AD_BREAK: '#EXT-X-VMAP-AD-BREAK:'
          };
          var TAGS_ALLOWLIST = ['#EXT-X-TARGETDURATION', '#EXT-X-MEDIA-SEQUENCE', '#EXT-X-DISCONTINUITY-SEQUENCE', '#EXT-X-ENDLIST', '#EXT-X-PLAYLIST-TYPE', '#EXT-X-I-FRAMES-ONLY', '#EXT-X-MEDIA', '#EXT-X-STREAM-INF', '#EXT-X-I-FRAME-STREAM-INF', '#EXT-X-SESSION-DATA', '#EXT-X-SESSION-KEY', '#EXT-X-INDEPENDENT-SEGMENTS', '#EXT-X-START'];
          var isAllowedTag = function isAllowedTag(str) {
            return TAGS_ALLOWLIST.some(function (el) {
              return str.startsWith(el);
            });
          };
          var pruneExtinfFromVmapBlock = function pruneExtinfFromVmapBlock(lines, i) {
            var array = lines.slice();
            var index = i;
            if (array[index].includes(AD_MARKER.EXTINF)) {
              array[index] = undefined;
              index += 1;
              if (array[index].includes(AD_MARKER.DISCONTINUITY)) {
                array[index] = undefined;
                index += 1;
                var prunedExtinf = pruneExtinfFromVmapBlock(array, index);
                array = prunedExtinf.array;
                index = prunedExtinf.index;
              }
            }
            return {
              array,
              index
            };
          };
          var pruneVmapBlock = function pruneVmapBlock(lines) {
            var array = lines.slice();
            for (var i = 0; i < array.length - 1; i += 1) {
              if (array[i].includes(COMCAST_AD_MARKER.VMAP_AD) || array[i].includes(COMCAST_AD_MARKER.VAST) || array[i].includes(COMCAST_AD_MARKER.AD)) {
                array[i] = undefined;
                if (array[i + 1].includes(AD_MARKER.EXTINF)) {
                  i += 1;
                  var prunedExtinf = pruneExtinfFromVmapBlock(array, i);
                  array = prunedExtinf.array;
                  i = prunedExtinf.index - 1;
                }
              }
            }
            return array;
          };
          var pruneSpliceoutBlock = function pruneSpliceoutBlock(line, index, array) {
            if (!line.startsWith(AD_MARKER.CUE)) {
              return line;
            }
            line = undefined;
            index += 1;
            if (array[index].startsWith(AD_MARKER.ASSET)) {
              array[index] = undefined;
              index += 1;
            }
            if (array[index].startsWith(AD_MARKER.SCTE35)) {
              array[index] = undefined;
              index += 1;
            }
            if (array[index].startsWith(AD_MARKER.CUE_IN)) {
              array[index] = undefined;
              index += 1;
            }
            if (array[index].startsWith(AD_MARKER.SCTE35)) {
              array[index] = undefined;
            }
            return line;
          };
          var removeM3ULineRegexp = toRegExp(propsToRemove);
          var pruneInfBlock = function pruneInfBlock(line, index, array) {
            if (!line.startsWith(AD_MARKER.EXTINF)) {
              return line;
            }
            if (!removeM3ULineRegexp.test(array[index + 1])) {
              return line;
            }
            if (!isAllowedTag(array[index])) {
              array[index] = undefined;
            }
            index += 1;
            if (!isAllowedTag(array[index])) {
              array[index] = undefined;
            }
            index += 1;
            if (array[index].startsWith(AD_MARKER.DISCONTINUITY)) {
              array[index] = undefined;
            }
            return line;
          };
          var pruneSegments = function pruneSegments(lines) {
            for (var i = 0; i < lines.length - 1; i += 1) {
              var _lines$i;
              if ((_lines$i = lines[i]) !== null && _lines$i !== void 0 && _lines$i.startsWith(SEGMENT_MARKER) && removeM3ULineRegexp.test(lines[i])) {
                var segmentName = lines[i].substring(0, lines[i].indexOf(':'));
                if (!segmentName) {
                  return lines;
                }
                lines[i] = undefined;
                i += 1;
                for (var j = i; j < lines.length; j += 1) {
                  if (!lines[j].includes(segmentName) && !isAllowedTag(lines[j])) {
                    lines[j] = undefined;
                  } else {
                    i = j - 1;
                    break;
                  }
                }
              }
            }
            return lines;
          };
          var isM3U = function isM3U(text) {
            if (typeof text === 'string') {
              var trimmedText = text.trim();
              return trimmedText.startsWith(AD_MARKER.EXTM3U) || trimmedText.startsWith(COMCAST_AD_MARKER.VMAP_AD_BREAK);
            }
            return false;
          };
          var isPruningNeeded = function isPruningNeeded(text, regexp) {
            return isM3U(text) && regexp.test(text);
          };
          var pruneM3U = function pruneM3U(text) {
            var lines = text.split(/\r?\n/);
            if (text.includes(COMCAST_AD_MARKER.VMAP_AD_BREAK)) {
              lines = pruneVmapBlock(lines);
              return lines.filter(function (l) {
                return !!l;
              }).join('\n');
            }
            lines = pruneSegments(lines);
            return lines.map(function (line, index, array) {
              if (typeof line === 'undefined') {
                return line;
              }
              line = pruneSpliceoutBlock(line, index, array);
              if (typeof line !== 'undefined') {
                line = pruneInfBlock(line, index, array);
              }
              return line;
            }).filter(function (l) {
              return !!l;
            }).join('\n');
          };
          var nativeOpen = window.XMLHttpRequest.prototype.open;
          var nativeSend = window.XMLHttpRequest.prototype.send;
          var xhrData;
          var openWrapper = function openWrapper(target, thisArg, args) {
            xhrData = getXhrData.apply(null, args);
            if (matchRequestProps(source, urlToMatch, xhrData)) {
              thisArg.shouldBePruned = true;
            }
            if (thisArg.shouldBePruned) {
              thisArg.collectedHeaders = [];
              var setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
                thisArg.collectedHeaders.push(args);
                return Reflect.apply(target, thisArg, args);
              };
              var setRequestHeaderHandler = {
                apply: setRequestHeaderWrapper
              };
              thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
            }
            return Reflect.apply(target, thisArg, args);
          };
          var sendWrapper = function sendWrapper(target, thisArg, args) {
            var allowedResponseTypeValues = ['', 'text'];
            if (!thisArg.shouldBePruned || !allowedResponseTypeValues.includes(thisArg.responseType)) {
              return Reflect.apply(target, thisArg, args);
            }
            var forgedRequest = new XMLHttpRequest();
            forgedRequest.addEventListener('readystatechange', function () {
              if (forgedRequest.readyState !== 4) {
                return;
              }
              var readyState = forgedRequest.readyState,
                response = forgedRequest.response,
                responseText = forgedRequest.responseText,
                responseURL = forgedRequest.responseURL,
                responseXML = forgedRequest.responseXML,
                status = forgedRequest.status,
                statusText = forgedRequest.statusText;
              var content = responseText || response;
              if (typeof content !== 'string') {
                return;
              }
              if (!propsToRemove) {
                if (isM3U(response)) {
                  var message = "XMLHttpRequest.open() URL: ".concat(responseURL, "\nresponse: ").concat(response);
                  logMessage(source, message);
                }
              } else {
                shouldPruneResponse = isPruningNeeded(response, removeM3ULineRegexp);
              }
              var responseContent = shouldPruneResponse ? pruneM3U(response) : response;
              Object.defineProperties(thisArg, {
                readyState: {
                  value: readyState,
                  writable: false
                },
                responseURL: {
                  value: responseURL,
                  writable: false
                },
                responseXML: {
                  value: responseXML,
                  writable: false
                },
                status: {
                  value: status,
                  writable: false
                },
                statusText: {
                  value: statusText,
                  writable: false
                },
                response: {
                  value: responseContent,
                  writable: false
                },
                responseText: {
                  value: responseContent,
                  writable: false
                }
              });
              setTimeout(function () {
                var stateEvent = new Event('readystatechange');
                thisArg.dispatchEvent(stateEvent);
                var loadEvent = new Event('load');
                thisArg.dispatchEvent(loadEvent);
                var loadEndEvent = new Event('loadend');
                thisArg.dispatchEvent(loadEndEvent);
              }, 1);
              hit(source);
            });
            nativeOpen.apply(forgedRequest, [xhrData.method, xhrData.url]);
            thisArg.collectedHeaders.forEach(function (header) {
              var name = header[0];
              var value = header[1];
              forgedRequest.setRequestHeader(name, value);
            });
            thisArg.collectedHeaders = [];
            try {
              nativeSend.call(forgedRequest, args);
            } catch (_unused) {
              return Reflect.apply(target, thisArg, args);
            }
            return undefined;
          };
          var openHandler = {
            apply: openWrapper
          };
          var sendHandler = {
            apply: sendWrapper
          };
          XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
          XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
          var nativeFetch = window.fetch;
          var fetchWrapper = async function fetchWrapper(target, thisArg, args) {
            var fetchURL = args[0] instanceof Request ? args[0].url : args[0];
            if (typeof fetchURL !== 'string' || fetchURL.length === 0) {
              return Reflect.apply(target, thisArg, args);
            }
            if (urlMatchRegexp.test(fetchURL)) {
              var response = await nativeFetch(...args);
              var clonedResponse = response.clone();
              var responseText = await response.text();
              if (!propsToRemove && isM3U(responseText)) {
                var message = "fetch URL: ".concat(fetchURL, "\nresponse text: ").concat(responseText);
                logMessage(source, message);
                return clonedResponse;
              }
              if (isPruningNeeded(responseText, removeM3ULineRegexp)) {
                var prunedText = pruneM3U(responseText);
                hit(source);
                return new Response(prunedText, {
                  status: response.status,
                  statusText: response.statusText,
                  headers: response.headers
                });
              }
              return clonedResponse;
            }
            return Reflect.apply(target, thisArg, args);
          };
          var fetchHandler = {
            apply: fetchWrapper
          };
          window.fetch = new Proxy(window.fetch, fetchHandler);
        }
        m3uPrune$1.names = ['m3u-prune',
        'm3u-prune.js', 'ubo-m3u-prune.js', 'ubo-m3u-prune'];
        m3uPrune$1.injections = [hit, toRegExp, logMessage, getXhrData, objectToString, matchRequestProps, getMatchPropsData, getRequestProps, isValidParsedData, parseMatchProps, isValidStrPattern, escapeRegExp, isEmptyObject];
        function trustedSetCookie$1(source, name, value) {
          var offsetExpiresSec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
          var path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '/';
          if (typeof name === 'undefined') {
            logMessage(source, 'Cookie name should be specified');
            return;
          }
          if (typeof value === 'undefined') {
            logMessage(source, 'Cookie value should be specified');
            return;
          }
          var parsedValue = parseKeywordValue(value);
          if (!isValidCookiePath(path)) {
            logMessage(source, "Invalid cookie path: '".concat(path, "'"));
            return;
          }
          var cookieToSet = concatCookieNameValuePath(name, parsedValue, path, false);
          if (!cookieToSet) {
            logMessage(source, 'Invalid cookie name or value');
            return;
          }
          if (offsetExpiresSec) {
            var parsedOffsetMs = getTrustedCookieOffsetMs(offsetExpiresSec);
            if (!parsedOffsetMs) {
              logMessage(source, "Invalid offsetExpiresSec value: ".concat(offsetExpiresSec));
              return;
            }
            var expires = Date.now() + parsedOffsetMs;
            cookieToSet += " expires=".concat(new Date(expires).toUTCString(), ";");
          }
          document.cookie = cookieToSet;
          hit(source);
        }
        trustedSetCookie$1.names = ['trusted-set-cookie'
        ];
        trustedSetCookie$1.injections = [hit, logMessage, nativeIsNaN, isCookieSetWithValue, concatCookieNameValuePath, isValidCookiePath, getTrustedCookieOffsetMs, parseKeywordValue, getCookiePath];
        function trustedSetCookieReload$1(source, name, value) {
          var offsetExpiresSec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
          var path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '/';
          if (typeof name === 'undefined') {
            logMessage(source, 'Cookie name should be specified');
            return;
          }
          if (typeof value === 'undefined') {
            logMessage(source, 'Cookie value should be specified');
            return;
          }
          if (isCookieSetWithValue(document.cookie, name, value)) {
            return;
          }
          var parsedValue = parseKeywordValue(value);
          if (!isValidCookiePath(path)) {
            logMessage(source, "Invalid cookie path: '".concat(path, "'"));
            return;
          }
          var cookieToSet = concatCookieNameValuePath(name, parsedValue, path, false);
          if (!cookieToSet) {
            logMessage(source, 'Invalid cookie name or value');
            return;
          }
          if (offsetExpiresSec) {
            var parsedOffsetMs = getTrustedCookieOffsetMs(offsetExpiresSec);
            if (!parsedOffsetMs) {
              logMessage(source, "Invalid offsetExpiresSec value: ".concat(offsetExpiresSec));
              return;
            }
            var expires = Date.now() + parsedOffsetMs;
            cookieToSet += " expires=".concat(new Date(expires).toUTCString(), ";");
          }
          document.cookie = cookieToSet;
          hit(source);
          var cookieValueToCheck = parseCookieString(document.cookie)[name];
          if (isCookieSetWithValue(document.cookie, name, cookieValueToCheck)) {
            window.location.reload();
          }
        }
        trustedSetCookieReload$1.names = ['trusted-set-cookie-reload'
        ];
        trustedSetCookieReload$1.injections = [hit, logMessage, nativeIsNaN, isCookieSetWithValue, concatCookieNameValuePath, isValidCookiePath, getTrustedCookieOffsetMs, parseKeywordValue, parseCookieString, getCookiePath];
        function trustedReplaceFetchResponse$1(source) {
          var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
          var propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
          if (typeof fetch === 'undefined' || typeof Proxy === 'undefined' || typeof Response === 'undefined') {
            return;
          }
          if (pattern === '' && replacement !== '') {
            logMessage(source, 'Pattern argument should not be empty string');
            return;
          }
          var shouldLog = pattern === '' && replacement === '';
          var nativeRequestClone = Request.prototype.clone;
          var nativeFetch = fetch;
          var shouldReplace = false;
          var fetchData;
          var handlerWrapper = function handlerWrapper(target, thisArg, args) {
            fetchData = getFetchData(args, nativeRequestClone);
            if (shouldLog) {
              logMessage(source, "fetch( ".concat(objectToString(fetchData), " )"), true);
              hit(source);
              return Reflect.apply(target, thisArg, args);
            }
            shouldReplace = matchRequestProps(source, propsToMatch, fetchData);
            if (!shouldReplace) {
              return Reflect.apply(target, thisArg, args);
            }
            var forgeResponse = function forgeResponse(response, textContent) {
              var bodyUsed = response.bodyUsed,
                headers = response.headers,
                ok = response.ok,
                redirected = response.redirected,
                status = response.status,
                statusText = response.statusText,
                type = response.type,
                url = response.url;
              var forgedResponse = new Response(textContent, {
                status,
                statusText,
                headers
              });
              Object.defineProperties(forgedResponse, {
                url: {
                  value: url
                },
                type: {
                  value: type
                },
                ok: {
                  value: ok
                },
                bodyUsed: {
                  value: bodyUsed
                },
                redirected: {
                  value: redirected
                }
              });
              return forgedResponse;
            };
            return nativeFetch.apply(null, args).then(function (response) {
              return response.text().then(function (bodyText) {
                var patternRegexp = pattern === '*' ? /(\n|.)*/ : toRegExp(pattern);
                var modifiedTextContent = bodyText.replace(patternRegexp, replacement);
                var forgedResponse = forgeResponse(response, modifiedTextContent);
                hit(source);
                return forgedResponse;
              }).catch(function () {
                var fetchDataStr = objectToString(fetchData);
                var message = "Response body can't be converted to text: ".concat(fetchDataStr);
                logMessage(source, message);
                return Reflect.apply(target, thisArg, args);
              });
            }).catch(function () {
              return Reflect.apply(target, thisArg, args);
            });
          };
          var fetchHandler = {
            apply: handlerWrapper
          };
          fetch = new Proxy(fetch, fetchHandler);
        }
        trustedReplaceFetchResponse$1.names = ['trusted-replace-fetch-response'
        ];
        trustedReplaceFetchResponse$1.injections = [hit, logMessage, getFetchData, objectToString, matchRequestProps, toRegExp, isValidStrPattern, escapeRegExp, isEmptyObject, getRequestData, getRequestProps, parseMatchProps, isValidParsedData, getMatchPropsData];
        function trustedSetLocalStorageItem$1(source, key, value) {
          if (typeof key === 'undefined') {
            logMessage(source, 'Item key should be specified');
            return;
          }
          if (typeof value === 'undefined') {
            logMessage(source, 'Item value should be specified');
            return;
          }
          var parsedValue = parseKeywordValue(value);
          var _window = window,
            localStorage = _window.localStorage;
          setStorageItem(source, localStorage, key, parsedValue);
          hit(source);
        }
        trustedSetLocalStorageItem$1.names = ['trusted-set-local-storage-item'
        ];
        trustedSetLocalStorageItem$1.injections = [hit, logMessage, nativeIsNaN, setStorageItem, parseKeywordValue];
        function trustedSetConstant$1(source, property, value, stack) {
          if (!property || !matchStackTrace(stack, new Error().stack)) {
            return;
          }
          var constantValue;
          try {
            constantValue = inferValue(value);
          } catch (e) {
            logMessage(source, e);
            return;
          }
          var canceled = false;
          var mustCancel = function mustCancel(value) {
            if (canceled) {
              return canceled;
            }
            canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue && value !== null;
            return canceled;
          };
          var trapProp = function trapProp(base, prop, configurable, handler) {
            if (!handler.init(base[prop])) {
              return false;
            }
            var origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
            var prevSetter;
            if (origDescriptor instanceof Object) {
              if (!origDescriptor.configurable) {
                var message = "Property '".concat(prop, "' is not configurable");
                logMessage(source, message);
                return false;
              }
              base[prop] = constantValue;
              if (origDescriptor.set instanceof Function) {
                prevSetter = origDescriptor.set;
              }
            }
            Object.defineProperty(base, prop, {
              configurable,
              get() {
                return handler.get();
              },
              set(a) {
                if (prevSetter !== undefined) {
                  prevSetter(a);
                }
                handler.set(a);
              }
            });
            return true;
          };
          var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
              chain = chainInfo.chain;
            var inChainPropHandler = {
              factValue: undefined,
              init(a) {
                this.factValue = a;
                return true;
              },
              get() {
                return this.factValue;
              },
              set(a) {
                if (this.factValue === a) {
                  return;
                }
                this.factValue = a;
                if (a instanceof Object) {
                  setChainPropAccess(a, chain);
                }
              }
            };
            var endPropHandler = {
              init(a) {
                if (mustCancel(a)) {
                  return false;
                }
                return true;
              },
              get() {
                return constantValue;
              },
              set(a) {
                if (!mustCancel(a)) {
                  return;
                }
                constantValue = a;
              }
            };
            if (!chain) {
              var isTrapped = trapProp(base, prop, false, endPropHandler);
              if (isTrapped) {
                hit(source);
              }
              return;
            }
            if (base !== undefined && base[prop] === null) {
              trapProp(base, prop, true, inChainPropHandler);
              return;
            }
            if ((base instanceof Object || typeof base === 'object') && isEmptyObject(base)) {
              trapProp(base, prop, true, inChainPropHandler);
            }
            var propValue = owner[prop];
            if (propValue instanceof Object || typeof propValue === 'object' && propValue !== null) {
              setChainPropAccess(propValue, chain);
            }
            trapProp(base, prop, true, inChainPropHandler);
          };
          setChainPropAccess(window, property);
        }
        trustedSetConstant$1.names = ['trusted-set-constant'
        ];
        trustedSetConstant$1.injections = [hit, inferValue, logMessage, noopArray, noopObject, noopFunc, noopCallbackFunc, trueFunc, falseFunc, throwFunc, noopPromiseReject, noopPromiseResolve, getPropertyInChain, setPropertyAccess, toRegExp, matchStackTrace, nativeIsNaN, isEmptyObject, getNativeRegexpTest,
        shouldAbortInlineOrInjectedScript];
        function injectCssInShadowDom$1(source, cssRule) {
          var hostSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
          if (!Element.prototype.attachShadow || typeof Proxy === 'undefined' || typeof Reflect === 'undefined') {
            return;
          }
          if (cssRule.match(/(url|image-set)\(.*\)/i)) {
            logMessage(source, '"url()" function is not allowed for css rules');
            return;
          }
          var callback = function callback(shadowRoot) {
            try {
              var stylesheet = new CSSStyleSheet();
              try {
                stylesheet.insertRule(cssRule);
              } catch (e) {
                logMessage(source, "Unable to apply the rule '".concat(cssRule, "' due to: \n'").concat(e.message, "'"));
                return;
              }
              shadowRoot.adoptedStyleSheets = [...shadowRoot.adoptedStyleSheets, stylesheet];
            } catch (_unused) {
              var styleTag = document.createElement('style');
              styleTag.innerText = cssRule;
              shadowRoot.appendChild(styleTag);
            }
            hit(source);
          };
          hijackAttachShadow(window, hostSelector, callback);
        }
        injectCssInShadowDom$1.names = ['inject-css-in-shadow-dom'];
        injectCssInShadowDom$1.injections = [hit, logMessage, hijackAttachShadow];
        function removeNodeText$1(source, nodeName, textMatch) {
          var _parseNodeTextParams = parseNodeTextParams(nodeName, textMatch),
            selector = _parseNodeTextParams.selector,
            nodeNameMatch = _parseNodeTextParams.nodeNameMatch,
            textContentMatch = _parseNodeTextParams.textContentMatch;
          var handleNodes = function handleNodes(nodes) {
            return nodes.forEach(function (node) {
              var shouldReplace = isTargetNode(node, nodeNameMatch, textContentMatch);
              if (shouldReplace) {
                var ALL_TEXT_PATTERN = /^[\s\S]*$/;
                var REPLACEMENT = '';
                replaceNodeText(source, node, ALL_TEXT_PATTERN, REPLACEMENT);
              }
            });
          };
          if (document.documentElement) {
            handleExistingNodes(selector, handleNodes);
          }
          observeDocumentWithTimeout(function (mutations) {
            return handleMutations(mutations, handleNodes);
          }, {
            childList: true,
            subtree: true
          });
        }
        removeNodeText$1.names = ['remove-node-text',
        'remove-node-text.js', 'ubo-remove-node-text.js', 'rmnt.js', 'ubo-rmnt.js', 'ubo-remove-node-text', 'ubo-rmnt'];
        removeNodeText$1.injections = [observeDocumentWithTimeout, handleExistingNodes, handleMutations, replaceNodeText, isTargetNode, parseNodeTextParams,
        hit, nodeListToArray, getAddedNodes, toRegExp];
        function trustedReplaceNodeText$1(source, nodeName, textMatch, pattern, replacement) {
          var uboAliases = ['replace-node-text.js', 'rpnt.js', 'sed.js'];
          if (uboAliases.includes(source.name)) {
            replacement = pattern;
            pattern = textMatch;
            for (var _len = arguments.length, extraArgs = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
              extraArgs[_key - 5] = arguments[_key];
            }
            for (var i = 0; i < extraArgs.length; i += 1) {
              var arg = extraArgs[i];
              if (arg === 'condition') {
                textMatch = extraArgs[i + 1];
                break;
              }
            }
          }
          var _parseNodeTextParams = parseNodeTextParams(nodeName, textMatch, pattern),
            selector = _parseNodeTextParams.selector,
            nodeNameMatch = _parseNodeTextParams.nodeNameMatch,
            textContentMatch = _parseNodeTextParams.textContentMatch,
            patternMatch = _parseNodeTextParams.patternMatch;
          var handleNodes = function handleNodes(nodes) {
            return nodes.forEach(function (node) {
              var shouldReplace = isTargetNode(node, nodeNameMatch, textContentMatch);
              if (shouldReplace) {
                replaceNodeText(source, node, patternMatch, replacement);
              }
            });
          };
          if (document.documentElement) {
            handleExistingNodes(selector, handleNodes);
          }
          observeDocumentWithTimeout(function (mutations) {
            return handleMutations(mutations, handleNodes);
          }, {
            childList: true,
            subtree: true
          });
        }
        trustedReplaceNodeText$1.names = ['trusted-replace-node-text'
        ];
        trustedReplaceNodeText$1.injections = [observeDocumentWithTimeout, handleExistingNodes, handleMutations, replaceNodeText, isTargetNode, parseNodeTextParams,
        hit, nodeListToArray, getAddedNodes, toRegExp];
        function evalDataPrune$1(source, propsToRemove, requiredInitialProps, stack) {
          var prunePaths = getPrunePath(propsToRemove);
          var requiredPaths = getPrunePath(requiredInitialProps);
          var nativeObjects = {
            nativeStringify: window.JSON.stringify
          };
          var evalWrapper = function evalWrapper(target, thisArg, args) {
            var data = Reflect.apply(target, thisArg, args);
            if (typeof data === 'object') {
              data = jsonPruner(source, data, prunePaths, requiredPaths, stack, nativeObjects);
            }
            return data;
          };
          var evalHandler = {
            apply: evalWrapper
          };
          window.eval = new Proxy(window.eval, evalHandler);
        }
        evalDataPrune$1.names = ['evaldata-prune',
        'evaldata-prune.js', 'ubo-evaldata-prune.js', 'ubo-evaldata-prune'];
        evalDataPrune$1.injections = [hit, matchStackTrace, getWildcardPropertyInChain, logMessage, toRegExp, isPruningNeeded, jsonPruner, getPrunePath,
        getNativeRegexpTest, shouldAbortInlineOrInjectedScript];
        function trustedPruneInboundObject$1(source, functionName, propsToRemove, requiredInitialProps) {
          var stack = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
          if (!functionName) {
            return;
          }
          var nativeObjects = {
            nativeStringify: window.JSON.stringify
          };
          var _getPropertyInChain = getPropertyInChain(window, functionName),
            base = _getPropertyInChain.base,
            prop = _getPropertyInChain.prop;
          if (!base || !prop || typeof base[prop] !== 'function') {
            var message = "".concat(functionName, " is not a function");
            logMessage(source, message);
            return;
          }
          var prunePaths = getPrunePath(propsToRemove);
          var requiredPaths = getPrunePath(requiredInitialProps);
          var objectWrapper = function objectWrapper(target, thisArg, args) {
            var data = args[0];
            if (typeof data === 'object') {
              data = jsonPruner(source, data, prunePaths, requiredPaths, stack, nativeObjects);
              args[0] = data;
            }
            return Reflect.apply(target, thisArg, args);
          };
          var objectHandler = {
            apply: objectWrapper
          };
          base[prop] = new Proxy(base[prop], objectHandler);
        }
        trustedPruneInboundObject$1.names = ['trusted-prune-inbound-object'
        ];
        trustedPruneInboundObject$1.injections = [hit, matchStackTrace, getPropertyInChain, getWildcardPropertyInChain, logMessage, isPruningNeeded, jsonPruner, getPrunePath,
        toRegExp, getNativeRegexpTest, shouldAbortInlineOrInjectedScript, isEmptyObject];
        var scriptletList = Object.freeze({
            __proto__: null,
            abortCurrentInlineScript: abortCurrentInlineScript$1,
            abortOnPropertyRead: abortOnPropertyRead$1,
            abortOnPropertyWrite: abortOnPropertyWrite$1,
            abortOnStackTrace: abortOnStackTrace$1,
            adjustSetInterval: adjustSetInterval$1,
            adjustSetTimeout: adjustSetTimeout$1,
            debugCurrentInlineScript: debugCurrentInlineScript$1,
            debugOnPropertyRead: debugOnPropertyRead$1,
            debugOnPropertyWrite: debugOnPropertyWrite$1,
            dirString: dirString$1,
            disableNewtabLinks: disableNewtabLinks$1,
            evalDataPrune: evalDataPrune$1,
            forceWindowClose: forceWindowClose$1,
            hideInShadowDom: hideInShadowDom$1,
            injectCssInShadowDom: injectCssInShadowDom$1,
            jsonPrune: jsonPrune$1,
            log: log$1,
            logAddEventListener: logAddEventListener$1,
            logEval: logEval$1,
            logOnStacktrace: logOnStacktrace$1,
            m3uPrune: m3uPrune$1,
            noTopics: noTopics$1,
            noeval: noeval$1,
            nowebrtc: nowebrtc$1,
            preventAddEventListener: preventAddEventListener$1,
            preventAdfly: preventAdfly$1,
            preventBab: preventBab$2,
            preventElementSrcLoading: preventElementSrcLoading$1,
            preventEvalIf: preventEvalIf$1,
            preventFab: preventFab$1,
            preventFetch: preventFetch$1,
            preventPopadsNet: preventPopadsNet$1,
            preventRefresh: preventRefresh$1,
            preventRequestAnimationFrame: preventRequestAnimationFrame$1,
            preventSetInterval: preventSetInterval$1,
            preventSetTimeout: preventSetTimeout$1,
            preventWindowOpen: preventWindowOpen$1,
            preventXHR: preventXHR$1,
            removeAttr: removeAttr$1,
            removeClass: removeClass$1,
            removeCookie: removeCookie$1,
            removeInShadowDom: removeInShadowDom$1,
            removeNodeText: removeNodeText$1,
            setAttr: setAttr$1,
            setConstant: setConstant$1,
            setCookie: setCookie$1,
            setCookieReload: setCookieReload$1,
            setLocalStorageItem: setLocalStorageItem$1,
            setPopadsDummy: setPopadsDummy$1,
            setSessionStorageItem: setSessionStorageItem$1,
            trustedClickElement: trustedClickElement$1,
            trustedPruneInboundObject: trustedPruneInboundObject$1,
            trustedReplaceFetchResponse: trustedReplaceFetchResponse$1,
            trustedReplaceNodeText: trustedReplaceNodeText$1,
            trustedReplaceXhrResponse: trustedReplaceXhrResponse$1,
            trustedSetConstant: trustedSetConstant$1,
            trustedSetCookie: trustedSetCookie$1,
            trustedSetCookieReload: trustedSetCookieReload$1,
            trustedSetLocalStorageItem: trustedSetLocalStorageItem$1,
            xmlPrune: xmlPrune$1
        });
        var redirects$1 = [{
          adg: '1x1-transparent.gif',
          ubo: '1x1.gif',
          abp: '1x1-transparent-gif'
        }, {
          adg: '2x2-transparent.png',
          ubo: '2x2.png',
          abp: '2x2-transparent-png'
        }, {
          adg: '3x2-transparent.png',
          ubo: '3x2.png',
          abp: '3x2-transparent-png'
        }, {
          adg: '32x32-transparent.png',
          ubo: '32x32.png',
          abp: '32x32-transparent-png'
        }, {
          adg: 'amazon-apstag',
          ubo: 'amazon_apstag.js'
        }, {
          adg: 'ati-smarttag'
        }, {
          adg: 'didomi-loader'
        }, {
          adg: 'click2load.html',
          ubo: 'click2load.html'
        }, {
          adg: 'fingerprintjs2',
          ubo: 'fingerprint2.js'
        }, {
          adg: 'fingerprintjs3',
          ubo: 'fingerprint3.js'
        }, {
          adg: 'google-analytics',
          ubo: 'google-analytics_analytics.js'
        }, {
          adg: 'google-analytics-ga',
          ubo: 'google-analytics_ga.js'
        }, {
          adg: 'googlesyndication-adsbygoogle',
          ubo: 'googlesyndication_adsbygoogle.js'
        }, {
          adg: 'googlesyndication-adsbygoogle',
          ubo: 'googlesyndication.com/adsbygoogle.js'
        }, {
          adg: 'googletagmanager-gtm',
          ubo: 'google-analytics_ga.js'
        }, {
          adg: 'googletagmanager-gtm',
          ubo: 'googletagmanager_gtm.js'
        }, {
          adg: 'googletagservices-gpt',
          ubo: 'googletagservices_gpt.js'
        }, {
          adg: 'google-ima3',
          ubo: 'google-ima.js'
        }, {
          adg: 'gemius'
        }, {
          adg: 'matomo'
        }, {
          adg: 'metrika-yandex-watch'
        }, {
          adg: 'metrika-yandex-tag'
        }, {
          adg: 'naver-wcslog'
        }, {
          adg: 'noeval',
          ubo: 'noeval-silent.js'
        }, {
          adg: 'noopcss',
          ubo: 'noop.css',
          abp: 'blank-css'
        }, {
          adg: 'noopframe',
          ubo: 'noop.html',
          abp: 'blank-html'
        }, {
          adg: 'noopjs',
          ubo: 'noop.js',
          abp: 'blank-js'
        }, {
          adg: 'noopjson',
          ubo: 'noop.json'
        }, {
          adg: 'nooptext',
          ubo: 'noop.txt',
          abp: 'blank-text'
        }, {
          adg: 'noopmp3-0.1s',
          ubo: 'noop-0.1s.mp3',
          abp: 'blank-mp3'
        }, {
          adg: 'noopmp4-1s',
          ubo: 'noop-1s.mp4',
          abp: 'blank-mp4'
        }, {
          adg: 'noopvmap-1.0',
          ubo: 'noop-vmap1.0.xml'
        }, {
          adg: 'noopvast-2.0'
        }, {
          adg: 'noopvast-3.0'
        }, {
          adg: 'noopvast-4.0'
        }, {
          adg: 'prebid'
        }, {
          adg: 'pardot-1.0'
        }, {
          adg: 'prevent-bab',
          ubo: 'nobab.js'
        }, {
          adg: 'prevent-bab2',
          ubo: 'nobab2.js'
        }, {
          adg: 'prevent-fab-3.2.0',
          ubo: 'nofab.js'
        }, {
          adg: 'prevent-fab-3.2.0',
          ubo: 'fuckadblock.js-3.2.0'
        }, {
          adg: 'prevent-popads-net',
          ubo: 'popads.js'
        }, {
          adg: 'scorecardresearch-beacon',
          ubo: 'scorecardresearch_beacon.js'
        }, {
          adg: 'set-popads-dummy',
          ubo: 'popads-dummy.js'
        }, {
          adg: 'empty',
          ubo: 'empty'
        }, {
          adg: 'prebid-ads',
          ubo: 'prebid-ads.js'
        }];
        var JS_RULE_MARKER = '#%#';
        var COMMENT_MARKER = '!';
        var UBO_REDIRECT_PRIORITY_MARKER = ':';
        var isComment = function isComment(rule) {
          return rule.startsWith(COMMENT_MARKER);
        };
        var UBO_SCRIPTLET_MASK_REG = /#@?#script:inject|#@?#\s*\+js/;
        var UBO_SCRIPTLET_MASK_1 = '##+js';
        var UBO_SCRIPTLET_MASK_2 = '##script:inject';
        var UBO_SCRIPTLET_EXCEPTION_MASK_1 = '#@#+js';
        var UBO_SCRIPTLET_EXCEPTION_MASK_2 = '#@#script:inject';
        var ABP_SCRIPTLET_MASK = '#$#';
        var ABP_SCRIPTLET_EXCEPTION_MASK = '#@$#';
        var ADG_CSS_MASK_REG = /#@?\$#.+?\s*\{.*\}\s*$/g;
        var isAdgScriptletRule = function isAdgScriptletRule(rule) {
          return !isComment(rule) && rule.includes(ADG_SCRIPTLET_MASK);
        };
        var isUboScriptletRule = function isUboScriptletRule(rule) {
          return (rule.includes(UBO_SCRIPTLET_MASK_1) || rule.includes(UBO_SCRIPTLET_MASK_2) || rule.includes(UBO_SCRIPTLET_EXCEPTION_MASK_1) || rule.includes(UBO_SCRIPTLET_EXCEPTION_MASK_2)) && UBO_SCRIPTLET_MASK_REG.test(rule) && !isComment(rule);
        };
        var isAbpSnippetRule = function isAbpSnippetRule(rule) {
          return (rule.includes(ABP_SCRIPTLET_MASK) || rule.includes(ABP_SCRIPTLET_EXCEPTION_MASK)) && rule.search(ADG_CSS_MASK_REG) === -1 && !isComment(rule);
        };
        var getScriptletsObjList = function getScriptletsObjList() {
          return Object.values(scriptletList);
        };
        var getScriptletByName = function getScriptletByName(name, scriptlets) {
          if (!scriptlets) {
            scriptlets = getScriptletsObjList();
          }
          return scriptlets.find(function (s) {
            return s.names
            && (s.names.includes(name)
            || !name.endsWith('.js') && s.names.includes("".concat(name, ".js")));
          });
        };
        var scriptletObjects = getScriptletsObjList();
        var isValidScriptletNameNotCached = function isValidScriptletNameNotCached(name) {
          if (!name) {
            return false;
          }
          return !!getScriptletByName(name, scriptletObjects);
        };
        var scriptletNameValidationCache = new Map();
        var isValidScriptletName = function isValidScriptletName(name) {
          if (!name) {
            return false;
          }
          if (!scriptletNameValidationCache.has(name)) {
            var isValid = isValidScriptletNameNotCached(name);
            scriptletNameValidationCache.set(name, isValid);
            return isValid;
          }
          return scriptletNameValidationCache.get(name);
        };
        var ADG_UBO_REDIRECT_MARKER = 'redirect=';
        var ADG_UBO_REDIRECT_RULE_MARKER = 'redirect-rule=';
        var ABP_REDIRECT_MARKER = 'rewrite=abp-resource:';
        var EMPTY_REDIRECT_MARKER = 'empty';
        var VALID_SOURCE_TYPES = ['image', 'media', 'subdocument', 'stylesheet', 'script', 'xmlhttprequest', 'other'];
        var ABSENT_SOURCE_TYPE_REPLACEMENT = [{
          NAME: 'nooptext',
          TYPES: VALID_SOURCE_TYPES
        }, {
          NAME: 'noopcss',
          TYPES: ['stylesheet']
        }, {
          NAME: 'noopjs',
          TYPES: ['script']
        }, {
          NAME: 'noopframe',
          TYPES: ['subdocument']
        }, {
          NAME: '1x1-transparent.gif',
          TYPES: ['image']
        }, {
          NAME: 'noopmp3-0.1s',
          TYPES: ['media']
        }, {
          NAME: 'noopmp4-1s',
          TYPES: ['media']
        }, {
          NAME: 'googlesyndication-adsbygoogle',
          TYPES: ['xmlhttprequest', 'script']
        }, {
          NAME: 'google-analytics',
          TYPES: ['script']
        }, {
          NAME: 'googletagservices-gpt',
          TYPES: ['script']
        }];
        var validAdgRedirects = redirects$1.filter(function (el) {
          return !!el.adg;
        });
        var uboToAdgCompatibility = Object.fromEntries(validAdgRedirects.filter(function (el) {
          return !!el.ubo;
        }).map(function (el) {
          return [el.ubo, el.adg];
        }));
        var abpToAdgCompatibility = Object.fromEntries(validAdgRedirects.filter(function (el) {
          return !!el.abp;
        }).map(function (el) {
          return [el.abp, el.adg];
        }));
        var adgToUboCompatibility = Object.fromEntries(validAdgRedirects.filter(function (el) {
          return el.ubo;
        }).map(function (el) {
          return [el.adg, el.ubo];
        }));
        var validAdgCompatibility = Object.fromEntries(validAdgRedirects.map(function (el) {
          return [el.adg, 'valid adg redirect'];
        }));
        var RedirectRuleType = function (RedirectRuleType) {
          RedirectRuleType["ValidAdg"] = "VALID_ADG";
          RedirectRuleType["Adg"] = "ADG";
          RedirectRuleType["Ubo"] = "UBO";
          RedirectRuleType["Abp"] = "ABP";
          return RedirectRuleType;
        }(RedirectRuleType || {});
        var REDIRECT_RULE_TYPES = {
          [RedirectRuleType.ValidAdg]: {
            redirectMarker: ADG_UBO_REDIRECT_MARKER,
            compatibility: validAdgCompatibility,
            redirectRuleMarker: ADG_UBO_REDIRECT_RULE_MARKER
          },
          [RedirectRuleType.Adg]: {
            redirectMarker: ADG_UBO_REDIRECT_MARKER,
            compatibility: adgToUboCompatibility,
            redirectRuleMarker: ADG_UBO_REDIRECT_RULE_MARKER
          },
          [RedirectRuleType.Ubo]: {
            redirectMarker: ADG_UBO_REDIRECT_MARKER,
            compatibility: uboToAdgCompatibility,
            redirectRuleMarker: ADG_UBO_REDIRECT_RULE_MARKER
          },
          [RedirectRuleType.Abp]: {
            redirectMarker: ABP_REDIRECT_MARKER,
            compatibility: abpToAdgCompatibility
          }
        };
        var parseModifiers = function parseModifiers(rule) {
          return substringAfter$1(rule, '$').split(',');
        };
        var getRedirectName = function getRedirectName(ruleModifiers, marker) {
          var redirectNamePart = ruleModifiers.find(function (el) {
            return el.includes(marker);
          });
          if (!redirectNamePart) {
            return null;
          }
          var redirectName = substringAfter$1(redirectNamePart, marker);
          var redirectPriorityIndex = redirectName.indexOf(UBO_REDIRECT_PRIORITY_MARKER);
          if (redirectPriorityIndex > -1) {
            redirectName = redirectName.substring(0, redirectPriorityIndex);
          }
          return redirectName;
        };
        var isAdgRedirectRule = function isAdgRedirectRule(rule) {
          var MARKER_IN_BASE_PART_MASK = '/((?!\\$|\\,).{1})redirect((-rule)?)=(.{0,}?)\\$(popup)?/';
          var _REDIRECT_RULE_TYPES$ = REDIRECT_RULE_TYPES[RedirectRuleType.Adg],
            redirectMarker = _REDIRECT_RULE_TYPES$.redirectMarker,
            redirectRuleMarker = _REDIRECT_RULE_TYPES$.redirectRuleMarker;
          return !isComment(rule) && (rule.includes(redirectMarker) || typeof redirectRuleMarker === 'string' && rule.includes(redirectRuleMarker))
          && !rule.includes(JS_RULE_MARKER)
          && !toRegExp(MARKER_IN_BASE_PART_MASK).test(rule);
        };
        var isRedirectRuleByType = function isRedirectRuleByType(rule, type) {
          var _REDIRECT_RULE_TYPES$2 = REDIRECT_RULE_TYPES[type],
            redirectMarker = _REDIRECT_RULE_TYPES$2.redirectMarker,
            redirectRuleMarker = _REDIRECT_RULE_TYPES$2.redirectRuleMarker,
            compatibility = _REDIRECT_RULE_TYPES$2.compatibility;
          if (rule && !isComment(rule)) {
            var marker;
            var markerIndex = redirectRuleMarker ? rule.indexOf(redirectRuleMarker) : -1;
            if (markerIndex > -1) {
              marker = redirectRuleMarker;
            } else {
              markerIndex = rule.indexOf(redirectMarker);
              if (markerIndex > -1) {
                marker = redirectMarker;
              } else {
                return false;
              }
            }
            if (!marker) {
              return false;
            }
            var redirectName = getRedirectName(parseModifiers(rule), marker);
            if (!redirectName) {
              return false;
            }
            return redirectName === Object.keys(compatibility).find(function (el) {
              return el === redirectName;
            });
          }
          return false;
        };
        var isValidAdgRedirectRule = function isValidAdgRedirectRule(rule) {
          return isRedirectRuleByType(rule, RedirectRuleType.ValidAdg);
        };
        var isAdgRedirectCompatibleWithUbo = function isAdgRedirectCompatibleWithUbo(rule) {
          return isAdgRedirectRule(rule) && isRedirectRuleByType(rule, RedirectRuleType.Adg);
        };
        var isUboRedirectCompatibleWithAdg = function isUboRedirectCompatibleWithAdg(rule) {
          return isRedirectRuleByType(rule, RedirectRuleType.Ubo);
        };
        var isAbpRedirectCompatibleWithAdg = function isAbpRedirectCompatibleWithAdg(rule) {
          return isRedirectRuleByType(rule, RedirectRuleType.Abp);
        };
        var hasValidContentType = function hasValidContentType(rule) {
          var ruleModifiers = parseModifiers(rule);
          var sourceTypes = ruleModifiers.filter(function (el) {
            return VALID_SOURCE_TYPES.includes(el);
          });
          var isSourceTypeSpecified = sourceTypes.length > 0;
          var isEmptyRedirect = ruleModifiers.includes("".concat(ADG_UBO_REDIRECT_MARKER).concat(EMPTY_REDIRECT_MARKER)) || ruleModifiers.includes("".concat(ADG_UBO_REDIRECT_RULE_MARKER).concat(EMPTY_REDIRECT_MARKER));
          if (isEmptyRedirect) {
            return true;
          }
          return isSourceTypeSpecified;
        };
        var validator = {
          UBO_SCRIPTLET_MASK_REG,
          ABP_SCRIPTLET_MASK,
          ABP_SCRIPTLET_EXCEPTION_MASK,
          isComment,
          isAdgScriptletRule,
          isUboScriptletRule,
          isAbpSnippetRule,
          getScriptletByName,
          isValidScriptletName,
          ADG_UBO_REDIRECT_RULE_MARKER,
          REDIRECT_RULE_TYPES,
          ABSENT_SOURCE_TYPE_REPLACEMENT,
          isAdgRedirectRule,
          isValidAdgRedirectRule,
          isAdgRedirectCompatibleWithUbo,
          isUboRedirectCompatibleWithAdg,
          isAbpRedirectCompatibleWithAdg,
          parseModifiers,
          getRedirectName,
          hasValidContentType,
          isRedirectRuleByType,
          RedirectRuleType
        };
        function _arrayWithHoles(arr) {
          if (Array.isArray(arr)) return arr;
        }
        function _iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _toArray(arr) {
          return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
        }
        var ADGUARD_SCRIPTLET_MASK_REG = /#@?%#\/\/scriptlet\(.+\)/;
        var ADGUARD_SCRIPTLET_TEMPLATE = '${domains}#%#//scriptlet(${args})';
        var ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@%#//scriptlet(${args})';
        var UBO_SCRIPTLET_TEMPLATE = '${domains}##+js(${args})';
        var UBO_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@#+js(${args})';
        var UBO_ALIAS_NAME_MARKER = 'ubo-';
        var UBO_SCRIPTLET_JS_ENDING = '.js';
        var UBO_XHR_TYPE = 'xhr';
        var ADG_XHR_TYPE = 'xmlhttprequest';
        var ADG_SET_CONSTANT_NAME = 'set-constant';
        var ADG_SET_CONSTANT_EMPTY_STRING = '';
        var ADG_SET_CONSTANT_EMPTY_ARRAY = 'emptyArr';
        var ADG_SET_CONSTANT_EMPTY_OBJECT = 'emptyObj';
        var UBO_SET_CONSTANT_EMPTY_STRING = '\'\'';
        var UBO_SET_CONSTANT_EMPTY_ARRAY = '[]';
        var UBO_SET_CONSTANT_EMPTY_OBJECT = '{}';
        var ADG_PREVENT_FETCH_NAME = 'prevent-fetch';
        var ADG_PREVENT_FETCH_EMPTY_STRING = '';
        var ADG_PREVENT_FETCH_WILDCARD = '*';
        var UBO_NO_FETCH_IF_WILDCARD = '/^/';
        var ESCAPED_COMMA_SEPARATOR = '\\,';
        var COMMA_SEPARATOR = ',';
        var REMOVE_ATTR_METHOD = 'removeAttr';
        var REMOVE_CLASS_METHOD = 'removeClass';
        var REMOVE_ATTR_ALIASES = scriptletList[REMOVE_ATTR_METHOD].names;
        var REMOVE_CLASS_ALIASES = scriptletList[REMOVE_CLASS_METHOD].names;
        var REMOVE_ATTR_CLASS_APPLYING = ['asap', 'stay', 'complete'];
        var ABP_RESOURCE_MARKER = 'abp-resource:';
        var Origin = function (Origin) {
          Origin["Ubo"] = "ubo";
          Origin["Abp"] = "abp";
          Origin["AdgValid"] = "adgValid";
          Origin["AdgInvalid"] = "adgInvalid";
          return Origin;
        }(Origin || {});
        var originNames = [Origin.Ubo, Origin.Abp, Origin.AdgValid, Origin.AdgInvalid];
        var getAbpSnippetArguments = function getAbpSnippetArguments(str) {
          var reg = /'.*?'|".*?"|\S+/g;
          var sentences = str.match(reg);
          if (!sentences) {
            throw new Error('Invalid ABP snippet args.');
          }
          return sentences;
        };
        var replacePlaceholders = function replacePlaceholders(str, data) {
          return Object.keys(data).reduce(function (acc, key) {
            var reg = new RegExp("\\$\\{".concat(key, "\\}"), 'g');
            acc = acc.replace(reg, data[key]);
            return acc;
          }, str);
        };
        var splitArgs = function splitArgs(str) {
          var args = [];
          var prevArgStart = 0;
          for (var i = 0; i < str.length; i += 1) {
            if (str[i] === COMMA_SEPARATOR && str[i - 1] !== '\\') {
              args.push(str.slice(prevArgStart, i).trim());
              prevArgStart = i + 1;
            }
          }
          args.push(str.slice(prevArgStart, str.length).trim());
          return args;
        };
        var validateRemoveAttrClassArgs = function validateRemoveAttrClassArgs(parsedArgs) {
          var _parsedArgs = _toArray(parsedArgs),
            name = _parsedArgs[0],
            value = _parsedArgs[1],
            restArgs = _parsedArgs.slice(2);
          if (restArgs.length === 0) {
            return [name, value];
          }
          var lastArg = restArgs.pop();
          var applying;
          if (REMOVE_ATTR_CLASS_APPLYING.some(function (el) {
            return lastArg.includes(el);
          })) {
            applying = lastArg;
          } else {
            restArgs.push(lastArg);
          }
          var selector = replaceAll(restArgs.join(', '), ESCAPED_COMMA_SEPARATOR, COMMA_SEPARATOR);
          if (selector.length > 0 && typeof document !== 'undefined') {
            document.querySelectorAll(selector);
          }
          var validArgs = applying ? [name, value, selector, applying] : [name, value, selector];
          return validArgs;
        };
        var convertUboScriptletToAdg = function convertUboScriptletToAdg(rule) {
          var domains = getBeforeRegExp(rule, validator.UBO_SCRIPTLET_MASK_REG);
          var matchResult = rule.match(validator.UBO_SCRIPTLET_MASK_REG);
          var mask = Array.isArray(matchResult) ? matchResult[0] : null;
          var template;
          if (mask !== null && mask !== void 0 && mask.includes('@')) {
            template = ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;
          } else {
            template = ADGUARD_SCRIPTLET_TEMPLATE;
          }
          var argsStr = getStringInBraces(rule);
          var parsedArgs = splitArgs(argsStr);
          var scriptletName = parsedArgs[0].includes(UBO_SCRIPTLET_JS_ENDING) ? "ubo-".concat(parsedArgs[0]) : "ubo-".concat(parsedArgs[0]).concat(UBO_SCRIPTLET_JS_ENDING);
          if (REMOVE_ATTR_ALIASES.includes(scriptletName) || REMOVE_CLASS_ALIASES.includes(scriptletName)) {
            parsedArgs = validateRemoveAttrClassArgs(parsedArgs);
          }
          var args = parsedArgs.map(function (arg, index) {
            var outputArg = arg;
            if (index === 0) {
              outputArg = scriptletName;
            }
            if (arg === '$') {
              outputArg = '$$';
            }
            return outputArg;
          }).map(function (arg) {
            return wrapInSingleQuotes(arg);
          }).join("".concat(COMMA_SEPARATOR, " "));
          var adgRule = replacePlaceholders(template, {
            domains,
            args
          });
          return [adgRule];
        };
        var convertAbpSnippetToAdg = function convertAbpSnippetToAdg(rule) {
          var SEMICOLON_DIVIDER = /;(?=(?:(?:[^"]*"){2})*[^"]*$)/g;
          var mask = rule.includes(validator.ABP_SCRIPTLET_MASK) ? validator.ABP_SCRIPTLET_MASK : validator.ABP_SCRIPTLET_EXCEPTION_MASK;
          var template = mask === validator.ABP_SCRIPTLET_MASK ? ADGUARD_SCRIPTLET_TEMPLATE : ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;
          var domains = substringBefore(rule, mask);
          var args = substringAfter$1(rule, mask);
          return args.split(SEMICOLON_DIVIDER)
          .filter(isExisting).map(function (args) {
            return getAbpSnippetArguments(args).map(function (arg, index) {
              return index === 0 ? "abp-".concat(arg) : arg;
            }).map(function (arg) {
              return wrapInSingleQuotes(arg);
            }).join("".concat(COMMA_SEPARATOR, " "));
          }).map(function (args) {
            return replacePlaceholders(template, {
              domains,
              args
            });
          });
        };
        var isValidAdgScriptletRuleSyntax = function isValidAdgScriptletRuleSyntax(adgRuleText) {
          if (!adgRuleText) {
            return false;
          }
          if (!validator.isAdgScriptletRule(adgRuleText)) {
            return false;
          }
          var parsedRule;
          try {
            parsedRule = parseRule(adgRuleText);
            return validator.isValidScriptletName(parsedRule.name);
          } catch (e) {
            return false;
          }
        };
        var OriginValidator = {
          [Origin.Ubo]: validator.isUboScriptletRule,
          [Origin.Abp]: validator.isAbpSnippetRule,
          [Origin.AdgValid]: isValidAdgScriptletRuleSyntax,
          [Origin.AdgInvalid]: function (r) {
            return validator.isAdgScriptletRule(r) && !isValidAdgScriptletRuleSyntax(r);
          }
        };
        var Converter = {
          [Origin.Ubo]: convertUboScriptletToAdg,
          [Origin.Abp]: convertAbpSnippetToAdg,
          [Origin.AdgValid]: function (r) {
            return [r];
          },
          [Origin.AdgInvalid]: function (r) {
            console.log("Invalid AdGuard scriptlet rule: ".concat(r));
            return [];
          }
        };
        var getRuleOrigin = function getRuleOrigin(rule) {
          return originNames.find(function (originName) {
            return OriginValidator[originName](rule);
          });
        };
        var convertScriptletToAdg = function convertScriptletToAdg(rule) {
          if (validator.isComment(rule)) {
            return [rule];
          }
          var originName = getRuleOrigin(rule);
          if (!originName) {
            return [rule];
          }
          return Converter[originName](rule);
        };
        var convertAdgScriptletToUbo = function convertAdgScriptletToUbo(rule) {
          var res;
          if (validator.isAdgScriptletRule(rule)) {
            var _parseRule = parseRule(rule),
              parsedName = _parseRule.name,
              parsedParams = _parseRule.args;
            var preparedParams;
            if (parsedName === ADG_SET_CONSTANT_NAME
            && parsedParams[1] === ADG_SET_CONSTANT_EMPTY_STRING) {
              preparedParams = [parsedParams[0], UBO_SET_CONSTANT_EMPTY_STRING];
            } else if (parsedName === ADG_SET_CONSTANT_NAME
            && parsedParams[1] === ADG_SET_CONSTANT_EMPTY_ARRAY) {
              preparedParams = [parsedParams[0], UBO_SET_CONSTANT_EMPTY_ARRAY];
            } else if (parsedName === ADG_SET_CONSTANT_NAME && parsedParams[1] === ADG_SET_CONSTANT_EMPTY_OBJECT) {
              preparedParams = [parsedParams[0], UBO_SET_CONSTANT_EMPTY_OBJECT];
            } else if (parsedName === ADG_PREVENT_FETCH_NAME
            && (parsedParams[0] === ADG_PREVENT_FETCH_WILDCARD || parsedParams[0] === ADG_PREVENT_FETCH_EMPTY_STRING)) {
              preparedParams = [UBO_NO_FETCH_IF_WILDCARD];
            } else {
              preparedParams = parsedParams;
            }
            if (preparedParams && preparedParams.length > 0) {
              preparedParams = preparedParams.map(function (param) {
                if (param.includes(COMMA_SEPARATOR)) {
                  return replaceAll(param, COMMA_SEPARATOR, ESCAPED_COMMA_SEPARATOR);
                }
                return param;
              });
            }
            var scriptletNames = Object.keys(scriptletList);
            var adgScriptletObject = scriptletNames.map(function (name) {
              return scriptletList[name];
            }).map(function (scriptlet) {
              var _scriptlet$names = _toArray(scriptlet.names),
                name = _scriptlet$names[0],
                aliases = _scriptlet$names.slice(1);
              return {
                name,
                aliases
              };
            }).find(function (el) {
              return el.name === parsedName || el.aliases.includes(parsedName);
            });
            var aliases = adgScriptletObject.aliases;
            if (aliases.length > 0) {
              var uboAlias = adgScriptletObject.aliases.find(function (alias) {
                return alias.includes(UBO_ALIAS_NAME_MARKER);
              });
              if (uboAlias) {
                var matchResult = rule.match(ADGUARD_SCRIPTLET_MASK_REG);
                var mask = Array.isArray(matchResult) ? matchResult[0] : null;
                var template;
                if (mask !== null && mask !== void 0 && mask.includes('@')) {
                  template = UBO_SCRIPTLET_EXCEPTION_TEMPLATE;
                } else {
                  template = UBO_SCRIPTLET_TEMPLATE;
                }
                var domains = getBeforeRegExp(rule, ADGUARD_SCRIPTLET_MASK_REG);
                var uboName = uboAlias.replace(UBO_ALIAS_NAME_MARKER, '')
                .replace(UBO_SCRIPTLET_JS_ENDING, '');
                var args = preparedParams.length > 0 ? "".concat(uboName, ", ").concat(preparedParams.join("".concat(COMMA_SEPARATOR, " "))) : uboName;
                var uboRule = replacePlaceholders(template, {
                  domains,
                  args
                });
                res = uboRule;
              }
            }
          }
          return res;
        };
        var getAdgScriptletName = function getAdgScriptletName(rule) {
          var buffer = substringAfter$1(rule, "".concat(ADG_SCRIPTLET_MASK, "("));
          if (!buffer) {
            return null;
          }
          var nameQuote = buffer[0];
          buffer = buffer.slice(1);
          if (!buffer) {
            return null;
          }
          var name = substringBefore(buffer, nameQuote);
          return name === buffer ? null : name;
        };
        var isValidScriptletRule = function isValidScriptletRule(ruleText) {
          if (!ruleText) {
            return false;
          }
          var rulesArray = convertScriptletToAdg(ruleText);
          if (rulesArray.length === 0) {
            return false;
          }
          var isValid = rulesArray.every(function (rule) {
            var name = getAdgScriptletName(rule);
            return name && validator.isValidScriptletName(name);
          });
          return isValid;
        };
        var getMarkerData = function getMarkerData(modifiers, redirectsData, rule) {
          var redirectRuleMarker = redirectsData.redirectRuleMarker,
            redirectMarker = redirectsData.redirectMarker;
          var index;
          if (redirectRuleMarker) {
            index = modifiers.findIndex(function (m) {
              return m.includes(redirectRuleMarker);
            });
            if (index > -1) {
              return {
                index,
                marker: redirectRuleMarker
              };
            }
          }
          index = modifiers.findIndex(function (m) {
            return m.includes(redirectMarker);
          });
          if (index > -1) {
            return {
              index,
              marker: redirectMarker
            };
          }
          throw new Error("No redirect resource modifier found in rule: ".concat(rule));
        };
        var convertUboRedirectToAdg = function convertUboRedirectToAdg(rule) {
          var firstPartOfRule = substringBefore(rule, '$');
          var uboModifiers = validator.parseModifiers(rule);
          var uboMarkerData = getMarkerData(uboModifiers, validator.REDIRECT_RULE_TYPES.UBO, rule);
          var adgModifiers = uboModifiers.map(function (modifier, index) {
            if (index === uboMarkerData.index) {
              var uboName = validator.getRedirectName([modifier], uboMarkerData.marker);
              if (uboName) {
                var adgName = validator.REDIRECT_RULE_TYPES.UBO.compatibility[uboName];
                var adgMarker = uboMarkerData.marker === validator.ADG_UBO_REDIRECT_RULE_MARKER ? validator.REDIRECT_RULE_TYPES.ADG.redirectRuleMarker : validator.REDIRECT_RULE_TYPES.ADG.redirectMarker;
                return "".concat(adgMarker).concat(adgName);
              }
            }
            if (modifier === UBO_XHR_TYPE) {
              return ADG_XHR_TYPE;
            }
            return modifier;
          }).join(COMMA_SEPARATOR);
          return "".concat(firstPartOfRule, "$").concat(adgModifiers);
        };
        var convertAbpRedirectToAdg = function convertAbpRedirectToAdg(rule) {
          var firstPartOfRule = substringBefore(rule, '$');
          var abpModifiers = validator.parseModifiers(rule);
          var adgModifiers = abpModifiers.map(function (modifier) {
            if (modifier.includes(validator.REDIRECT_RULE_TYPES.ABP.redirectMarker)) {
              var abpName = substringAfter$1(modifier, validator.REDIRECT_RULE_TYPES.ABP.redirectMarker);
              var adgName = validator.REDIRECT_RULE_TYPES.ABP.compatibility[abpName];
              return "".concat(validator.REDIRECT_RULE_TYPES.ADG.redirectMarker).concat(adgName);
            }
            return modifier;
          }).join(COMMA_SEPARATOR);
          return "".concat(firstPartOfRule, "$").concat(adgModifiers);
        };
        var convertRedirectToAdg = function convertRedirectToAdg(rule) {
          var result;
          if (validator.isUboRedirectCompatibleWithAdg(rule)) {
            result = convertUboRedirectToAdg(rule);
          } else if (validator.isAbpRedirectCompatibleWithAdg(rule)) {
            result = convertAbpRedirectToAdg(rule);
          } else if (validator.isValidAdgRedirectRule(rule)) {
            result = rule;
          }
          return result;
        };
        var convertAdgRedirectToUbo = function convertAdgRedirectToUbo(rule) {
          if (!validator.isAdgRedirectCompatibleWithUbo(rule)) {
            throw new Error("Unable to convert for uBO - unsupported redirect in rule: ".concat(rule));
          }
          var basePart = substringBefore(rule, '$');
          var adgModifiers = validator.parseModifiers(rule);
          var adgMarkerData = getMarkerData(adgModifiers, validator.REDIRECT_RULE_TYPES.ADG, rule);
          var adgRedirectName = validator.getRedirectName(adgModifiers, adgMarkerData.marker);
          if (!adgRedirectName) {
            throw new Error("Unable to convert for uBO - no valid redirect name in rule: ".concat(rule));
          }
          if (!validator.hasValidContentType(rule)) {
            var sourceTypesData = validator.ABSENT_SOURCE_TYPE_REPLACEMENT.find(function (el) {
              return el.NAME === adgRedirectName;
            });
            if (typeof sourceTypesData === 'undefined') {
              throw new Error("Unable to convert for uBO - no types to add for specific redirect in rule: ".concat(rule));
            }
            var additionModifiers = sourceTypesData.TYPES;
            adgModifiers.push(...additionModifiers);
          }
          var uboModifiers = adgModifiers.map(function (el, index) {
            if (index === adgMarkerData.index) {
              var uboMarker = adgMarkerData.marker === validator.ADG_UBO_REDIRECT_RULE_MARKER ? validator.REDIRECT_RULE_TYPES.UBO.redirectRuleMarker : validator.REDIRECT_RULE_TYPES.UBO.redirectMarker;
              var uboRedirectName = validator.REDIRECT_RULE_TYPES.ADG.compatibility[adgRedirectName];
              return "".concat(uboMarker).concat(uboRedirectName);
            }
            return el;
          }).join(COMMA_SEPARATOR);
          return "".concat(basePart, "$").concat(uboModifiers);
        };
        var convertRedirectNameToAdg = function convertRedirectNameToAdg(name) {
          var nameToCheck = name.trim();
          if (validator.REDIRECT_RULE_TYPES.ADG.compatibility[nameToCheck]) {
            return nameToCheck;
          }
          if (validator.REDIRECT_RULE_TYPES.UBO.compatibility[nameToCheck]) {
            return validator.REDIRECT_RULE_TYPES.UBO.compatibility[nameToCheck];
          }
          if (nameToCheck.startsWith(ABP_RESOURCE_MARKER)) {
            nameToCheck = nameToCheck.slice(ABP_RESOURCE_MARKER.length).trim();
          }
          return validator.REDIRECT_RULE_TYPES.ABP.compatibility[nameToCheck];
        };
        function GoogleAnalytics(source) {
          var Tracker = function Tracker() {};
          var proto = Tracker.prototype;
          proto.get = noopFunc;
          proto.set = noopFunc;
          proto.send = noopFunc;
          var googleAnalyticsName = window.GoogleAnalyticsObject || 'ga';
          function ga(a) {
            var len = arguments.length;
            if (len === 0) {
              return;
            }
            var lastArg = arguments[len - 1];
            var replacer;
            if (lastArg instanceof Object && lastArg !== null && typeof lastArg.hitCallback === 'function') {
              replacer = lastArg.hitCallback;
            } else if (typeof lastArg === 'function') {
              replacer = function replacer() {
                lastArg(ga.create());
              };
            }
            try {
              setTimeout(replacer, 1);
            } catch (ex) {}
          }
          ga.create = function () {
            return new Tracker();
          };
          ga.getByName = function () {
            return new Tracker();
          };
          ga.getAll = function () {
            return [new Tracker()];
          };
          ga.remove = noopFunc;
          ga.loaded = true;
          window[googleAnalyticsName] = ga;
          var _window = window,
            dataLayer = _window.dataLayer,
            google_optimize = _window.google_optimize;
          if (dataLayer instanceof Object === false) {
            return;
          }
          if (dataLayer.hide instanceof Object && typeof dataLayer.hide.end === 'function') {
            dataLayer.hide.end();
          }
          var handleCallback = function handleCallback(dataObj, funcName) {
            if (dataObj && typeof dataObj[funcName] === 'function') {
              setTimeout(dataObj[funcName]);
            }
          };
          if (typeof dataLayer.push === 'function') {
            dataLayer.push = function (data) {
              if (data instanceof Object) {
                handleCallback(data, 'eventCallback');
                for (var key in data) {
                  handleCallback(data[key], 'event_callback');
                }
                if (!data.hasOwnProperty('eventCallback') && !data.hasOwnProperty('eventCallback')) {
                  [].push.call(window.dataLayer, data);
                }
              }
              if (Array.isArray(data)) {
                data.forEach(function (arg) {
                  handleCallback(arg, 'callback');
                });
              }
              return noopFunc;
            };
          }
          if (google_optimize instanceof Object && typeof google_optimize.get === 'function') {
            var googleOptimizeWrapper = {
              get: noopFunc
            };
            window.google_optimize = googleOptimizeWrapper;
          }
          hit(source);
        }
        GoogleAnalytics.names = ['google-analytics', 'ubo-google-analytics_analytics.js', 'google-analytics_analytics.js',
        'googletagmanager-gtm', 'ubo-googletagmanager_gtm.js', 'googletagmanager_gtm.js'];
        GoogleAnalytics.injections = [hit, noopFunc, noopNull, noopArray];
        function GoogleAnalyticsGa(source) {
          function Gaq() {}
          Gaq.prototype.Na = noopFunc;
          Gaq.prototype.O = noopFunc;
          Gaq.prototype.Sa = noopFunc;
          Gaq.prototype.Ta = noopFunc;
          Gaq.prototype.Va = noopFunc;
          Gaq.prototype._createAsyncTracker = noopFunc;
          Gaq.prototype._getAsyncTracker = noopFunc;
          Gaq.prototype._getPlugin = noopFunc;
          Gaq.prototype.push = function (data) {
            if (typeof data === 'function') {
              data();
              return;
            }
            if (Array.isArray(data) === false) {
              return;
            }
            if (typeof data[0] === 'string' && /(^|\.)_link$/.test(data[0]) && typeof data[1] === 'string') {
              window.location.assign(data[1]);
            }
            if (data[0] === '_set' && data[1] === 'hitCallback' && typeof data[2] === 'function') {
              data[2]();
            }
          };
          var gaq = new Gaq();
          var asyncTrackers = window._gaq || [];
          if (Array.isArray(asyncTrackers)) {
            while (asyncTrackers[0]) {
              gaq.push(asyncTrackers.shift());
            }
          }
          window._gaq = gaq.qf = gaq;
          function Gat() {}
          var api = ['_addIgnoredOrganic', '_addIgnoredRef', '_addItem', '_addOrganic', '_addTrans', '_clearIgnoredOrganic', '_clearIgnoredRef', '_clearOrganic', '_cookiePathCopy', '_deleteCustomVar', '_getName', '_setAccount', '_getAccount', '_getClientInfo', '_getDetectFlash', '_getDetectTitle', '_getLinkerUrl', '_getLocalGifPath', '_getServiceMode', '_getVersion', '_getVisitorCustomVar', '_initData', '_link', '_linkByPost', '_setAllowAnchor', '_setAllowHash', '_setAllowLinker', '_setCampContentKey', '_setCampMediumKey', '_setCampNameKey', '_setCampNOKey', '_setCampSourceKey', '_setCampTermKey', '_setCampaignCookieTimeout', '_setCampaignTrack', '_setClientInfo', '_setCookiePath', '_setCookiePersistence', '_setCookieTimeout', '_setCustomVar', '_setDetectFlash', '_setDetectTitle', '_setDomainName', '_setLocalGifPath', '_setLocalRemoteServerMode', '_setLocalServerMode', '_setReferrerOverride', '_setRemoteServerMode', '_setSampleRate', '_setSessionTimeout', '_setSiteSpeedSampleRate', '_setSessionCookieTimeout', '_setVar', '_setVisitorCookieTimeout', '_trackEvent', '_trackPageLoadTime', '_trackPageview', '_trackSocial', '_trackTiming', '_trackTrans', '_visitCode'];
          var tracker = api.reduce(function (res, funcName) {
            res[funcName] = noopFunc;
            return res;
          }, {});
          tracker._getLinkerUrl = function (a) {
            return a;
          };
          tracker._link = function (url) {
            if (typeof url !== 'string') {
              return;
            }
            try {
              window.location.assign(url);
            } catch (e) {
              logMessage(source, e);
            }
          };
          Gat.prototype._anonymizeIP = noopFunc;
          Gat.prototype._createTracker = noopFunc;
          Gat.prototype._forceSSL = noopFunc;
          Gat.prototype._getPlugin = noopFunc;
          Gat.prototype._getTracker = function () {
            return tracker;
          };
          Gat.prototype._getTrackerByName = function () {
            return tracker;
          };
          Gat.prototype._getTrackers = noopFunc;
          Gat.prototype.aa = noopFunc;
          Gat.prototype.ab = noopFunc;
          Gat.prototype.hb = noopFunc;
          Gat.prototype.la = noopFunc;
          Gat.prototype.oa = noopFunc;
          Gat.prototype.pa = noopFunc;
          Gat.prototype.u = noopFunc;
          var gat = new Gat();
          window._gat = gat;
          hit(source);
        }
        GoogleAnalyticsGa.names = ['google-analytics-ga', 'ubo-google-analytics_ga.js', 'google-analytics_ga.js'];
        GoogleAnalyticsGa.injections = [hit, noopFunc, logMessage];
        function GoogleSyndicationAdsByGoogle(source) {
          window.adsbygoogle = {
            loaded: true,
            push(arg) {
              if (typeof this.length === 'undefined') {
                this.length = 0;
                this.length += 1;
              }
              if (arg !== null && arg instanceof Object && arg.constructor.name === 'Object') {
                for (var _i = 0, _Object$keys = Object.keys(arg); _i < _Object$keys.length; _i++) {
                  var key = _Object$keys[_i];
                  if (typeof arg[key] === 'function') {
                    try {
                      arg[key].call(this, {});
                    } catch (_unused) {
                    }
                  }
                }
              }
            }
          };
          var adElems = document.querySelectorAll('.adsbygoogle');
          var css = 'height:1px!important;max-height:1px!important;max-width:1px!important;width:1px!important;';
          var statusAttrName = 'data-adsbygoogle-status';
          var ASWIFT_IFRAME_MARKER = 'aswift_';
          var GOOGLE_ADS_IFRAME_MARKER = 'google_ads_iframe_';
          var executed = false;
          for (var i = 0; i < adElems.length; i += 1) {
            var adElemChildNodes = adElems[i].childNodes;
            var childNodesQuantity = adElemChildNodes.length;
            var areIframesDefined = false;
            if (childNodesQuantity > 0) {
              areIframesDefined = childNodesQuantity === 2
              && adElemChildNodes[0].nodeName.toLowerCase() === 'iframe' && adElemChildNodes[0].id.includes(ASWIFT_IFRAME_MARKER)
              && adElemChildNodes[1].nodeName.toLowerCase() === 'iframe' && adElemChildNodes[1].id.includes(GOOGLE_ADS_IFRAME_MARKER);
            }
            if (!areIframesDefined) {
              adElems[i].setAttribute(statusAttrName, 'done');
              var aswiftIframe = document.createElement('iframe');
              aswiftIframe.id = "".concat(ASWIFT_IFRAME_MARKER).concat(i);
              aswiftIframe.style = css;
              adElems[i].appendChild(aswiftIframe);
              var innerAswiftIframe = document.createElement('iframe');
              aswiftIframe.contentWindow.document.body.appendChild(innerAswiftIframe);
              var googleadsIframe = document.createElement('iframe');
              googleadsIframe.id = "".concat(GOOGLE_ADS_IFRAME_MARKER).concat(i);
              googleadsIframe.style = css;
              adElems[i].appendChild(googleadsIframe);
              var innerGoogleadsIframe = document.createElement('iframe');
              googleadsIframe.contentWindow.document.body.appendChild(innerGoogleadsIframe);
              executed = true;
            }
          }
          if (executed) {
            hit(source);
          }
        }
        GoogleSyndicationAdsByGoogle.names = ['googlesyndication-adsbygoogle', 'ubo-googlesyndication_adsbygoogle.js', 'googlesyndication_adsbygoogle.js'];
        GoogleSyndicationAdsByGoogle.injections = [hit];
        function GoogleTagServicesGpt(source) {
          var slots = new Map();
          var slotsById = new Map();
          var slotsPerPath = new Map();
          var slotCreatives = new Map();
          var eventCallbacks = new Map();
          var gTargeting = new Map();
          var addEventListener = function addEventListener(name, listener) {
            if (!eventCallbacks.has(name)) {
              eventCallbacks.set(name, new Set());
            }
            eventCallbacks.get(name).add(listener);
            return this;
          };
          var removeEventListener = function removeEventListener(name, listener) {
            if (eventCallbacks.has(name)) {
              return eventCallbacks.get(name).delete(listener);
            }
            return false;
          };
          var fireSlotEvent = function fireSlotEvent(name, slot) {
            return new Promise(function (resolve) {
              requestAnimationFrame(function () {
                var size = [0, 0];
                var callbacksSet = eventCallbacks.get(name) || [];
                var callbackArray = Array.from(callbacksSet);
                for (var i = 0; i < callbackArray.length; i += 1) {
                  callbackArray[i]({
                    isEmpty: true,
                    size,
                    slot
                  });
                }
                resolve();
              });
            });
          };
          var emptySlotElement = function emptySlotElement(slot) {
            var node = document.getElementById(slot.getSlotElementId());
            while (node !== null && node !== void 0 && node.lastChild) {
              node.lastChild.remove();
            }
          };
          var recreateIframeForSlot = function recreateIframeForSlot(slot) {
            var _document$getElementB;
            var eid = "google_ads_iframe_".concat(slot.getId());
            (_document$getElementB = document.getElementById(eid)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.remove();
            var node = document.getElementById(slot.getSlotElementId());
            if (node) {
              var f = document.createElement('iframe');
              f.id = eid;
              f.srcdoc = '<body></body>';
              f.style = 'position:absolute; width:0; height:0; left:0; right:0; z-index:-1; border:0';
              f.setAttribute('width', 0);
              f.setAttribute('height', 0);
              f.setAttribute('data-load-complete', true);
              f.setAttribute('data-google-container-id', true);
              f.setAttribute('sandbox', '');
              node.appendChild(f);
            }
          };
          var displaySlot = function displaySlot(slot) {
            if (!slot) {
              return;
            }
            var id = slot.getSlotElementId();
            if (!document.getElementById(id)) {
              return;
            }
            var parent = document.getElementById(id);
            if (parent) {
              parent.appendChild(document.createElement('div'));
            }
            emptySlotElement(slot);
            recreateIframeForSlot(slot);
            fireSlotEvent('slotRenderEnded', slot);
            fireSlotEvent('slotRequested', slot);
            fireSlotEvent('slotResponseReceived', slot);
            fireSlotEvent('slotOnload', slot);
            fireSlotEvent('impressionViewable', slot);
          };
          var companionAdsService = {
            addEventListener,
            removeEventListener,
            enableSyncLoading: noopFunc,
            setRefreshUnfilledSlots: noopFunc,
            getSlots: noopArray
          };
          var contentService = {
            addEventListener,
            removeEventListener,
            setContent: noopFunc
          };
          function PassbackSlot() {}
          PassbackSlot.prototype.display = noopFunc;
          PassbackSlot.prototype.get = noopNull;
          PassbackSlot.prototype.set = noopThis;
          PassbackSlot.prototype.setClickUrl = noopThis;
          PassbackSlot.prototype.setTagForChildDirectedTreatment = noopThis;
          PassbackSlot.prototype.setTargeting = noopThis;
          PassbackSlot.prototype.updateTargetingFromMap = noopThis;
          function SizeMappingBuilder() {}
          SizeMappingBuilder.prototype.addSize = noopThis;
          SizeMappingBuilder.prototype.build = noopNull;
          var getTargetingValue = function getTargetingValue(v) {
            if (typeof v === 'string') {
              return [v];
            }
            try {
              return Array.prototype.flat.call(v);
            } catch (_unused) {
            }
            return [];
          };
          var updateTargeting = function updateTargeting(targeting, map) {
            if (typeof map === 'object') {
              for (var key in map) {
                if (Object.prototype.hasOwnProperty.call(map, key)) {
                  targeting.set(key, getTargetingValue(map[key]));
                }
              }
            }
          };
          var defineSlot = function defineSlot(adUnitPath, creatives, optDiv) {
            if (slotsById.has(optDiv)) {
              var _document$getElementB2;
              (_document$getElementB2 = document.getElementById(optDiv)) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.remove();
              return slotsById.get(optDiv);
            }
            var attributes = new Map();
            var targeting = new Map();
            var exclusions = new Set();
            var response = {
              advertiserId: undefined,
              campaignId: undefined,
              creativeId: undefined,
              creativeTemplateId: undefined,
              lineItemId: undefined
            };
            var sizes = [{
              getHeight: function getHeight() {
                return 2;
              },
              getWidth: function getWidth() {
                return 2;
              }
            }];
            var num = (slotsPerPath.get(adUnitPath) || 0) + 1;
            slotsPerPath.set(adUnitPath, num);
            var id = "".concat(adUnitPath, "_").concat(num);
            var clickUrl = '';
            var collapseEmptyDiv = null;
            var services = new Set();
            var slot = {
              addService(e) {
                services.add(e);
                return slot;
              },
              clearCategoryExclusions: noopThis,
              clearTargeting(k) {
                if (k === undefined) {
                  targeting.clear();
                } else {
                  targeting.delete(k);
                }
              },
              defineSizeMapping(mapping) {
                slotCreatives.set(optDiv, mapping);
                return this;
              },
              get: function get(k) {
                return attributes.get(k);
              },
              getAdUnitPath: function getAdUnitPath() {
                return adUnitPath;
              },
              getAttributeKeys: function getAttributeKeys() {
                return Array.from(attributes.keys());
              },
              getCategoryExclusions: function getCategoryExclusions() {
                return Array.from(exclusions);
              },
              getClickUrl: function getClickUrl() {
                return clickUrl;
              },
              getCollapseEmptyDiv: function getCollapseEmptyDiv() {
                return collapseEmptyDiv;
              },
              getContentUrl: function getContentUrl() {
                return '';
              },
              getDivStartsCollapsed: function getDivStartsCollapsed() {
                return null;
              },
              getDomId: function getDomId() {
                return optDiv;
              },
              getEscapedQemQueryId: function getEscapedQemQueryId() {
                return '';
              },
              getFirstLook: function getFirstLook() {
                return 0;
              },
              getId: function getId() {
                return id;
              },
              getHtml: function getHtml() {
                return '';
              },
              getName: function getName() {
                return id;
              },
              getOutOfPage: function getOutOfPage() {
                return false;
              },
              getResponseInformation: function getResponseInformation() {
                return response;
              },
              getServices: function getServices() {
                return Array.from(services);
              },
              getSizes: function getSizes() {
                return sizes;
              },
              getSlotElementId: function getSlotElementId() {
                return optDiv;
              },
              getSlotId: function getSlotId() {
                return slot;
              },
              getTargeting: function getTargeting(k) {
                return targeting.get(k) || gTargeting.get(k) || [];
              },
              getTargetingKeys: function getTargetingKeys() {
                return Array.from(new Set(Array.of(...gTargeting.keys(), ...targeting.keys())));
              },
              getTargetingMap: function getTargetingMap() {
                return Object.assign(Object.fromEntries(gTargeting.entries()), Object.fromEntries(targeting.entries()));
              },
              set(k, v) {
                attributes.set(k, v);
                return slot;
              },
              setCategoryExclusion(e) {
                exclusions.add(e);
                return slot;
              },
              setClickUrl(u) {
                clickUrl = u;
                return slot;
              },
              setCollapseEmptyDiv(v) {
                collapseEmptyDiv = !!v;
                return slot;
              },
              setSafeFrameConfig: noopThis,
              setTagForChildDirectedTreatment: noopThis,
              setTargeting(k, v) {
                targeting.set(k, getTargetingValue(v));
                return slot;
              },
              toString: function toString() {
                return id;
              },
              updateTargetingFromMap(map) {
                updateTargeting(targeting, map);
                return slot;
              }
            };
            slots.set(adUnitPath, slot);
            slotsById.set(optDiv, slot);
            slotCreatives.set(optDiv, creatives);
            return slot;
          };
          var pubAdsService = {
            addEventListener,
            removeEventListener,
            clear: noopFunc,
            clearCategoryExclusions: noopThis,
            clearTagForChildDirectedTreatment: noopThis,
            clearTargeting(k) {
              if (k === undefined) {
                gTargeting.clear();
              } else {
                gTargeting.delete(k);
              }
            },
            collapseEmptyDivs: noopFunc,
            defineOutOfPagePassback() {
              return new PassbackSlot();
            },
            definePassback() {
              return new PassbackSlot();
            },
            disableInitialLoad: noopFunc,
            display: noopFunc,
            enableAsyncRendering: noopFunc,
            enableLazyLoad: noopFunc,
            enableSingleRequest: noopFunc,
            enableSyncRendering: noopFunc,
            enableVideoAds: noopFunc,
            get: noopNull,
            getAttributeKeys: noopArray,
            getTargeting: noopArray,
            getTargetingKeys: noopArray,
            getSlots: noopArray,
            isInitialLoadDisabled: trueFunc,
            refresh: noopFunc,
            set: noopThis,
            setCategoryExclusion: noopThis,
            setCentering: noopFunc,
            setCookieOptions: noopThis,
            setForceSafeFrame: noopThis,
            setLocation: noopThis,
            setPrivacySettings: noopThis,
            setPublisherProvidedId: noopThis,
            setRequestNonPersonalizedAds: noopThis,
            setSafeFrameConfig: noopThis,
            setTagForChildDirectedTreatment: noopThis,
            setTargeting: noopThis,
            setVideoContent: noopThis,
            updateCorrelator: noopFunc
          };
          var _window = window,
            _window$googletag = _window.googletag,
            googletag = _window$googletag === void 0 ? {} : _window$googletag;
          var _googletag$cmd = googletag.cmd,
            cmd = _googletag$cmd === void 0 ? [] : _googletag$cmd;
          googletag.apiReady = true;
          googletag.cmd = [];
          googletag.cmd.push = function (a) {
            try {
              a();
            } catch (ex) {}
            return 1;
          };
          googletag.companionAds = function () {
            return companionAdsService;
          };
          googletag.content = function () {
            return contentService;
          };
          googletag.defineOutOfPageSlot = defineSlot;
          googletag.defineSlot = defineSlot;
          googletag.destroySlots = function () {
            slots.clear();
            slotsById.clear();
          };
          googletag.disablePublisherConsole = noopFunc;
          googletag.display = function (arg) {
            var id;
            if (arg !== null && arg !== void 0 && arg.getSlotElementId) {
              id = arg.getSlotElementId();
            } else if (arg !== null && arg !== void 0 && arg.nodeType) {
              id = arg.id;
            } else {
              id = String(arg);
            }
            displaySlot(slotsById.get(id));
          };
          googletag.enableServices = noopFunc;
          googletag.getVersion = noopStr;
          googletag.pubads = function () {
            return pubAdsService;
          };
          googletag.pubadsReady = true;
          googletag.setAdIframeTitle = noopFunc;
          googletag.sizeMapping = function () {
            return new SizeMappingBuilder();
          };
          window.googletag = googletag;
          while (cmd.length !== 0) {
            googletag.cmd.push(cmd.shift());
          }
          hit(source);
        }
        GoogleTagServicesGpt.names = ['googletagservices-gpt', 'ubo-googletagservices_gpt.js', 'googletagservices_gpt.js'];
        GoogleTagServicesGpt.injections = [hit, noopFunc, noopThis, noopNull, noopArray, noopStr, trueFunc];
        function ScoreCardResearchBeacon(source) {
          window.COMSCORE = {
            purge() {
              window._comscore = [];
            },
            beacon() {}
          };
          hit(source);
        }
        ScoreCardResearchBeacon.names = ['scorecardresearch-beacon', 'ubo-scorecardresearch_beacon.js', 'scorecardresearch_beacon.js'];
        ScoreCardResearchBeacon.injections = [hit];
        function metrikaYandexTag(source) {
          var asyncCallbackFromOptions = function asyncCallbackFromOptions(id, param) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var callback = options.callback;
            var ctx = options.ctx;
            if (typeof callback === 'function') {
              callback = ctx !== undefined ? callback.bind(ctx) : callback;
              setTimeout(function () {
                return callback();
              });
            }
          };
          var addFileExtension = noopFunc;
          var extLink = asyncCallbackFromOptions;
          var file = asyncCallbackFromOptions;
          var getClientID = function getClientID(id, cb) {
            if (!cb) {
              return;
            }
            setTimeout(cb(null));
          };
          var hitFunc = asyncCallbackFromOptions;
          var notBounce = asyncCallbackFromOptions;
          var params = noopFunc;
          var reachGoal = function reachGoal(id, target, params, callback, ctx) {
            asyncCallbackFromOptions(null, null, {
              callback,
              ctx
            });
          };
          var setUserID = noopFunc;
          var userParams = noopFunc;
          var destruct = noopFunc;
          var api = {
            addFileExtension,
            extLink,
            file,
            getClientID,
            hit: hitFunc,
            notBounce,
            params,
            reachGoal,
            setUserID,
            userParams,
            destruct
          };
          function ym(id, funcName) {
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            return api[funcName] && api[funcName](id, ...args);
          }
          function init(id) {
            window["yaCounter".concat(id)] = api;
            document.dispatchEvent(new Event("yacounter".concat(id, "inited")));
          }
          if (typeof window.ym === 'undefined') {
            window.ym = ym;
            ym.a = [];
          } else if (window.ym && window.ym.a) {
            ym.a = window.ym.a;
            window.ym = ym;
            window.ym.a.forEach(function (params) {
              var id = params[0];
              init(id);
            });
          }
          hit(source);
        }
        metrikaYandexTag.names = ['metrika-yandex-tag'];
        metrikaYandexTag.injections = [hit, noopFunc];
        function metrikaYandexWatch(source) {
          var cbName = 'yandex_metrika_callbacks';
          var asyncCallbackFromOptions = function asyncCallbackFromOptions() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var callback = options.callback;
            var ctx = options.ctx;
            if (typeof callback === 'function') {
              callback = ctx !== undefined ? callback.bind(ctx) : callback;
              setTimeout(function () {
                return callback();
              });
            }
          };
          function Metrika() {}
          Metrika.counters = noopArray;
          Metrika.prototype.addFileExtension = noopFunc;
          Metrika.prototype.getClientID = noopFunc;
          Metrika.prototype.setUserID = noopFunc;
          Metrika.prototype.userParams = noopFunc;
          Metrika.prototype.params = noopFunc;
          Metrika.prototype.counters = noopArray;
          Metrika.prototype.extLink = function (url, options) {
            asyncCallbackFromOptions(options);
          };
          Metrika.prototype.file = function (url, options) {
            asyncCallbackFromOptions(options);
          };
          Metrika.prototype.hit = function (url, options) {
            asyncCallbackFromOptions(options);
          };
          Metrika.prototype.reachGoal = function (target, params, cb, ctx) {
            asyncCallbackFromOptions({
              callback: cb,
              ctx
            });
          };
          Metrika.prototype.notBounce = asyncCallbackFromOptions;
          if (window.Ya) {
            window.Ya.Metrika = Metrika;
          } else {
            window.Ya = {
              Metrika
            };
          }
          if (window[cbName] && Array.isArray(window[cbName])) {
            window[cbName].forEach(function (func) {
              if (typeof func === 'function') {
                func();
              }
            });
          }
          hit(source);
        }
        metrikaYandexWatch.names = ['metrika-yandex-watch'];
        metrikaYandexWatch.injections = [hit, noopFunc, noopArray];
        function Pardot(source) {
          window.piVersion = '1.0.2';
          window.piScriptNum = 0;
          window.piScriptObj = [];
          window.checkNamespace = noopFunc;
          window.getPardotUrl = noopStr;
          window.piGetParameter = noopNull;
          window.piSetCookie = noopFunc;
          window.piGetCookie = noopStr;
          function piTracker() {
            window.pi = {
              tracker: {
                visitor_id: '',
                visitor_id_sign: '',
                pi_opt_in: '',
                campaign_id: ''
              }
            };
            window.piScriptNum += 1;
          }
          window.piResponse = noopFunc;
          window.piTracker = piTracker;
          piTracker();
          hit(source);
        }
        Pardot.names = ['pardot-1.0'];
        Pardot.injections = [hit, noopFunc, noopStr, noopNull];
        var preventBab$1 = preventBab$2;
        preventBab$1.names = ['prevent-bab',
        'nobab.js', 'ubo-nobab.js', 'bab-defuser.js', 'ubo-bab-defuser.js', 'ubo-nobab', 'ubo-bab-defuser'];
        function AmazonApstag(source) {
          var apstagWrapper = {
            fetchBids(a, b) {
              if (typeof b === 'function') {
                b([]);
              }
            },
            init: noopFunc,
            setDisplayBids: noopFunc,
            targetingKeys: noopFunc
          };
          window.apstag = apstagWrapper;
          hit(source);
        }
        AmazonApstag.names = ['amazon-apstag', 'ubo-amazon_apstag.js', 'amazon_apstag.js'];
        AmazonApstag.injections = [hit, noopFunc];
        function Matomo(source) {
          var Tracker = function Tracker() {};
          Tracker.prototype.setDoNotTrack = noopFunc;
          Tracker.prototype.setDomains = noopFunc;
          Tracker.prototype.setCustomDimension = noopFunc;
          Tracker.prototype.trackPageView = noopFunc;
          var AsyncTracker = function AsyncTracker() {};
          AsyncTracker.prototype.addListener = noopFunc;
          var matomoWrapper = {
            getTracker: Tracker,
            getAsyncTracker: AsyncTracker
          };
          window.Piwik = matomoWrapper;
          hit(source);
        }
        Matomo.names = ['matomo'];
        Matomo.injections = [hit, noopFunc];
        function Fingerprintjs2(source) {
          var browserId = '';
          for (var i = 0; i < 8; i += 1) {
            browserId += (Math.random() * 0x10000 + 0x1000).toString(16).slice(-4);
          }
          var Fingerprint2 = function Fingerprint2() {};
          Fingerprint2.get = function (options, callback) {
            if (!callback) {
              callback = options;
            }
            setTimeout(function () {
              if (callback) {
                callback(browserId, []);
              }
            }, 1);
          };
          Fingerprint2.prototype = {
            get: Fingerprint2.get
          };
          window.Fingerprint2 = Fingerprint2;
          hit(source);
        }
        Fingerprintjs2.names = ['fingerprintjs2',
        'ubo-fingerprint2.js',
        'fingerprint2.js'];
        Fingerprintjs2.injections = [hit];
        function Fingerprintjs3(source) {
          var visitorId = function () {
            var id = '';
            for (var i = 0; i < 8; i += 1) {
              id += (Math.random() * 0x10000 + 0x1000).toString(16).slice(-4);
            }
            return id;
          }();
          var FingerprintJS = function FingerprintJS() {};
          FingerprintJS.prototype = {
            load() {
              return Promise.resolve(new FingerprintJS());
            },
            get() {
              return Promise.resolve({
                visitorId
              });
            },
            hashComponents: noopStr
          };
          window.FingerprintJS = new FingerprintJS();
          hit(source);
        }
        Fingerprintjs3.names = ['fingerprintjs3',
        'ubo-fingerprint3.js',
        'fingerprint3.js'];
        Fingerprintjs3.injections = [hit, noopStr];
        function Gemius(source) {
          var GemiusPlayer = function GemiusPlayer() {};
          GemiusPlayer.prototype = {
            setVideoObject: noopFunc,
            newProgram: noopFunc,
            programEvent: noopFunc,
            newAd: noopFunc,
            adEvent: noopFunc
          };
          window.GemiusPlayer = GemiusPlayer;
          hit(source);
        }
        Gemius.names = ['gemius'];
        Gemius.injections = [hit, noopFunc];
        function ATInternetSmartTag(source) {
          var setNoopFuncWrapper = {
            set: noopFunc
          };
          var sendNoopFuncWrapper = {
            send: noopFunc
          };
          var ecommerceWrapper = {
            displayCart: {
              products: setNoopFuncWrapper,
              cart: setNoopFuncWrapper
            },
            updateCart: {
              cart: setNoopFuncWrapper
            },
            displayProduct: {
              products: setNoopFuncWrapper
            },
            displayPageProduct: {
              products: setNoopFuncWrapper
            },
            addProduct: {
              products: setNoopFuncWrapper
            },
            removeProduct: {
              products: setNoopFuncWrapper
            }
          };
          var tag = function tag() {};
          tag.prototype = {
            setConfig: noopFunc,
            setParam: noopFunc,
            dispatch: noopFunc,
            customVars: setNoopFuncWrapper,
            publisher: setNoopFuncWrapper,
            order: setNoopFuncWrapper,
            click: sendNoopFuncWrapper,
            clickListener: sendNoopFuncWrapper,
            internalSearch: {
              set: noopFunc,
              send: noopFunc
            },
            ecommerce: ecommerceWrapper,
            identifiedVisitor: {
              unset: noopFunc
            },
            page: {
              set: noopFunc,
              send: noopFunc
            },
            selfPromotion: {
              add: noopFunc,
              send: noopFunc
            },
            privacy: {
              setVisitorMode: noopFunc,
              getVisitorMode: noopFunc,
              hit: noopFunc
            },
            richMedia: {
              add: noopFunc,
              send: noopFunc,
              remove: noopFunc,
              removeAll: noopFunc
            }
          };
          var smartTagWrapper = {
            Tracker: {
              Tag: tag
            }
          };
          window.ATInternet = smartTagWrapper;
          hit(source);
        }
        ATInternetSmartTag.names = ['ati-smarttag'];
        ATInternetSmartTag.injections = [hit, noopFunc];
        function preventBab2(source) {
          var script = document.currentScript;
          if (script === null) {
            return;
          }
          var url = script.src;
          if (typeof url !== 'string') {
            return;
          }
          var domainsStr = ['adclixx\\.net', 'adnetasia\\.com', 'adtrackers\\.net', 'bannertrack\\.net'].join('|');
          var matchStr = "^https?://[\\w-]+\\.(".concat(domainsStr, ")/.");
          var domainsRegex = new RegExp(matchStr);
          if (domainsRegex.test(url) === false) {
            return;
          }
          window.nH7eXzOsG = 858;
          hit(source);
        }
        preventBab2.names = ['prevent-bab2',
        'nobab2.js'];
        preventBab2.injections = [hit];
        function GoogleIma3(source) {
          var _window$google$ima;
          var VERSION = '3.453.0';
          var ima = {};
          var AdDisplayContainer = function AdDisplayContainer() {};
          AdDisplayContainer.prototype.destroy = noopFunc;
          AdDisplayContainer.prototype.initialize = noopFunc;
          var ImaSdkSettings = function ImaSdkSettings() {};
          ImaSdkSettings.CompanionBackfillMode = {
            ALWAYS: 'always',
            ON_MASTER_AD: 'on_master_ad'
          };
          ImaSdkSettings.VpaidMode = {
            DISABLED: 0,
            ENABLED: 1,
            INSECURE: 2
          };
          ImaSdkSettings.prototype = {
            c: true,
            f: {},
            i: false,
            l: '',
            p: '',
            r: 0,
            t: '',
            v: '',
            getCompanionBackfill: noopFunc,
            getDisableCustomPlaybackForIOS10Plus() {
              return this.i;
            },
            getDisabledFlashAds: function getDisabledFlashAds() {
              return true;
            },
            getFeatureFlags() {
              return this.f;
            },
            getLocale() {
              return this.l;
            },
            getNumRedirects() {
              return this.r;
            },
            getPlayerType() {
              return this.t;
            },
            getPlayerVersion() {
              return this.v;
            },
            getPpid() {
              return this.p;
            },
            getVpaidMode() {
              return this.C;
            },
            isCookiesEnabled() {
              return this.c;
            },
            isVpaidAdapter() {
              return this.M;
            },
            setCompanionBackfill: noopFunc,
            setAutoPlayAdBreaks(a) {
              this.K = a;
            },
            setCookiesEnabled(c) {
              this.c = !!c;
            },
            setDisableCustomPlaybackForIOS10Plus(i) {
              this.i = !!i;
            },
            setDisableFlashAds: noopFunc,
            setFeatureFlags(f) {
              this.f = !!f;
            },
            setIsVpaidAdapter(a) {
              this.M = a;
            },
            setLocale(l) {
              this.l = !!l;
            },
            setNumRedirects(r) {
              this.r = !!r;
            },
            setPageCorrelator(a) {
              this.R = a;
            },
            setPlayerType(t) {
              this.t = !!t;
            },
            setPlayerVersion(v) {
              this.v = !!v;
            },
            setPpid(p) {
              this.p = !!p;
            },
            setVpaidMode(a) {
              this.C = a;
            },
            setSessionId: noopFunc,
            setStreamCorrelator: noopFunc,
            setVpaidAllowed: noopFunc,
            CompanionBackfillMode: {
              ALWAYS: 'always',
              ON_MASTER_AD: 'on_master_ad'
            },
            VpaidMode: {
              DISABLED: 0,
              ENABLED: 1,
              INSECURE: 2
            }
          };
          var EventHandler = function EventHandler() {
            this.listeners = new Map();
            this._dispatch = function (e) {
              var listeners = this.listeners.get(e.type) || [];
              for (var _i = 0, _Array$from = Array.from(listeners); _i < _Array$from.length; _i++) {
                var listener = _Array$from[_i];
                try {
                  listener(e);
                } catch (r) {
                  logMessage(source, r);
                }
              }
            };
            this.addEventListener = function (t, c) {
              if (!this.listeners.has(t)) {
                this.listeners.set(t, new Set());
              }
              this.listeners.get(t).add(c);
            };
            this.removeEventListener = function (t, c) {
              var _this$listeners$get;
              (_this$listeners$get = this.listeners.get(t)) === null || _this$listeners$get === void 0 ? void 0 : _this$listeners$get.delete(c);
            };
          };
          var AdsManager = new EventHandler();
          AdsManager.volume = 1;
          AdsManager.collapse = noopFunc;
          AdsManager.configureAdsManager = noopFunc;
          AdsManager.destroy = noopFunc;
          AdsManager.discardAdBreak = noopFunc;
          AdsManager.expand = noopFunc;
          AdsManager.focus = noopFunc;
          AdsManager.getAdSkippableState = function () {
            return false;
          };
          AdsManager.getCuePoints = function () {
            return [0];
          };
          AdsManager.getCurrentAd = function () {
            return currentAd;
          };
          AdsManager.getCurrentAdCuePoints = function () {
            return [];
          };
          AdsManager.getRemainingTime = function () {
            return 0;
          };
          AdsManager.getVolume = function () {
            return this.volume;
          };
          AdsManager.init = noopFunc;
          AdsManager.isCustomClickTrackingUsed = function () {
            return false;
          };
          AdsManager.isCustomPlaybackUsed = function () {
            return false;
          };
          AdsManager.pause = noopFunc;
          AdsManager.requestNextAdBreak = noopFunc;
          AdsManager.resize = noopFunc;
          AdsManager.resume = noopFunc;
          AdsManager.setVolume = function (v) {
            this.volume = v;
          };
          AdsManager.skip = noopFunc;
          AdsManager.start = function () {
            for (var _i2 = 0, _arr = [AdEvent.Type.ALL_ADS_COMPLETED, AdEvent.Type.CONTENT_RESUME_REQUESTED]; _i2 < _arr.length; _i2++) {
              var type = _arr[_i2];
              try {
                this._dispatch(new ima.AdEvent(type));
              } catch (e) {
                logMessage(source, e);
              }
            }
          };
          AdsManager.stop = noopFunc;
          AdsManager.updateAdsRenderingSettings = noopFunc;
          var manager = Object.create(AdsManager);
          var AdsManagerLoadedEvent = function AdsManagerLoadedEvent(type, adsRequest, userRequestContext) {
            this.type = type;
            this.adsRequest = adsRequest;
            this.userRequestContext = userRequestContext;
          };
          AdsManagerLoadedEvent.prototype = {
            getAdsManager: function getAdsManager() {
              return manager;
            },
            getUserRequestContext() {
              if (this.userRequestContext) {
                return this.userRequestContext;
              }
              return {};
            }
          };
          AdsManagerLoadedEvent.Type = {
            ADS_MANAGER_LOADED: 'adsManagerLoaded'
          };
          var AdsLoader = EventHandler;
          AdsLoader.prototype.settings = new ImaSdkSettings();
          AdsLoader.prototype.contentComplete = noopFunc;
          AdsLoader.prototype.destroy = noopFunc;
          AdsLoader.prototype.getSettings = function () {
            return this.settings;
          };
          AdsLoader.prototype.getVersion = function () {
            return VERSION;
          };
          AdsLoader.prototype.requestAds = function (adsRequest, userRequestContext) {
            var _this = this;
            requestAnimationFrame(function () {
              var ADS_MANAGER_LOADED = AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED;
              var event = new ima.AdsManagerLoadedEvent(ADS_MANAGER_LOADED, adsRequest, userRequestContext);
              _this._dispatch(event);
            });
            var e = new ima.AdError('adPlayError', 1205, 1205, 'The browser prevented playback initiated without user interaction.', adsRequest, userRequestContext);
            requestAnimationFrame(function () {
              _this._dispatch(new ima.AdErrorEvent(e));
            });
          };
          var AdsRenderingSettings = noopFunc;
          var AdsRequest = function AdsRequest() {};
          AdsRequest.prototype = {
            setAdWillAutoPlay: noopFunc,
            setAdWillPlayMuted: noopFunc,
            setContinuousPlayback: noopFunc
          };
          var AdPodInfo = function AdPodInfo() {};
          AdPodInfo.prototype = {
            getAdPosition: function getAdPosition() {
              return 1;
            },
            getIsBumper: function getIsBumper() {
              return false;
            },
            getMaxDuration: function getMaxDuration() {
              return -1;
            },
            getPodIndex: function getPodIndex() {
              return 1;
            },
            getTimeOffset: function getTimeOffset() {
              return 0;
            },
            getTotalAds: function getTotalAds() {
              return 1;
            }
          };
          var Ad = function Ad() {};
          Ad.prototype = {
            pi: new AdPodInfo(),
            getAdId: function getAdId() {
              return '';
            },
            getAdPodInfo() {
              return this.pi;
            },
            getAdSystem: function getAdSystem() {
              return '';
            },
            getAdvertiserName: function getAdvertiserName() {
              return '';
            },
            getApiFramework: function getApiFramework() {
              return null;
            },
            getCompanionAds: function getCompanionAds() {
              return [];
            },
            getContentType: function getContentType() {
              return '';
            },
            getCreativeAdId: function getCreativeAdId() {
              return '';
            },
            getDealId: function getDealId() {
              return '';
            },
            getDescription: function getDescription() {
              return '';
            },
            getDuration: function getDuration() {
              return 8.5;
            },
            getHeight: function getHeight() {
              return 0;
            },
            getMediaUrl: function getMediaUrl() {
              return null;
            },
            getMinSuggestedDuration: function getMinSuggestedDuration() {
              return -2;
            },
            getSkipTimeOffset: function getSkipTimeOffset() {
              return -1;
            },
            getSurveyUrl: function getSurveyUrl() {
              return null;
            },
            getTitle: function getTitle() {
              return '';
            },
            getTraffickingParametersString: function getTraffickingParametersString() {
              return '';
            },
            getUiElements: function getUiElements() {
              return [''];
            },
            getUniversalAdIdRegistry: function getUniversalAdIdRegistry() {
              return 'unknown';
            },
            getUniversalAdIds: function getUniversalAdIds() {
              return [''];
            },
            getUniversalAdIdValue: function getUniversalAdIdValue() {
              return 'unknown';
            },
            getVastMediaBitrate: function getVastMediaBitrate() {
              return 0;
            },
            getVastMediaHeight: function getVastMediaHeight() {
              return 0;
            },
            getVastMediaWidth: function getVastMediaWidth() {
              return 0;
            },
            getWidth: function getWidth() {
              return 0;
            },
            getWrapperAdIds: function getWrapperAdIds() {
              return [''];
            },
            getWrapperAdSystems: function getWrapperAdSystems() {
              return [''];
            },
            getWrapperCreativeIds: function getWrapperCreativeIds() {
              return [''];
            },
            isLinear: function isLinear() {
              return true;
            },
            isSkippable() {
              return true;
            }
          };
          var CompanionAd = function CompanionAd() {};
          CompanionAd.prototype = {
            getAdSlotId: function getAdSlotId() {
              return '';
            },
            getContent: function getContent() {
              return '';
            },
            getContentType: function getContentType() {
              return '';
            },
            getHeight: function getHeight() {
              return 1;
            },
            getWidth: function getWidth() {
              return 1;
            }
          };
          var AdError = function AdError(type, code, vast, message, adsRequest, userRequestContext) {
            this.errorCode = code;
            this.message = message;
            this.type = type;
            this.adsRequest = adsRequest;
            this.userRequestContext = userRequestContext;
            this.getErrorCode = function () {
              return this.errorCode;
            };
            this.getInnerError = function () {};
            this.getMessage = function () {
              return this.message;
            };
            this.getType = function () {
              return this.type;
            };
            this.getVastErrorCode = function () {
              return this.vastErrorCode;
            };
            this.toString = function () {
              return "AdError ".concat(this.errorCode, ": ").concat(this.message);
            };
          };
          AdError.ErrorCode = {};
          AdError.Type = {};
          var isEngadget = function isEngadget() {
            try {
              for (var _i3 = 0, _Object$values = Object.values(window.vidible._getContexts()); _i3 < _Object$values.length; _i3++) {
                var _ctx$getPlayer, _ctx$getPlayer$div;
                var ctx = _Object$values[_i3];
                if ((_ctx$getPlayer = ctx.getPlayer()) !== null && _ctx$getPlayer !== void 0 && (_ctx$getPlayer$div = _ctx$getPlayer.div) !== null && _ctx$getPlayer$div !== void 0 && _ctx$getPlayer$div.innerHTML.includes('www.engadget.com')) {
                  return true;
                }
              }
            } catch (e) {}
            return false;
          };
          var currentAd = isEngadget() ? undefined : new Ad();
          var AdEvent = function AdEvent(type) {
            this.type = type;
          };
          AdEvent.prototype = {
            getAd: function getAd() {
              return currentAd;
            },
            getAdData: function getAdData() {}
          };
          AdEvent.Type = {
            AD_BREAK_READY: 'adBreakReady',
            AD_BUFFERING: 'adBuffering',
            AD_CAN_PLAY: 'adCanPlay',
            AD_METADATA: 'adMetadata',
            AD_PROGRESS: 'adProgress',
            ALL_ADS_COMPLETED: 'allAdsCompleted',
            CLICK: 'click',
            COMPLETE: 'complete',
            CONTENT_PAUSE_REQUESTED: 'contentPauseRequested',
            CONTENT_RESUME_REQUESTED: 'contentResumeRequested',
            DURATION_CHANGE: 'durationChange',
            EXPANDED_CHANGED: 'expandedChanged',
            FIRST_QUARTILE: 'firstQuartile',
            IMPRESSION: 'impression',
            INTERACTION: 'interaction',
            LINEAR_CHANGE: 'linearChange',
            LINEAR_CHANGED: 'linearChanged',
            LOADED: 'loaded',
            LOG: 'log',
            MIDPOINT: 'midpoint',
            PAUSED: 'pause',
            RESUMED: 'resume',
            SKIPPABLE_STATE_CHANGED: 'skippableStateChanged',
            SKIPPED: 'skip',
            STARTED: 'start',
            THIRD_QUARTILE: 'thirdQuartile',
            USER_CLOSE: 'userClose',
            VIDEO_CLICKED: 'videoClicked',
            VIDEO_ICON_CLICKED: 'videoIconClicked',
            VIEWABLE_IMPRESSION: 'viewable_impression',
            VOLUME_CHANGED: 'volumeChange',
            VOLUME_MUTED: 'mute'
          };
          var AdErrorEvent = function AdErrorEvent(error) {
            this.error = error;
            this.type = 'adError';
            this.getError = function () {
              return this.error;
            };
            this.getUserRequestContext = function () {
              var _this$error;
              if ((_this$error = this.error) !== null && _this$error !== void 0 && _this$error.userRequestContext) {
                return this.error.userRequestContext;
              }
              return {};
            };
          };
          AdErrorEvent.Type = {
            AD_ERROR: 'adError'
          };
          var CustomContentLoadedEvent = function CustomContentLoadedEvent() {};
          CustomContentLoadedEvent.Type = {
            CUSTOM_CONTENT_LOADED: 'deprecated-event'
          };
          var CompanionAdSelectionSettings = function CompanionAdSelectionSettings() {};
          CompanionAdSelectionSettings.CreativeType = {
            ALL: 'All',
            FLASH: 'Flash',
            IMAGE: 'Image'
          };
          CompanionAdSelectionSettings.ResourceType = {
            ALL: 'All',
            HTML: 'Html',
            IFRAME: 'IFrame',
            STATIC: 'Static'
          };
          CompanionAdSelectionSettings.SizeCriteria = {
            IGNORE: 'IgnoreSize',
            SELECT_EXACT_MATCH: 'SelectExactMatch',
            SELECT_NEAR_MATCH: 'SelectNearMatch'
          };
          var AdCuePoints = function AdCuePoints() {};
          AdCuePoints.prototype = {
            getCuePoints: function getCuePoints() {
              return [];
            },
            getAdIdRegistry: function getAdIdRegistry() {
              return '';
            },
            getAdIsValue: function getAdIsValue() {
              return '';
            }
          };
          var AdProgressData = noopFunc;
          var UniversalAdIdInfo = function UniversalAdIdInfo() {};
          Object.assign(ima, {
            AdCuePoints,
            AdDisplayContainer,
            AdError,
            AdErrorEvent,
            AdEvent,
            AdPodInfo,
            AdProgressData,
            AdsLoader,
            AdsManager: manager,
            AdsManagerLoadedEvent,
            AdsRenderingSettings,
            AdsRequest,
            CompanionAd,
            CompanionAdSelectionSettings,
            CustomContentLoadedEvent,
            gptProxyInstance: {},
            ImaSdkSettings,
            OmidAccessMode: {
              DOMAIN: 'domain',
              FULL: 'full',
              LIMITED: 'limited'
            },
            settings: new ImaSdkSettings(),
            UiElements: {
              AD_ATTRIBUTION: 'adAttribution',
              COUNTDOWN: 'countdown'
            },
            UniversalAdIdInfo,
            VERSION,
            ViewMode: {
              FULLSCREEN: 'fullscreen',
              NORMAL: 'normal'
            }
          });
          if (!window.google) {
            window.google = {};
          }
          if ((_window$google$ima = window.google.ima) !== null && _window$google$ima !== void 0 && _window$google$ima.dai) {
            ima.dai = window.google.ima.dai;
          }
          window.google.ima = ima;
          hit(source);
        }
        GoogleIma3.names = ['google-ima3',
        'ubo-google-ima.js',
        'google-ima.js'];
        GoogleIma3.injections = [hit, noopFunc, logMessage];
        function DidomiLoader(source) {
          function UserConsentStatusForVendorSubscribe() {}
          UserConsentStatusForVendorSubscribe.prototype.filter = function () {
            return new UserConsentStatusForVendorSubscribe();
          };
          UserConsentStatusForVendorSubscribe.prototype.subscribe = noopFunc;
          function UserConsentStatusForVendor() {}
          UserConsentStatusForVendor.prototype.first = function () {
            return new UserConsentStatusForVendorSubscribe();
          };
          UserConsentStatusForVendor.prototype.filter = function () {
            return new UserConsentStatusForVendorSubscribe();
          };
          UserConsentStatusForVendor.prototype.subscribe = noopFunc;
          var DidomiWrapper = {
            isConsentRequired: falseFunc,
            getUserConsentStatusForPurpose: trueFunc,
            getUserConsentStatus: trueFunc,
            getUserStatus: noopFunc,
            getRequiredPurposes: noopArray,
            getUserConsentStatusForVendor: trueFunc,
            Purposes: {
              Cookies: 'cookies'
            },
            notice: {
              configure: noopFunc,
              hide: noopFunc,
              isVisible: falseFunc,
              show: noopFunc,
              showDataProcessing: trueFunc
            },
            isUserConsentStatusPartial: falseFunc,
            on() {
              return {
                actions: {},
                emitter: {},
                services: {},
                store: {}
              };
            },
            shouldConsentBeCollected: falseFunc,
            getUserConsentStatusForAll: noopFunc,
            getObservableOnUserConsentStatusForVendor() {
              return new UserConsentStatusForVendor();
            }
          };
          window.Didomi = DidomiWrapper;
          var didomiStateWrapper = {
            didomiExperimentId: '',
            didomiExperimentUserGroup: '',
            didomiGDPRApplies: 1,
            didomiIABConsent: '',
            didomiPurposesConsent: '',
            didomiPurposesConsentDenied: '',
            didomiPurposesConsentUnknown: '',
            didomiVendorsConsent: '',
            didomiVendorsConsentDenied: '',
            didomiVendorsConsentUnknown: '',
            didomiVendorsRawConsent: '',
            didomiVendorsRawConsentDenied: '',
            didomiVendorsRawConsentUnknown: ''
          };
          window.didomiState = didomiStateWrapper;
          var tcData = {
            eventStatus: 'tcloaded',
            gdprApplies: false,
            listenerId: noopFunc,
            vendor: {
              consents: []
            },
            purpose: {
              consents: []
            }
          };
          var __tcfapiWrapper = function __tcfapiWrapper(command, version, callback) {
            if (typeof callback !== 'function' || command === 'removeEventListener') {
              return;
            }
            callback(tcData, true);
          };
          window.__tcfapi = __tcfapiWrapper;
          var didomiEventListenersWrapper = {
            stub: true,
            push: noopFunc
          };
          window.didomiEventListeners = didomiEventListenersWrapper;
          var didomiOnReadyWrapper = {
            stub: true,
            push(arg) {
              if (typeof arg !== 'function') {
                return;
              }
              if (document.readyState !== 'complete') {
                window.addEventListener('load', function () {
                  setTimeout(arg(window.Didomi));
                });
              } else {
                setTimeout(arg(window.Didomi));
              }
            }
          };
          window.didomiOnReady = window.didomiOnReady || didomiOnReadyWrapper;
          if (Array.isArray(window.didomiOnReady)) {
            window.didomiOnReady.forEach(function (arg) {
              if (typeof arg === 'function') {
                try {
                  setTimeout(arg(window.Didomi));
                } catch (e) {
                }
              }
            });
          }
          hit(source);
        }
        DidomiLoader.names = ['didomi-loader'];
        DidomiLoader.injections = [hit, noopFunc, noopArray, trueFunc, falseFunc];
        function Prebid(source) {
          var pushFunction = function pushFunction(arg) {
            if (typeof arg === 'function') {
              try {
                arg.call();
              } catch (ex) {
              }
            }
          };
          var pbjsWrapper = {
            addAdUnits() {},
            adServers: {
              dfp: {
                buildVideoUrl: noopStr
              }
            },
            adUnits: [],
            aliasBidder() {},
            cmd: [],
            enableAnalytics() {},
            getHighestCpmBids: noopArray,
            libLoaded: true,
            que: [],
            requestBids(arg) {
              if (arg instanceof Object && arg.bidsBackHandler) {
                try {
                  arg.bidsBackHandler.call();
                } catch (ex) {
                }
              }
            },
            removeAdUnit() {},
            setBidderConfig() {},
            setConfig() {},
            setTargetingForGPTAsync() {}
          };
          pbjsWrapper.cmd.push = pushFunction;
          pbjsWrapper.que.push = pushFunction;
          window.pbjs = pbjsWrapper;
          hit(source);
        }
        Prebid.names = ['prebid'];
        Prebid.injections = [hit, noopFunc, noopStr, noopArray];
        function prebidAds(source) {
          window.canRunAds = true;
          window.isAdBlockActive = false;
          hit(source);
        }
        prebidAds.names = ['prebid-ads', 'ubo-prebid-ads.js', 'prebid-ads.js'];
        prebidAds.injections = [hit];
        function NaverWcslog(source) {
          window.wcs_add = {};
          window.wcs_do = noopFunc;
          window.wcs = {
            inflow: noopFunc
          };
          hit(source);
        }
        NaverWcslog.names = ['naver-wcslog'];
        NaverWcslog.injections = [hit, noopFunc];
        var redirectsList = Object.freeze({
            __proto__: null,
            ATInternetSmartTag: ATInternetSmartTag,
            AmazonApstag: AmazonApstag,
            DidomiLoader: DidomiLoader,
            Fingerprintjs2: Fingerprintjs2,
            Fingerprintjs3: Fingerprintjs3,
            Gemius: Gemius,
            GoogleAnalytics: GoogleAnalytics,
            GoogleAnalyticsGa: GoogleAnalyticsGa,
            GoogleIma3: GoogleIma3,
            GoogleSyndicationAdsByGoogle: GoogleSyndicationAdsByGoogle,
            GoogleTagServicesGpt: GoogleTagServicesGpt,
            Matomo: Matomo,
            NaverWcslog: NaverWcslog,
            Pardot: Pardot,
            Prebid: Prebid,
            ScoreCardResearchBeacon: ScoreCardResearchBeacon,
            metrikaYandexTag: metrikaYandexTag,
            metrikaYandexWatch: metrikaYandexWatch,
            noeval: noeval$1,
            prebidAds: prebidAds,
            preventBab: preventBab$1,
            preventBab2: preventBab2,
            preventFab: preventFab$1,
            preventPopadsNet: preventPopadsNet$1,
            setPopadsDummy: setPopadsDummy$1
        });
        function _typeof(obj) {
          "@babel/helpers - typeof";
          return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          }, _typeof(obj);
        }
        function _toPrimitive(input, hint) {
          if (_typeof(input) !== "object" || input === null) return input;
          var prim = input[Symbol.toPrimitive];
          if (prim !== undefined) {
            var res = prim.call(input, hint || "default");
            if (_typeof(res) !== "object") return res;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (hint === "string" ? String : Number)(input);
        }
        function _toPropertyKey(arg) {
          var key = _toPrimitive(arg, "string");
          return _typeof(key) === "symbol" ? key : String(key);
        }
        function _defineProperty(obj, key, value) {
          key = _toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function getDefaultExportFromCjs (x) {
        	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
        }
        var jsYaml$2 = {};
        var loader$1 = {};
        var common$6 = {};
        function isNothing(subject) {
          return typeof subject === 'undefined' || subject === null;
        }
        function isObject(subject) {
          return typeof subject === 'object' && subject !== null;
        }
        function toArray(sequence) {
          if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];
          return [sequence];
        }
        function extend(target, source) {
          var index, length, key, sourceKeys;
          if (source) {
            sourceKeys = Object.keys(source);
            for (index = 0, length = sourceKeys.length; index < length; index += 1) {
              key = sourceKeys[index];
              target[key] = source[key];
            }
          }
          return target;
        }
        function repeat(string, count) {
          var result = '',
            cycle;
          for (cycle = 0; cycle < count; cycle += 1) {
            result += string;
          }
          return result;
        }
        function isNegativeZero(number) {
          return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
        }
        common$6.isNothing = isNothing;
        common$6.isObject = isObject;
        common$6.toArray = toArray;
        common$6.repeat = repeat;
        common$6.isNegativeZero = isNegativeZero;
        common$6.extend = extend;
        function YAMLException$4(reason, mark) {
          Error.call(this);
          this.name = 'YAMLException';
          this.reason = reason;
          this.mark = mark;
          this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          } else {
            this.stack = new Error().stack || '';
          }
        }
        YAMLException$4.prototype = Object.create(Error.prototype);
        YAMLException$4.prototype.constructor = YAMLException$4;
        YAMLException$4.prototype.toString = function toString(compact) {
          var result = this.name + ': ';
          result += this.reason || '(unknown reason)';
          if (!compact && this.mark) {
            result += ' ' + this.mark.toString();
          }
          return result;
        };
        var exception = YAMLException$4;
        var common$5 = common$6;
        function Mark$1(name, buffer, position, line, column) {
          this.name = name;
          this.buffer = buffer;
          this.position = position;
          this.line = line;
          this.column = column;
        }
        Mark$1.prototype.getSnippet = function getSnippet(indent, maxLength) {
          var head, start, tail, end, snippet;
          if (!this.buffer) return null;
          indent = indent || 4;
          maxLength = maxLength || 75;
          head = '';
          start = this.position;
          while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
            start -= 1;
            if (this.position - start > maxLength / 2 - 1) {
              head = ' ... ';
              start += 5;
              break;
            }
          }
          tail = '';
          end = this.position;
          while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
            end += 1;
            if (end - this.position > maxLength / 2 - 1) {
              tail = ' ... ';
              end -= 5;
              break;
            }
          }
          snippet = this.buffer.slice(start, end);
          return common$5.repeat(' ', indent) + head + snippet + tail + '\n' + common$5.repeat(' ', indent + this.position - start + head.length) + '^';
        };
        Mark$1.prototype.toString = function toString(compact) {
          var snippet,
            where = '';
          if (this.name) {
            where += 'in "' + this.name + '" ';
          }
          where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);
          if (!compact) {
            snippet = this.getSnippet();
            if (snippet) {
              where += ':\n' + snippet;
            }
          }
          return where;
        };
        var mark = Mark$1;
        var YAMLException$3 = exception;
        var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];
        var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];
        function compileStyleAliases(map) {
          var result = {};
          if (map !== null) {
            Object.keys(map).forEach(function (style) {
              map[style].forEach(function (alias) {
                result[String(alias)] = style;
              });
            });
          }
          return result;
        }
        function Type$h(tag, options) {
          options = options || {};
          Object.keys(options).forEach(function (name) {
            if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
              throw new YAMLException$3('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
            }
          });
          this.tag = tag;
          this.kind = options['kind'] || null;
          this.resolve = options['resolve'] || function () {
            return true;
          };
          this.construct = options['construct'] || function (data) {
            return data;
          };
          this.instanceOf = options['instanceOf'] || null;
          this.predicate = options['predicate'] || null;
          this.represent = options['represent'] || null;
          this.defaultStyle = options['defaultStyle'] || null;
          this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
          if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
            throw new YAMLException$3('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
          }
        }
        var type = Type$h;
        var common$4 = common$6;
        var YAMLException$2 = exception;
        var Type$g = type;
        function compileList(schema, name, result) {
          var exclude = [];
          schema.include.forEach(function (includedSchema) {
            result = compileList(includedSchema, name, result);
          });
          schema[name].forEach(function (currentType) {
            result.forEach(function (previousType, previousIndex) {
              if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
                exclude.push(previousIndex);
              }
            });
            result.push(currentType);
          });
          return result.filter(function (type, index) {
            return exclude.indexOf(index) === -1;
          });
        }
        function compileMap(
        ) {
          var result = {
              scalar: {},
              sequence: {},
              mapping: {},
              fallback: {}
            },
            index,
            length;
          function collectType(type) {
            result[type.kind][type.tag] = result['fallback'][type.tag] = type;
          }
          for (index = 0, length = arguments.length; index < length; index += 1) {
            arguments[index].forEach(collectType);
          }
          return result;
        }
        function Schema$5(definition) {
          this.include = definition.include || [];
          this.implicit = definition.implicit || [];
          this.explicit = definition.explicit || [];
          this.implicit.forEach(function (type) {
            if (type.loadKind && type.loadKind !== 'scalar') {
              throw new YAMLException$2('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
            }
          });
          this.compiledImplicit = compileList(this, 'implicit', []);
          this.compiledExplicit = compileList(this, 'explicit', []);
          this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
        }
        Schema$5.DEFAULT = null;
        Schema$5.create = function createSchema() {
          var schemas, types;
          switch (arguments.length) {
            case 1:
              schemas = Schema$5.DEFAULT;
              types = arguments[0];
              break;
            case 2:
              schemas = arguments[0];
              types = arguments[1];
              break;
            default:
              throw new YAMLException$2('Wrong number of arguments for Schema.create function');
          }
          schemas = common$4.toArray(schemas);
          types = common$4.toArray(types);
          if (!schemas.every(function (schema) {
            return schema instanceof Schema$5;
          })) {
            throw new YAMLException$2('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
          }
          if (!types.every(function (type) {
            return type instanceof Type$g;
          })) {
            throw new YAMLException$2('Specified list of YAML types (or a single Type object) contains a non-Type object.');
          }
          return new Schema$5({
            include: schemas,
            explicit: types
          });
        };
        var schema = Schema$5;
        var Type$f = type;
        var str = new Type$f('tag:yaml.org,2002:str', {
          kind: 'scalar',
          construct: function construct(data) {
            return data !== null ? data : '';
          }
        });
        var Type$e = type;
        var seq = new Type$e('tag:yaml.org,2002:seq', {
          kind: 'sequence',
          construct: function construct(data) {
            return data !== null ? data : [];
          }
        });
        var Type$d = type;
        var map = new Type$d('tag:yaml.org,2002:map', {
          kind: 'mapping',
          construct: function construct(data) {
            return data !== null ? data : {};
          }
        });
        var Schema$4 = schema;
        var failsafe = new Schema$4({
          explicit: [str, seq, map]
        });
        var Type$c = type;
        function resolveYamlNull(data) {
          if (data === null) return true;
          var max = data.length;
          return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
        }
        function constructYamlNull() {
          return null;
        }
        function isNull(object) {
          return object === null;
        }
        var _null = new Type$c('tag:yaml.org,2002:null', {
          kind: 'scalar',
          resolve: resolveYamlNull,
          construct: constructYamlNull,
          predicate: isNull,
          represent: {
            canonical: function canonical() {
              return '~';
            },
            lowercase: function lowercase() {
              return 'null';
            },
            uppercase: function uppercase() {
              return 'NULL';
            },
            camelcase: function camelcase() {
              return 'Null';
            }
          },
          defaultStyle: 'lowercase'
        });
        var Type$b = type;
        function resolveYamlBoolean(data) {
          if (data === null) return false;
          var max = data.length;
          return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
        }
        function constructYamlBoolean(data) {
          return data === 'true' || data === 'True' || data === 'TRUE';
        }
        function isBoolean(object) {
          return Object.prototype.toString.call(object) === '[object Boolean]';
        }
        var bool = new Type$b('tag:yaml.org,2002:bool', {
          kind: 'scalar',
          resolve: resolveYamlBoolean,
          construct: constructYamlBoolean,
          predicate: isBoolean,
          represent: {
            lowercase: function lowercase(object) {
              return object ? 'true' : 'false';
            },
            uppercase: function uppercase(object) {
              return object ? 'TRUE' : 'FALSE';
            },
            camelcase: function camelcase(object) {
              return object ? 'True' : 'False';
            }
          },
          defaultStyle: 'lowercase'
        });
        var common$3 = common$6;
        var Type$a = type;
        function isHexCode(c) {
          return 0x30  <= c && c <= 0x39  || 0x41  <= c && c <= 0x46  || 0x61  <= c && c <= 0x66 ;
        }
        function isOctCode(c) {
          return 0x30  <= c && c <= 0x37 ;
        }
        function isDecCode(c) {
          return 0x30  <= c && c <= 0x39 ;
        }
        function resolveYamlInteger(data) {
          if (data === null) return false;
          var max = data.length,
            index = 0,
            hasDigits = false,
            ch;
          if (!max) return false;
          ch = data[index];
          if (ch === '-' || ch === '+') {
            ch = data[++index];
          }
          if (ch === '0') {
            if (index + 1 === max) return true;
            ch = data[++index];
            if (ch === 'b') {
              index++;
              for (; index < max; index++) {
                ch = data[index];
                if (ch === '_') continue;
                if (ch !== '0' && ch !== '1') return false;
                hasDigits = true;
              }
              return hasDigits && ch !== '_';
            }
            if (ch === 'x') {
              index++;
              for (; index < max; index++) {
                ch = data[index];
                if (ch === '_') continue;
                if (!isHexCode(data.charCodeAt(index))) return false;
                hasDigits = true;
              }
              return hasDigits && ch !== '_';
            }
            for (; index < max; index++) {
              ch = data[index];
              if (ch === '_') continue;
              if (!isOctCode(data.charCodeAt(index))) return false;
              hasDigits = true;
            }
            return hasDigits && ch !== '_';
          }
          if (ch === '_') return false;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === '_') continue;
            if (ch === ':') break;
            if (!isDecCode(data.charCodeAt(index))) {
              return false;
            }
            hasDigits = true;
          }
          if (!hasDigits || ch === '_') return false;
          if (ch !== ':') return true;
          return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
        }
        function constructYamlInteger(data) {
          var value = data,
            sign = 1,
            ch,
            base,
            digits = [];
          if (value.indexOf('_') !== -1) {
            value = value.replace(/_/g, '');
          }
          ch = value[0];
          if (ch === '-' || ch === '+') {
            if (ch === '-') sign = -1;
            value = value.slice(1);
            ch = value[0];
          }
          if (value === '0') return 0;
          if (ch === '0') {
            if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
            if (value[1] === 'x') return sign * parseInt(value, 16);
            return sign * parseInt(value, 8);
          }
          if (value.indexOf(':') !== -1) {
            value.split(':').forEach(function (v) {
              digits.unshift(parseInt(v, 10));
            });
            value = 0;
            base = 1;
            digits.forEach(function (d) {
              value += d * base;
              base *= 60;
            });
            return sign * value;
          }
          return sign * parseInt(value, 10);
        }
        function isInteger(object) {
          return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common$3.isNegativeZero(object);
        }
        var int = new Type$a('tag:yaml.org,2002:int', {
          kind: 'scalar',
          resolve: resolveYamlInteger,
          construct: constructYamlInteger,
          predicate: isInteger,
          represent: {
            binary: function binary(obj) {
              return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);
            },
            octal: function octal(obj) {
              return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1);
            },
            decimal: function decimal(obj) {
              return obj.toString(10);
            },
            hexadecimal: function hexadecimal(obj) {
              return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);
            }
          },
          defaultStyle: 'decimal',
          styleAliases: {
            binary: [2, 'bin'],
            octal: [8, 'oct'],
            decimal: [10, 'dec'],
            hexadecimal: [16, 'hex']
          }
        });
        var common$2 = common$6;
        var Type$9 = type;
        var YAML_FLOAT_PATTERN = new RegExp(
        '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
        '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
        '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
        '|[-+]?\\.(?:inf|Inf|INF)' +
        '|\\.(?:nan|NaN|NAN))$');
        function resolveYamlFloat(data) {
          if (data === null) return false;
          if (!YAML_FLOAT_PATTERN.test(data) ||
          data[data.length - 1] === '_') {
            return false;
          }
          return true;
        }
        function constructYamlFloat(data) {
          var value, sign, base, digits;
          value = data.replace(/_/g, '').toLowerCase();
          sign = value[0] === '-' ? -1 : 1;
          digits = [];
          if ('+-'.indexOf(value[0]) >= 0) {
            value = value.slice(1);
          }
          if (value === '.inf') {
            return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
          } else if (value === '.nan') {
            return NaN;
          } else if (value.indexOf(':') >= 0) {
            value.split(':').forEach(function (v) {
              digits.unshift(parseFloat(v, 10));
            });
            value = 0.0;
            base = 1;
            digits.forEach(function (d) {
              value += d * base;
              base *= 60;
            });
            return sign * value;
          }
          return sign * parseFloat(value, 10);
        }
        var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
        function representYamlFloat(object, style) {
          var res;
          if (isNaN(object)) {
            switch (style) {
              case 'lowercase':
                return '.nan';
              case 'uppercase':
                return '.NAN';
              case 'camelcase':
                return '.NaN';
            }
          } else if (Number.POSITIVE_INFINITY === object) {
            switch (style) {
              case 'lowercase':
                return '.inf';
              case 'uppercase':
                return '.INF';
              case 'camelcase':
                return '.Inf';
            }
          } else if (Number.NEGATIVE_INFINITY === object) {
            switch (style) {
              case 'lowercase':
                return '-.inf';
              case 'uppercase':
                return '-.INF';
              case 'camelcase':
                return '-.Inf';
            }
          } else if (common$2.isNegativeZero(object)) {
            return '-0.0';
          }
          res = object.toString(10);
          return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
        }
        function isFloat(object) {
          return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common$2.isNegativeZero(object));
        }
        var float = new Type$9('tag:yaml.org,2002:float', {
          kind: 'scalar',
          resolve: resolveYamlFloat,
          construct: constructYamlFloat,
          predicate: isFloat,
          represent: representYamlFloat,
          defaultStyle: 'lowercase'
        });
        var Schema$3 = schema;
        var json = new Schema$3({
          include: [failsafe],
          implicit: [_null, bool, int, float]
        });
        var Schema$2 = schema;
        var core = new Schema$2({
          include: [json]
        });
        var Type$8 = type;
        var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +
        '-([0-9][0-9])' +
        '-([0-9][0-9])$');
        var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +
        '-([0-9][0-9]?)' +
        '-([0-9][0-9]?)' +
        '(?:[Tt]|[ \\t]+)' +
        '([0-9][0-9]?)' +
        ':([0-9][0-9])' +
        ':([0-9][0-9])' +
        '(?:\\.([0-9]*))?' +
        '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' +
        '(?::([0-9][0-9]))?))?$');
        function resolveYamlTimestamp(data) {
          if (data === null) return false;
          if (YAML_DATE_REGEXP.exec(data) !== null) return true;
          if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
          return false;
        }
        function constructYamlTimestamp(data) {
          var match,
            year,
            month,
            day,
            hour,
            minute,
            second,
            fraction = 0,
            delta = null,
            tz_hour,
            tz_minute,
            date;
          match = YAML_DATE_REGEXP.exec(data);
          if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
          if (match === null) throw new Error('Date resolve error');
          year = +match[1];
          month = +match[2] - 1;
          day = +match[3];
          if (!match[4]) {
            return new Date(Date.UTC(year, month, day));
          }
          hour = +match[4];
          minute = +match[5];
          second = +match[6];
          if (match[7]) {
            fraction = match[7].slice(0, 3);
            while (fraction.length < 3) {
              fraction += '0';
            }
            fraction = +fraction;
          }
          if (match[9]) {
            tz_hour = +match[10];
            tz_minute = +(match[11] || 0);
            delta = (tz_hour * 60 + tz_minute) * 60000;
            if (match[9] === '-') delta = -delta;
          }
          date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
          if (delta) date.setTime(date.getTime() - delta);
          return date;
        }
        function representYamlTimestamp(object ) {
          return object.toISOString();
        }
        var timestamp = new Type$8('tag:yaml.org,2002:timestamp', {
          kind: 'scalar',
          resolve: resolveYamlTimestamp,
          construct: constructYamlTimestamp,
          instanceOf: Date,
          represent: representYamlTimestamp
        });
        var Type$7 = type;
        function resolveYamlMerge(data) {
          return data === '<<' || data === null;
        }
        var merge = new Type$7('tag:yaml.org,2002:merge', {
          kind: 'scalar',
          resolve: resolveYamlMerge
        });
        function commonjsRequire(path) {
        	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
        }
        var NodeBuffer;
        try {
          var _require$1 = commonjsRequire;
          NodeBuffer = _require$1('buffer').Buffer;
        } catch (__) {}
        var Type$6 = type;
        var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
        function resolveYamlBinary(data) {
          if (data === null) return false;
          var code,
            idx,
            bitlen = 0,
            max = data.length,
            map = BASE64_MAP;
          for (idx = 0; idx < max; idx++) {
            code = map.indexOf(data.charAt(idx));
            if (code > 64) continue;
            if (code < 0) return false;
            bitlen += 6;
          }
          return bitlen % 8 === 0;
        }
        function constructYamlBinary(data) {
          var idx,
            tailbits,
            input = data.replace(/[\r\n=]/g, ''),
            max = input.length,
            map = BASE64_MAP,
            bits = 0,
            result = [];
          for (idx = 0; idx < max; idx++) {
            if (idx % 4 === 0 && idx) {
              result.push(bits >> 16 & 0xFF);
              result.push(bits >> 8 & 0xFF);
              result.push(bits & 0xFF);
            }
            bits = bits << 6 | map.indexOf(input.charAt(idx));
          }
          tailbits = max % 4 * 6;
          if (tailbits === 0) {
            result.push(bits >> 16 & 0xFF);
            result.push(bits >> 8 & 0xFF);
            result.push(bits & 0xFF);
          } else if (tailbits === 18) {
            result.push(bits >> 10 & 0xFF);
            result.push(bits >> 2 & 0xFF);
          } else if (tailbits === 12) {
            result.push(bits >> 4 & 0xFF);
          }
          if (NodeBuffer) {
            return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
          }
          return result;
        }
        function representYamlBinary(object ) {
          var result = '',
            bits = 0,
            idx,
            tail,
            max = object.length,
            map = BASE64_MAP;
          for (idx = 0; idx < max; idx++) {
            if (idx % 3 === 0 && idx) {
              result += map[bits >> 18 & 0x3F];
              result += map[bits >> 12 & 0x3F];
              result += map[bits >> 6 & 0x3F];
              result += map[bits & 0x3F];
            }
            bits = (bits << 8) + object[idx];
          }
          tail = max % 3;
          if (tail === 0) {
            result += map[bits >> 18 & 0x3F];
            result += map[bits >> 12 & 0x3F];
            result += map[bits >> 6 & 0x3F];
            result += map[bits & 0x3F];
          } else if (tail === 2) {
            result += map[bits >> 10 & 0x3F];
            result += map[bits >> 4 & 0x3F];
            result += map[bits << 2 & 0x3F];
            result += map[64];
          } else if (tail === 1) {
            result += map[bits >> 2 & 0x3F];
            result += map[bits << 4 & 0x3F];
            result += map[64];
            result += map[64];
          }
          return result;
        }
        function isBinary(object) {
          return NodeBuffer && NodeBuffer.isBuffer(object);
        }
        var binary = new Type$6('tag:yaml.org,2002:binary', {
          kind: 'scalar',
          resolve: resolveYamlBinary,
          construct: constructYamlBinary,
          predicate: isBinary,
          represent: representYamlBinary
        });
        var Type$5 = type;
        var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
        var _toString$2 = Object.prototype.toString;
        function resolveYamlOmap(data) {
          if (data === null) return true;
          var objectKeys = [],
            index,
            length,
            pair,
            pairKey,
            pairHasKey,
            object = data;
          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            pairHasKey = false;
            if (_toString$2.call(pair) !== '[object Object]') return false;
            for (pairKey in pair) {
              if (_hasOwnProperty$3.call(pair, pairKey)) {
                if (!pairHasKey) pairHasKey = true;else return false;
              }
            }
            if (!pairHasKey) return false;
            if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;
          }
          return true;
        }
        function constructYamlOmap(data) {
          return data !== null ? data : [];
        }
        var omap = new Type$5('tag:yaml.org,2002:omap', {
          kind: 'sequence',
          resolve: resolveYamlOmap,
          construct: constructYamlOmap
        });
        var Type$4 = type;
        var _toString$1 = Object.prototype.toString;
        function resolveYamlPairs(data) {
          if (data === null) return true;
          var index,
            length,
            pair,
            keys,
            result,
            object = data;
          result = new Array(object.length);
          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            if (_toString$1.call(pair) !== '[object Object]') return false;
            keys = Object.keys(pair);
            if (keys.length !== 1) return false;
            result[index] = [keys[0], pair[keys[0]]];
          }
          return true;
        }
        function constructYamlPairs(data) {
          if (data === null) return [];
          var index,
            length,
            pair,
            keys,
            result,
            object = data;
          result = new Array(object.length);
          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            keys = Object.keys(pair);
            result[index] = [keys[0], pair[keys[0]]];
          }
          return result;
        }
        var pairs = new Type$4('tag:yaml.org,2002:pairs', {
          kind: 'sequence',
          resolve: resolveYamlPairs,
          construct: constructYamlPairs
        });
        var Type$3 = type;
        var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
        function resolveYamlSet(data) {
          if (data === null) return true;
          var key,
            object = data;
          for (key in object) {
            if (_hasOwnProperty$2.call(object, key)) {
              if (object[key] !== null) return false;
            }
          }
          return true;
        }
        function constructYamlSet(data) {
          return data !== null ? data : {};
        }
        var set = new Type$3('tag:yaml.org,2002:set', {
          kind: 'mapping',
          resolve: resolveYamlSet,
          construct: constructYamlSet
        });
        var Schema$1 = schema;
        var default_safe = new Schema$1({
          include: [core],
          implicit: [timestamp, merge],
          explicit: [binary, omap, pairs, set]
        });
        var Type$2 = type;
        function resolveJavascriptUndefined() {
          return true;
        }
        function constructJavascriptUndefined() {
          return undefined;
        }
        function representJavascriptUndefined() {
          return '';
        }
        function isUndefined(object) {
          return typeof object === 'undefined';
        }
        var _undefined = new Type$2('tag:yaml.org,2002:js/undefined', {
          kind: 'scalar',
          resolve: resolveJavascriptUndefined,
          construct: constructJavascriptUndefined,
          predicate: isUndefined,
          represent: representJavascriptUndefined
        });
        var Type$1 = type;
        function resolveJavascriptRegExp(data) {
          if (data === null) return false;
          if (data.length === 0) return false;
          var regexp = data,
            tail = /\/([gim]*)$/.exec(data),
            modifiers = '';
          if (regexp[0] === '/') {
            if (tail) modifiers = tail[1];
            if (modifiers.length > 3) return false;
            if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
          }
          return true;
        }
        function constructJavascriptRegExp(data) {
          var regexp = data,
            tail = /\/([gim]*)$/.exec(data),
            modifiers = '';
          if (regexp[0] === '/') {
            if (tail) modifiers = tail[1];
            regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
          }
          return new RegExp(regexp, modifiers);
        }
        function representJavascriptRegExp(object ) {
          var result = '/' + object.source + '/';
          if (object.global) result += 'g';
          if (object.multiline) result += 'm';
          if (object.ignoreCase) result += 'i';
          return result;
        }
        function isRegExp(object) {
          return Object.prototype.toString.call(object) === '[object RegExp]';
        }
        var regexp = new Type$1('tag:yaml.org,2002:js/regexp', {
          kind: 'scalar',
          resolve: resolveJavascriptRegExp,
          construct: constructJavascriptRegExp,
          predicate: isRegExp,
          represent: representJavascriptRegExp
        });
        var esprima;
        try {
          var _require = commonjsRequire;
          esprima = _require('esprima');
        } catch (_) {
          if (typeof window !== 'undefined') esprima = window.esprima;
        }
        var Type = type;
        function resolveJavascriptFunction(data) {
          if (data === null) return false;
          try {
            var source = '(' + data + ')',
              ast = esprima.parse(source, {
                range: true
              });
            if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
              return false;
            }
            return true;
          } catch (err) {
            return false;
          }
        }
        function constructJavascriptFunction(data) {
          var source = '(' + data + ')',
            ast = esprima.parse(source, {
              range: true
            }),
            params = [],
            body;
          if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
            throw new Error('Failed to resolve function');
          }
          ast.body[0].expression.params.forEach(function (param) {
            params.push(param.name);
          });
          body = ast.body[0].expression.body.range;
          if (ast.body[0].expression.body.type === 'BlockStatement') {
            return new Function(params, source.slice(body[0] + 1, body[1] - 1));
          }
          return new Function(params, 'return ' + source.slice(body[0], body[1]));
        }
        function representJavascriptFunction(object ) {
          return object.toString();
        }
        function isFunction(object) {
          return Object.prototype.toString.call(object) === '[object Function]';
        }
        var _function = new Type('tag:yaml.org,2002:js/function', {
          kind: 'scalar',
          resolve: resolveJavascriptFunction,
          construct: constructJavascriptFunction,
          predicate: isFunction,
          represent: representJavascriptFunction
        });
        var Schema = schema;
        var default_full = Schema.DEFAULT = new Schema({
          include: [default_safe],
          explicit: [_undefined, regexp, _function]
        });
        var common$1 = common$6;
        var YAMLException$1 = exception;
        var Mark = mark;
        var DEFAULT_SAFE_SCHEMA$1 = default_safe;
        var DEFAULT_FULL_SCHEMA$1 = default_full;
        var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
        var CONTEXT_FLOW_IN = 1;
        var CONTEXT_FLOW_OUT = 2;
        var CONTEXT_BLOCK_IN = 3;
        var CONTEXT_BLOCK_OUT = 4;
        var CHOMPING_CLIP = 1;
        var CHOMPING_STRIP = 2;
        var CHOMPING_KEEP = 3;
        var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
        var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
        var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
        var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
        var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
        function _class(obj) {
          return Object.prototype.toString.call(obj);
        }
        function is_EOL(c) {
          return c === 0x0A  || c === 0x0D ;
        }
        function is_WHITE_SPACE(c) {
          return c === 0x09  || c === 0x20 ;
        }
        function is_WS_OR_EOL(c) {
          return c === 0x09  || c === 0x20  || c === 0x0A  || c === 0x0D ;
        }
        function is_FLOW_INDICATOR(c) {
          return c === 0x2C  || c === 0x5B  || c === 0x5D  || c === 0x7B  || c === 0x7D ;
        }
        function fromHexCode(c) {
          var lc;
          if (0x30  <= c && c <= 0x39 ) {
            return c - 0x30;
          }
          lc = c | 0x20;
          if (0x61  <= lc && lc <= 0x66 ) {
            return lc - 0x61 + 10;
          }
          return -1;
        }
        function escapedHexLen(c) {
          if (c === 0x78 ) {
            return 2;
          }
          if (c === 0x75 ) {
            return 4;
          }
          if (c === 0x55 ) {
            return 8;
          }
          return 0;
        }
        function fromDecimalCode(c) {
          if (0x30  <= c && c <= 0x39 ) {
            return c - 0x30;
          }
          return -1;
        }
        function simpleEscapeSequence(c) {
          return c === 0x30  ? '\x00' : c === 0x61  ? '\x07' : c === 0x62  ? '\x08' : c === 0x74  ? '\x09' : c === 0x09  ? '\x09' : c === 0x6E  ? '\x0A' : c === 0x76  ? '\x0B' : c === 0x66  ? '\x0C' : c === 0x72  ? '\x0D' : c === 0x65  ? '\x1B' : c === 0x20  ? ' ' : c === 0x22  ? '\x22' : c === 0x2F  ? '/' : c === 0x5C  ? '\x5C' : c === 0x4E  ? '\x85' : c === 0x5F  ? '\xA0' : c === 0x4C  ? "\u2028" : c === 0x50  ? "\u2029" : '';
        }
        function charFromCodepoint(c) {
          if (c <= 0xFFFF) {
            return String.fromCharCode(c);
          }
          return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
        }
        var simpleEscapeCheck = new Array(256);
        var simpleEscapeMap = new Array(256);
        for (var i = 0; i < 256; i++) {
          simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
          simpleEscapeMap[i] = simpleEscapeSequence(i);
        }
        function State$1(input, options) {
          this.input = input;
          this.filename = options['filename'] || null;
          this.schema = options['schema'] || DEFAULT_FULL_SCHEMA$1;
          this.onWarning = options['onWarning'] || null;
          this.legacy = options['legacy'] || false;
          this.json = options['json'] || false;
          this.listener = options['listener'] || null;
          this.implicitTypes = this.schema.compiledImplicit;
          this.typeMap = this.schema.compiledTypeMap;
          this.length = input.length;
          this.position = 0;
          this.line = 0;
          this.lineStart = 0;
          this.lineIndent = 0;
          this.documents = [];
        }
        function generateError(state, message) {
          return new YAMLException$1(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
        }
        function throwError(state, message) {
          throw generateError(state, message);
        }
        function throwWarning(state, message) {
          if (state.onWarning) {
            state.onWarning.call(null, generateError(state, message));
          }
        }
        var directiveHandlers = {
          YAML: function handleYamlDirective(state, name, args) {
            var match, major, minor;
            if (state.version !== null) {
              throwError(state, 'duplication of %YAML directive');
            }
            if (args.length !== 1) {
              throwError(state, 'YAML directive accepts exactly one argument');
            }
            match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
            if (match === null) {
              throwError(state, 'ill-formed argument of the YAML directive');
            }
            major = parseInt(match[1], 10);
            minor = parseInt(match[2], 10);
            if (major !== 1) {
              throwError(state, 'unacceptable YAML version of the document');
            }
            state.version = args[0];
            state.checkLineBreaks = minor < 2;
            if (minor !== 1 && minor !== 2) {
              throwWarning(state, 'unsupported YAML version of the document');
            }
          },
          TAG: function handleTagDirective(state, name, args) {
            var handle, prefix;
            if (args.length !== 2) {
              throwError(state, 'TAG directive accepts exactly two arguments');
            }
            handle = args[0];
            prefix = args[1];
            if (!PATTERN_TAG_HANDLE.test(handle)) {
              throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
            }
            if (_hasOwnProperty$1.call(state.tagMap, handle)) {
              throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
            }
            if (!PATTERN_TAG_URI.test(prefix)) {
              throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
            }
            state.tagMap[handle] = prefix;
          }
        };
        function captureSegment(state, start, end, checkJson) {
          var _position, _length, _character, _result;
          if (start < end) {
            _result = state.input.slice(start, end);
            if (checkJson) {
              for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
                _character = _result.charCodeAt(_position);
                if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
                  throwError(state, 'expected valid JSON character');
                }
              }
            } else if (PATTERN_NON_PRINTABLE.test(_result)) {
              throwError(state, 'the stream contains non-printable characters');
            }
            state.result += _result;
          }
        }
        function mergeMappings(state, destination, source, overridableKeys) {
          var sourceKeys, key, index, quantity;
          if (!common$1.isObject(source)) {
            throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
          }
          sourceKeys = Object.keys(source);
          for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
            key = sourceKeys[index];
            if (!_hasOwnProperty$1.call(destination, key)) {
              destination[key] = source[key];
              overridableKeys[key] = true;
            }
          }
        }
        function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
          var index, quantity;
          if (Array.isArray(keyNode)) {
            keyNode = Array.prototype.slice.call(keyNode);
            for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
              if (Array.isArray(keyNode[index])) {
                throwError(state, 'nested arrays are not supported inside keys');
              }
              if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
                keyNode[index] = '[object Object]';
              }
            }
          }
          if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
            keyNode = '[object Object]';
          }
          keyNode = String(keyNode);
          if (_result === null) {
            _result = {};
          }
          if (keyTag === 'tag:yaml.org,2002:merge') {
            if (Array.isArray(valueNode)) {
              for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
                mergeMappings(state, _result, valueNode[index], overridableKeys);
              }
            } else {
              mergeMappings(state, _result, valueNode, overridableKeys);
            }
          } else {
            if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
              state.line = startLine || state.line;
              state.position = startPos || state.position;
              throwError(state, 'duplicated mapping key');
            }
            _result[keyNode] = valueNode;
            delete overridableKeys[keyNode];
          }
          return _result;
        }
        function readLineBreak(state) {
          var ch;
          ch = state.input.charCodeAt(state.position);
          if (ch === 0x0A ) {
            state.position++;
          } else if (ch === 0x0D ) {
            state.position++;
            if (state.input.charCodeAt(state.position) === 0x0A ) {
              state.position++;
            }
          } else {
            throwError(state, 'a line break is expected');
          }
          state.line += 1;
          state.lineStart = state.position;
        }
        function skipSeparationSpace(state, allowComments, checkIndent) {
          var lineBreaks = 0,
            ch = state.input.charCodeAt(state.position);
          while (ch !== 0) {
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (allowComments && ch === 0x23 ) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (ch !== 0x0A  && ch !== 0x0D  && ch !== 0);
            }
            if (is_EOL(ch)) {
              readLineBreak(state);
              ch = state.input.charCodeAt(state.position);
              lineBreaks++;
              state.lineIndent = 0;
              while (ch === 0x20 ) {
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
              }
            } else {
              break;
            }
          }
          if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
            throwWarning(state, 'deficient indentation');
          }
          return lineBreaks;
        }
        function testDocumentSeparator(state) {
          var _position = state.position,
            ch;
          ch = state.input.charCodeAt(_position);
          if ((ch === 0x2D  || ch === 0x2E ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
            _position += 3;
            ch = state.input.charCodeAt(_position);
            if (ch === 0 || is_WS_OR_EOL(ch)) {
              return true;
            }
          }
          return false;
        }
        function writeFoldedLines(state, count) {
          if (count === 1) {
            state.result += ' ';
          } else if (count > 1) {
            state.result += common$1.repeat('\n', count - 1);
          }
        }
        function readPlainScalar(state, nodeIndent, withinFlowCollection) {
          var preceding,
            following,
            captureStart,
            captureEnd,
            hasPendingContent,
            _line,
            _lineStart,
            _lineIndent,
            _kind = state.kind,
            _result = state.result,
            ch;
          ch = state.input.charCodeAt(state.position);
          if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23  || ch === 0x26  || ch === 0x2A  || ch === 0x21  || ch === 0x7C  || ch === 0x3E  || ch === 0x27  || ch === 0x22  || ch === 0x25  || ch === 0x40  || ch === 0x60 ) {
            return false;
          }
          if (ch === 0x3F  || ch === 0x2D ) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
              return false;
            }
          }
          state.kind = 'scalar';
          state.result = '';
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
          while (ch !== 0) {
            if (ch === 0x3A ) {
              following = state.input.charCodeAt(state.position + 1);
              if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
                break;
              }
            } else if (ch === 0x23 ) {
              preceding = state.input.charCodeAt(state.position - 1);
              if (is_WS_OR_EOL(preceding)) {
                break;
              }
            } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
              break;
            } else if (is_EOL(ch)) {
              _line = state.line;
              _lineStart = state.lineStart;
              _lineIndent = state.lineIndent;
              skipSeparationSpace(state, false, -1);
              if (state.lineIndent >= nodeIndent) {
                hasPendingContent = true;
                ch = state.input.charCodeAt(state.position);
                continue;
              } else {
                state.position = captureEnd;
                state.line = _line;
                state.lineStart = _lineStart;
                state.lineIndent = _lineIndent;
                break;
              }
            }
            if (hasPendingContent) {
              captureSegment(state, captureStart, captureEnd, false);
              writeFoldedLines(state, state.line - _line);
              captureStart = captureEnd = state.position;
              hasPendingContent = false;
            }
            if (!is_WHITE_SPACE(ch)) {
              captureEnd = state.position + 1;
            }
            ch = state.input.charCodeAt(++state.position);
          }
          captureSegment(state, captureStart, captureEnd, false);
          if (state.result) {
            return true;
          }
          state.kind = _kind;
          state.result = _result;
          return false;
        }
        function readSingleQuotedScalar(state, nodeIndent) {
          var ch, captureStart, captureEnd;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 0x27 ) {
            return false;
          }
          state.kind = 'scalar';
          state.result = '';
          state.position++;
          captureStart = captureEnd = state.position;
          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            if (ch === 0x27 ) {
              captureSegment(state, captureStart, state.position, true);
              ch = state.input.charCodeAt(++state.position);
              if (ch === 0x27 ) {
                captureStart = state.position;
                state.position++;
                captureEnd = state.position;
              } else {
                return true;
              }
            } else if (is_EOL(ch)) {
              captureSegment(state, captureStart, captureEnd, true);
              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
              captureStart = captureEnd = state.position;
            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
              throwError(state, 'unexpected end of the document within a single quoted scalar');
            } else {
              state.position++;
              captureEnd = state.position;
            }
          }
          throwError(state, 'unexpected end of the stream within a single quoted scalar');
        }
        function readDoubleQuotedScalar(state, nodeIndent) {
          var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 0x22 ) {
            return false;
          }
          state.kind = 'scalar';
          state.result = '';
          state.position++;
          captureStart = captureEnd = state.position;
          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            if (ch === 0x22 ) {
              captureSegment(state, captureStart, state.position, true);
              state.position++;
              return true;
            } else if (ch === 0x5C ) {
              captureSegment(state, captureStart, state.position, true);
              ch = state.input.charCodeAt(++state.position);
              if (is_EOL(ch)) {
                skipSeparationSpace(state, false, nodeIndent);
              } else if (ch < 256 && simpleEscapeCheck[ch]) {
                state.result += simpleEscapeMap[ch];
                state.position++;
              } else if ((tmp = escapedHexLen(ch)) > 0) {
                hexLength = tmp;
                hexResult = 0;
                for (; hexLength > 0; hexLength--) {
                  ch = state.input.charCodeAt(++state.position);
                  if ((tmp = fromHexCode(ch)) >= 0) {
                    hexResult = (hexResult << 4) + tmp;
                  } else {
                    throwError(state, 'expected hexadecimal character');
                  }
                }
                state.result += charFromCodepoint(hexResult);
                state.position++;
              } else {
                throwError(state, 'unknown escape sequence');
              }
              captureStart = captureEnd = state.position;
            } else if (is_EOL(ch)) {
              captureSegment(state, captureStart, captureEnd, true);
              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
              captureStart = captureEnd = state.position;
            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
              throwError(state, 'unexpected end of the document within a double quoted scalar');
            } else {
              state.position++;
              captureEnd = state.position;
            }
          }
          throwError(state, 'unexpected end of the stream within a double quoted scalar');
        }
        function readFlowCollection(state, nodeIndent) {
          var readNext = true,
            _line,
            _tag = state.tag,
            _result,
            _anchor = state.anchor,
            following,
            terminator,
            isPair,
            isExplicitPair,
            isMapping,
            overridableKeys = {},
            keyNode,
            keyTag,
            valueNode,
            ch;
          ch = state.input.charCodeAt(state.position);
          if (ch === 0x5B ) {
            terminator = 0x5D;
            isMapping = false;
            _result = [];
          } else if (ch === 0x7B ) {
            terminator = 0x7D;
            isMapping = true;
            _result = {};
          } else {
            return false;
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }
          ch = state.input.charCodeAt(++state.position);
          while (ch !== 0) {
            skipSeparationSpace(state, true, nodeIndent);
            ch = state.input.charCodeAt(state.position);
            if (ch === terminator) {
              state.position++;
              state.tag = _tag;
              state.anchor = _anchor;
              state.kind = isMapping ? 'mapping' : 'sequence';
              state.result = _result;
              return true;
            } else if (!readNext) {
              throwError(state, 'missed comma between flow collection entries');
            }
            keyTag = keyNode = valueNode = null;
            isPair = isExplicitPair = false;
            if (ch === 0x3F ) {
              following = state.input.charCodeAt(state.position + 1);
              if (is_WS_OR_EOL(following)) {
                isPair = isExplicitPair = true;
                state.position++;
                skipSeparationSpace(state, true, nodeIndent);
              }
            }
            _line = state.line;
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
            keyTag = state.tag;
            keyNode = state.result;
            skipSeparationSpace(state, true, nodeIndent);
            ch = state.input.charCodeAt(state.position);
            if ((isExplicitPair || state.line === _line) && ch === 0x3A ) {
              isPair = true;
              ch = state.input.charCodeAt(++state.position);
              skipSeparationSpace(state, true, nodeIndent);
              composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
              valueNode = state.result;
            }
            if (isMapping) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
            } else if (isPair) {
              _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
            } else {
              _result.push(keyNode);
            }
            skipSeparationSpace(state, true, nodeIndent);
            ch = state.input.charCodeAt(state.position);
            if (ch === 0x2C ) {
              readNext = true;
              ch = state.input.charCodeAt(++state.position);
            } else {
              readNext = false;
            }
          }
          throwError(state, 'unexpected end of the stream within a flow collection');
        }
        function readBlockScalar(state, nodeIndent) {
          var captureStart,
            folding,
            chomping = CHOMPING_CLIP,
            didReadContent = false,
            detectedIndent = false,
            textIndent = nodeIndent,
            emptyLines = 0,
            atMoreIndented = false,
            tmp,
            ch;
          ch = state.input.charCodeAt(state.position);
          if (ch === 0x7C ) {
            folding = false;
          } else if (ch === 0x3E ) {
            folding = true;
          } else {
            return false;
          }
          state.kind = 'scalar';
          state.result = '';
          while (ch !== 0) {
            ch = state.input.charCodeAt(++state.position);
            if (ch === 0x2B  || ch === 0x2D ) {
              if (CHOMPING_CLIP === chomping) {
                chomping = ch === 0x2B  ? CHOMPING_KEEP : CHOMPING_STRIP;
              } else {
                throwError(state, 'repeat of a chomping mode identifier');
              }
            } else if ((tmp = fromDecimalCode(ch)) >= 0) {
              if (tmp === 0) {
                throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
              } else if (!detectedIndent) {
                textIndent = nodeIndent + tmp - 1;
                detectedIndent = true;
              } else {
                throwError(state, 'repeat of an indentation width identifier');
              }
            } else {
              break;
            }
          }
          if (is_WHITE_SPACE(ch)) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (is_WHITE_SPACE(ch));
            if (ch === 0x23 ) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (!is_EOL(ch) && ch !== 0);
            }
          }
          while (ch !== 0) {
            readLineBreak(state);
            state.lineIndent = 0;
            ch = state.input.charCodeAt(state.position);
            while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 ) {
              state.lineIndent++;
              ch = state.input.charCodeAt(++state.position);
            }
            if (!detectedIndent && state.lineIndent > textIndent) {
              textIndent = state.lineIndent;
            }
            if (is_EOL(ch)) {
              emptyLines++;
              continue;
            }
            if (state.lineIndent < textIndent) {
              if (chomping === CHOMPING_KEEP) {
                state.result += common$1.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
              } else if (chomping === CHOMPING_CLIP) {
                if (didReadContent) {
                  state.result += '\n';
                }
              }
              break;
            }
            if (folding) {
              if (is_WHITE_SPACE(ch)) {
                atMoreIndented = true;
                state.result += common$1.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
              } else if (atMoreIndented) {
                atMoreIndented = false;
                state.result += common$1.repeat('\n', emptyLines + 1);
              } else if (emptyLines === 0) {
                if (didReadContent) {
                  state.result += ' ';
                }
              } else {
                state.result += common$1.repeat('\n', emptyLines);
              }
            } else {
              state.result += common$1.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
            }
            didReadContent = true;
            detectedIndent = true;
            emptyLines = 0;
            captureStart = state.position;
            while (!is_EOL(ch) && ch !== 0) {
              ch = state.input.charCodeAt(++state.position);
            }
            captureSegment(state, captureStart, state.position, false);
          }
          return true;
        }
        function readBlockSequence(state, nodeIndent) {
          var _line,
            _tag = state.tag,
            _anchor = state.anchor,
            _result = [],
            following,
            detected = false,
            ch;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }
          ch = state.input.charCodeAt(state.position);
          while (ch !== 0) {
            if (ch !== 0x2D ) {
              break;
            }
            following = state.input.charCodeAt(state.position + 1);
            if (!is_WS_OR_EOL(following)) {
              break;
            }
            detected = true;
            state.position++;
            if (skipSeparationSpace(state, true, -1)) {
              if (state.lineIndent <= nodeIndent) {
                _result.push(null);
                ch = state.input.charCodeAt(state.position);
                continue;
              }
            }
            _line = state.line;
            composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
            _result.push(state.result);
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
            if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
              throwError(state, 'bad indentation of a sequence entry');
            } else if (state.lineIndent < nodeIndent) {
              break;
            }
          }
          if (detected) {
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = 'sequence';
            state.result = _result;
            return true;
          }
          return false;
        }
        function readBlockMapping(state, nodeIndent, flowIndent) {
          var following,
            allowCompact,
            _line,
            _pos,
            _tag = state.tag,
            _anchor = state.anchor,
            _result = {},
            overridableKeys = {},
            keyTag = null,
            keyNode = null,
            valueNode = null,
            atExplicitKey = false,
            detected = false,
            ch;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }
          ch = state.input.charCodeAt(state.position);
          while (ch !== 0) {
            following = state.input.charCodeAt(state.position + 1);
            _line = state.line;
            _pos = state.position;
            if ((ch === 0x3F  || ch === 0x3A ) && is_WS_OR_EOL(following)) {
              if (ch === 0x3F ) {
                if (atExplicitKey) {
                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                  keyTag = keyNode = valueNode = null;
                }
                detected = true;
                atExplicitKey = true;
                allowCompact = true;
              } else if (atExplicitKey) {
                atExplicitKey = false;
                allowCompact = true;
              } else {
                throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
              }
              state.position += 1;
              ch = following;
            } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
              if (state.line === _line) {
                ch = state.input.charCodeAt(state.position);
                while (is_WHITE_SPACE(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }
                if (ch === 0x3A ) {
                  ch = state.input.charCodeAt(++state.position);
                  if (!is_WS_OR_EOL(ch)) {
                    throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
                  }
                  if (atExplicitKey) {
                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                    keyTag = keyNode = valueNode = null;
                  }
                  detected = true;
                  atExplicitKey = false;
                  allowCompact = false;
                  keyTag = state.tag;
                  keyNode = state.result;
                } else if (detected) {
                  throwError(state, 'can not read an implicit mapping pair; a colon is missed');
                } else {
                  state.tag = _tag;
                  state.anchor = _anchor;
                  return true;
                }
              } else if (detected) {
                throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
              } else {
                state.tag = _tag;
                state.anchor = _anchor;
                return true;
              }
            } else {
              break;
            }
            if (state.line === _line || state.lineIndent > nodeIndent) {
              if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
                if (atExplicitKey) {
                  keyNode = state.result;
                } else {
                  valueNode = state.result;
                }
              }
              if (!atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
                keyTag = keyNode = valueNode = null;
              }
              skipSeparationSpace(state, true, -1);
              ch = state.input.charCodeAt(state.position);
            }
            if (state.lineIndent > nodeIndent && ch !== 0) {
              throwError(state, 'bad indentation of a mapping entry');
            } else if (state.lineIndent < nodeIndent) {
              break;
            }
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          }
          if (detected) {
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = 'mapping';
            state.result = _result;
          }
          return detected;
        }
        function readTagProperty(state) {
          var _position,
            isVerbatim = false,
            isNamed = false,
            tagHandle,
            tagName,
            ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 0x21 ) return false;
          if (state.tag !== null) {
            throwError(state, 'duplication of a tag property');
          }
          ch = state.input.charCodeAt(++state.position);
          if (ch === 0x3C ) {
            isVerbatim = true;
            ch = state.input.charCodeAt(++state.position);
          } else if (ch === 0x21 ) {
            isNamed = true;
            tagHandle = '!!';
            ch = state.input.charCodeAt(++state.position);
          } else {
            tagHandle = '!';
          }
          _position = state.position;
          if (isVerbatim) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && ch !== 0x3E );
            if (state.position < state.length) {
              tagName = state.input.slice(_position, state.position);
              ch = state.input.charCodeAt(++state.position);
            } else {
              throwError(state, 'unexpected end of the stream within a verbatim tag');
            }
          } else {
            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              if (ch === 0x21 ) {
                if (!isNamed) {
                  tagHandle = state.input.slice(_position - 1, state.position + 1);
                  if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                    throwError(state, 'named tag handle cannot contain such characters');
                  }
                  isNamed = true;
                  _position = state.position + 1;
                } else {
                  throwError(state, 'tag suffix cannot contain exclamation marks');
                }
              }
              ch = state.input.charCodeAt(++state.position);
            }
            tagName = state.input.slice(_position, state.position);
            if (PATTERN_FLOW_INDICATORS.test(tagName)) {
              throwError(state, 'tag suffix cannot contain flow indicator characters');
            }
          }
          if (tagName && !PATTERN_TAG_URI.test(tagName)) {
            throwError(state, 'tag name cannot contain such characters: ' + tagName);
          }
          if (isVerbatim) {
            state.tag = tagName;
          } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
            state.tag = state.tagMap[tagHandle] + tagName;
          } else if (tagHandle === '!') {
            state.tag = '!' + tagName;
          } else if (tagHandle === '!!') {
            state.tag = 'tag:yaml.org,2002:' + tagName;
          } else {
            throwError(state, 'undeclared tag handle "' + tagHandle + '"');
          }
          return true;
        }
        function readAnchorProperty(state) {
          var _position, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 0x26 ) return false;
          if (state.anchor !== null) {
            throwError(state, 'duplication of an anchor property');
          }
          ch = state.input.charCodeAt(++state.position);
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (state.position === _position) {
            throwError(state, 'name of an anchor node must contain at least one character');
          }
          state.anchor = state.input.slice(_position, state.position);
          return true;
        }
        function readAlias(state) {
          var _position, alias, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 0x2A ) return false;
          ch = state.input.charCodeAt(++state.position);
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (state.position === _position) {
            throwError(state, 'name of an alias node must contain at least one character');
          }
          alias = state.input.slice(_position, state.position);
          if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
            throwError(state, 'unidentified alias "' + alias + '"');
          }
          state.result = state.anchorMap[alias];
          skipSeparationSpace(state, true, -1);
          return true;
        }
        function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
          var allowBlockStyles,
            allowBlockScalars,
            allowBlockCollections,
            indentStatus = 1,
            atNewLine = false,
            hasContent = false,
            typeIndex,
            typeQuantity,
            type,
            flowIndent,
            blockIndent;
          if (state.listener !== null) {
            state.listener('open', state);
          }
          state.tag = null;
          state.anchor = null;
          state.kind = null;
          state.result = null;
          allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
          if (allowToSeek) {
            if (skipSeparationSpace(state, true, -1)) {
              atNewLine = true;
              if (state.lineIndent > parentIndent) {
                indentStatus = 1;
              } else if (state.lineIndent === parentIndent) {
                indentStatus = 0;
              } else if (state.lineIndent < parentIndent) {
                indentStatus = -1;
              }
            }
          }
          if (indentStatus === 1) {
            while (readTagProperty(state) || readAnchorProperty(state)) {
              if (skipSeparationSpace(state, true, -1)) {
                atNewLine = true;
                allowBlockCollections = allowBlockStyles;
                if (state.lineIndent > parentIndent) {
                  indentStatus = 1;
                } else if (state.lineIndent === parentIndent) {
                  indentStatus = 0;
                } else if (state.lineIndent < parentIndent) {
                  indentStatus = -1;
                }
              } else {
                allowBlockCollections = false;
              }
            }
          }
          if (allowBlockCollections) {
            allowBlockCollections = atNewLine || allowCompact;
          }
          if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
            if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
              flowIndent = parentIndent;
            } else {
              flowIndent = parentIndent + 1;
            }
            blockIndent = state.position - state.lineStart;
            if (indentStatus === 1) {
              if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
                hasContent = true;
              } else {
                if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
                  hasContent = true;
                } else if (readAlias(state)) {
                  hasContent = true;
                  if (state.tag !== null || state.anchor !== null) {
                    throwError(state, 'alias node should not have any properties');
                  }
                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                  hasContent = true;
                  if (state.tag === null) {
                    state.tag = '?';
                  }
                }
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              }
            } else if (indentStatus === 0) {
              hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
            }
          }
          if (state.tag !== null && state.tag !== '!') {
            if (state.tag === '?') {
              if (state.result !== null && state.kind !== 'scalar') {
                throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
              }
              for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
                type = state.implicitTypes[typeIndex];
                if (type.resolve(state.result)) {
                  state.result = type.construct(state.result);
                  state.tag = type.tag;
                  if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                  }
                  break;
                }
              }
            } else if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
              type = state.typeMap[state.kind || 'fallback'][state.tag];
              if (state.result !== null && type.kind !== state.kind) {
                throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
              }
              if (!type.resolve(state.result)) {
                throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
              } else {
                state.result = type.construct(state.result);
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              }
            } else {
              throwError(state, 'unknown tag !<' + state.tag + '>');
            }
          }
          if (state.listener !== null) {
            state.listener('close', state);
          }
          return state.tag !== null || state.anchor !== null || hasContent;
        }
        function readDocument(state) {
          var documentStart = state.position,
            _position,
            directiveName,
            directiveArgs,
            hasDirectives = false,
            ch;
          state.version = null;
          state.checkLineBreaks = state.legacy;
          state.tagMap = {};
          state.anchorMap = {};
          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
            if (state.lineIndent > 0 || ch !== 0x25 ) {
              break;
            }
            hasDirectives = true;
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;
            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            directiveName = state.input.slice(_position, state.position);
            directiveArgs = [];
            if (directiveName.length < 1) {
              throwError(state, 'directive name must not be less than one character in length');
            }
            while (ch !== 0) {
              while (is_WHITE_SPACE(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              if (ch === 0x23 ) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (ch !== 0 && !is_EOL(ch));
                break;
              }
              if (is_EOL(ch)) break;
              _position = state.position;
              while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              directiveArgs.push(state.input.slice(_position, state.position));
            }
            if (ch !== 0) readLineBreak(state);
            if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
              directiveHandlers[directiveName](state, directiveName, directiveArgs);
            } else {
              throwWarning(state, 'unknown document directive "' + directiveName + '"');
            }
          }
          skipSeparationSpace(state, true, -1);
          if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D  && state.input.charCodeAt(state.position + 1) === 0x2D  && state.input.charCodeAt(state.position + 2) === 0x2D ) {
            state.position += 3;
            skipSeparationSpace(state, true, -1);
          } else if (hasDirectives) {
            throwError(state, 'directives end mark is expected');
          }
          composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
          skipSeparationSpace(state, true, -1);
          if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
            throwWarning(state, 'non-ASCII line breaks are interpreted as content');
          }
          state.documents.push(state.result);
          if (state.position === state.lineStart && testDocumentSeparator(state)) {
            if (state.input.charCodeAt(state.position) === 0x2E ) {
              state.position += 3;
              skipSeparationSpace(state, true, -1);
            }
            return;
          }
          if (state.position < state.length - 1) {
            throwError(state, 'end of the stream or a document separator is expected');
          } else {
            return;
          }
        }
        function loadDocuments(input, options) {
          input = String(input);
          options = options || {};
          if (input.length !== 0) {
            if (input.charCodeAt(input.length - 1) !== 0x0A  && input.charCodeAt(input.length - 1) !== 0x0D ) {
              input += '\n';
            }
            if (input.charCodeAt(0) === 0xFEFF) {
              input = input.slice(1);
            }
          }
          var state = new State$1(input, options);
          var nullpos = input.indexOf('\0');
          if (nullpos !== -1) {
            state.position = nullpos;
            throwError(state, 'null byte is not allowed in input');
          }
          state.input += '\0';
          while (state.input.charCodeAt(state.position) === 0x20 ) {
            state.lineIndent += 1;
            state.position += 1;
          }
          while (state.position < state.length - 1) {
            readDocument(state);
          }
          return state.documents;
        }
        function loadAll(input, iterator, options) {
          if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
            options = iterator;
            iterator = null;
          }
          var documents = loadDocuments(input, options);
          if (typeof iterator !== 'function') {
            return documents;
          }
          for (var index = 0, length = documents.length; index < length; index += 1) {
            iterator(documents[index]);
          }
        }
        function load(input, options) {
          var documents = loadDocuments(input, options);
          if (documents.length === 0) {
            return undefined;
          } else if (documents.length === 1) {
            return documents[0];
          }
          throw new YAMLException$1('expected a single document in the stream, but found more');
        }
        function safeLoadAll(input, iterator, options) {
          if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
            options = iterator;
            iterator = null;
          }
          return loadAll(input, iterator, common$1.extend({
            schema: DEFAULT_SAFE_SCHEMA$1
          }, options));
        }
        function safeLoad(input, options) {
          return load(input, common$1.extend({
            schema: DEFAULT_SAFE_SCHEMA$1
          }, options));
        }
        loader$1.loadAll = loadAll;
        loader$1.load = load;
        loader$1.safeLoadAll = safeLoadAll;
        loader$1.safeLoad = safeLoad;
        var dumper$1 = {};
        var common = common$6;
        var YAMLException = exception;
        var DEFAULT_FULL_SCHEMA = default_full;
        var DEFAULT_SAFE_SCHEMA = default_safe;
        var _toString = Object.prototype.toString;
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        var CHAR_TAB = 0x09;
        var CHAR_LINE_FEED = 0x0A;
        var CHAR_CARRIAGE_RETURN = 0x0D;
        var CHAR_SPACE = 0x20;
        var CHAR_EXCLAMATION = 0x21;
        var CHAR_DOUBLE_QUOTE = 0x22;
        var CHAR_SHARP = 0x23;
        var CHAR_PERCENT = 0x25;
        var CHAR_AMPERSAND = 0x26;
        var CHAR_SINGLE_QUOTE = 0x27;
        var CHAR_ASTERISK = 0x2A;
        var CHAR_COMMA = 0x2C;
        var CHAR_MINUS = 0x2D;
        var CHAR_COLON = 0x3A;
        var CHAR_EQUALS = 0x3D;
        var CHAR_GREATER_THAN = 0x3E;
        var CHAR_QUESTION = 0x3F;
        var CHAR_COMMERCIAL_AT = 0x40;
        var CHAR_LEFT_SQUARE_BRACKET = 0x5B;
        var CHAR_RIGHT_SQUARE_BRACKET = 0x5D;
        var CHAR_GRAVE_ACCENT = 0x60;
        var CHAR_LEFT_CURLY_BRACKET = 0x7B;
        var CHAR_VERTICAL_LINE = 0x7C;
        var CHAR_RIGHT_CURLY_BRACKET = 0x7D;
        var ESCAPE_SEQUENCES = {};
        ESCAPE_SEQUENCES[0x00] = '\\0';
        ESCAPE_SEQUENCES[0x07] = '\\a';
        ESCAPE_SEQUENCES[0x08] = '\\b';
        ESCAPE_SEQUENCES[0x09] = '\\t';
        ESCAPE_SEQUENCES[0x0A] = '\\n';
        ESCAPE_SEQUENCES[0x0B] = '\\v';
        ESCAPE_SEQUENCES[0x0C] = '\\f';
        ESCAPE_SEQUENCES[0x0D] = '\\r';
        ESCAPE_SEQUENCES[0x1B] = '\\e';
        ESCAPE_SEQUENCES[0x22] = '\\"';
        ESCAPE_SEQUENCES[0x5C] = '\\\\';
        ESCAPE_SEQUENCES[0x85] = '\\N';
        ESCAPE_SEQUENCES[0xA0] = '\\_';
        ESCAPE_SEQUENCES[0x2028] = '\\L';
        ESCAPE_SEQUENCES[0x2029] = '\\P';
        var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];
        function compileStyleMap(schema, map) {
          var result, keys, index, length, tag, style, type;
          if (map === null) return {};
          result = {};
          keys = Object.keys(map);
          for (index = 0, length = keys.length; index < length; index += 1) {
            tag = keys[index];
            style = String(map[tag]);
            if (tag.slice(0, 2) === '!!') {
              tag = 'tag:yaml.org,2002:' + tag.slice(2);
            }
            type = schema.compiledTypeMap['fallback'][tag];
            if (type && _hasOwnProperty.call(type.styleAliases, style)) {
              style = type.styleAliases[style];
            }
            result[tag] = style;
          }
          return result;
        }
        function encodeHex(character) {
          var string, handle, length;
          string = character.toString(16).toUpperCase();
          if (character <= 0xFF) {
            handle = 'x';
            length = 2;
          } else if (character <= 0xFFFF) {
            handle = 'u';
            length = 4;
          } else if (character <= 0xFFFFFFFF) {
            handle = 'U';
            length = 8;
          } else {
            throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
          }
          return '\\' + handle + common.repeat('0', length - string.length) + string;
        }
        function State(options) {
          this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
          this.indent = Math.max(1, options['indent'] || 2);
          this.noArrayIndent = options['noArrayIndent'] || false;
          this.skipInvalid = options['skipInvalid'] || false;
          this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
          this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
          this.sortKeys = options['sortKeys'] || false;
          this.lineWidth = options['lineWidth'] || 80;
          this.noRefs = options['noRefs'] || false;
          this.noCompatMode = options['noCompatMode'] || false;
          this.condenseFlow = options['condenseFlow'] || false;
          this.implicitTypes = this.schema.compiledImplicit;
          this.explicitTypes = this.schema.compiledExplicit;
          this.tag = null;
          this.result = '';
          this.duplicates = [];
          this.usedDuplicates = null;
        }
        function indentString(string, spaces) {
          var ind = common.repeat(' ', spaces),
            position = 0,
            next = -1,
            result = '',
            line,
            length = string.length;
          while (position < length) {
            next = string.indexOf('\n', position);
            if (next === -1) {
              line = string.slice(position);
              position = length;
            } else {
              line = string.slice(position, next + 1);
              position = next + 1;
            }
            if (line.length && line !== '\n') result += ind;
            result += line;
          }
          return result;
        }
        function generateNextLine(state, level) {
          return '\n' + common.repeat(' ', state.indent * level);
        }
        function testImplicitResolving(state, str) {
          var index, length, type;
          for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
            type = state.implicitTypes[index];
            if (type.resolve(str)) {
              return true;
            }
          }
          return false;
        }
        function isWhitespace(c) {
          return c === CHAR_SPACE || c === CHAR_TAB;
        }
        function isPrintable(c) {
          return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF  || 0x10000 <= c && c <= 0x10FFFF;
        }
        function isNsChar(c) {
          return isPrintable(c) && !isWhitespace(c)
          && c !== 0xFEFF
          && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
        }
        function isPlainSafe(c, prev) {
          return isPrintable(c) && c !== 0xFEFF
          && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
          && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
        }
        function isPlainSafeFirst(c) {
          return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c)
          && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
          && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE
          && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
        }
        function needIndentIndicator(string) {
          var leadingSpaceRe = /^\n* /;
          return leadingSpaceRe.test(string);
        }
        var STYLE_PLAIN = 1,
          STYLE_SINGLE = 2,
          STYLE_LITERAL = 3,
          STYLE_FOLDED = 4,
          STYLE_DOUBLE = 5;
        function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
          var i;
          var char, prev_char;
          var hasLineBreak = false;
          var hasFoldableLine = false;
          var shouldTrackWidth = lineWidth !== -1;
          var previousLineBreak = -1;
          var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
          if (singleLineOnly) {
            for (i = 0; i < string.length; i++) {
              char = string.charCodeAt(i);
              if (!isPrintable(char)) {
                return STYLE_DOUBLE;
              }
              prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
              plain = plain && isPlainSafe(char, prev_char);
            }
          } else {
            for (i = 0; i < string.length; i++) {
              char = string.charCodeAt(i);
              if (char === CHAR_LINE_FEED) {
                hasLineBreak = true;
                if (shouldTrackWidth) {
                  hasFoldableLine = hasFoldableLine ||
                  i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
                  previousLineBreak = i;
                }
              } else if (!isPrintable(char)) {
                return STYLE_DOUBLE;
              }
              prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
              plain = plain && isPlainSafe(char, prev_char);
            }
            hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
          }
          if (!hasLineBreak && !hasFoldableLine) {
            return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
          }
          if (indentPerLevel > 9 && needIndentIndicator(string)) {
            return STYLE_DOUBLE;
          }
          return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
        }
        function writeScalar(state, string, level, iskey) {
          state.dump = function () {
            if (string.length === 0) {
              return "''";
            }
            if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
              return "'" + string + "'";
            }
            var indent = state.indent * Math.max(1, level);
            var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
            var singleLineOnly = iskey
            || state.flowLevel > -1 && level >= state.flowLevel;
            function testAmbiguity(string) {
              return testImplicitResolving(state, string);
            }
            switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
              case STYLE_PLAIN:
                return string;
              case STYLE_SINGLE:
                return "'" + string.replace(/'/g, "''") + "'";
              case STYLE_LITERAL:
                return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
              case STYLE_FOLDED:
                return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
              case STYLE_DOUBLE:
                return '"' + escapeString(string) + '"';
              default:
                throw new YAMLException('impossible error: invalid scalar style');
            }
          }();
        }
        function blockHeader(string, indentPerLevel) {
          var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';
          var clip = string[string.length - 1] === '\n';
          var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
          var chomp = keep ? '+' : clip ? '' : '-';
          return indentIndicator + chomp + '\n';
        }
        function dropEndingNewline(string) {
          return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
        }
        function foldString(string, width) {
          var lineRe = /(\n+)([^\n]*)/g;
          var result = function () {
            var nextLF = string.indexOf('\n');
            nextLF = nextLF !== -1 ? nextLF : string.length;
            lineRe.lastIndex = nextLF;
            return foldLine(string.slice(0, nextLF), width);
          }();
          var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
          var moreIndented;
          var match;
          while (match = lineRe.exec(string)) {
            var prefix = match[1],
              line = match[2];
            moreIndented = line[0] === ' ';
            result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
            prevMoreIndented = moreIndented;
          }
          return result;
        }
        function foldLine(line, width) {
          if (line === '' || line[0] === ' ') return line;
          var breakRe = / [^ ]/g;
          var match;
          var start = 0,
            end,
            curr = 0,
            next = 0;
          var result = '';
          while (match = breakRe.exec(line)) {
            next = match.index;
            if (next - start > width) {
              end = curr > start ? curr : next;
              result += '\n' + line.slice(start, end);
              start = end + 1;
            }
            curr = next;
          }
          result += '\n';
          if (line.length - start > width && curr > start) {
            result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
          } else {
            result += line.slice(start);
          }
          return result.slice(1);
        }
        function escapeString(string) {
          var result = '';
          var char, nextChar;
          var escapeSeq;
          for (var i = 0; i < string.length; i++) {
            char = string.charCodeAt(i);
            if (char >= 0xD800 && char <= 0xDBFF ) {
              nextChar = string.charCodeAt(i + 1);
              if (nextChar >= 0xDC00 && nextChar <= 0xDFFF ) {
                result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
                i++;
                continue;
              }
            }
            escapeSeq = ESCAPE_SEQUENCES[char];
            result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
          }
          return result;
        }
        function writeFlowSequence(state, level, object) {
          var _result = '',
            _tag = state.tag,
            index,
            length;
          for (index = 0, length = object.length; index < length; index += 1) {
            if (writeNode(state, level, object[index], false, false)) {
              if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
              _result += state.dump;
            }
          }
          state.tag = _tag;
          state.dump = '[' + _result + ']';
        }
        function writeBlockSequence(state, level, object, compact) {
          var _result = '',
            _tag = state.tag,
            index,
            length;
          for (index = 0, length = object.length; index < length; index += 1) {
            if (writeNode(state, level + 1, object[index], true, true)) {
              if (!compact || index !== 0) {
                _result += generateNextLine(state, level);
              }
              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                _result += '-';
              } else {
                _result += '- ';
              }
              _result += state.dump;
            }
          }
          state.tag = _tag;
          state.dump = _result || '[]';
        }
        function writeFlowMapping(state, level, object) {
          var _result = '',
            _tag = state.tag,
            objectKeyList = Object.keys(object),
            index,
            length,
            objectKey,
            objectValue,
            pairBuffer;
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            pairBuffer = '';
            if (index !== 0) pairBuffer += ', ';
            if (state.condenseFlow) pairBuffer += '"';
            objectKey = objectKeyList[index];
            objectValue = object[objectKey];
            if (!writeNode(state, level, objectKey, false, false)) {
              continue;
            }
            if (state.dump.length > 1024) pairBuffer += '? ';
            pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');
            if (!writeNode(state, level, objectValue, false, false)) {
              continue;
            }
            pairBuffer += state.dump;
            _result += pairBuffer;
          }
          state.tag = _tag;
          state.dump = '{' + _result + '}';
        }
        function writeBlockMapping(state, level, object, compact) {
          var _result = '',
            _tag = state.tag,
            objectKeyList = Object.keys(object),
            index,
            length,
            objectKey,
            objectValue,
            explicitPair,
            pairBuffer;
          if (state.sortKeys === true) {
            objectKeyList.sort();
          } else if (typeof state.sortKeys === 'function') {
            objectKeyList.sort(state.sortKeys);
          } else if (state.sortKeys) {
            throw new YAMLException('sortKeys must be a boolean or a function');
          }
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            pairBuffer = '';
            if (!compact || index !== 0) {
              pairBuffer += generateNextLine(state, level);
            }
            objectKey = objectKeyList[index];
            objectValue = object[objectKey];
            if (!writeNode(state, level + 1, objectKey, true, true, true)) {
              continue;
            }
            explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;
            if (explicitPair) {
              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                pairBuffer += '?';
              } else {
                pairBuffer += '? ';
              }
            }
            pairBuffer += state.dump;
            if (explicitPair) {
              pairBuffer += generateNextLine(state, level);
            }
            if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
              continue;
            }
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              pairBuffer += ':';
            } else {
              pairBuffer += ': ';
            }
            pairBuffer += state.dump;
            _result += pairBuffer;
          }
          state.tag = _tag;
          state.dump = _result || '{}';
        }
        function detectType(state, object, explicit) {
          var _result, typeList, index, length, type, style;
          typeList = explicit ? state.explicitTypes : state.implicitTypes;
          for (index = 0, length = typeList.length; index < length; index += 1) {
            type = typeList[index];
            if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
              state.tag = explicit ? type.tag : '?';
              if (type.represent) {
                style = state.styleMap[type.tag] || type.defaultStyle;
                if (_toString.call(type.represent) === '[object Function]') {
                  _result = type.represent(object, style);
                } else if (_hasOwnProperty.call(type.represent, style)) {
                  _result = type.represent[style](object, style);
                } else {
                  throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
                }
                state.dump = _result;
              }
              return true;
            }
          }
          return false;
        }
        function writeNode(state, level, object, block, compact, iskey) {
          state.tag = null;
          state.dump = object;
          if (!detectType(state, object, false)) {
            detectType(state, object, true);
          }
          var type = _toString.call(state.dump);
          if (block) {
            block = state.flowLevel < 0 || state.flowLevel > level;
          }
          var objectOrArray = type === '[object Object]' || type === '[object Array]',
            duplicateIndex,
            duplicate;
          if (objectOrArray) {
            duplicateIndex = state.duplicates.indexOf(object);
            duplicate = duplicateIndex !== -1;
          }
          if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
            compact = false;
          }
          if (duplicate && state.usedDuplicates[duplicateIndex]) {
            state.dump = '*ref_' + duplicateIndex;
          } else {
            if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
              state.usedDuplicates[duplicateIndex] = true;
            }
            if (type === '[object Object]') {
              if (block && Object.keys(state.dump).length !== 0) {
                writeBlockMapping(state, level, state.dump, compact);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + state.dump;
                }
              } else {
                writeFlowMapping(state, level, state.dump);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
              }
            } else if (type === '[object Array]') {
              var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
              if (block && state.dump.length !== 0) {
                writeBlockSequence(state, arrayLevel, state.dump, compact);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + state.dump;
                }
              } else {
                writeFlowSequence(state, arrayLevel, state.dump);
                if (duplicate) {
                  state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
              }
            } else if (type === '[object String]') {
              if (state.tag !== '?') {
                writeScalar(state, state.dump, level, iskey);
              }
            } else {
              if (state.skipInvalid) return false;
              throw new YAMLException('unacceptable kind of an object to dump ' + type);
            }
            if (state.tag !== null && state.tag !== '?') {
              state.dump = '!<' + state.tag + '> ' + state.dump;
            }
          }
          return true;
        }
        function getDuplicateReferences(object, state) {
          var objects = [],
            duplicatesIndexes = [],
            index,
            length;
          inspectNode(object, objects, duplicatesIndexes);
          for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
            state.duplicates.push(objects[duplicatesIndexes[index]]);
          }
          state.usedDuplicates = new Array(length);
        }
        function inspectNode(object, objects, duplicatesIndexes) {
          var objectKeyList, index, length;
          if (object !== null && typeof object === 'object') {
            index = objects.indexOf(object);
            if (index !== -1) {
              if (duplicatesIndexes.indexOf(index) === -1) {
                duplicatesIndexes.push(index);
              }
            } else {
              objects.push(object);
              if (Array.isArray(object)) {
                for (index = 0, length = object.length; index < length; index += 1) {
                  inspectNode(object[index], objects, duplicatesIndexes);
                }
              } else {
                objectKeyList = Object.keys(object);
                for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                  inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
                }
              }
            }
          }
        }
        function dump(input, options) {
          options = options || {};
          var state = new State(options);
          if (!state.noRefs) getDuplicateReferences(input, state);
          if (writeNode(state, 0, input, true, true)) return state.dump + '\n';
          return '';
        }
        function safeDump(input, options) {
          return dump(input, common.extend({
            schema: DEFAULT_SAFE_SCHEMA
          }, options));
        }
        dumper$1.dump = dump;
        dumper$1.safeDump = safeDump;
        var loader = loader$1;
        var dumper = dumper$1;
        function deprecated(name) {
          return function () {
            throw new Error('Function ' + name + ' is deprecated and cannot be used.');
          };
        }
        jsYaml$2.Type = type;
        jsYaml$2.Schema = schema;
        jsYaml$2.FAILSAFE_SCHEMA = failsafe;
        jsYaml$2.JSON_SCHEMA = json;
        jsYaml$2.CORE_SCHEMA = core;
        jsYaml$2.DEFAULT_SAFE_SCHEMA = default_safe;
        jsYaml$2.DEFAULT_FULL_SCHEMA = default_full;
        jsYaml$2.load = loader.load;
        jsYaml$2.loadAll = loader.loadAll;
        jsYaml$2.safeLoad = loader.safeLoad;
        jsYaml$2.safeLoadAll = loader.safeLoadAll;
        jsYaml$2.dump = dumper.dump;
        jsYaml$2.safeDump = dumper.safeDump;
        jsYaml$2.YAMLException = exception;
        jsYaml$2.MINIMAL_SCHEMA = failsafe;
        jsYaml$2.SAFE_SCHEMA = default_safe;
        jsYaml$2.DEFAULT_SCHEMA = default_full;
        jsYaml$2.scan = deprecated('scan');
        jsYaml$2.parse = deprecated('parse');
        jsYaml$2.compose = deprecated('compose');
        jsYaml$2.addConstructor = deprecated('addConstructor');
        var yaml = jsYaml$2;
        var jsYaml = yaml;
        var jsYaml$1 = getDefaultExportFromCjs(jsYaml);
        function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
        function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
        class Redirects {
          constructor(rawYaml) {
            try {
              var arrOfRedirects = jsYaml$1.safeLoad(rawYaml);
              this.redirects = arrOfRedirects.reduce(function (acc, redirect) {
                return _objectSpread(_objectSpread({}, acc), {}, {
                  [redirect.title]: redirect
                });
              }, {});
            } catch (e) {
              console.log("Was unable to load YAML into JS due to: ".concat(e.message));
              throw e;
            }
          }
          getRedirect(title) {
            var _this = this;
            if (Object.prototype.hasOwnProperty.call(this.redirects, title)) {
              return this.redirects[title];
            }
            var values = Object.keys(this.redirects).map(function (key) {
              return _this.redirects[key];
            });
            return values.find(function (redirect) {
              var aliases = redirect.aliases;
              if (!aliases) {
                return false;
              }
              return aliases.includes(title);
            });
          }
          isBlocking(title) {
            var redirect = this.redirects[title];
            if (redirect) {
              return !!redirect.isBlocking;
            }
            return false;
          }
        }
        var redirectsMap = {
          "1x1-transparent.gif": "1x1-transparent.gif",
          "1x1.gif": "1x1-transparent.gif",
          "1x1-transparent-gif": "1x1-transparent.gif",
          "2x2-transparent.png": "2x2-transparent.png",
          "2x2.png": "2x2-transparent.png",
          "2x2-transparent-png": "2x2-transparent.png",
          "3x2-transparent.png": "3x2-transparent.png",
          "3x2.png": "3x2-transparent.png",
          "3x2-transparent-png": "3x2-transparent.png",
          "32x32-transparent.png": "32x32-transparent.png",
          "32x32.png": "32x32-transparent.png",
          "32x32-transparent-png": "32x32-transparent.png",
          noopframe: "noopframe.html",
          "noop.html": "noopframe.html",
          "blank-html": "noopframe.html",
          noopcss: "noopcss.css",
          "noop.css": "noopcss.css",
          "blank-css": "noopcss.css",
          noopjs: "noopjs.js",
          "noop.js": "noopjs.js",
          "blank-js": "noopjs.js",
          noopjson: "noopjson.json",
          "noop.json": "noopjson.json",
          nooptext: "nooptext.js",
          "noop.txt": "nooptext.js",
          "blank-text": "nooptext.js",
          empty: "nooptext.js",
          "noopvmap-1.0": "noopvmap01.xml",
          "noop-vmap1.0.xml": "noopvmap01.xml",
          "noopvast-2.0": "noopvast02.xml",
          "noopvast-3.0": "noopvast03.xml",
          "noopvast-4.0": "noopvast04.xml",
          "noopmp3-0.1s": "noopmp3.mp3",
          "blank-mp3": "noopmp3.mp3",
          "noopmp4-1s": "noopmp4.mp4",
          "noop-1s.mp4": "noopmp4.mp4",
          "blank-mp4": "noopmp4.mp4",
          "click2load.html": "click2load.html",
          "ubo-click2load.html": "click2load.html",
          "amazon-apstag": "amazon-apstag.js",
          "ubo-amazon_apstag.js": "amazon-apstag.js",
          "amazon_apstag.js": "amazon-apstag.js",
          "ati-smarttag": "ati-smarttag.js",
          "didomi-loader": "didomi-loader.js",
          fingerprintjs2: "fingerprintjs2.js",
          "ubo-fingerprint2.js": "fingerprintjs2.js",
          "fingerprint2.js": "fingerprintjs2.js",
          fingerprintjs3: "fingerprintjs3.js",
          "ubo-fingerprint3.js": "fingerprintjs3.js",
          "fingerprint3.js": "fingerprintjs3.js",
          gemius: "gemius.js",
          "google-analytics-ga": "google-analytics-ga.js",
          "ubo-google-analytics_ga.js": "google-analytics-ga.js",
          "google-analytics_ga.js": "google-analytics-ga.js",
          "google-analytics": "google-analytics.js",
          "ubo-google-analytics_analytics.js": "google-analytics.js",
          "google-analytics_analytics.js": "google-analytics.js",
          "googletagmanager-gtm": "google-analytics.js",
          "ubo-googletagmanager_gtm.js": "google-analytics.js",
          "googletagmanager_gtm.js": "google-analytics.js",
          "google-ima3": "google-ima3.js",
          "ubo-google-ima.js": "google-ima3.js",
          "google-ima.js": "google-ima3.js",
          "googlesyndication-adsbygoogle": "googlesyndication-adsbygoogle.js",
          "ubo-googlesyndication_adsbygoogle.js": "googlesyndication-adsbygoogle.js",
          "googlesyndication_adsbygoogle.js": "googlesyndication-adsbygoogle.js",
          "googletagservices-gpt": "googletagservices-gpt.js",
          "ubo-googletagservices_gpt.js": "googletagservices-gpt.js",
          "googletagservices_gpt.js": "googletagservices-gpt.js",
          matomo: "matomo.js",
          "metrika-yandex-tag": "metrika-yandex-tag.js",
          "metrika-yandex-watch": "metrika-yandex-watch.js",
          "naver-wcslog": "naver-wcslog.js",
          noeval: "noeval.js",
          "noeval.js": "noeval.js",
          "silent-noeval.js": "noeval.js",
          "ubo-noeval.js": "noeval.js",
          "ubo-silent-noeval.js": "noeval.js",
          "ubo-noeval": "noeval.js",
          "ubo-silent-noeval": "noeval.js",
          "pardot-1.0": "pardot-1.0.js",
          "prebid-ads": "prebid-ads.js",
          "ubo-prebid-ads.js": "prebid-ads.js",
          "prebid-ads.js": "prebid-ads.js",
          prebid: "prebid.js",
          "prevent-bab": "prevent-bab.js",
          "nobab.js": "prevent-bab.js",
          "ubo-nobab.js": "prevent-bab.js",
          "bab-defuser.js": "prevent-bab.js",
          "ubo-bab-defuser.js": "prevent-bab.js",
          "ubo-nobab": "prevent-bab.js",
          "ubo-bab-defuser": "prevent-bab.js",
          "prevent-bab2": "prevent-bab2.js",
          "nobab2.js": "prevent-bab2.js",
          "prevent-fab-3.2.0": "prevent-fab-3.2.0.js",
          "nofab.js": "prevent-fab-3.2.0.js",
          "ubo-nofab.js": "prevent-fab-3.2.0.js",
          "fuckadblock.js-3.2.0": "prevent-fab-3.2.0.js",
          "ubo-fuckadblock.js-3.2.0": "prevent-fab-3.2.0.js",
          "ubo-nofab": "prevent-fab-3.2.0.js",
          "prevent-popads-net": "prevent-popads-net.js",
          "popads.net.js": "prevent-popads-net.js",
          "ubo-popads.net.js": "prevent-popads-net.js",
          "ubo-popads.net": "prevent-popads-net.js",
          "scorecardresearch-beacon": "scorecardresearch-beacon.js",
          "ubo-scorecardresearch_beacon.js": "scorecardresearch-beacon.js",
          "scorecardresearch_beacon.js": "scorecardresearch-beacon.js",
          "set-popads-dummy": "set-popads-dummy.js",
          "popads-dummy.js": "set-popads-dummy.js",
          "ubo-popads-dummy.js": "set-popads-dummy.js",
          "ubo-popads-dummy": "set-popads-dummy.js"
        };
        var getRedirectByName = function getRedirectByName(name) {
          var redirects = Object.keys(redirectsList).map(function (key) {
            return redirectsList[key];
          });
          return redirects.find(function (r) {
            return r.names && r.names.includes(name);
          });
        };
        var getRedirectCode = function getRedirectCode(source) {
          var redirect = getRedirectByName(source.name);
          var result = attachDependencies(redirect);
          result = addCall(redirect, result);
          result = source.engine === 'test' ? wrapInNonameFunc(result) : passSourceAndProps(source, result, true);
          return result;
        };
        var getRedirectFilename = function getRedirectFilename(name) {
          return redirectsMap[name];
        };
        var redirects = {
          Redirects,
          getRedirectFilename,
          getCode: getRedirectCode,
          isAdgRedirectRule: validator.isAdgRedirectRule,
          isValidAdgRedirectRule: validator.isValidAdgRedirectRule,
          isAdgRedirectCompatibleWithUbo: validator.isAdgRedirectCompatibleWithUbo,
          isUboRedirectCompatibleWithAdg: validator.isUboRedirectCompatibleWithAdg,
          isAbpRedirectCompatibleWithAdg: validator.isAbpRedirectCompatibleWithAdg,
          convertUboRedirectToAdg,
          convertAbpRedirectToAdg,
          convertRedirectToAdg,
          convertRedirectNameToAdg,
          convertAdgRedirectToUbo
        };
        var version = "1.9.101";
        function abortCurrentInlineScript(source, args) {
          function abortCurrentInlineScript(source, property, search) {
            var searchRegexp = toRegExp(search);
            var rid = randomId();
            var SRC_DATA_MARKER = "data:text/javascript;base64,";
            var getCurrentScript = function getCurrentScript() {
              if ("currentScript" in document) {
                return document.currentScript;
              }
              var scripts = document.getElementsByTagName("script");
              return scripts[scripts.length - 1];
            };
            var ourScript = getCurrentScript();
            var abort = function abort() {
              var _scriptEl$src;
              var scriptEl = getCurrentScript();
              if (!scriptEl) {
                return;
              }
              var content = scriptEl.textContent;
              try {
                var textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, "textContent").get;
                content = textContentGetter.call(scriptEl);
              } catch (e) {}
              if (content.length === 0 && typeof scriptEl.src !== "undefined" && (_scriptEl$src = scriptEl.src) !== null && _scriptEl$src !== void 0 && _scriptEl$src.startsWith(SRC_DATA_MARKER)) {
                var encodedContent = scriptEl.src.slice(SRC_DATA_MARKER.length);
                content = window.atob(encodedContent);
              }
              if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
                hit(source);
                throw new ReferenceError(rid);
              }
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                chain = chainInfo.chain;
              if (base instanceof Object === false && base === null) {
                var props = property.split(".");
                var propIndex = props.indexOf(prop);
                var baseName = props[propIndex - 1];
                var message = "The scriptlet had been executed before the ".concat(baseName, " was loaded.");
                logMessage(source, message);
                return;
              }
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              var currentValue = base[prop];
              var origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
              if (origDescriptor instanceof Object === false || origDescriptor.get instanceof Function === false) {
                currentValue = base[prop];
                origDescriptor = undefined;
              }
              var descriptorWrapper = Object.assign(getDescriptorAddon(), {
                currentValue: currentValue,
                get() {
                  if (!this.isAbortingSuspended) {
                    this.isolateCallback(abort);
                  }
                  if (origDescriptor instanceof Object) {
                    return origDescriptor.get.call(base);
                  }
                  return this.currentValue;
                },
                set(newValue) {
                  if (!this.isAbortingSuspended) {
                    this.isolateCallback(abort);
                  }
                  if (origDescriptor instanceof Object) {
                    origDescriptor.set.call(base, newValue);
                  } else {
                    this.currentValue = newValue;
                  }
                }
              });
              setPropertyAccess(base, prop, {
                get() {
                  return descriptorWrapper.get.call(descriptorWrapper);
                },
                set(newValue) {
                  descriptorWrapper.set.call(descriptorWrapper, newValue);
                }
              });
            };
            setChainPropAccess(window, property);
            window.onerror = createOnErrorHandler(rid).bind();
          }
          function randomId() {
            return Math.random().toString(36).slice(2, 9);
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.includes(rid)) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [error, ...args]);
              }
              return false;
            };
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          function getDescriptorAddon() {
            return {
              isAbortingSuspended: false,
              isolateCallback(cb) {
                this.isAbortingSuspended = true;
                try {
                  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                  }
                  var result = cb(...args);
                  this.isAbortingSuspended = false;
                  return result;
                } catch (_unused) {
                  var rid = randomId();
                  this.isAbortingSuspended = false;
                  throw new ReferenceError(rid);
                }
              }
            };
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            abortCurrentInlineScript.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function abortOnPropertyRead(source, args) {
          function abortOnPropertyRead(source, property) {
            if (!property) {
              return;
            }
            var rid = randomId();
            var abort = function abort() {
              hit(source);
              throw new ReferenceError(rid);
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                chain = chainInfo.chain;
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              setPropertyAccess(base, prop, {
                get: abort,
                set: function set() {}
              });
            };
            setChainPropAccess(window, property);
            window.onerror = createOnErrorHandler(rid).bind();
          }
          function randomId() {
            return Math.random().toString(36).slice(2, 9);
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.includes(rid)) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [error, ...args]);
              }
              return false;
            };
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            abortOnPropertyRead.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function abortOnPropertyWrite(source, args) {
          function abortOnPropertyWrite(source, property) {
            if (!property) {
              return;
            }
            var rid = randomId();
            var abort = function abort() {
              hit(source);
              throw new ReferenceError(rid);
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                chain = chainInfo.chain;
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              setPropertyAccess(base, prop, {
                set: abort
              });
            };
            setChainPropAccess(window, property);
            window.onerror = createOnErrorHandler(rid).bind();
          }
          function randomId() {
            return Math.random().toString(36).slice(2, 9);
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.includes(rid)) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [error, ...args]);
              }
              return false;
            };
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            abortOnPropertyWrite.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function abortOnStackTrace(source, args) {
          function abortOnStackTrace(source, property, stack) {
            if (!property || !stack) {
              return;
            }
            var rid = randomId();
            var abort = function abort() {
              hit(source);
              throw new ReferenceError(rid);
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                chain = chainInfo.chain;
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              if (!stack.match(/^(inlineScript|injectedScript)$/) && !isValidStrPattern(stack)) {
                logMessage(source, "Invalid parameter: ".concat(stack));
                return;
              }
              var descriptorWrapper = Object.assign(getDescriptorAddon(), {
                value: base[prop],
                get() {
                  if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
                    abort();
                  }
                  return this.value;
                },
                set(newValue) {
                  if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, new Error().stack)) {
                    abort();
                  }
                  this.value = newValue;
                }
              });
              setPropertyAccess(base, prop, {
                get() {
                  return descriptorWrapper.get.call(descriptorWrapper);
                },
                set(newValue) {
                  descriptorWrapper.set.call(descriptorWrapper, newValue);
                }
              });
            };
            setChainPropAccess(window, property);
            window.onerror = createOnErrorHandler(rid).bind();
          }
          function randomId() {
            return Math.random().toString(36).slice(2, 9);
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.includes(rid)) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [error, ...args]);
              }
              return false;
            };
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function matchStackTrace(stackMatch, stackTrace) {
            if (!stackMatch || stackMatch === "") {
              return true;
            }
            if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
              return true;
            }
            var stackRegexp = toRegExp(stackMatch);
            var refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
              return line.trim();
            }).join("\n");
            return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
          }
          function getDescriptorAddon() {
            return {
              isAbortingSuspended: false,
              isolateCallback(cb) {
                this.isAbortingSuspended = true;
                try {
                  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                  }
                  var result = cb(...args);
                  this.isAbortingSuspended = false;
                  return result;
                } catch (_unused) {
                  var rid = randomId();
                  this.isAbortingSuspended = false;
                  throw new ReferenceError(rid);
                }
              }
            };
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          function getNativeRegexpTest() {
            var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
            var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
            if (descriptor && typeof descriptor.value === "function") {
              return nativeRegexTest;
            }
            throw new Error("RegExp.prototype.test is not a function");
          }
          function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
            var INLINE_SCRIPT_STRING = "inlineScript";
            var INJECTED_SCRIPT_STRING = "injectedScript";
            var INJECTED_SCRIPT_MARKER = "<anonymous>";
            var isInlineScript = function isInlineScript(match) {
              return match.includes(INLINE_SCRIPT_STRING);
            };
            var isInjectedScript = function isInjectedScript(match) {
              return match.includes(INJECTED_SCRIPT_STRING);
            };
            if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
              return false;
            }
            var documentURL = window.location.href;
            var pos = documentURL.indexOf("#");
            if (pos !== -1) {
              documentURL = documentURL.slice(0, pos);
            }
            var stackSteps = stackTrace.split("\n").slice(2).map(function (line) {
              return line.trim();
            });
            var stackLines = stackSteps.map(function (line) {
              var stack;
              var getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
              if (getStackTraceURL) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceURL[2];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                  stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                  var _stackFunction;
                  stackURL = INJECTED_SCRIPT_STRING;
                  var stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
                  if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                    stackFunction = stackFunction.slice(2).trim();
                  }
                  stack = "".concat(stackFunction, " ").concat(stackURL).trim();
                } else {
                  stack = stackURL;
                }
              } else {
                stack = line;
              }
              return stack;
            });
            if (stackLines) {
              for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
                  return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING)) {
                  return true;
                }
              }
            }
            return false;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            abortOnStackTrace.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function adjustSetInterval(source, args) {
          function adjustSetInterval(source, matchCallback, matchDelay, boost) {
            var nativeSetInterval = window.setInterval;
            var matchRegexp = toRegExp(matchCallback);
            var intervalWrapper = function intervalWrapper(callback, delay) {
              if (!isValidCallback(callback)) {
                var message = "Scriptlet can't be applied because of invalid callback: '".concat(String(callback), "'");
                logMessage(source, message);
              } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
                delay *= getBoostMultiplier(boost);
                hit(source);
              }
              for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }
              return nativeSetInterval.apply(window, [callback, delay, ...args]);
            };
            window.setInterval = intervalWrapper;
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function isValidCallback(callback) {
            return callback instanceof Function || typeof callback === "string";
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function getBoostMultiplier(boost) {
            var DEFAULT_MULTIPLIER = .05;
            var MIN_MULTIPLIER = .001;
            var MAX_MULTIPLIER = 50;
            var parsedBoost = parseFloat(boost);
            var boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER : parsedBoost;
            if (boostMultiplier < MIN_MULTIPLIER) {
              boostMultiplier = MIN_MULTIPLIER;
            }
            if (boostMultiplier > MAX_MULTIPLIER) {
              boostMultiplier = MAX_MULTIPLIER;
            }
            return boostMultiplier;
          }
          function isDelayMatched(inputDelay, realDelay) {
            return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function nativeIsFinite(num) {
            var native = Number.isFinite || window.isFinite;
            return native(num);
          }
          function getMatchDelay(delay) {
            var DEFAULT_DELAY = 1e3;
            var parsedDelay = parseInt(delay, 10);
            var delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY : parsedDelay;
            return delayMatch;
          }
          function shouldMatchAnyDelay(delay) {
            return delay === "*";
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            adjustSetInterval.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function adjustSetTimeout(source, args) {
          function adjustSetTimeout(source, matchCallback, matchDelay, boost) {
            var nativeSetTimeout = window.setTimeout;
            var matchRegexp = toRegExp(matchCallback);
            var timeoutWrapper = function timeoutWrapper(callback, delay) {
              if (!isValidCallback(callback)) {
                var message = "Scriptlet can't be applied because of invalid callback: '".concat(String(callback), "'");
                logMessage(source, message);
              } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
                delay *= getBoostMultiplier(boost);
                hit(source);
              }
              for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }
              return nativeSetTimeout.apply(window, [callback, delay, ...args]);
            };
            window.setTimeout = timeoutWrapper;
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function isValidCallback(callback) {
            return callback instanceof Function || typeof callback === "string";
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function getBoostMultiplier(boost) {
            var DEFAULT_MULTIPLIER = .05;
            var MIN_MULTIPLIER = .001;
            var MAX_MULTIPLIER = 50;
            var parsedBoost = parseFloat(boost);
            var boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER : parsedBoost;
            if (boostMultiplier < MIN_MULTIPLIER) {
              boostMultiplier = MIN_MULTIPLIER;
            }
            if (boostMultiplier > MAX_MULTIPLIER) {
              boostMultiplier = MAX_MULTIPLIER;
            }
            return boostMultiplier;
          }
          function isDelayMatched(inputDelay, realDelay) {
            return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function nativeIsFinite(num) {
            var native = Number.isFinite || window.isFinite;
            return native(num);
          }
          function getMatchDelay(delay) {
            var DEFAULT_DELAY = 1e3;
            var parsedDelay = parseInt(delay, 10);
            var delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY : parsedDelay;
            return delayMatch;
          }
          function shouldMatchAnyDelay(delay) {
            return delay === "*";
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            adjustSetTimeout.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function debugCurrentInlineScript(source, args) {
          function debugCurrentInlineScript(source, property, search) {
            var searchRegexp = toRegExp(search);
            var rid = randomId();
            var getCurrentScript = function getCurrentScript() {
              if ("currentScript" in document) {
                return document.currentScript;
              }
              var scripts = document.getElementsByTagName("script");
              return scripts[scripts.length - 1];
            };
            var ourScript = getCurrentScript();
            var abort = function abort() {
              var scriptEl = getCurrentScript();
              if (!scriptEl) {
                return;
              }
              var content = scriptEl.textContent;
              try {
                var textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, "textContent").get;
                content = textContentGetter.call(scriptEl);
              } catch (e) {}
              if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
                hit(source);
                debugger;
              }
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                chain = chainInfo.chain;
              if (base instanceof Object === false && base === null) {
                var props = property.split(".");
                var propIndex = props.indexOf(prop);
                var baseName = props[propIndex - 1];
                var message = "The scriptlet had been executed before the ".concat(baseName, " was loaded.");
                logMessage(message, source.verbose);
                return;
              }
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              var currentValue = base[prop];
              setPropertyAccess(base, prop, {
                set: function set(value) {
                  abort();
                  currentValue = value;
                },
                get: function get() {
                  abort();
                  return currentValue;
                }
              });
            };
            setChainPropAccess(window, property);
            window.onerror = createOnErrorHandler(rid).bind();
          }
          function randomId() {
            return Math.random().toString(36).slice(2, 9);
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.includes(rid)) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [error, ...args]);
              }
              return false;
            };
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            debugCurrentInlineScript.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function debugOnPropertyRead(source, args) {
          function debugOnPropertyRead(source, property) {
            if (!property) {
              return;
            }
            var rid = randomId();
            var abort = function abort() {
              hit(source);
              debugger;
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                chain = chainInfo.chain;
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              setPropertyAccess(base, prop, {
                get: abort,
                set: noopFunc
              });
            };
            setChainPropAccess(window, property);
            window.onerror = createOnErrorHandler(rid).bind();
          }
          function randomId() {
            return Math.random().toString(36).slice(2, 9);
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.includes(rid)) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [error, ...args]);
              }
              return false;
            };
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function noopFunc() {}
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            debugOnPropertyRead.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function debugOnPropertyWrite(source, args) {
          function debugOnPropertyWrite(source, property) {
            if (!property) {
              return;
            }
            var rid = randomId();
            var abort = function abort() {
              hit(source);
              debugger;
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                chain = chainInfo.chain;
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              setPropertyAccess(base, prop, {
                set: abort
              });
            };
            setChainPropAccess(window, property);
            window.onerror = createOnErrorHandler(rid).bind();
          }
          function randomId() {
            return Math.random().toString(36).slice(2, 9);
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.includes(rid)) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [error, ...args]);
              }
              return false;
            };
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            debugOnPropertyWrite.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function dirString(source, args) {
          function dirString(source, times) {
            var _console = console,
              dir = _console.dir;
            function dirWrapper(object) {
              if (typeof dir === "function") {
                dir.call(this, object);
              }
              hit(source);
            }
            console.dir = dirWrapper;
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            dirString.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function disableNewtabLinks(source, args) {
          function disableNewtabLinks(source) {
            document.addEventListener("click", function (ev) {
              var target = ev.target;
              while (target !== null) {
                if (target.localName === "a" && target.hasAttribute("target")) {
                  ev.stopPropagation();
                  ev.preventDefault();
                  hit(source);
                  break;
                }
                target = target.parentNode;
              }
            });
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            disableNewtabLinks.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function evalDataPrune(source, args) {
          function evalDataPrune(source, propsToRemove, requiredInitialProps, stack) {
            var prunePaths = getPrunePath(propsToRemove);
            var requiredPaths = getPrunePath(requiredInitialProps);
            var nativeObjects = {
              nativeStringify: window.JSON.stringify
            };
            var evalWrapper = function evalWrapper(target, thisArg, args) {
              var data = Reflect.apply(target, thisArg, args);
              if (typeof data === "object") {
                data = jsonPruner(source, data, prunePaths, requiredPaths, stack, nativeObjects);
              }
              return data;
            };
            var evalHandler = {
              apply: evalWrapper
            };
            window.eval = new Proxy(window.eval, evalHandler);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function matchStackTrace(stackMatch, stackTrace) {
            if (!stackMatch || stackMatch === "") {
              return true;
            }
            if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
              return true;
            }
            var stackRegexp = toRegExp(stackMatch);
            var refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
              return line.trim();
            }).join("\n");
            return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
          }
          function getWildcardPropertyInChain(base, chain) {
            var lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
            var pos = chain.indexOf(".");
            if (pos === -1) {
              if (chain === "*" || chain === "[]") {
                for (var key in base) {
                  if (Object.prototype.hasOwnProperty.call(base, key)) {
                    output.push({
                      base: base,
                      prop: key
                    });
                  }
                }
              } else {
                output.push({
                  base: base,
                  prop: chain
                });
              }
              return output;
            }
            var prop = chain.slice(0, pos);
            var shouldLookThrough = prop === "[]" && Array.isArray(base) || prop === "*" && base instanceof Object;
            if (shouldLookThrough) {
              var nextProp = chain.slice(pos + 1);
              var baseKeys = Object.keys(base);
              baseKeys.forEach(function (key) {
                var item = base[key];
                getWildcardPropertyInChain(item, nextProp, lookThrough, output);
              });
            }
            if (Array.isArray(base)) {
              base.forEach(function (key) {
                var nextBase = key;
                if (nextBase !== undefined) {
                  getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
                }
              });
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if (nextBase !== undefined) {
              getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
            }
            return output;
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
            if (!root) {
              return false;
            }
            var nativeStringify = nativeObjects.nativeStringify;
            var shouldProcess;
            if (prunePaths.length === 0 && requiredPaths.length > 0) {
              var rootString = nativeStringify(root);
              var matchRegex = toRegExp(requiredPaths.join(""));
              var shouldLog = matchRegex.test(rootString);
              if (shouldLog) {
                logMessage(source, "".concat(window.location.hostname, "\n").concat(nativeStringify(root, null, 2), "\nStack trace:\n").concat(new Error().stack), true);
                if (root && typeof root === "object") {
                  logMessage(source, root, true, false);
                }
                shouldProcess = false;
                return shouldProcess;
              }
            }
            if (stack && !matchStackTrace(stack, new Error().stack || "")) {
              shouldProcess = false;
              return shouldProcess;
            }
            var wildcardSymbols = [".*.", "*.", ".*", ".[].", "[].", ".[]"];
            var _loop = function _loop() {
              var requiredPath = requiredPaths[i];
              var lastNestedPropName = requiredPath.split(".").pop();
              var hasWildcard = wildcardSymbols.some(function (symbol) {
                return requiredPath.includes(symbol);
              });
              var details = getWildcardPropertyInChain(root, requiredPath, hasWildcard);
              if (!details.length) {
                shouldProcess = false;
                return {
                  v: shouldProcess
                };
              }
              shouldProcess = !hasWildcard;
              for (var j = 0; j < details.length; j += 1) {
                var hasRequiredProp = typeof lastNestedPropName === "string" && details[j].base[lastNestedPropName] !== undefined;
                if (hasWildcard) {
                  shouldProcess = hasRequiredProp || shouldProcess;
                } else {
                  shouldProcess = hasRequiredProp && shouldProcess;
                }
              }
            };
            for (var i = 0; i < requiredPaths.length; i += 1) {
              var _ret = _loop();
              if (typeof _ret === "object") return _ret.v;
            }
            return shouldProcess;
          }
          function jsonPruner(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
            var nativeStringify = nativeObjects.nativeStringify;
            if (prunePaths.length === 0 && requiredPaths.length === 0) {
              logMessage(source, "".concat(window.location.hostname, "\n").concat(nativeStringify(root, null, 2), "\nStack trace:\n").concat(new Error().stack), true);
              if (root && typeof root === "object") {
                logMessage(source, root, true, false);
              }
              return root;
            }
            try {
              if (isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) === false) {
                return root;
              }
              prunePaths.forEach(function (path) {
                var ownerObjArr = getWildcardPropertyInChain(root, path, true);
                ownerObjArr.forEach(function (ownerObj) {
                  if (ownerObj !== undefined && ownerObj.base) {
                    delete ownerObj.base[ownerObj.prop];
                    hit(source);
                  }
                });
              });
            } catch (e) {
              logMessage(source, e);
            }
            return root;
          }
          function getPrunePath(props) {
            var validPropsString = typeof props === "string" && props !== undefined && props !== "";
            return validPropsString ? props.split(/ +/) : [];
          }
          function getNativeRegexpTest() {
            var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
            var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
            if (descriptor && typeof descriptor.value === "function") {
              return nativeRegexTest;
            }
            throw new Error("RegExp.prototype.test is not a function");
          }
          function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
            var INLINE_SCRIPT_STRING = "inlineScript";
            var INJECTED_SCRIPT_STRING = "injectedScript";
            var INJECTED_SCRIPT_MARKER = "<anonymous>";
            var isInlineScript = function isInlineScript(match) {
              return match.includes(INLINE_SCRIPT_STRING);
            };
            var isInjectedScript = function isInjectedScript(match) {
              return match.includes(INJECTED_SCRIPT_STRING);
            };
            if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
              return false;
            }
            var documentURL = window.location.href;
            var pos = documentURL.indexOf("#");
            if (pos !== -1) {
              documentURL = documentURL.slice(0, pos);
            }
            var stackSteps = stackTrace.split("\n").slice(2).map(function (line) {
              return line.trim();
            });
            var stackLines = stackSteps.map(function (line) {
              var stack;
              var getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
              if (getStackTraceURL) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceURL[2];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                  stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                  var _stackFunction;
                  stackURL = INJECTED_SCRIPT_STRING;
                  var stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
                  if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                    stackFunction = stackFunction.slice(2).trim();
                  }
                  stack = "".concat(stackFunction, " ").concat(stackURL).trim();
                } else {
                  stack = stackURL;
                }
              } else {
                stack = line;
              }
              return stack;
            });
            if (stackLines) {
              for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
                  return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING)) {
                  return true;
                }
              }
            }
            return false;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            evalDataPrune.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function forceWindowClose(source, args) {
          function forceWindowClose(source) {
            var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            if (typeof window.close !== "function") {
              var message = "window.close() is not a function so 'close-window' scriptlet is unavailable";
              logMessage(source, message);
              return;
            }
            var closeImmediately = function closeImmediately() {
              try {
                hit(source);
                window.close();
              } catch (e) {
                logMessage(source, e);
              }
            };
            var closeByExtension = function closeByExtension() {
              var extCall = function extCall() {
                dispatchEvent(new Event("adguard:scriptlet-close-window"));
              };
              window.addEventListener("adguard:subscribed-to-close-window", extCall, {
                once: true
              });
              setTimeout(function () {
                window.removeEventListener("adguard:subscribed-to-close-window", extCall, {
                  once: true
                });
              }, 5e3);
            };
            var shouldClose = function shouldClose() {
              if (path === "") {
                return true;
              }
              var pathRegexp = toRegExp(path);
              var currentPath = "".concat(window.location.pathname).concat(window.location.search);
              return pathRegexp.test(currentPath);
            };
            if (shouldClose()) {
              closeImmediately();
              if (navigator.userAgent.includes("Chrome")) {
                closeByExtension();
              }
            }
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            forceWindowClose.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function hideInShadowDom(source, args) {
          function hideInShadowDom(source, selector, baseSelector) {
            if (!Element.prototype.attachShadow) {
              return;
            }
            var hideElement = function hideElement(targetElement) {
              var DISPLAY_NONE_CSS = "display:none!important;";
              targetElement.style.cssText = DISPLAY_NONE_CSS;
            };
            var hideHandler = function hideHandler() {
              var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
              var _loop = function _loop() {
                var isHidden = false;
                var _pierceShadowDom = pierceShadowDom(selector, hostElements),
                  targets = _pierceShadowDom.targets,
                  innerHosts = _pierceShadowDom.innerHosts;
                targets.forEach(function (targetEl) {
                  hideElement(targetEl);
                  isHidden = true;
                });
                if (isHidden) {
                  hit(source);
                }
                hostElements = innerHosts;
              };
              while (hostElements.length !== 0) {
                _loop();
              }
            };
            hideHandler();
            observeDOMChanges(hideHandler, true);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function observeDOMChanges(callback) {
            var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
            var THROTTLE_DELAY_MS = 20;
            var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
            var connect = function connect() {
              if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs,
                  attributeFilter: attrsToObserve
                });
              } else {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs
                });
              }
            };
            var disconnect = function disconnect() {
              observer.disconnect();
            };
            function callbackWrapper() {
              disconnect();
              callback();
              connect();
            }
            connect();
          }
          function findHostElements(rootElement) {
            var hosts = [];
            if (rootElement) {
              var domElems = rootElement.querySelectorAll("*");
              domElems.forEach(function (el) {
                if (el.shadowRoot) {
                  hosts.push(el);
                }
              });
            }
            return hosts;
          }
          function pierceShadowDom(selector, hostElements) {
            var targets = [];
            var innerHostsAcc = [];
            hostElements.forEach(function (host) {
              var simpleElems = host.querySelectorAll(selector);
              targets = targets.concat([].slice.call(simpleElems));
              var shadowRootElem = host.shadowRoot;
              var shadowChildren = shadowRootElem.querySelectorAll(selector);
              targets = targets.concat([].slice.call(shadowChildren));
              innerHostsAcc.push(findHostElements(shadowRootElem));
            });
            var innerHosts = flatten(innerHostsAcc);
            return {
              targets: targets,
              innerHosts: innerHosts
            };
          }
          function flatten(input) {
            var stack = [];
            input.forEach(function (el) {
              return stack.push(el);
            });
            var res = [];
            while (stack.length) {
              var next = stack.pop();
              if (Array.isArray(next)) {
                next.forEach(function (el) {
                  return stack.push(el);
                });
              } else {
                res.push(next);
              }
            }
            return res.reverse();
          }
          function throttle(cb, delay) {
            var wait = false;
            var savedArgs;
            var wrapper = function wrapper() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              if (wait) {
                savedArgs = args;
                return;
              }
              cb(...args);
              wait = true;
              setTimeout(function () {
                wait = false;
                if (savedArgs) {
                  wrapper(...savedArgs);
                  savedArgs = null;
                }
              }, delay);
            };
            return wrapper;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            hideInShadowDom.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function injectCssInShadowDom(source, args) {
          function injectCssInShadowDom(source, cssRule) {
            var hostSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
            if (!Element.prototype.attachShadow || typeof Proxy === "undefined" || typeof Reflect === "undefined") {
              return;
            }
            if (cssRule.match(/(url|image-set)\(.*\)/i)) {
              logMessage(source, '"url()" function is not allowed for css rules');
              return;
            }
            var callback = function callback(shadowRoot) {
              try {
                var stylesheet = new CSSStyleSheet();
                try {
                  stylesheet.insertRule(cssRule);
                } catch (e) {
                  logMessage(source, "Unable to apply the rule '".concat(cssRule, "' due to: \n'").concat(e.message, "'"));
                  return;
                }
                shadowRoot.adoptedStyleSheets = [...shadowRoot.adoptedStyleSheets, stylesheet];
              } catch (_unused) {
                var styleTag = document.createElement("style");
                styleTag.innerText = cssRule;
                shadowRoot.appendChild(styleTag);
              }
              hit(source);
            };
            hijackAttachShadow(window, hostSelector, callback);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function hijackAttachShadow(context, hostSelector, callback) {
            var handlerWrapper = function handlerWrapper(target, thisArg, args) {
              var shadowRoot = Reflect.apply(target, thisArg, args);
              if (thisArg && thisArg.matches(hostSelector || "*")) {
                callback(shadowRoot);
              }
              return shadowRoot;
            };
            var attachShadowHandler = {
              apply: handlerWrapper
            };
            context.Element.prototype.attachShadow = new Proxy(context.Element.prototype.attachShadow, attachShadowHandler);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            injectCssInShadowDom.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function jsonPrune(source, args) {
          function jsonPrune(source, propsToRemove, requiredInitialProps) {
            var stack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
            var prunePaths = getPrunePath(propsToRemove);
            var requiredPaths = getPrunePath(requiredInitialProps);
            var nativeObjects = {
              nativeStringify: window.JSON.stringify
            };
            var nativeJSONParse = JSON.parse;
            var jsonParseWrapper = function jsonParseWrapper() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              var root = nativeJSONParse.apply(JSON, args);
              return jsonPruner(source, root, prunePaths, requiredPaths, stack, nativeObjects);
            };
            jsonParseWrapper.toString = nativeJSONParse.toString.bind(nativeJSONParse);
            JSON.parse = jsonParseWrapper;
            var nativeResponseJson = Response.prototype.json;
            var responseJsonWrapper = function responseJsonWrapper() {
              var promise = nativeResponseJson.apply(this);
              return promise.then(function (obj) {
                return jsonPruner(source, obj, prunePaths, requiredPaths, stack, nativeObjects);
              });
            };
            if (typeof Response === "undefined") {
              return;
            }
            Response.prototype.json = responseJsonWrapper;
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function matchStackTrace(stackMatch, stackTrace) {
            if (!stackMatch || stackMatch === "") {
              return true;
            }
            if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
              return true;
            }
            var stackRegexp = toRegExp(stackMatch);
            var refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
              return line.trim();
            }).join("\n");
            return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
          }
          function getWildcardPropertyInChain(base, chain) {
            var lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
            var pos = chain.indexOf(".");
            if (pos === -1) {
              if (chain === "*" || chain === "[]") {
                for (var key in base) {
                  if (Object.prototype.hasOwnProperty.call(base, key)) {
                    output.push({
                      base: base,
                      prop: key
                    });
                  }
                }
              } else {
                output.push({
                  base: base,
                  prop: chain
                });
              }
              return output;
            }
            var prop = chain.slice(0, pos);
            var shouldLookThrough = prop === "[]" && Array.isArray(base) || prop === "*" && base instanceof Object;
            if (shouldLookThrough) {
              var nextProp = chain.slice(pos + 1);
              var baseKeys = Object.keys(base);
              baseKeys.forEach(function (key) {
                var item = base[key];
                getWildcardPropertyInChain(item, nextProp, lookThrough, output);
              });
            }
            if (Array.isArray(base)) {
              base.forEach(function (key) {
                var nextBase = key;
                if (nextBase !== undefined) {
                  getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
                }
              });
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if (nextBase !== undefined) {
              getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
            }
            return output;
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
            if (!root) {
              return false;
            }
            var nativeStringify = nativeObjects.nativeStringify;
            var shouldProcess;
            if (prunePaths.length === 0 && requiredPaths.length > 0) {
              var rootString = nativeStringify(root);
              var matchRegex = toRegExp(requiredPaths.join(""));
              var shouldLog = matchRegex.test(rootString);
              if (shouldLog) {
                logMessage(source, "".concat(window.location.hostname, "\n").concat(nativeStringify(root, null, 2), "\nStack trace:\n").concat(new Error().stack), true);
                if (root && typeof root === "object") {
                  logMessage(source, root, true, false);
                }
                shouldProcess = false;
                return shouldProcess;
              }
            }
            if (stack && !matchStackTrace(stack, new Error().stack || "")) {
              shouldProcess = false;
              return shouldProcess;
            }
            var wildcardSymbols = [".*.", "*.", ".*", ".[].", "[].", ".[]"];
            var _loop = function _loop() {
              var requiredPath = requiredPaths[i];
              var lastNestedPropName = requiredPath.split(".").pop();
              var hasWildcard = wildcardSymbols.some(function (symbol) {
                return requiredPath.includes(symbol);
              });
              var details = getWildcardPropertyInChain(root, requiredPath, hasWildcard);
              if (!details.length) {
                shouldProcess = false;
                return {
                  v: shouldProcess
                };
              }
              shouldProcess = !hasWildcard;
              for (var j = 0; j < details.length; j += 1) {
                var hasRequiredProp = typeof lastNestedPropName === "string" && details[j].base[lastNestedPropName] !== undefined;
                if (hasWildcard) {
                  shouldProcess = hasRequiredProp || shouldProcess;
                } else {
                  shouldProcess = hasRequiredProp && shouldProcess;
                }
              }
            };
            for (var i = 0; i < requiredPaths.length; i += 1) {
              var _ret = _loop();
              if (typeof _ret === "object") return _ret.v;
            }
            return shouldProcess;
          }
          function jsonPruner(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
            var nativeStringify = nativeObjects.nativeStringify;
            if (prunePaths.length === 0 && requiredPaths.length === 0) {
              logMessage(source, "".concat(window.location.hostname, "\n").concat(nativeStringify(root, null, 2), "\nStack trace:\n").concat(new Error().stack), true);
              if (root && typeof root === "object") {
                logMessage(source, root, true, false);
              }
              return root;
            }
            try {
              if (isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) === false) {
                return root;
              }
              prunePaths.forEach(function (path) {
                var ownerObjArr = getWildcardPropertyInChain(root, path, true);
                ownerObjArr.forEach(function (ownerObj) {
                  if (ownerObj !== undefined && ownerObj.base) {
                    delete ownerObj.base[ownerObj.prop];
                    hit(source);
                  }
                });
              });
            } catch (e) {
              logMessage(source, e);
            }
            return root;
          }
          function getPrunePath(props) {
            var validPropsString = typeof props === "string" && props !== undefined && props !== "";
            return validPropsString ? props.split(/ +/) : [];
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function getNativeRegexpTest() {
            var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
            var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
            if (descriptor && typeof descriptor.value === "function") {
              return nativeRegexTest;
            }
            throw new Error("RegExp.prototype.test is not a function");
          }
          function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
            var INLINE_SCRIPT_STRING = "inlineScript";
            var INJECTED_SCRIPT_STRING = "injectedScript";
            var INJECTED_SCRIPT_MARKER = "<anonymous>";
            var isInlineScript = function isInlineScript(match) {
              return match.includes(INLINE_SCRIPT_STRING);
            };
            var isInjectedScript = function isInjectedScript(match) {
              return match.includes(INJECTED_SCRIPT_STRING);
            };
            if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
              return false;
            }
            var documentURL = window.location.href;
            var pos = documentURL.indexOf("#");
            if (pos !== -1) {
              documentURL = documentURL.slice(0, pos);
            }
            var stackSteps = stackTrace.split("\n").slice(2).map(function (line) {
              return line.trim();
            });
            var stackLines = stackSteps.map(function (line) {
              var stack;
              var getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
              if (getStackTraceURL) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceURL[2];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                  stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                  var _stackFunction;
                  stackURL = INJECTED_SCRIPT_STRING;
                  var stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
                  if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                    stackFunction = stackFunction.slice(2).trim();
                  }
                  stack = "".concat(stackFunction, " ").concat(stackURL).trim();
                } else {
                  stack = stackURL;
                }
              } else {
                stack = line;
              }
              return stack;
            });
            if (stackLines) {
              for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
                  return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING)) {
                  return true;
                }
              }
            }
            return false;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            jsonPrune.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function log(source, args) {
          function log() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            console.log(args);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            log.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function logAddEventListener(source, args) {
          function logAddEventListener(source) {
            var nativeAddEventListener = window.EventTarget.prototype.addEventListener;
            function addEventListenerWrapper(type, listener) {
              var _this$constructor;
              if (validateType(type) && validateListener(listener)) {
                var message = 'addEventListener("'.concat(type, '", ').concat(listenerToString(listener), ")");
                logMessage(source, message, true);
                hit(source);
              } else {
                var _message = "Invalid event type or listener passed to addEventListener:\n        type: ".concat(convertTypeToString(type), "\n        listener: ").concat(convertTypeToString(listener));
                logMessage(source, _message, true);
              }
              var context = this;
              if (this && ((_this$constructor = this.constructor) === null || _this$constructor === void 0 ? void 0 : _this$constructor.name) === "Window" && this !== window) {
                context = window;
              }
              for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }
              return nativeAddEventListener.apply(context, [type, listener, ...args]);
            }
            var descriptor = {
              configurable: true,
              set: function set() {},
              get: function get() {
                return addEventListenerWrapper;
              }
            };
            Object.defineProperty(window.EventTarget.prototype, "addEventListener", descriptor);
            Object.defineProperty(window, "addEventListener", descriptor);
            Object.defineProperty(document, "addEventListener", descriptor);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function validateType(type) {
            return typeof type !== "undefined";
          }
          function validateListener(listener) {
            return typeof listener !== "undefined" && (typeof listener === "function" || typeof listener === "object" && listener !== null && "handleEvent" in listener && typeof listener.handleEvent === "function");
          }
          function listenerToString(listener) {
            return typeof listener === "function" ? listener.toString() : listener.handleEvent.toString();
          }
          function convertTypeToString(value) {
            var output;
            if (typeof value === "undefined") {
              output = "undefined";
            } else if (typeof value === "object") {
              if (value === null) {
                output = "null";
              } else {
                output = objectToString(value);
              }
            } else {
              output = value.toString();
            }
            return output;
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function objectToString(obj) {
            if (!obj || typeof obj !== "object") {
              return String(obj);
            }
            return isEmptyObject(obj) ? "{}" : Object.entries(obj).map(function (pair) {
              var key = pair[0];
              var value = pair[1];
              var recordValueStr = value;
              if (value instanceof Object) {
                recordValueStr = "{ ".concat(objectToString(value), " }");
              }
              return "".concat(key, ':"').concat(recordValueStr, '"');
            }).join(" ");
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            logAddEventListener.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function logEval(source, args) {
          function logEval(source) {
            var nativeEval = window.eval;
            function evalWrapper(str) {
              hit(source);
              logMessage(source, 'eval("'.concat(str, '")'), true);
              return nativeEval(str);
            }
            window.eval = evalWrapper;
            var nativeFunction = window.Function;
            function FunctionWrapper() {
              hit(source);
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              logMessage(source, "new Function(".concat(args.join(", "), ")"), true);
              return nativeFunction.apply(this, [...args]);
            }
            FunctionWrapper.prototype = Object.create(nativeFunction.prototype);
            FunctionWrapper.prototype.constructor = FunctionWrapper;
            window.Function = FunctionWrapper;
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            logEval.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function logOnStacktrace(source, args) {
          function logOnStacktrace(source, property) {
            if (!property) {
              return;
            }
            var refineStackTrace = function refineStackTrace(stackString) {
              var stackSteps = stackString.split("\n").slice(2).map(function (line) {
                return line.replace(/ {4}at /, "");
              });
              var logInfoArray = stackSteps.map(function (line) {
                var funcName;
                var funcFullPath;
                var reg = /\(([^\)]+)\)/;
                var regFirefox = /(.*?@)(\S+)(:\d+):\d+\)?$/;
                if (line.match(reg)) {
                  funcName = line.split(" ").slice(0, -1).join(" ");
                  funcFullPath = line.match(reg)[1];
                } else if (line.match(regFirefox)) {
                  funcName = line.split("@").slice(0, -1).join(" ");
                  funcFullPath = line.match(regFirefox)[2];
                } else {
                  funcName = "function name is not available";
                  funcFullPath = line;
                }
                return [funcName, funcFullPath];
              });
              var logInfoObject = {};
              logInfoArray.forEach(function (pair) {
                logInfoObject[pair[0]] = pair[1];
              });
              return logInfoObject;
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                chain = chainInfo.chain;
              if (chain) {
                var setter = function setter(a) {
                  base = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                };
                Object.defineProperty(owner, prop, {
                  get: function get() {
                    return base;
                  },
                  set: setter
                });
                return;
              }
              var value = base[prop];
              setPropertyAccess(base, prop, {
                get() {
                  hit(source);
                  logMessage(source, "Get ".concat(prop), true);
                  console.table(refineStackTrace(new Error().stack));
                  return value;
                },
                set(newValue) {
                  hit(source);
                  logMessage(source, "Set ".concat(prop), true);
                  console.table(refineStackTrace(new Error().stack));
                  value = newValue;
                }
              });
            };
            setChainPropAccess(window, property);
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            logOnStacktrace.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function m3uPrune(source, args) {
          function m3uPrune(source, propsToRemove) {
            var urlToMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
            if (typeof Reflect === "undefined" || typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
              return;
            }
            var shouldPruneResponse = false;
            var urlMatchRegexp = toRegExp(urlToMatch);
            var SEGMENT_MARKER = "#";
            var AD_MARKER = {
              ASSET: "#EXT-X-ASSET:",
              CUE: "#EXT-X-CUE:",
              CUE_IN: "#EXT-X-CUE-IN",
              DISCONTINUITY: "#EXT-X-DISCONTINUITY",
              EXTINF: "#EXTINF",
              EXTM3U: "#EXTM3U",
              SCTE35: "#EXT-X-SCTE35:"
            };
            var COMCAST_AD_MARKER = {
              AD: "-AD-",
              VAST: "-VAST-",
              VMAP_AD: "-VMAP-AD-",
              VMAP_AD_BREAK: "#EXT-X-VMAP-AD-BREAK:"
            };
            var TAGS_ALLOWLIST = ["#EXT-X-TARGETDURATION", "#EXT-X-MEDIA-SEQUENCE", "#EXT-X-DISCONTINUITY-SEQUENCE", "#EXT-X-ENDLIST", "#EXT-X-PLAYLIST-TYPE", "#EXT-X-I-FRAMES-ONLY", "#EXT-X-MEDIA", "#EXT-X-STREAM-INF", "#EXT-X-I-FRAME-STREAM-INF", "#EXT-X-SESSION-DATA", "#EXT-X-SESSION-KEY", "#EXT-X-INDEPENDENT-SEGMENTS", "#EXT-X-START"];
            var isAllowedTag = function isAllowedTag(str) {
              return TAGS_ALLOWLIST.some(function (el) {
                return str.startsWith(el);
              });
            };
            var pruneExtinfFromVmapBlock = function pruneExtinfFromVmapBlock(lines, i) {
              var array = lines.slice();
              var index = i;
              if (array[index].includes(AD_MARKER.EXTINF)) {
                array[index] = undefined;
                index += 1;
                if (array[index].includes(AD_MARKER.DISCONTINUITY)) {
                  array[index] = undefined;
                  index += 1;
                  var prunedExtinf = pruneExtinfFromVmapBlock(array, index);
                  array = prunedExtinf.array;
                  index = prunedExtinf.index;
                }
              }
              return {
                array: array,
                index: index
              };
            };
            var pruneVmapBlock = function pruneVmapBlock(lines) {
              var array = lines.slice();
              for (var i = 0; i < array.length - 1; i += 1) {
                if (array[i].includes(COMCAST_AD_MARKER.VMAP_AD) || array[i].includes(COMCAST_AD_MARKER.VAST) || array[i].includes(COMCAST_AD_MARKER.AD)) {
                  array[i] = undefined;
                  if (array[i + 1].includes(AD_MARKER.EXTINF)) {
                    i += 1;
                    var prunedExtinf = pruneExtinfFromVmapBlock(array, i);
                    array = prunedExtinf.array;
                    i = prunedExtinf.index - 1;
                  }
                }
              }
              return array;
            };
            var pruneSpliceoutBlock = function pruneSpliceoutBlock(line, index, array) {
              if (!line.startsWith(AD_MARKER.CUE)) {
                return line;
              }
              line = undefined;
              index += 1;
              if (array[index].startsWith(AD_MARKER.ASSET)) {
                array[index] = undefined;
                index += 1;
              }
              if (array[index].startsWith(AD_MARKER.SCTE35)) {
                array[index] = undefined;
                index += 1;
              }
              if (array[index].startsWith(AD_MARKER.CUE_IN)) {
                array[index] = undefined;
                index += 1;
              }
              if (array[index].startsWith(AD_MARKER.SCTE35)) {
                array[index] = undefined;
              }
              return line;
            };
            var removeM3ULineRegexp = toRegExp(propsToRemove);
            var pruneInfBlock = function pruneInfBlock(line, index, array) {
              if (!line.startsWith(AD_MARKER.EXTINF)) {
                return line;
              }
              if (!removeM3ULineRegexp.test(array[index + 1])) {
                return line;
              }
              if (!isAllowedTag(array[index])) {
                array[index] = undefined;
              }
              index += 1;
              if (!isAllowedTag(array[index])) {
                array[index] = undefined;
              }
              index += 1;
              if (array[index].startsWith(AD_MARKER.DISCONTINUITY)) {
                array[index] = undefined;
              }
              return line;
            };
            var pruneSegments = function pruneSegments(lines) {
              for (var i = 0; i < lines.length - 1; i += 1) {
                var _lines$i;
                if ((_lines$i = lines[i]) !== null && _lines$i !== void 0 && _lines$i.startsWith(SEGMENT_MARKER) && removeM3ULineRegexp.test(lines[i])) {
                  var segmentName = lines[i].substring(0, lines[i].indexOf(":"));
                  if (!segmentName) {
                    return lines;
                  }
                  lines[i] = undefined;
                  i += 1;
                  for (var j = i; j < lines.length; j += 1) {
                    if (!lines[j].includes(segmentName) && !isAllowedTag(lines[j])) {
                      lines[j] = undefined;
                    } else {
                      i = j - 1;
                      break;
                    }
                  }
                }
              }
              return lines;
            };
            var isM3U = function isM3U(text) {
              if (typeof text === "string") {
                var trimmedText = text.trim();
                return trimmedText.startsWith(AD_MARKER.EXTM3U) || trimmedText.startsWith(COMCAST_AD_MARKER.VMAP_AD_BREAK);
              }
              return false;
            };
            var isPruningNeeded = function isPruningNeeded(text, regexp) {
              return isM3U(text) && regexp.test(text);
            };
            var pruneM3U = function pruneM3U(text) {
              var lines = text.split(/\r?\n/);
              if (text.includes(COMCAST_AD_MARKER.VMAP_AD_BREAK)) {
                lines = pruneVmapBlock(lines);
                return lines.filter(function (l) {
                  return !!l;
                }).join("\n");
              }
              lines = pruneSegments(lines);
              return lines.map(function (line, index, array) {
                if (typeof line === "undefined") {
                  return line;
                }
                line = pruneSpliceoutBlock(line, index, array);
                if (typeof line !== "undefined") {
                  line = pruneInfBlock(line, index, array);
                }
                return line;
              }).filter(function (l) {
                return !!l;
              }).join("\n");
            };
            var nativeOpen = window.XMLHttpRequest.prototype.open;
            var nativeSend = window.XMLHttpRequest.prototype.send;
            var xhrData;
            var openWrapper = function openWrapper(target, thisArg, args) {
              xhrData = getXhrData.apply(null, args);
              if (matchRequestProps(source, urlToMatch, xhrData)) {
                thisArg.shouldBePruned = true;
              }
              if (thisArg.shouldBePruned) {
                thisArg.collectedHeaders = [];
                var setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
                  thisArg.collectedHeaders.push(args);
                  return Reflect.apply(target, thisArg, args);
                };
                var setRequestHeaderHandler = {
                  apply: setRequestHeaderWrapper
                };
                thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
              }
              return Reflect.apply(target, thisArg, args);
            };
            var sendWrapper = function sendWrapper(target, thisArg, args) {
              var allowedResponseTypeValues = ["", "text"];
              if (!thisArg.shouldBePruned || !allowedResponseTypeValues.includes(thisArg.responseType)) {
                return Reflect.apply(target, thisArg, args);
              }
              var forgedRequest = new XMLHttpRequest();
              forgedRequest.addEventListener("readystatechange", function () {
                if (forgedRequest.readyState !== 4) {
                  return;
                }
                var readyState = forgedRequest.readyState,
                  response = forgedRequest.response,
                  responseText = forgedRequest.responseText,
                  responseURL = forgedRequest.responseURL,
                  responseXML = forgedRequest.responseXML,
                  status = forgedRequest.status,
                  statusText = forgedRequest.statusText;
                var content = responseText || response;
                if (typeof content !== "string") {
                  return;
                }
                if (!propsToRemove) {
                  if (isM3U(response)) {
                    var message = "XMLHttpRequest.open() URL: ".concat(responseURL, "\nresponse: ").concat(response);
                    logMessage(source, message);
                  }
                } else {
                  shouldPruneResponse = isPruningNeeded(response, removeM3ULineRegexp);
                }
                var responseContent = shouldPruneResponse ? pruneM3U(response) : response;
                Object.defineProperties(thisArg, {
                  readyState: {
                    value: readyState,
                    writable: false
                  },
                  responseURL: {
                    value: responseURL,
                    writable: false
                  },
                  responseXML: {
                    value: responseXML,
                    writable: false
                  },
                  status: {
                    value: status,
                    writable: false
                  },
                  statusText: {
                    value: statusText,
                    writable: false
                  },
                  response: {
                    value: responseContent,
                    writable: false
                  },
                  responseText: {
                    value: responseContent,
                    writable: false
                  }
                });
                setTimeout(function () {
                  var stateEvent = new Event("readystatechange");
                  thisArg.dispatchEvent(stateEvent);
                  var loadEvent = new Event("load");
                  thisArg.dispatchEvent(loadEvent);
                  var loadEndEvent = new Event("loadend");
                  thisArg.dispatchEvent(loadEndEvent);
                }, 1);
                hit(source);
              });
              nativeOpen.apply(forgedRequest, [xhrData.method, xhrData.url]);
              thisArg.collectedHeaders.forEach(function (header) {
                var name = header[0];
                var value = header[1];
                forgedRequest.setRequestHeader(name, value);
              });
              thisArg.collectedHeaders = [];
              try {
                nativeSend.call(forgedRequest, args);
              } catch (_unused) {
                return Reflect.apply(target, thisArg, args);
              }
              return undefined;
            };
            var openHandler = {
              apply: openWrapper
            };
            var sendHandler = {
              apply: sendWrapper
            };
            XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
            XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
            var nativeFetch = window.fetch;
            var fetchWrapper = async function fetchWrapper(target, thisArg, args) {
              var fetchURL = args[0] instanceof Request ? args[0].url : args[0];
              if (typeof fetchURL !== "string" || fetchURL.length === 0) {
                return Reflect.apply(target, thisArg, args);
              }
              if (urlMatchRegexp.test(fetchURL)) {
                var response = await nativeFetch(...args);
                var clonedResponse = response.clone();
                var responseText = await response.text();
                if (!propsToRemove && isM3U(responseText)) {
                  var message = "fetch URL: ".concat(fetchURL, "\nresponse text: ").concat(responseText);
                  logMessage(source, message);
                  return clonedResponse;
                }
                if (isPruningNeeded(responseText, removeM3ULineRegexp)) {
                  var prunedText = pruneM3U(responseText);
                  hit(source);
                  return new Response(prunedText, {
                    status: response.status,
                    statusText: response.statusText,
                    headers: response.headers
                  });
                }
                return clonedResponse;
              }
              return Reflect.apply(target, thisArg, args);
            };
            var fetchHandler = {
              apply: fetchWrapper
            };
            window.fetch = new Proxy(window.fetch, fetchHandler);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function getXhrData(method, url, async, user, password) {
            return {
              method: method,
              url: url,
              async: async,
              user: user,
              password: password
            };
          }
          function matchRequestProps(source, propsToMatch, requestData) {
            if (propsToMatch === "" || propsToMatch === "*") {
              return true;
            }
            var isMatched;
            var parsedData = parseMatchProps(propsToMatch);
            if (!isValidParsedData(parsedData)) {
              logMessage(source, "Invalid parameter: ".concat(propsToMatch));
              isMatched = false;
            } else {
              var matchData = getMatchPropsData(parsedData);
              var matchKeys = Object.keys(matchData);
              isMatched = matchKeys.every(function (matchKey) {
                var matchValue = matchData[matchKey];
                var dataValue = requestData[matchKey];
                return Object.prototype.hasOwnProperty.call(requestData, matchKey) && typeof dataValue === "string" && (matchValue === null || matchValue === void 0 ? void 0 : matchValue.test(dataValue));
              });
            }
            return isMatched;
          }
          function getMatchPropsData(data) {
            var matchData = {};
            var dataKeys = Object.keys(data);
            dataKeys.forEach(function (key) {
              matchData[key] = toRegExp(data[key]);
            });
            return matchData;
          }
          function getRequestProps() {
            return ["url", "method", "headers", "body", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal", "mode"];
          }
          function isValidParsedData(data) {
            return Object.values(data).every(function (value) {
              return isValidStrPattern(value);
            });
          }
          function parseMatchProps(propsToMatchStr) {
            var PROPS_DIVIDER = " ";
            var PAIRS_MARKER = ":";
            var isRequestProp = function isRequestProp(prop) {
              return getRequestProps().includes(prop);
            };
            var propsObj = {};
            var props = propsToMatchStr.split(PROPS_DIVIDER);
            props.forEach(function (prop) {
              var dividerInd = prop.indexOf(PAIRS_MARKER);
              var key = prop.slice(0, dividerInd);
              if (isRequestProp(key)) {
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
              } else {
                propsObj.url = prop;
              }
            });
            return propsObj;
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            m3uPrune.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function noTopics(source, args) {
          function noTopics(source) {
            var TOPICS_PROPERTY_NAME = "browsingTopics";
            if (Document instanceof Object === false) {
              return;
            }
            if (!Object.prototype.hasOwnProperty.call(Document.prototype, TOPICS_PROPERTY_NAME) || Document.prototype[TOPICS_PROPERTY_NAME] instanceof Function === false) {
              return;
            }
            Document.prototype[TOPICS_PROPERTY_NAME] = function () {
              return noopPromiseResolve("[]");
            };
            hit(source);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function noopPromiseResolve() {
            var responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "{}";
            var responseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            var responseType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "default";
            if (typeof Response === "undefined") {
              return;
            }
            var response = new Response(responseBody, {
              status: 200,
              statusText: "OK"
            });
            Object.defineProperties(response, {
              url: {
                value: responseUrl
              },
              type: {
                value: responseType
              }
            });
            if (responseType === "opaque") {
              Object.defineProperties(response, {
                body: {
                  value: null
                },
                status: {
                  value: 0
                },
                statusText: {
                  value: ""
                }
              });
            }
            return Promise.resolve(response);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            noTopics.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function noeval(source, args) {
          function noeval(source) {
            window.eval = function evalWrapper(s) {
              hit(source);
              logMessage(source, "AdGuard has prevented eval:\n".concat(s), true);
            }.bind();
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            noeval.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function nowebrtc(source, args) {
          function nowebrtc(source) {
            var propertyName = "";
            if (window.RTCPeerConnection) {
              propertyName = "RTCPeerConnection";
            } else if (window.webkitRTCPeerConnection) {
              propertyName = "webkitRTCPeerConnection";
            }
            if (propertyName === "") {
              return;
            }
            var rtcReplacement = function rtcReplacement(config) {
              var message = "Document tried to create an RTCPeerConnection: ".concat(convertRtcConfigToString(config));
              logMessage(source, message);
              hit(source);
            };
            rtcReplacement.prototype = {
              close: noopFunc,
              createDataChannel: noopFunc,
              createOffer: noopFunc,
              setRemoteDescription: noopFunc
            };
            var rtc = window[propertyName];
            window[propertyName] = rtcReplacement;
            if (rtc.prototype) {
              rtc.prototype.createDataChannel = function (a, b) {
                return {
                  close: noopFunc,
                  send: noopFunc
                };
              }.bind(null);
            }
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function noopFunc() {}
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function convertRtcConfigToString(config) {
            var UNDEF_STR = "undefined";
            var str = UNDEF_STR;
            if (config === null) {
              str = "null";
            } else if (config instanceof Object) {
              var SERVERS_PROP_NAME = "iceServers";
              var URLS_PROP_NAME = "urls";
              if (Object.prototype.hasOwnProperty.call(config, SERVERS_PROP_NAME) && config[SERVERS_PROP_NAME] && Object.prototype.hasOwnProperty.call(config[SERVERS_PROP_NAME][0], URLS_PROP_NAME) && !!config[SERVERS_PROP_NAME][0][URLS_PROP_NAME]) {
                str = config[SERVERS_PROP_NAME][0][URLS_PROP_NAME].toString();
              }
            }
            return str;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            nowebrtc.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventAddEventListener(source, args) {
          function preventAddEventListener(source, typeSearch, listenerSearch) {
            var typeSearchRegexp = toRegExp(typeSearch);
            var listenerSearchRegexp = toRegExp(listenerSearch);
            var nativeAddEventListener = window.EventTarget.prototype.addEventListener;
            function addEventListenerWrapper(type, listener) {
              var _this$constructor;
              var shouldPrevent = false;
              if (validateType(type) && validateListener(listener)) {
                shouldPrevent = typeSearchRegexp.test(type.toString()) && listenerSearchRegexp.test(listenerToString(listener));
              }
              if (shouldPrevent) {
                hit(source);
                return undefined;
              }
              var context = this;
              if (this && ((_this$constructor = this.constructor) === null || _this$constructor === void 0 ? void 0 : _this$constructor.name) === "Window" && this !== window) {
                context = window;
              }
              for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }
              return nativeAddEventListener.apply(context, [type, listener, ...args]);
            }
            var descriptor = {
              configurable: true,
              set: function set() {},
              get: function get() {
                return addEventListenerWrapper;
              }
            };
            Object.defineProperty(window.EventTarget.prototype, "addEventListener", descriptor);
            Object.defineProperty(window, "addEventListener", descriptor);
            Object.defineProperty(document, "addEventListener", descriptor);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function validateType(type) {
            return typeof type !== "undefined";
          }
          function validateListener(listener) {
            return typeof listener !== "undefined" && (typeof listener === "function" || typeof listener === "object" && listener !== null && "handleEvent" in listener && typeof listener.handleEvent === "function");
          }
          function listenerToString(listener) {
            return typeof listener === "function" ? listener.toString() : listener.handleEvent.toString();
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventAddEventListener.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventAdfly(source, args) {
          function preventAdfly(source) {
            var isDigit = function isDigit(data) {
              return /^\d$/.test(data);
            };
            var handler = function handler(encodedURL) {
              var evenChars = "";
              var oddChars = "";
              for (var i = 0; i < encodedURL.length; i += 1) {
                if (i % 2 === 0) {
                  evenChars += encodedURL.charAt(i);
                } else {
                  oddChars = encodedURL.charAt(i) + oddChars;
                }
              }
              var data = (evenChars + oddChars).split("");
              for (var _i = 0; _i < data.length; _i += 1) {
                if (isDigit(data[_i])) {
                  for (var ii = _i + 1; ii < data.length; ii += 1) {
                    if (isDigit(data[ii])) {
                      var temp = parseInt(data[_i], 10) ^ parseInt(data[ii], 10);
                      if (temp < 10) {
                        data[_i] = temp.toString();
                      }
                      _i = ii;
                      break;
                    }
                  }
                }
              }
              data = data.join("");
              var decodedURL = window.atob(data).slice(16, -16);
              if (window.stop) {
                window.stop();
              }
              window.onbeforeunload = null;
              window.location.href = decodedURL;
            };
            var val;
            var applyHandler = true;
            var result = setPropertyAccess(window, "ysmm", {
              configurable: false,
              set: function set(value) {
                if (applyHandler) {
                  applyHandler = false;
                  try {
                    if (typeof value === "string") {
                      handler(value);
                    }
                  } catch (err) {}
                }
                val = value;
              },
              get: function get() {
                return val;
              }
            });
            if (result) {
              hit(source);
            } else {
              logMessage(source, "Failed to set up prevent-adfly scriptlet");
            }
          }
          function setPropertyAccess(object, property, descriptor) {
            var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
            if (currentDescriptor && !currentDescriptor.configurable) {
              return false;
            }
            Object.defineProperty(object, property, descriptor);
            return true;
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventAdfly.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventBab(source, args) {
          function preventBab(source) {
            var nativeSetTimeout = window.setTimeout;
            var babRegex = /\.bab_elementid.$/;
            var timeoutWrapper = function timeoutWrapper(callback) {
              if (typeof callback !== "string" || !babRegex.test(callback)) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeSetTimeout.apply(window, [callback, ...args]);
              }
              hit(source);
            };
            window.setTimeout = timeoutWrapper;
            var signatures = [["blockadblock"], ["babasbm"], [/getItem\('babn'\)/], ["getElementById", "String.fromCharCode", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", "charAt", "DOMContentLoaded", "AdBlock", "addEventListener", "doScroll", "fromCharCode", "<<2|r>>4", "sessionStorage", "clientWidth", "localStorage", "Math", "random"]];
            var check = function check(str) {
              if (typeof str !== "string") {
                return false;
              }
              for (var i = 0; i < signatures.length; i += 1) {
                var tokens = signatures[i];
                var match = 0;
                for (var j = 0; j < tokens.length; j += 1) {
                  var token = tokens[j];
                  var found = token instanceof RegExp ? token.test(str) : str.includes(token);
                  if (found) {
                    match += 1;
                  }
                }
                if (match / tokens.length >= .8) {
                  return true;
                }
              }
              return false;
            };
            var nativeEval = window.eval;
            var evalWrapper = function evalWrapper(str) {
              if (!check(str)) {
                return nativeEval(str);
              }
              hit(source);
              var bodyEl = document.body;
              if (bodyEl) {
                bodyEl.style.removeProperty("visibility");
              }
              var el = document.getElementById("babasbmsgx");
              if (el) {
                el.parentNode.removeChild(el);
              }
            };
            window.eval = evalWrapper.bind(window);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventBab.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventElementSrcLoading(source, args) {
          function preventElementSrcLoading(source, tagName, match) {
            if (typeof Proxy === "undefined" || typeof Reflect === "undefined") {
              return;
            }
            var srcMockData = {
              script: "data:text/javascript;base64,KCk9Pnt9",
              img: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
              iframe: "data:text/html;base64, PGRpdj48L2Rpdj4=",
              link: "data:text/plain;base64,"
            };
            var instance;
            if (tagName === "script") {
              instance = HTMLScriptElement;
            } else if (tagName === "img") {
              instance = HTMLImageElement;
            } else if (tagName === "iframe") {
              instance = HTMLIFrameElement;
            } else if (tagName === "link") {
              instance = HTMLLinkElement;
            } else {
              return;
            }
            var hasTrustedTypes = window.trustedTypes && typeof window.trustedTypes.createPolicy === "function";
            var policy;
            if (hasTrustedTypes) {
              policy = window.trustedTypes.createPolicy("AGPolicy", {
                createScriptURL: function createScriptURL(arg) {
                  return arg;
                }
              });
            }
            var SOURCE_PROPERTY_NAME = tagName === "link" ? "href" : "src";
            var ONERROR_PROPERTY_NAME = "onerror";
            var searchRegexp = toRegExp(match);
            var setMatchedAttribute = function setMatchedAttribute(elem) {
              return elem.setAttribute(source.name, "matched");
            };
            var setAttributeWrapper = function setAttributeWrapper(target, thisArg, args) {
              if (!args[0] || !args[1]) {
                return Reflect.apply(target, thisArg, args);
              }
              var nodeName = thisArg.nodeName.toLowerCase();
              var attrName = args[0].toLowerCase();
              var attrValue = args[1];
              var isMatched = attrName === SOURCE_PROPERTY_NAME && tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(attrValue);
              if (!isMatched) {
                return Reflect.apply(target, thisArg, args);
              }
              hit(source);
              setMatchedAttribute(thisArg);
              return Reflect.apply(target, thisArg, [attrName, srcMockData[nodeName]]);
            };
            var setAttributeHandler = {
              apply: setAttributeWrapper
            };
            instance.prototype.setAttribute = new Proxy(Element.prototype.setAttribute, setAttributeHandler);
            var origSrcDescriptor = safeGetDescriptor(instance.prototype, SOURCE_PROPERTY_NAME);
            if (!origSrcDescriptor) {
              return;
            }
            Object.defineProperty(instance.prototype, SOURCE_PROPERTY_NAME, {
              enumerable: true,
              configurable: true,
              get() {
                return origSrcDescriptor.get.call(this);
              },
              set(urlValue) {
                var nodeName = this.nodeName.toLowerCase();
                var isMatched = tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(urlValue);
                if (!isMatched) {
                  origSrcDescriptor.set.call(this, urlValue);
                  return true;
                }
                if (policy && urlValue instanceof TrustedScriptURL) {
                  var trustedSrc = policy.createScriptURL(urlValue);
                  origSrcDescriptor.set.call(this, trustedSrc);
                  hit(source);
                  return;
                }
                setMatchedAttribute(this);
                origSrcDescriptor.set.call(this, srcMockData[nodeName]);
                hit(source);
              }
            });
            var origOnerrorDescriptor = safeGetDescriptor(HTMLElement.prototype, ONERROR_PROPERTY_NAME);
            if (!origOnerrorDescriptor) {
              return;
            }
            Object.defineProperty(HTMLElement.prototype, ONERROR_PROPERTY_NAME, {
              enumerable: true,
              configurable: true,
              get() {
                return origOnerrorDescriptor.get.call(this);
              },
              set(cb) {
                var isMatched = this.getAttribute(source.name) === "matched";
                if (!isMatched) {
                  origOnerrorDescriptor.set.call(this, cb);
                  return true;
                }
                origOnerrorDescriptor.set.call(this, noopFunc);
                return true;
              }
            });
            var addEventListenerWrapper = function addEventListenerWrapper(target, thisArg, args) {
              if (!args[0] || !args[1] || !thisArg) {
                return Reflect.apply(target, thisArg, args);
              }
              var eventName = args[0];
              var isMatched = typeof thisArg.getAttribute === "function" && thisArg.getAttribute(source.name) === "matched" && eventName === "error";
              if (isMatched) {
                return Reflect.apply(target, thisArg, [eventName, noopFunc]);
              }
              return Reflect.apply(target, thisArg, args);
            };
            var addEventListenerHandler = {
              apply: addEventListenerWrapper
            };
            EventTarget.prototype.addEventListener = new Proxy(EventTarget.prototype.addEventListener, addEventListenerHandler);
            var preventInlineOnerror = function preventInlineOnerror(tagName, src) {
              window.addEventListener("error", function (event) {
                if (!event.target || !event.target.nodeName || event.target.nodeName.toLowerCase() !== tagName || !event.target.src || !src.test(event.target.src)) {
                  return;
                }
                hit(source);
                if (typeof event.target.onload === "function") {
                  event.target.onerror = event.target.onload;
                  return;
                }
                event.target.onerror = noopFunc;
              }, true);
            };
            preventInlineOnerror(tagName, searchRegexp);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function safeGetDescriptor(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            if (descriptor && descriptor.configurable) {
              return descriptor;
            }
            return null;
          }
          function noopFunc() {}
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventElementSrcLoading.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventEvalIf(source, args) {
          function preventEvalIf(source, search) {
            var searchRegexp = toRegExp(search);
            var nativeEval = window.eval;
            window.eval = function (payload) {
              if (!searchRegexp.test(payload.toString())) {
                return nativeEval.call(window, payload);
              }
              hit(source);
              return undefined;
            }.bind(window);
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventEvalIf.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventFab(source, args) {
          function preventFab(source) {
            hit(source);
            var Fab = function Fab() {};
            Fab.prototype.check = noopFunc;
            Fab.prototype.clearEvent = noopFunc;
            Fab.prototype.emitEvent = noopFunc;
            Fab.prototype.on = function (a, b) {
              if (!a) {
                b();
              }
              return this;
            };
            Fab.prototype.onDetected = noopThis;
            Fab.prototype.onNotDetected = function (a) {
              a();
              return this;
            };
            Fab.prototype.setOption = noopFunc;
            Fab.prototype.options = {
              set: noopFunc,
              get: noopFunc
            };
            var fab = new Fab();
            var getSetFab = {
              get() {
                return Fab;
              },
              set() {}
            };
            var getsetfab = {
              get() {
                return fab;
              },
              set() {}
            };
            if (Object.prototype.hasOwnProperty.call(window, "FuckAdBlock")) {
              window.FuckAdBlock = Fab;
            } else {
              Object.defineProperty(window, "FuckAdBlock", getSetFab);
            }
            if (Object.prototype.hasOwnProperty.call(window, "BlockAdBlock")) {
              window.BlockAdBlock = Fab;
            } else {
              Object.defineProperty(window, "BlockAdBlock", getSetFab);
            }
            if (Object.prototype.hasOwnProperty.call(window, "SniffAdBlock")) {
              window.SniffAdBlock = Fab;
            } else {
              Object.defineProperty(window, "SniffAdBlock", getSetFab);
            }
            if (Object.prototype.hasOwnProperty.call(window, "fuckAdBlock")) {
              window.fuckAdBlock = fab;
            } else {
              Object.defineProperty(window, "fuckAdBlock", getsetfab);
            }
            if (Object.prototype.hasOwnProperty.call(window, "blockAdBlock")) {
              window.blockAdBlock = fab;
            } else {
              Object.defineProperty(window, "blockAdBlock", getsetfab);
            }
            if (Object.prototype.hasOwnProperty.call(window, "sniffAdBlock")) {
              window.sniffAdBlock = fab;
            } else {
              Object.defineProperty(window, "sniffAdBlock", getsetfab);
            }
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function noopFunc() {}
          function noopThis() {
            return this;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventFab.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventFetch(source, args) {
          function preventFetch(source, propsToMatch) {
            var responseBody = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "emptyObj";
            var responseType = arguments.length > 3 ? arguments[3] : undefined;
            if (typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
              return;
            }
            var nativeRequestClone = Request.prototype.clone;
            var strResponseBody;
            if (responseBody === "" || responseBody === "emptyObj") {
              strResponseBody = "{}";
            } else if (responseBody === "emptyArr") {
              strResponseBody = "[]";
            } else if (responseBody === "emptyStr") {
              strResponseBody = "";
            } else {
              logMessage(source, "Invalid responseBody parameter: '".concat(responseBody, "'"));
              return;
            }
            var isResponseTypeSpecified = typeof responseType !== "undefined";
            var isResponseTypeSupported = function isResponseTypeSupported(responseType) {
              var SUPPORTED_TYPES = ["default", "opaque"];
              return SUPPORTED_TYPES.includes(responseType);
            };
            if (isResponseTypeSpecified && !isResponseTypeSupported(responseType)) {
              logMessage(source, "Invalid responseType parameter: '".concat(responseType, "'"));
              return;
            }
            var handlerWrapper = async function handlerWrapper(target, thisArg, args) {
              var shouldPrevent = false;
              var fetchData = getFetchData(args, nativeRequestClone);
              if (typeof propsToMatch === "undefined") {
                logMessage(source, "fetch( ".concat(objectToString(fetchData), " )"), true);
                hit(source);
                return Reflect.apply(target, thisArg, args);
              }
              shouldPrevent = matchRequestProps(source, propsToMatch, fetchData);
              if (shouldPrevent) {
                hit(source);
                try {
                  var origResponse = await Reflect.apply(target, thisArg, args);
                  if (!origResponse.ok) {
                    return noopPromiseResolve(strResponseBody, fetchData.url, responseType);
                  }
                  return modifyResponse(origResponse, {
                    body: strResponseBody,
                    type: responseType
                  });
                } catch (ex) {
                  return noopPromiseResolve(strResponseBody, fetchData.url, responseType);
                }
              }
              return Reflect.apply(target, thisArg, args);
            };
            var fetchHandler = {
              apply: handlerWrapper
            };
            fetch = new Proxy(fetch, fetchHandler);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function getFetchData(args, nativeRequestClone) {
            var fetchPropsObj = {};
            var resource = args[0];
            var fetchUrl;
            var fetchInit;
            if (resource instanceof Request) {
              var realData = nativeRequestClone.call(resource);
              var requestData = getRequestData(realData);
              fetchUrl = requestData.url;
              fetchInit = requestData;
            } else {
              fetchUrl = resource;
              fetchInit = args[1];
            }
            fetchPropsObj.url = fetchUrl;
            if (fetchInit instanceof Object) {
              var props = Object.keys(fetchInit);
              props.forEach(function (prop) {
                fetchPropsObj[prop] = fetchInit[prop];
              });
            }
            return fetchPropsObj;
          }
          function objectToString(obj) {
            if (!obj || typeof obj !== "object") {
              return String(obj);
            }
            return isEmptyObject(obj) ? "{}" : Object.entries(obj).map(function (pair) {
              var key = pair[0];
              var value = pair[1];
              var recordValueStr = value;
              if (value instanceof Object) {
                recordValueStr = "{ ".concat(objectToString(value), " }");
              }
              return "".concat(key, ':"').concat(recordValueStr, '"');
            }).join(" ");
          }
          function matchRequestProps(source, propsToMatch, requestData) {
            if (propsToMatch === "" || propsToMatch === "*") {
              return true;
            }
            var isMatched;
            var parsedData = parseMatchProps(propsToMatch);
            if (!isValidParsedData(parsedData)) {
              logMessage(source, "Invalid parameter: ".concat(propsToMatch));
              isMatched = false;
            } else {
              var matchData = getMatchPropsData(parsedData);
              var matchKeys = Object.keys(matchData);
              isMatched = matchKeys.every(function (matchKey) {
                var matchValue = matchData[matchKey];
                var dataValue = requestData[matchKey];
                return Object.prototype.hasOwnProperty.call(requestData, matchKey) && typeof dataValue === "string" && (matchValue === null || matchValue === void 0 ? void 0 : matchValue.test(dataValue));
              });
            }
            return isMatched;
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function noopPromiseResolve() {
            var responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "{}";
            var responseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            var responseType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "default";
            if (typeof Response === "undefined") {
              return;
            }
            var response = new Response(responseBody, {
              status: 200,
              statusText: "OK"
            });
            Object.defineProperties(response, {
              url: {
                value: responseUrl
              },
              type: {
                value: responseType
              }
            });
            if (responseType === "opaque") {
              Object.defineProperties(response, {
                body: {
                  value: null
                },
                status: {
                  value: 0
                },
                statusText: {
                  value: ""
                }
              });
            }
            return Promise.resolve(response);
          }
          function modifyResponse(origResponse) {
            var _origResponse$headers;
            var replacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
              body: "{}"
            };
            var headers = {};
            origResponse === null || origResponse === void 0 ? void 0 : (_origResponse$headers = origResponse.headers) === null || _origResponse$headers === void 0 ? void 0 : _origResponse$headers.forEach(function (value, key) {
              headers[key] = value;
            });
            var modifiedResponse = new Response(replacement.body, {
              status: origResponse.status,
              statusText: origResponse.statusText,
              headers: headers
            });
            Object.defineProperties(modifiedResponse, {
              url: {
                value: origResponse.url
              },
              type: {
                value: replacement.type || origResponse.type
              }
            });
            return modifiedResponse;
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          function getRequestData(request) {
            var requestInitOptions = getRequestProps();
            var entries = requestInitOptions.map(function (key) {
              var value = request[key];
              return [key, value];
            });
            return Object.fromEntries(entries);
          }
          function getRequestProps() {
            return ["url", "method", "headers", "body", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal", "mode"];
          }
          function parseMatchProps(propsToMatchStr) {
            var PROPS_DIVIDER = " ";
            var PAIRS_MARKER = ":";
            var isRequestProp = function isRequestProp(prop) {
              return getRequestProps().includes(prop);
            };
            var propsObj = {};
            var props = propsToMatchStr.split(PROPS_DIVIDER);
            props.forEach(function (prop) {
              var dividerInd = prop.indexOf(PAIRS_MARKER);
              var key = prop.slice(0, dividerInd);
              if (isRequestProp(key)) {
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
              } else {
                propsObj.url = prop;
              }
            });
            return propsObj;
          }
          function isValidParsedData(data) {
            return Object.values(data).every(function (value) {
              return isValidStrPattern(value);
            });
          }
          function getMatchPropsData(data) {
            var matchData = {};
            var dataKeys = Object.keys(data);
            dataKeys.forEach(function (key) {
              matchData[key] = toRegExp(data[key]);
            });
            return matchData;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventFetch.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventPopadsNet(source, args) {
          function preventPopadsNet(source) {
            var rid = randomId();
            var throwError = function throwError() {
              throw new ReferenceError(rid);
            };
            delete window.PopAds;
            delete window.popns;
            Object.defineProperties(window, {
              PopAds: {
                set: throwError
              },
              popns: {
                set: throwError
              }
            });
            window.onerror = createOnErrorHandler(rid).bind();
            hit(source);
          }
          function createOnErrorHandler(rid) {
            var nativeOnError = window.onerror;
            return function onError(error) {
              if (typeof error === "string" && error.includes(rid)) {
                return true;
              }
              if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [error, ...args]);
              }
              return false;
            };
          }
          function randomId() {
            return Math.random().toString(36).slice(2, 9);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventPopadsNet.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventRefresh(source, args) {
          function preventRefresh(source, delaySec) {
            var getMetaElements = function getMetaElements() {
              var metaNodes = [];
              try {
                metaNodes = document.querySelectorAll('meta[http-equiv="refresh" i][content]');
              } catch (e) {
                try {
                  metaNodes = document.querySelectorAll('meta[http-equiv="refresh"][content]');
                } catch (e) {
                  logMessage(source, e);
                }
              }
              return Array.from(metaNodes);
            };
            var getMetaContentDelay = function getMetaContentDelay(metaElements) {
              var delays = metaElements.map(function (meta) {
                var contentString = meta.getAttribute("content");
                if (contentString.length === 0) {
                  return null;
                }
                var contentDelay;
                var limiterIndex = contentString.indexOf(";");
                if (limiterIndex !== -1) {
                  var delaySubstring = contentString.substring(0, limiterIndex);
                  contentDelay = getNumberFromString(delaySubstring);
                } else {
                  contentDelay = getNumberFromString(contentString);
                }
                return contentDelay;
              }).filter(function (delay) {
                return delay !== null;
              });
              if (!delays.length) {
                return null;
              }
              var minDelay = delays.reduce(function (a, b) {
                return Math.min(a, b);
              });
              return minDelay;
            };
            var stop = function stop() {
              var metaElements = getMetaElements();
              if (metaElements.length === 0) {
                return;
              }
              var secondsToRun = getNumberFromString(delaySec);
              if (secondsToRun === null) {
                secondsToRun = getMetaContentDelay(metaElements);
              }
              if (secondsToRun === null) {
                return;
              }
              var delayMs = secondsToRun * 1e3;
              setTimeout(function () {
                window.stop();
                hit(source);
              }, delayMs);
            };
            if (document.readyState === "loading") {
              document.addEventListener("DOMContentLoaded", stop, {
                once: true
              });
            } else {
              stop();
            }
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function getNumberFromString(rawString) {
            var parsedDelay = parseInt(rawString, 10);
            var validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
            return validDelay;
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventRefresh.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventRequestAnimationFrame(source, args) {
          function preventRequestAnimationFrame(source, match) {
            var nativeRequestAnimationFrame = window.requestAnimationFrame;
            var shouldLog = typeof match === "undefined";
            var _parseMatchArg = parseMatchArg(match),
              isInvertedMatch = _parseMatchArg.isInvertedMatch,
              matchRegexp = _parseMatchArg.matchRegexp;
            var rafWrapper = function rafWrapper(callback) {
              var shouldPrevent = false;
              if (shouldLog) {
                hit(source);
                logMessage(source, "requestAnimationFrame(".concat(String(callback), ")"), true);
              } else if (isValidCallback(callback) && isValidStrPattern(match)) {
                shouldPrevent = matchRegexp.test(callback.toString()) !== isInvertedMatch;
              }
              if (shouldPrevent) {
                hit(source);
                return nativeRequestAnimationFrame(noopFunc);
              }
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              return nativeRequestAnimationFrame.apply(window, [callback, ...args]);
            };
            window.requestAnimationFrame = rafWrapper;
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function noopFunc() {}
          function parseMatchArg(match) {
            var INVERT_MARKER = "!";
            var isInvertedMatch = match ? match === null || match === void 0 ? void 0 : match.startsWith(INVERT_MARKER) : false;
            var matchValue = isInvertedMatch ? match.slice(1) : match;
            var matchRegexp = toRegExp(matchValue);
            return {
              isInvertedMatch: isInvertedMatch,
              matchRegexp: matchRegexp,
              matchValue: matchValue
            };
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function isValidCallback(callback) {
            return callback instanceof Function || typeof callback === "string";
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventRequestAnimationFrame.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventSetInterval(source, args) {
          function preventSetInterval(source, matchCallback, matchDelay) {
            var shouldLog = typeof matchCallback === "undefined" && typeof matchDelay === "undefined";
            var handlerWrapper = function handlerWrapper(target, thisArg, args) {
              var callback = args[0];
              var delay = args[1];
              var shouldPrevent = false;
              if (shouldLog) {
                hit(source);
                logMessage(source, "setInterval(".concat(String(callback), ", ").concat(delay, ")"), true);
              } else {
                shouldPrevent = isPreventionNeeded({
                  callback: callback,
                  delay: delay,
                  matchCallback: matchCallback,
                  matchDelay: matchDelay
                });
              }
              if (shouldPrevent) {
                hit(source);
                args[0] = noopFunc;
              }
              return target.apply(thisArg, args);
            };
            var setIntervalHandler = {
              apply: handlerWrapper
            };
            window.setInterval = new Proxy(window.setInterval, setIntervalHandler);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function noopFunc() {}
          function isPreventionNeeded(_ref) {
            var callback = _ref.callback,
              delay = _ref.delay,
              matchCallback = _ref.matchCallback,
              matchDelay = _ref.matchDelay;
            if (!isValidCallback(callback)) {
              return false;
            }
            if (!isValidMatchStr(matchCallback) || matchDelay && !isValidMatchNumber(matchDelay)) {
              return false;
            }
            var _parseMatchArg = parseMatchArg(matchCallback),
              isInvertedMatch = _parseMatchArg.isInvertedMatch,
              matchRegexp = _parseMatchArg.matchRegexp;
            var _parseDelayArg = parseDelayArg(matchDelay),
              isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,
              delayMatch = _parseDelayArg.delayMatch;
            var parsedDelay = parseRawDelay(delay);
            var shouldPrevent = false;
            var callbackStr = String(callback);
            if (delayMatch === null) {
              shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch;
            } else if (!matchCallback) {
              shouldPrevent = parsedDelay === delayMatch !== isInvertedDelayMatch;
            } else {
              shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch && parsedDelay === delayMatch !== isInvertedDelayMatch;
            }
            return shouldPrevent;
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function parseMatchArg(match) {
            var INVERT_MARKER = "!";
            var isInvertedMatch = match ? match === null || match === void 0 ? void 0 : match.startsWith(INVERT_MARKER) : false;
            var matchValue = isInvertedMatch ? match.slice(1) : match;
            var matchRegexp = toRegExp(matchValue);
            return {
              isInvertedMatch: isInvertedMatch,
              matchRegexp: matchRegexp,
              matchValue: matchValue
            };
          }
          function parseDelayArg(delay) {
            var INVERT_MARKER = "!";
            var isInvertedDelayMatch = delay === null || delay === void 0 ? void 0 : delay.startsWith(INVERT_MARKER);
            var delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;
            var parsedDelay = parseInt(delayValue, 10);
            var delayMatch = nativeIsNaN(parsedDelay) ? null : parsedDelay;
            return {
              isInvertedDelayMatch: isInvertedDelayMatch,
              delayMatch: delayMatch
            };
          }
          function isValidCallback(callback) {
            return callback instanceof Function || typeof callback === "string";
          }
          function isValidMatchStr(match) {
            var INVERT_MARKER = "!";
            var str = match;
            if (match !== null && match !== void 0 && match.startsWith(INVERT_MARKER)) {
              str = match.slice(1);
            }
            return isValidStrPattern(str);
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function nativeIsFinite(num) {
            var native = Number.isFinite || window.isFinite;
            return native(num);
          }
          function isValidMatchNumber(match) {
            var INVERT_MARKER = "!";
            var str = match;
            if (match !== null && match !== void 0 && match.startsWith(INVERT_MARKER)) {
              str = match.slice(1);
            }
            var num = parseFloat(str);
            return !nativeIsNaN(num) && nativeIsFinite(num);
          }
          function parseRawDelay(delay) {
            var parsedDelay = Math.floor(parseInt(delay, 10));
            return typeof parsedDelay === "number" && !nativeIsNaN(parsedDelay) ? parsedDelay : delay;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventSetInterval.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventSetTimeout(source, args) {
          function preventSetTimeout(source, matchCallback, matchDelay) {
            var shouldLog = typeof matchCallback === "undefined" && typeof matchDelay === "undefined";
            var handlerWrapper = function handlerWrapper(target, thisArg, args) {
              var callback = args[0];
              var delay = args[1];
              var shouldPrevent = false;
              if (shouldLog) {
                hit(source);
                logMessage(source, "setTimeout(".concat(String(callback), ", ").concat(delay, ")"), true);
              } else {
                shouldPrevent = isPreventionNeeded({
                  callback: callback,
                  delay: delay,
                  matchCallback: matchCallback,
                  matchDelay: matchDelay
                });
              }
              if (shouldPrevent) {
                hit(source);
                args[0] = noopFunc;
              }
              return target.apply(thisArg, args);
            };
            var setTimeoutHandler = {
              apply: handlerWrapper
            };
            window.setTimeout = new Proxy(window.setTimeout, setTimeoutHandler);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function noopFunc() {}
          function isPreventionNeeded(_ref) {
            var callback = _ref.callback,
              delay = _ref.delay,
              matchCallback = _ref.matchCallback,
              matchDelay = _ref.matchDelay;
            if (!isValidCallback(callback)) {
              return false;
            }
            if (!isValidMatchStr(matchCallback) || matchDelay && !isValidMatchNumber(matchDelay)) {
              return false;
            }
            var _parseMatchArg = parseMatchArg(matchCallback),
              isInvertedMatch = _parseMatchArg.isInvertedMatch,
              matchRegexp = _parseMatchArg.matchRegexp;
            var _parseDelayArg = parseDelayArg(matchDelay),
              isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,
              delayMatch = _parseDelayArg.delayMatch;
            var parsedDelay = parseRawDelay(delay);
            var shouldPrevent = false;
            var callbackStr = String(callback);
            if (delayMatch === null) {
              shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch;
            } else if (!matchCallback) {
              shouldPrevent = parsedDelay === delayMatch !== isInvertedDelayMatch;
            } else {
              shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch && parsedDelay === delayMatch !== isInvertedDelayMatch;
            }
            return shouldPrevent;
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function parseMatchArg(match) {
            var INVERT_MARKER = "!";
            var isInvertedMatch = match ? match === null || match === void 0 ? void 0 : match.startsWith(INVERT_MARKER) : false;
            var matchValue = isInvertedMatch ? match.slice(1) : match;
            var matchRegexp = toRegExp(matchValue);
            return {
              isInvertedMatch: isInvertedMatch,
              matchRegexp: matchRegexp,
              matchValue: matchValue
            };
          }
          function parseDelayArg(delay) {
            var INVERT_MARKER = "!";
            var isInvertedDelayMatch = delay === null || delay === void 0 ? void 0 : delay.startsWith(INVERT_MARKER);
            var delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;
            var parsedDelay = parseInt(delayValue, 10);
            var delayMatch = nativeIsNaN(parsedDelay) ? null : parsedDelay;
            return {
              isInvertedDelayMatch: isInvertedDelayMatch,
              delayMatch: delayMatch
            };
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function isValidCallback(callback) {
            return callback instanceof Function || typeof callback === "string";
          }
          function isValidMatchStr(match) {
            var INVERT_MARKER = "!";
            var str = match;
            if (match !== null && match !== void 0 && match.startsWith(INVERT_MARKER)) {
              str = match.slice(1);
            }
            return isValidStrPattern(str);
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function nativeIsFinite(num) {
            var native = Number.isFinite || window.isFinite;
            return native(num);
          }
          function isValidMatchNumber(match) {
            var INVERT_MARKER = "!";
            var str = match;
            if (match !== null && match !== void 0 && match.startsWith(INVERT_MARKER)) {
              str = match.slice(1);
            }
            var num = parseFloat(str);
            return !nativeIsNaN(num) && nativeIsFinite(num);
          }
          function parseRawDelay(delay) {
            var parsedDelay = Math.floor(parseInt(delay, 10));
            return typeof parsedDelay === "number" && !nativeIsNaN(parsedDelay) ? parsedDelay : delay;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventSetTimeout.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventWindowOpen(source, args) {
          function preventWindowOpen(source) {
            var match = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "*";
            var delay = arguments.length > 2 ? arguments[2] : undefined;
            var replacement = arguments.length > 3 ? arguments[3] : undefined;
            var nativeOpen = window.open;
            var isNewSyntax = match !== "0" && match !== "1";
            var oldOpenWrapper = function oldOpenWrapper(str) {
              match = Number(match) > 0;
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              if (!isValidStrPattern(delay)) {
                logMessage(source, "Invalid parameter: ".concat(delay));
                return nativeOpen.apply(window, [str, ...args]);
              }
              var searchRegexp = toRegExp(delay);
              if (match !== searchRegexp.test(str)) {
                return nativeOpen.apply(window, [str, ...args]);
              }
              hit(source);
              return handleOldReplacement(replacement);
            };
            var newOpenWrapper = function newOpenWrapper(url) {
              var shouldLog = replacement && replacement.includes("log");
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              if (shouldLog) {
                var argsStr = args && args.length > 0 ? ", ".concat(args.join(", ")) : "";
                var message = "".concat(url).concat(argsStr);
                logMessage(source, message, true);
                hit(source);
              }
              var shouldPrevent = false;
              if (match === "*") {
                shouldPrevent = true;
              } else if (isValidMatchStr(match)) {
                var _parseMatchArg = parseMatchArg(match),
                  isInvertedMatch = _parseMatchArg.isInvertedMatch,
                  matchRegexp = _parseMatchArg.matchRegexp;
                shouldPrevent = matchRegexp.test(url) !== isInvertedMatch;
              } else {
                logMessage(source, "Invalid parameter: ".concat(match));
                shouldPrevent = false;
              }
              if (shouldPrevent) {
                var parsedDelay = parseInt(delay, 10);
                var result;
                if (nativeIsNaN(parsedDelay)) {
                  result = noopNull();
                } else {
                  var decoyArgs = {
                    replacement: replacement,
                    url: url,
                    delay: parsedDelay
                  };
                  var decoy = createDecoy(decoyArgs);
                  var popup = decoy.contentWindow;
                  if (typeof popup === "object" && popup !== null) {
                    Object.defineProperty(popup, "closed", {
                      value: false
                    });
                    Object.defineProperty(popup, "opener", {
                      value: window
                    });
                    Object.defineProperty(popup, "frameElement", {
                      value: null
                    });
                  } else {
                    var nativeGetter = decoy.contentWindow && decoy.contentWindow.get;
                    Object.defineProperty(decoy, "contentWindow", {
                      get: getPreventGetter(nativeGetter)
                    });
                    popup = decoy.contentWindow;
                  }
                  result = popup;
                }
                hit(source);
                return result;
              }
              return nativeOpen.apply(window, [url, ...args]);
            };
            window.open = isNewSyntax ? newOpenWrapper : oldOpenWrapper;
            window.open.toString = nativeOpen.toString.bind(nativeOpen);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function isValidMatchStr(match) {
            var INVERT_MARKER = "!";
            var str = match;
            if (match !== null && match !== void 0 && match.startsWith(INVERT_MARKER)) {
              str = match.slice(1);
            }
            return isValidStrPattern(str);
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function parseMatchArg(match) {
            var INVERT_MARKER = "!";
            var isInvertedMatch = match ? match === null || match === void 0 ? void 0 : match.startsWith(INVERT_MARKER) : false;
            var matchValue = isInvertedMatch ? match.slice(1) : match;
            var matchRegexp = toRegExp(matchValue);
            return {
              isInvertedMatch: isInvertedMatch,
              matchRegexp: matchRegexp,
              matchValue: matchValue
            };
          }
          function handleOldReplacement(replacement) {
            var result;
            if (!replacement) {
              result = noopFunc;
            } else if (replacement === "trueFunc") {
              result = trueFunc;
            } else if (replacement.includes("=")) {
              var isProp = replacement.startsWith("{") && replacement.endsWith("}");
              if (isProp) {
                var propertyPart = replacement.slice(1, -1);
                var propertyName = substringBefore(propertyPart, "=");
                var propertyValue = substringAfter(propertyPart, "=");
                if (propertyValue === "noopFunc") {
                  result = {};
                  result[propertyName] = noopFunc;
                }
              }
            }
            return result;
          }
          function createDecoy(args) {
            var UrlPropNameOf = function (UrlPropNameOf) {
              UrlPropNameOf["Object"] = "data";
              UrlPropNameOf["Iframe"] = "src";
              return UrlPropNameOf;
            }({});
            var replacement = args.replacement,
              url = args.url,
              delay = args.delay;
            var tag;
            if (replacement === "obj") {
              tag = "object";
            } else {
              tag = "iframe";
            }
            var decoy = document.createElement(tag);
            if (decoy instanceof HTMLObjectElement) {
              decoy[UrlPropNameOf.Object] = url;
            } else if (decoy instanceof HTMLIFrameElement) {
              decoy[UrlPropNameOf.Iframe] = url;
            }
            decoy.style.setProperty("height", "1px", "important");
            decoy.style.setProperty("position", "fixed", "important");
            decoy.style.setProperty("top", "-1px", "important");
            decoy.style.setProperty("width", "1px", "important");
            document.body.appendChild(decoy);
            setTimeout(function () {
              return decoy.remove();
            }, delay * 1e3);
            return decoy;
          }
          function getPreventGetter(nativeGetter) {
            var preventGetter = function preventGetter(target, prop) {
              if (prop && prop === "closed") {
                return false;
              }
              if (typeof nativeGetter === "function") {
                return noopFunc;
              }
              return prop && target[prop];
            };
            return preventGetter;
          }
          function noopNull() {
            return null;
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function noopFunc() {}
          function trueFunc() {
            return true;
          }
          function substringBefore(str, separator) {
            if (!str || !separator) {
              return str;
            }
            var index = str.indexOf(separator);
            return index < 0 ? str : str.substring(0, index);
          }
          function substringAfter(str, separator) {
            if (!str) {
              return str;
            }
            var index = str.indexOf(separator);
            return index < 0 ? "" : str.substring(index + separator.length);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventWindowOpen.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function preventXHR(source, args) {
          function preventXHR(source, propsToMatch, customResponseText) {
            if (typeof Proxy === "undefined") {
              return;
            }
            var nativeOpen = window.XMLHttpRequest.prototype.open;
            var nativeSend = window.XMLHttpRequest.prototype.send;
            var nativeGetResponseHeader = window.XMLHttpRequest.prototype.getResponseHeader;
            var nativeGetAllResponseHeaders = window.XMLHttpRequest.prototype.getAllResponseHeaders;
            var xhrData;
            var modifiedResponse = "";
            var modifiedResponseText = "";
            var openWrapper = function openWrapper(target, thisArg, args) {
              xhrData = getXhrData.apply(null, args);
              if (typeof propsToMatch === "undefined") {
                logMessage(source, "xhr( ".concat(objectToString(xhrData), " )"), true);
                hit(source);
              } else if (matchRequestProps(source, propsToMatch, xhrData)) {
                thisArg.shouldBePrevented = true;
                thisArg.xhrData = xhrData;
              }
              if (thisArg.shouldBePrevented) {
                thisArg.collectedHeaders = [];
                var setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
                  thisArg.collectedHeaders.push(args);
                  return Reflect.apply(target, thisArg, args);
                };
                var setRequestHeaderHandler = {
                  apply: setRequestHeaderWrapper
                };
                thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
              }
              return Reflect.apply(target, thisArg, args);
            };
            var sendWrapper = function sendWrapper(target, thisArg, args) {
              if (!thisArg.shouldBePrevented) {
                return Reflect.apply(target, thisArg, args);
              }
              if (thisArg.responseType === "blob") {
                modifiedResponse = new Blob();
              }
              if (thisArg.responseType === "arraybuffer") {
                modifiedResponse = new ArrayBuffer();
              }
              if (customResponseText) {
                var randomText = generateRandomResponse(customResponseText);
                if (randomText) {
                  modifiedResponseText = randomText;
                } else {
                  logMessage(source, "Invalid randomize parameter: '".concat(customResponseText, "'"));
                }
              }
              var forgedRequest = new XMLHttpRequest();
              forgedRequest.addEventListener("readystatechange", function () {
                if (forgedRequest.readyState !== 4) {
                  return;
                }
                var readyState = forgedRequest.readyState,
                  responseURL = forgedRequest.responseURL,
                  responseXML = forgedRequest.responseXML,
                  statusText = forgedRequest.statusText;
                Object.defineProperties(thisArg, {
                  readyState: {
                    value: readyState,
                    writable: false
                  },
                  statusText: {
                    value: statusText,
                    writable: false
                  },
                  responseURL: {
                    value: responseURL || thisArg.xhrData.url,
                    writable: false
                  },
                  responseXML: {
                    value: responseXML,
                    writable: false
                  },
                  status: {
                    value: 200,
                    writable: false
                  },
                  response: {
                    value: modifiedResponse,
                    writable: false
                  },
                  responseText: {
                    value: modifiedResponseText,
                    writable: false
                  }
                });
                setTimeout(function () {
                  var stateEvent = new Event("readystatechange");
                  thisArg.dispatchEvent(stateEvent);
                  var loadEvent = new Event("load");
                  thisArg.dispatchEvent(loadEvent);
                  var loadEndEvent = new Event("loadend");
                  thisArg.dispatchEvent(loadEndEvent);
                }, 1);
                hit(source);
              });
              nativeOpen.apply(forgedRequest, [thisArg.xhrData.method, thisArg.xhrData.url]);
              thisArg.collectedHeaders.forEach(function (header) {
                var name = header[0];
                var value = header[1];
                forgedRequest.setRequestHeader(name, value);
              });
              try {
                nativeSend.call(forgedRequest, args);
              } catch (_unused) {
                return Reflect.apply(target, thisArg, args);
              }
              return undefined;
            };
            var getHeaderWrapper = function getHeaderWrapper(target, thisArg, args) {
              if (!thisArg.shouldBePrevented) {
                return nativeGetResponseHeader.apply(thisArg, args);
              }
              if (!thisArg.collectedHeaders.length) {
                return null;
              }
              var searchHeaderName = args[0].toLowerCase();
              var matchedHeader = thisArg.collectedHeaders.find(function (header) {
                var headerName = header[0].toLowerCase();
                return headerName === searchHeaderName;
              });
              return matchedHeader ? matchedHeader[1] : null;
            };
            var getAllHeadersWrapper = function getAllHeadersWrapper(target, thisArg) {
              if (!thisArg.shouldBePrevented) {
                return nativeGetAllResponseHeaders.call(thisArg);
              }
              if (!thisArg.collectedHeaders.length) {
                return "";
              }
              var allHeadersStr = thisArg.collectedHeaders.map(function (header) {
                var headerName = header[0];
                var headerValue = header[1];
                return "".concat(headerName.toLowerCase(), ": ").concat(headerValue);
              }).join("\r\n");
              return allHeadersStr;
            };
            var openHandler = {
              apply: openWrapper
            };
            var sendHandler = {
              apply: sendWrapper
            };
            var getHeaderHandler = {
              apply: getHeaderWrapper
            };
            var getAllHeadersHandler = {
              apply: getAllHeadersWrapper
            };
            XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
            XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
            XMLHttpRequest.prototype.getResponseHeader = new Proxy(XMLHttpRequest.prototype.getResponseHeader, getHeaderHandler);
            XMLHttpRequest.prototype.getAllResponseHeaders = new Proxy(XMLHttpRequest.prototype.getAllResponseHeaders, getAllHeadersHandler);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function objectToString(obj) {
            if (!obj || typeof obj !== "object") {
              return String(obj);
            }
            return isEmptyObject(obj) ? "{}" : Object.entries(obj).map(function (pair) {
              var key = pair[0];
              var value = pair[1];
              var recordValueStr = value;
              if (value instanceof Object) {
                recordValueStr = "{ ".concat(objectToString(value), " }");
              }
              return "".concat(key, ':"').concat(recordValueStr, '"');
            }).join(" ");
          }
          function generateRandomResponse(customResponseText) {
            var customResponse = customResponseText;
            if (customResponse === "true") {
              customResponse = Math.random().toString(36).slice(-10);
              return customResponse;
            }
            customResponse = customResponse.replace("length:", "");
            var rangeRegex = /^\d+-\d+$/;
            if (!rangeRegex.test(customResponse)) {
              return null;
            }
            var rangeMin = getNumberFromString(customResponse.split("-")[0]);
            var rangeMax = getNumberFromString(customResponse.split("-")[1]);
            if (!nativeIsFinite(rangeMin) || !nativeIsFinite(rangeMax)) {
              return null;
            }
            if (rangeMin > rangeMax) {
              var temp = rangeMin;
              rangeMin = rangeMax;
              rangeMax = temp;
            }
            var LENGTH_RANGE_LIMIT = 500 * 1e3;
            if (rangeMax > LENGTH_RANGE_LIMIT) {
              return null;
            }
            var length = getRandomIntInclusive(rangeMin, rangeMax);
            customResponse = getRandomStrByLength(length);
            return customResponse;
          }
          function matchRequestProps(source, propsToMatch, requestData) {
            if (propsToMatch === "" || propsToMatch === "*") {
              return true;
            }
            var isMatched;
            var parsedData = parseMatchProps(propsToMatch);
            if (!isValidParsedData(parsedData)) {
              logMessage(source, "Invalid parameter: ".concat(propsToMatch));
              isMatched = false;
            } else {
              var matchData = getMatchPropsData(parsedData);
              var matchKeys = Object.keys(matchData);
              isMatched = matchKeys.every(function (matchKey) {
                var matchValue = matchData[matchKey];
                var dataValue = requestData[matchKey];
                return Object.prototype.hasOwnProperty.call(requestData, matchKey) && typeof dataValue === "string" && (matchValue === null || matchValue === void 0 ? void 0 : matchValue.test(dataValue));
              });
            }
            return isMatched;
          }
          function getXhrData(method, url, async, user, password) {
            return {
              method: method,
              url: url,
              async: async,
              user: user,
              password: password
            };
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          function getNumberFromString(rawString) {
            var parsedDelay = parseInt(rawString, 10);
            var validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
            return validDelay;
          }
          function nativeIsFinite(num) {
            var native = Number.isFinite || window.isFinite;
            return native(num);
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function parseMatchProps(propsToMatchStr) {
            var PROPS_DIVIDER = " ";
            var PAIRS_MARKER = ":";
            var isRequestProp = function isRequestProp(prop) {
              return getRequestProps().includes(prop);
            };
            var propsObj = {};
            var props = propsToMatchStr.split(PROPS_DIVIDER);
            props.forEach(function (prop) {
              var dividerInd = prop.indexOf(PAIRS_MARKER);
              var key = prop.slice(0, dividerInd);
              if (isRequestProp(key)) {
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
              } else {
                propsObj.url = prop;
              }
            });
            return propsObj;
          }
          function isValidParsedData(data) {
            return Object.values(data).every(function (value) {
              return isValidStrPattern(value);
            });
          }
          function getMatchPropsData(data) {
            var matchData = {};
            var dataKeys = Object.keys(data);
            dataKeys.forEach(function (key) {
              matchData[key] = toRegExp(data[key]);
            });
            return matchData;
          }
          function getRequestProps() {
            return ["url", "method", "headers", "body", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal", "mode"];
          }
          function getRandomIntInclusive(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1) + min);
          }
          function getRandomStrByLength(length) {
            var result = "";
            var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+=~";
            var charactersLength = characters.length;
            for (var i = 0; i < length; i += 1) {
              result += characters.charAt(Math.floor(Math.random() * charactersLength));
            }
            return result;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            preventXHR.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function removeAttr(source, args) {
          function removeAttr(source, attrs, selector) {
            var applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "asap stay";
            if (!attrs) {
              return;
            }
            attrs = attrs.split(/\s*\|\s*/);
            if (!selector) {
              selector = "[".concat(attrs.join("],["), "]");
            }
            var rmattr = function rmattr() {
              var nodes = [];
              try {
                nodes = [].slice.call(document.querySelectorAll(selector));
              } catch (e) {
                logMessage(source, "Invalid selector arg: '".concat(selector, "'"));
              }
              var removed = false;
              nodes.forEach(function (node) {
                attrs.forEach(function (attr) {
                  node.removeAttribute(attr);
                  removed = true;
                });
              });
              if (removed) {
                hit(source);
              }
            };
            var flags = parseFlags(applying);
            var run = function run() {
              rmattr();
              if (!flags.hasFlag(flags.STAY)) {
                return;
              }
              observeDOMChanges(rmattr, true);
            };
            if (flags.hasFlag(flags.ASAP)) {
              if (document.readyState === "loading") {
                window.addEventListener("DOMContentLoaded", rmattr, {
                  once: true
                });
              } else {
                rmattr();
              }
            }
            if (document.readyState !== "complete" && flags.hasFlag(flags.COMPLETE)) {
              window.addEventListener("load", run, {
                once: true
              });
            } else if (flags.hasFlag(flags.STAY)) {
              if (!applying.includes(" ")) {
                rmattr();
              }
              observeDOMChanges(rmattr, true);
            }
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function observeDOMChanges(callback) {
            var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
            var THROTTLE_DELAY_MS = 20;
            var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
            var connect = function connect() {
              if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs,
                  attributeFilter: attrsToObserve
                });
              } else {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs
                });
              }
            };
            var disconnect = function disconnect() {
              observer.disconnect();
            };
            function callbackWrapper() {
              disconnect();
              callback();
              connect();
            }
            connect();
          }
          function parseFlags(flags) {
            var FLAGS_DIVIDER = " ";
            var ASAP_FLAG = "asap";
            var COMPLETE_FLAG = "complete";
            var STAY_FLAG = "stay";
            var VALID_FLAGS = [STAY_FLAG, ASAP_FLAG, COMPLETE_FLAG];
            var passedFlags = flags.trim().split(FLAGS_DIVIDER).filter(function (f) {
              return VALID_FLAGS.includes(f);
            });
            return {
              ASAP: ASAP_FLAG,
              COMPLETE: COMPLETE_FLAG,
              STAY: STAY_FLAG,
              hasFlag(flag) {
                return passedFlags.includes(flag);
              }
            };
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function throttle(cb, delay) {
            var wait = false;
            var savedArgs;
            var wrapper = function wrapper() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              if (wait) {
                savedArgs = args;
                return;
              }
              cb(...args);
              wait = true;
              setTimeout(function () {
                wait = false;
                if (savedArgs) {
                  wrapper(...savedArgs);
                  savedArgs = null;
                }
              }, delay);
            };
            return wrapper;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            removeAttr.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function removeClass(source, args) {
          function removeClass(source, classNames, selector) {
            var applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "asap stay";
            if (!classNames) {
              return;
            }
            classNames = classNames.split(/\s*\|\s*/);
            var selectors = [];
            if (!selector) {
              selectors = classNames.map(function (className) {
                return ".".concat(className);
              });
            }
            var removeClassHandler = function removeClassHandler() {
              var nodes = new Set();
              if (selector) {
                var foundNodes = [];
                try {
                  foundNodes = [].slice.call(document.querySelectorAll(selector));
                } catch (e) {
                  logMessage(source, "Invalid selector arg: '".concat(selector, "'"));
                }
                foundNodes.forEach(function (n) {
                  return nodes.add(n);
                });
              } else if (selectors.length > 0) {
                selectors.forEach(function (s) {
                  var elements = document.querySelectorAll(s);
                  for (var i = 0; i < elements.length; i += 1) {
                    var element = elements[i];
                    nodes.add(element);
                  }
                });
              }
              var removed = false;
              nodes.forEach(function (node) {
                classNames.forEach(function (className) {
                  if (node.classList.contains(className)) {
                    node.classList.remove(className);
                    removed = true;
                  }
                });
              });
              if (removed) {
                hit(source);
              }
            };
            var CLASS_ATTR_NAME = ["class"];
            var flags = parseFlags(applying);
            var run = function run() {
              removeClassHandler();
              if (!flags.hasFlag(flags.STAY)) {
                return;
              }
              observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
            };
            if (flags.hasFlag(flags.ASAP)) {
              if (document.readyState === "loading") {
                window.addEventListener("DOMContentLoaded", removeClassHandler, {
                  once: true
                });
              } else {
                removeClassHandler();
              }
            }
            if (document.readyState !== "complete" && flags.hasFlag(flags.COMPLETE)) {
              window.addEventListener("load", run, {
                once: true
              });
            } else if (flags.hasFlag(flags.STAY)) {
              if (!applying.includes(" ")) {
                removeClassHandler();
              }
              observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
            }
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function observeDOMChanges(callback) {
            var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
            var THROTTLE_DELAY_MS = 20;
            var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
            var connect = function connect() {
              if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs,
                  attributeFilter: attrsToObserve
                });
              } else {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs
                });
              }
            };
            var disconnect = function disconnect() {
              observer.disconnect();
            };
            function callbackWrapper() {
              disconnect();
              callback();
              connect();
            }
            connect();
          }
          function parseFlags(flags) {
            var FLAGS_DIVIDER = " ";
            var ASAP_FLAG = "asap";
            var COMPLETE_FLAG = "complete";
            var STAY_FLAG = "stay";
            var VALID_FLAGS = [STAY_FLAG, ASAP_FLAG, COMPLETE_FLAG];
            var passedFlags = flags.trim().split(FLAGS_DIVIDER).filter(function (f) {
              return VALID_FLAGS.includes(f);
            });
            return {
              ASAP: ASAP_FLAG,
              COMPLETE: COMPLETE_FLAG,
              STAY: STAY_FLAG,
              hasFlag(flag) {
                return passedFlags.includes(flag);
              }
            };
          }
          function throttle(cb, delay) {
            var wait = false;
            var savedArgs;
            var wrapper = function wrapper() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              if (wait) {
                savedArgs = args;
                return;
              }
              cb(...args);
              wait = true;
              setTimeout(function () {
                wait = false;
                if (savedArgs) {
                  wrapper(...savedArgs);
                  savedArgs = null;
                }
              }, delay);
            };
            return wrapper;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            removeClass.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function removeCookie(source, args) {
          function removeCookie(source, match) {
            var matchRegexp = toRegExp(match);
            var removeCookieFromHost = function removeCookieFromHost(cookieName, hostName) {
              var cookieSpec = "".concat(cookieName, "=");
              var domain1 = "; domain=".concat(hostName);
              var domain2 = "; domain=.".concat(hostName);
              var path = "; path=/";
              var expiration = "; expires=Thu, 01 Jan 1970 00:00:00 GMT";
              document.cookie = cookieSpec + expiration;
              document.cookie = cookieSpec + domain1 + expiration;
              document.cookie = cookieSpec + domain2 + expiration;
              document.cookie = cookieSpec + path + expiration;
              document.cookie = cookieSpec + domain1 + path + expiration;
              document.cookie = cookieSpec + domain2 + path + expiration;
              hit(source);
            };
            var rmCookie = function rmCookie() {
              document.cookie.split(";").forEach(function (cookieStr) {
                var pos = cookieStr.indexOf("=");
                if (pos === -1) {
                  return;
                }
                var cookieName = cookieStr.slice(0, pos).trim();
                if (!matchRegexp.test(cookieName)) {
                  return;
                }
                var hostParts = document.location.hostname.split(".");
                for (var i = 0; i <= hostParts.length - 1; i += 1) {
                  var hostName = hostParts.slice(i).join(".");
                  if (hostName) {
                    removeCookieFromHost(cookieName, hostName);
                  }
                }
              });
            };
            rmCookie();
            window.addEventListener("beforeunload", rmCookie);
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            removeCookie.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function removeInShadowDom(source, args) {
          function removeInShadowDom(source, selector, baseSelector) {
            if (!Element.prototype.attachShadow) {
              return;
            }
            var removeElement = function removeElement(targetElement) {
              targetElement.remove();
            };
            var removeHandler = function removeHandler() {
              var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
              var _loop = function _loop() {
                var isRemoved = false;
                var _pierceShadowDom = pierceShadowDom(selector, hostElements),
                  targets = _pierceShadowDom.targets,
                  innerHosts = _pierceShadowDom.innerHosts;
                targets.forEach(function (targetEl) {
                  removeElement(targetEl);
                  isRemoved = true;
                });
                if (isRemoved) {
                  hit(source);
                }
                hostElements = innerHosts;
              };
              while (hostElements.length !== 0) {
                _loop();
              }
            };
            removeHandler();
            observeDOMChanges(removeHandler, true);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function observeDOMChanges(callback) {
            var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
            var THROTTLE_DELAY_MS = 20;
            var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
            var connect = function connect() {
              if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs,
                  attributeFilter: attrsToObserve
                });
              } else {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs
                });
              }
            };
            var disconnect = function disconnect() {
              observer.disconnect();
            };
            function callbackWrapper() {
              disconnect();
              callback();
              connect();
            }
            connect();
          }
          function findHostElements(rootElement) {
            var hosts = [];
            if (rootElement) {
              var domElems = rootElement.querySelectorAll("*");
              domElems.forEach(function (el) {
                if (el.shadowRoot) {
                  hosts.push(el);
                }
              });
            }
            return hosts;
          }
          function pierceShadowDom(selector, hostElements) {
            var targets = [];
            var innerHostsAcc = [];
            hostElements.forEach(function (host) {
              var simpleElems = host.querySelectorAll(selector);
              targets = targets.concat([].slice.call(simpleElems));
              var shadowRootElem = host.shadowRoot;
              var shadowChildren = shadowRootElem.querySelectorAll(selector);
              targets = targets.concat([].slice.call(shadowChildren));
              innerHostsAcc.push(findHostElements(shadowRootElem));
            });
            var innerHosts = flatten(innerHostsAcc);
            return {
              targets: targets,
              innerHosts: innerHosts
            };
          }
          function flatten(input) {
            var stack = [];
            input.forEach(function (el) {
              return stack.push(el);
            });
            var res = [];
            while (stack.length) {
              var next = stack.pop();
              if (Array.isArray(next)) {
                next.forEach(function (el) {
                  return stack.push(el);
                });
              } else {
                res.push(next);
              }
            }
            return res.reverse();
          }
          function throttle(cb, delay) {
            var wait = false;
            var savedArgs;
            var wrapper = function wrapper() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              if (wait) {
                savedArgs = args;
                return;
              }
              cb(...args);
              wait = true;
              setTimeout(function () {
                wait = false;
                if (savedArgs) {
                  wrapper(...savedArgs);
                  savedArgs = null;
                }
              }, delay);
            };
            return wrapper;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            removeInShadowDom.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function removeNodeText(source, args) {
          function removeNodeText(source, nodeName, textMatch) {
            var _parseNodeTextParams = parseNodeTextParams(nodeName, textMatch),
              selector = _parseNodeTextParams.selector,
              nodeNameMatch = _parseNodeTextParams.nodeNameMatch,
              textContentMatch = _parseNodeTextParams.textContentMatch;
            var handleNodes = function handleNodes(nodes) {
              return nodes.forEach(function (node) {
                var shouldReplace = isTargetNode(node, nodeNameMatch, textContentMatch);
                if (shouldReplace) {
                  var ALL_TEXT_PATTERN = /^[\s\S]*$/;
                  var REPLACEMENT = "";
                  replaceNodeText(source, node, ALL_TEXT_PATTERN, REPLACEMENT);
                }
              });
            };
            if (document.documentElement) {
              handleExistingNodes(selector, handleNodes);
            }
            observeDocumentWithTimeout(function (mutations) {
              return handleMutations(mutations, handleNodes);
            }, {
              childList: true,
              subtree: true
            });
          }
          function observeDocumentWithTimeout(callback, options) {
            var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e4;
            var documentObserver = new MutationObserver(function (mutations, observer) {
              observer.disconnect();
              callback(mutations, observer);
              observer.observe(document.documentElement, options);
            });
            documentObserver.observe(document.documentElement, options);
            if (typeof timeout === "number") {
              setTimeout(function () {
                return documentObserver.disconnect();
              }, timeout);
            }
          }
          function handleExistingNodes(selector, handler) {
            var nodeList = document.querySelectorAll(selector);
            var nodes = nodeListToArray(nodeList);
            handler(nodes);
          }
          function handleMutations(mutations, handler) {
            var addedNodes = getAddedNodes(mutations);
            handler(addedNodes);
          }
          function replaceNodeText(source, node, pattern, replacement) {
            var textContent = node.textContent;
            if (textContent) {
              node.textContent = textContent.replace(pattern, replacement);
              hit(source);
            }
          }
          function isTargetNode(node, nodeNameMatch, textContentMatch) {
            var nodeName = node.nodeName,
              textContent = node.textContent;
            var nodeNameLowerCase = nodeName.toLowerCase();
            return textContent !== null && textContent !== "" && (nodeNameMatch instanceof RegExp ? nodeNameMatch.test(nodeNameLowerCase) : nodeNameMatch === nodeNameLowerCase) && (textContentMatch instanceof RegExp ? textContentMatch.test(textContent) : textContent.includes(textContentMatch));
          }
          function parseNodeTextParams(nodeName, textMatch) {
            var pattern = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
            var REGEXP_START_MARKER = "/";
            var isStringNameMatch = !(nodeName.startsWith(REGEXP_START_MARKER) && nodeName.endsWith(REGEXP_START_MARKER));
            var selector = isStringNameMatch ? nodeName : "*";
            var nodeNameMatch = isStringNameMatch ? nodeName : toRegExp(nodeName);
            var textContentMatch = !textMatch.startsWith(REGEXP_START_MARKER) ? textMatch : toRegExp(textMatch);
            var patternMatch;
            if (pattern) {
              patternMatch = !pattern.startsWith(REGEXP_START_MARKER) ? pattern : toRegExp(pattern);
            }
            return {
              selector: selector,
              nodeNameMatch: nodeNameMatch,
              textContentMatch: textContentMatch,
              patternMatch: patternMatch
            };
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function nodeListToArray(nodeList) {
            var nodes = [];
            for (var i = 0; i < nodeList.length; i += 1) {
              nodes.push(nodeList[i]);
            }
            return nodes;
          }
          function getAddedNodes(mutations) {
            var nodes = [];
            for (var i = 0; i < mutations.length; i += 1) {
              var addedNodes = mutations[i].addedNodes;
              for (var j = 0; j < addedNodes.length; j += 1) {
                nodes.push(addedNodes[j]);
              }
            }
            return nodes;
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            removeNodeText.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function setAttr(source, args) {
          function setAttr(source, selector, attr) {
            var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
            if (!selector || !attr) {
              return;
            }
            var allowedValues = ["true", "false"];
            if (value.length !== 0 && (nativeIsNaN(parseInt(value, 10)) || parseInt(value, 10) < 0 || parseInt(value, 10) > 32767) && !allowedValues.includes(value.toLowerCase())) {
              return;
            }
            var setAttr = function setAttr() {
              var nodes = [].slice.call(document.querySelectorAll(selector));
              var set = false;
              nodes.forEach(function (node) {
                node.setAttribute(attr, value);
                set = true;
              });
              if (set) {
                hit(source);
              }
            };
            setAttr();
            observeDOMChanges(setAttr, true);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function observeDOMChanges(callback) {
            var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
            var THROTTLE_DELAY_MS = 20;
            var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
            var connect = function connect() {
              if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs,
                  attributeFilter: attrsToObserve
                });
              } else {
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: observeAttrs
                });
              }
            };
            var disconnect = function disconnect() {
              observer.disconnect();
            };
            function callbackWrapper() {
              disconnect();
              callback();
              connect();
            }
            connect();
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function throttle(cb, delay) {
            var wait = false;
            var savedArgs;
            var wrapper = function wrapper() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              if (wait) {
                savedArgs = args;
                return;
              }
              cb(...args);
              wait = true;
              setTimeout(function () {
                wait = false;
                if (savedArgs) {
                  wrapper(...savedArgs);
                  savedArgs = null;
                }
              }, delay);
            };
            return wrapper;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            setAttr.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function setConstant(source, args) {
          function setConstant(source, property, value) {
            var stack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
            var valueWrapper = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
            var setProxyTrap = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
            var uboAliases = ["set-constant.js", "ubo-set-constant.js", "set.js", "ubo-set.js", "ubo-set-constant", "ubo-set"];
            if (uboAliases.includes(source.name)) {
              if (stack.length !== 1 && !getNumberFromString(stack)) {
                valueWrapper = stack;
              }
              stack = undefined;
            }
            if (!property || !matchStackTrace(stack, new Error().stack)) {
              return;
            }
            var isProxyTrapSet = false;
            var emptyArr = noopArray();
            var emptyObj = noopObject();
            var constantValue;
            if (value === "undefined") {
              constantValue = undefined;
            } else if (value === "false") {
              constantValue = false;
            } else if (value === "true") {
              constantValue = true;
            } else if (value === "null") {
              constantValue = null;
            } else if (value === "emptyArr") {
              constantValue = emptyArr;
            } else if (value === "emptyObj") {
              constantValue = emptyObj;
            } else if (value === "noopFunc") {
              constantValue = noopFunc;
            } else if (value === "noopCallbackFunc") {
              constantValue = noopCallbackFunc;
            } else if (value === "trueFunc") {
              constantValue = trueFunc;
            } else if (value === "falseFunc") {
              constantValue = falseFunc;
            } else if (value === "throwFunc") {
              constantValue = throwFunc;
            } else if (value === "noopPromiseResolve") {
              constantValue = noopPromiseResolve;
            } else if (value === "noopPromiseReject") {
              constantValue = noopPromiseReject;
            } else if (/^\d+$/.test(value)) {
              constantValue = parseFloat(value);
              if (nativeIsNaN(constantValue)) {
                return;
              }
              if (Math.abs(constantValue) > 32767) {
                return;
              }
            } else if (value === "-1") {
              constantValue = -1;
            } else if (value === "") {
              constantValue = "";
            } else if (value === "yes") {
              constantValue = "yes";
            } else if (value === "no") {
              constantValue = "no";
            } else {
              return;
            }
            var valueWrapperNames = ["asFunction", "asCallback", "asResolved", "asRejected"];
            if (valueWrapperNames.includes(valueWrapper)) {
              var valueWrappersMap = {
                asFunction(v) {
                  return function () {
                    return v;
                  };
                },
                asCallback(v) {
                  return function () {
                    return function () {
                      return v;
                    };
                  };
                },
                asResolved(v) {
                  return Promise.resolve(v);
                },
                asRejected(v) {
                  return Promise.reject(v);
                }
              };
              constantValue = valueWrappersMap[valueWrapper](constantValue);
            }
            var canceled = false;
            var mustCancel = function mustCancel(value) {
              if (canceled) {
                return canceled;
              }
              canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue && value !== null;
              return canceled;
            };
            var trapProp = function trapProp(base, prop, configurable, handler) {
              if (!handler.init(base[prop])) {
                return false;
              }
              var origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
              var prevSetter;
              if (origDescriptor instanceof Object) {
                if (!origDescriptor.configurable) {
                  var message = "Property '".concat(prop, "' is not configurable");
                  logMessage(source, message);
                  return false;
                }
                if (base[prop]) {
                  base[prop] = constantValue;
                }
                if (origDescriptor.set instanceof Function) {
                  prevSetter = origDescriptor.set;
                }
              }
              Object.defineProperty(base, prop, {
                configurable: configurable,
                get() {
                  return handler.get();
                },
                set(a) {
                  if (prevSetter !== undefined) {
                    prevSetter(a);
                  }
                  if (a instanceof Object) {
                    var propertiesToCheck = property.split(".").slice(1);
                    if (setProxyTrap && !isProxyTrapSet) {
                      isProxyTrapSet = true;
                      a = new Proxy(a, {
                        get: function get(target, propertyKey, val) {
                          propertiesToCheck.reduce(function (object, currentProp, index, array) {
                            var currentObj = object === null || object === void 0 ? void 0 : object[currentProp];
                            if (currentObj && index === array.length - 1 && currentObj !== constantValue) {
                              object[currentProp] = constantValue;
                            }
                            return currentObj || object;
                          }, target);
                          return Reflect.get(target, propertyKey, val);
                        }
                      });
                    }
                  }
                  handler.set(a);
                }
              });
              return true;
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                chain = chainInfo.chain;
              var inChainPropHandler = {
                factValue: undefined,
                init(a) {
                  this.factValue = a;
                  return true;
                },
                get() {
                  return this.factValue;
                },
                set(a) {
                  if (this.factValue === a) {
                    return;
                  }
                  this.factValue = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                }
              };
              var endPropHandler = {
                init(a) {
                  if (mustCancel(a)) {
                    return false;
                  }
                  return true;
                },
                get() {
                  return constantValue;
                },
                set(a) {
                  if (!mustCancel(a)) {
                    return;
                  }
                  constantValue = a;
                }
              };
              if (!chain) {
                var isTrapped = trapProp(base, prop, false, endPropHandler);
                if (isTrapped) {
                  hit(source);
                }
                return;
              }
              if (base !== undefined && base[prop] === null) {
                trapProp(base, prop, true, inChainPropHandler);
                return;
              }
              if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
                trapProp(base, prop, true, inChainPropHandler);
              }
              var propValue = owner[prop];
              if (propValue instanceof Object || typeof propValue === "object" && propValue !== null) {
                setChainPropAccess(propValue, chain);
              }
              trapProp(base, prop, true, inChainPropHandler);
            };
            setChainPropAccess(window, property);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function getNumberFromString(rawString) {
            var parsedDelay = parseInt(rawString, 10);
            var validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
            return validDelay;
          }
          function noopArray() {
            return [];
          }
          function noopObject() {
            return {};
          }
          function noopFunc() {}
          function noopCallbackFunc() {
            return noopFunc;
          }
          function trueFunc() {
            return true;
          }
          function falseFunc() {
            return false;
          }
          function throwFunc() {
            throw new Error();
          }
          function noopPromiseReject() {
            return Promise.reject();
          }
          function noopPromiseResolve() {
            var responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "{}";
            var responseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            var responseType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "default";
            if (typeof Response === "undefined") {
              return;
            }
            var response = new Response(responseBody, {
              status: 200,
              statusText: "OK"
            });
            Object.defineProperties(response, {
              url: {
                value: responseUrl
              },
              type: {
                value: responseType
              }
            });
            if (responseType === "opaque") {
              Object.defineProperties(response, {
                body: {
                  value: null
                },
                status: {
                  value: 0
                },
                statusText: {
                  value: ""
                }
              });
            }
            return Promise.resolve(response);
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function matchStackTrace(stackMatch, stackTrace) {
            if (!stackMatch || stackMatch === "") {
              return true;
            }
            if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
              return true;
            }
            var stackRegexp = toRegExp(stackMatch);
            var refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
              return line.trim();
            }).join("\n");
            return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
            var INLINE_SCRIPT_STRING = "inlineScript";
            var INJECTED_SCRIPT_STRING = "injectedScript";
            var INJECTED_SCRIPT_MARKER = "<anonymous>";
            var isInlineScript = function isInlineScript(match) {
              return match.includes(INLINE_SCRIPT_STRING);
            };
            var isInjectedScript = function isInjectedScript(match) {
              return match.includes(INJECTED_SCRIPT_STRING);
            };
            if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
              return false;
            }
            var documentURL = window.location.href;
            var pos = documentURL.indexOf("#");
            if (pos !== -1) {
              documentURL = documentURL.slice(0, pos);
            }
            var stackSteps = stackTrace.split("\n").slice(2).map(function (line) {
              return line.trim();
            });
            var stackLines = stackSteps.map(function (line) {
              var stack;
              var getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
              if (getStackTraceURL) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceURL[2];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                  stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                  var _stackFunction;
                  stackURL = INJECTED_SCRIPT_STRING;
                  var stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
                  if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                    stackFunction = stackFunction.slice(2).trim();
                  }
                  stack = "".concat(stackFunction, " ").concat(stackURL).trim();
                } else {
                  stack = stackURL;
                }
              } else {
                stack = line;
              }
              return stack;
            });
            if (stackLines) {
              for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
                  return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING)) {
                  return true;
                }
              }
            }
            return false;
          }
          function getNativeRegexpTest() {
            var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
            var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
            if (descriptor && typeof descriptor.value === "function") {
              return nativeRegexTest;
            }
            throw new Error("RegExp.prototype.test is not a function");
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            setConstant.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function setCookie(source, args) {
          function setCookie(source, name, value) {
            var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "/";
            var validValue = getLimitedCookieValue(value);
            if (validValue === null) {
              logMessage(source, "Invalid cookie value: '".concat(validValue, "'"));
              return;
            }
            if (!isValidCookiePath(path)) {
              logMessage(source, "Invalid cookie path: '".concat(path, "'"));
              return;
            }
            var cookieToSet = concatCookieNameValuePath(name, validValue, path);
            if (!cookieToSet) {
              logMessage(source, "Invalid cookie name or value");
              return;
            }
            hit(source);
            document.cookie = cookieToSet;
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function getLimitedCookieValue(value) {
            if (!value) {
              return null;
            }
            var allowedCookieValues = new Set(["true", "false", "yes", "y", "no", "n", "ok", "on", "off", "accept", "accepted", "notaccepted", "reject", "rejected", "allow", "allowed", "disallow", "deny", "enable", "enabled", "disable", "disabled"]);
            var validValue;
            if (allowedCookieValues.has(value.toLowerCase())) {
              validValue = value;
            } else if (/^\d+$/.test(value)) {
              validValue = parseFloat(value);
              if (nativeIsNaN(validValue)) {
                return null;
              }
              if (Math.abs(validValue) < 0 || Math.abs(validValue) > 15) {
                return null;
              }
            } else {
              return null;
            }
            return validValue;
          }
          function concatCookieNameValuePath(rawName, rawValue, rawPath) {
            var shouldEncode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var COOKIE_BREAKER = ";";
            if (!shouldEncode && (rawName.includes(COOKIE_BREAKER) || "".concat(rawValue).includes(COOKIE_BREAKER))) {
              return null;
            }
            var name = shouldEncode ? encodeURIComponent(rawName) : rawName;
            var value = shouldEncode ? encodeURIComponent(rawValue) : rawValue;
            return "".concat(name, "=").concat(value, "; ").concat(getCookiePath(rawPath), ";");
          }
          function isValidCookiePath(rawPath) {
            return rawPath === "/" || rawPath === "none";
          }
          function getCookiePath(rawPath) {
            if (rawPath === "/") {
              return "path=/";
            }
            return "";
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            setCookie.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function setCookieReload(source, args) {
          function setCookieReload(source, name, value) {
            var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "/";
            if (isCookieSetWithValue(document.cookie, name, value)) {
              return;
            }
            var validValue = getLimitedCookieValue(value);
            if (validValue === null) {
              logMessage(source, "Invalid cookie value: '".concat(value, "'"));
              return;
            }
            if (!isValidCookiePath(path)) {
              logMessage(source, "Invalid cookie path: '".concat(path, "'"));
              return;
            }
            var cookieToSet = concatCookieNameValuePath(name, validValue, path);
            if (!cookieToSet) {
              logMessage(source, "Invalid cookie name or value");
              return;
            }
            document.cookie = cookieToSet;
            hit(source);
            if (isCookieSetWithValue(document.cookie, name, value)) {
              window.location.reload();
            }
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function isCookieSetWithValue(cookieString, name, value) {
            return cookieString.split(";").some(function (cookieStr) {
              var pos = cookieStr.indexOf("=");
              if (pos === -1) {
                return false;
              }
              var cookieName = cookieStr.slice(0, pos).trim();
              var cookieValue = cookieStr.slice(pos + 1).trim();
              return name === cookieName && value === cookieValue;
            });
          }
          function getLimitedCookieValue(value) {
            if (!value) {
              return null;
            }
            var allowedCookieValues = new Set(["true", "false", "yes", "y", "no", "n", "ok", "on", "off", "accept", "accepted", "notaccepted", "reject", "rejected", "allow", "allowed", "disallow", "deny", "enable", "enabled", "disable", "disabled"]);
            var validValue;
            if (allowedCookieValues.has(value.toLowerCase())) {
              validValue = value;
            } else if (/^\d+$/.test(value)) {
              validValue = parseFloat(value);
              if (nativeIsNaN(validValue)) {
                return null;
              }
              if (Math.abs(validValue) < 0 || Math.abs(validValue) > 15) {
                return null;
              }
            } else {
              return null;
            }
            return validValue;
          }
          function concatCookieNameValuePath(rawName, rawValue, rawPath) {
            var shouldEncode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var COOKIE_BREAKER = ";";
            if (!shouldEncode && (rawName.includes(COOKIE_BREAKER) || "".concat(rawValue).includes(COOKIE_BREAKER))) {
              return null;
            }
            var name = shouldEncode ? encodeURIComponent(rawName) : rawName;
            var value = shouldEncode ? encodeURIComponent(rawValue) : rawValue;
            return "".concat(name, "=").concat(value, "; ").concat(getCookiePath(rawPath), ";");
          }
          function isValidCookiePath(rawPath) {
            return rawPath === "/" || rawPath === "none";
          }
          function getCookiePath(rawPath) {
            if (rawPath === "/") {
              return "path=/";
            }
            return "";
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            setCookieReload.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function setLocalStorageItem(source, args) {
          function setLocalStorageItem(source, key, value) {
            if (typeof key === "undefined") {
              logMessage(source, "Item key should be specified.");
              return;
            }
            var validValue;
            try {
              validValue = getLimitedStorageItemValue(value);
            } catch (_unused) {
              logMessage(source, "Invalid storage item value: '".concat(value, "'"));
              return;
            }
            var _window = window,
              localStorage = _window.localStorage;
            if (validValue === "$remove$") {
              removeStorageItem(source, localStorage, key);
            } else {
              setStorageItem(source, localStorage, key, validValue);
            }
            hit(source);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function setStorageItem(source, storage, key, value) {
            try {
              storage.setItem(key, value);
            } catch (e) {
              var message = "Unable to set sessionStorage item due to: ".concat(e.message);
              logMessage(source, message);
            }
          }
          function removeStorageItem(source, storage, key) {
            try {
              if (key.startsWith("/") && (key.endsWith("/") || key.endsWith("/i")) && isValidStrPattern(key)) {
                var regExpKey = toRegExp(key);
                var storageKeys = Object.keys(storage);
                storageKeys.forEach(function (storageKey) {
                  if (regExpKey.test(storageKey)) {
                    storage.removeItem(storageKey);
                  }
                });
              } else {
                storage.removeItem(key);
              }
            } catch (e) {
              var message = "Unable to remove storage item due to: ".concat(e.message);
              logMessage(source, message);
            }
          }
          function getLimitedStorageItemValue(value) {
            if (typeof value !== "string") {
              throw new Error("Invalid value");
            }
            var allowedStorageValues = new Set(["undefined", "false", "true", "null", "", "yes", "no", "on", "off"]);
            var validValue;
            if (allowedStorageValues.has(value.toLowerCase())) {
              validValue = value;
            } else if (value === "emptyArr") {
              validValue = "[]";
            } else if (value === "emptyObj") {
              validValue = "{}";
            } else if (/^\d+$/.test(value)) {
              validValue = parseFloat(value);
              if (nativeIsNaN(validValue)) {
                throw new Error("Invalid value");
              }
              if (Math.abs(validValue) > 32767) {
                throw new Error("Invalid value");
              }
            } else if (value === "$remove$") {
              validValue = "$remove$";
            } else {
              throw new Error("Invalid value");
            }
            return validValue;
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            setLocalStorageItem.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function setPopadsDummy(source, args) {
          function setPopadsDummy(source) {
            delete window.PopAds;
            delete window.popns;
            Object.defineProperties(window, {
              PopAds: {
                get: function get() {
                  hit(source);
                  return {};
                }
              },
              popns: {
                get: function get() {
                  hit(source);
                  return {};
                }
              }
            });
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            setPopadsDummy.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function setSessionStorageItem(source, args) {
          function setSessionStorageItem(source, key, value) {
            if (typeof key === "undefined") {
              logMessage(source, "Item key should be specified.");
              return;
            }
            var validValue;
            try {
              validValue = getLimitedStorageItemValue(value);
            } catch (_unused) {
              logMessage(source, "Invalid storage item value: '".concat(value, "'"));
              return;
            }
            var _window = window,
              sessionStorage = _window.sessionStorage;
            if (validValue === "$remove$") {
              removeStorageItem(source, sessionStorage, key);
            } else {
              setStorageItem(source, sessionStorage, key, validValue);
            }
            hit(source);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function setStorageItem(source, storage, key, value) {
            try {
              storage.setItem(key, value);
            } catch (e) {
              var message = "Unable to set sessionStorage item due to: ".concat(e.message);
              logMessage(source, message);
            }
          }
          function removeStorageItem(source, storage, key) {
            try {
              if (key.startsWith("/") && (key.endsWith("/") || key.endsWith("/i")) && isValidStrPattern(key)) {
                var regExpKey = toRegExp(key);
                var storageKeys = Object.keys(storage);
                storageKeys.forEach(function (storageKey) {
                  if (regExpKey.test(storageKey)) {
                    storage.removeItem(storageKey);
                  }
                });
              } else {
                storage.removeItem(key);
              }
            } catch (e) {
              var message = "Unable to remove storage item due to: ".concat(e.message);
              logMessage(source, message);
            }
          }
          function getLimitedStorageItemValue(value) {
            if (typeof value !== "string") {
              throw new Error("Invalid value");
            }
            var allowedStorageValues = new Set(["undefined", "false", "true", "null", "", "yes", "no", "on", "off"]);
            var validValue;
            if (allowedStorageValues.has(value.toLowerCase())) {
              validValue = value;
            } else if (value === "emptyArr") {
              validValue = "[]";
            } else if (value === "emptyObj") {
              validValue = "{}";
            } else if (/^\d+$/.test(value)) {
              validValue = parseFloat(value);
              if (nativeIsNaN(validValue)) {
                throw new Error("Invalid value");
              }
              if (Math.abs(validValue) > 32767) {
                throw new Error("Invalid value");
              }
            } else if (value === "$remove$") {
              validValue = "$remove$";
            } else {
              throw new Error("Invalid value");
            }
            return validValue;
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            setSessionStorageItem.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function trustedClickElement(source, args) {
          function trustedClickElement(source, selectors) {
            var extraMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
            var delay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NaN;
            if (!selectors) {
              return;
            }
            var OBSERVER_TIMEOUT_MS = 1e4;
            var THROTTLE_DELAY_MS = 20;
            var STATIC_CLICK_DELAY_MS = 150;
            var COOKIE_MATCH_MARKER = "cookie:";
            var LOCAL_STORAGE_MATCH_MARKER = "localStorage:";
            var SELECTORS_DELIMITER = ",";
            var COOKIE_STRING_DELIMITER = ";";
            var EXTRA_MATCH_DELIMITER = /(,\s*){1}(?=!?cookie:|!?localStorage:)/;
            var sleep = function sleep(delayMs) {
              return new Promise(function (resolve) {
                return setTimeout(resolve, delayMs);
              });
            };
            var parsedDelay;
            if (delay) {
              parsedDelay = parseInt(delay, 10);
              var isValidDelay = !Number.isNaN(parsedDelay) || parsedDelay < OBSERVER_TIMEOUT_MS;
              if (!isValidDelay) {
                var message = "Passed delay '".concat(delay, "' is invalid or bigger than ").concat(OBSERVER_TIMEOUT_MS, " ms");
                logMessage(source, message);
                return;
              }
            }
            var canClick = !parsedDelay;
            var cookieMatches = [];
            var localStorageMatches = [];
            var isInvertedMatchCookie = false;
            var isInvertedMatchLocalStorage = false;
            if (extraMatch) {
              var parsedExtraMatch = extraMatch.split(EXTRA_MATCH_DELIMITER).map(function (matchStr) {
                return matchStr.trim();
              });
              parsedExtraMatch.forEach(function (matchStr) {
                if (matchStr.includes(COOKIE_MATCH_MARKER)) {
                  var _parseMatchArg = parseMatchArg(matchStr),
                    isInvertedMatch = _parseMatchArg.isInvertedMatch,
                    matchValue = _parseMatchArg.matchValue;
                  isInvertedMatchCookie = isInvertedMatch;
                  var cookieMatch = matchValue.replace(COOKIE_MATCH_MARKER, "");
                  cookieMatches.push(cookieMatch);
                }
                if (matchStr.includes(LOCAL_STORAGE_MATCH_MARKER)) {
                  var _parseMatchArg2 = parseMatchArg(matchStr),
                    _isInvertedMatch = _parseMatchArg2.isInvertedMatch,
                    _matchValue = _parseMatchArg2.matchValue;
                  isInvertedMatchLocalStorage = _isInvertedMatch;
                  var localStorageMatch = _matchValue.replace(LOCAL_STORAGE_MATCH_MARKER, "");
                  localStorageMatches.push(localStorageMatch);
                }
              });
            }
            if (cookieMatches.length > 0) {
              var parsedCookieMatches = parseCookieString(cookieMatches.join(COOKIE_STRING_DELIMITER));
              var parsedCookies = parseCookieString(document.cookie);
              var cookieKeys = Object.keys(parsedCookies);
              if (cookieKeys.length === 0) {
                return;
              }
              var cookiesMatched = Object.keys(parsedCookieMatches).every(function (key) {
                var valueMatch = parsedCookieMatches[key] ? toRegExp(parsedCookieMatches[key]) : null;
                var keyMatch = toRegExp(key);
                return cookieKeys.some(function (key) {
                  var keysMatched = keyMatch.test(key);
                  if (!keysMatched) {
                    return false;
                  }
                  if (!valueMatch) {
                    return true;
                  }
                  return valueMatch.test(parsedCookies[key]);
                });
              });
              var shouldRun = cookiesMatched !== isInvertedMatchCookie;
              if (!shouldRun) {
                return;
              }
            }
            if (localStorageMatches.length > 0) {
              var localStorageMatched = localStorageMatches.every(function (str) {
                var itemValue = window.localStorage.getItem(str);
                return itemValue || itemValue === "";
              });
              var _shouldRun = localStorageMatched !== isInvertedMatchLocalStorage;
              if (!_shouldRun) {
                return;
              }
            }
            var selectorsSequence = selectors.split(SELECTORS_DELIMITER).map(function (selector) {
              return selector.trim();
            });
            var createElementObj = function createElementObj(element) {
              return {
                element: element || null,
                clicked: false
              };
            };
            var elementsSequence = Array(selectorsSequence.length).fill(createElementObj());
            var clickElementsBySequence = async function clickElementsBySequence() {
              for (var i = 0; i < elementsSequence.length; i += 1) {
                var elementObj = elementsSequence[i];
                if (i >= 1) {
                  await sleep(STATIC_CLICK_DELAY_MS);
                }
                if (!elementObj.element) {
                  break;
                }
                if (!elementObj.clicked) {
                  elementObj.element.click();
                  elementObj.clicked = true;
                }
              }
              var allElementsClicked = elementsSequence.every(function (elementObj) {
                return elementObj.clicked === true;
              });
              if (allElementsClicked) {
                hit(source);
              }
            };
            var handleElement = function handleElement(element, i) {
              var elementObj = createElementObj(element);
              elementsSequence[i] = elementObj;
              if (canClick) {
                clickElementsBySequence();
              }
            };
            var findElements = function findElements(mutations, observer) {
              var fulfilledSelectors = [];
              selectorsSequence.forEach(function (selector, i) {
                if (!selector) {
                  return;
                }
                var element = document.querySelector(selector);
                if (!element) {
                  return;
                }
                handleElement(element, i);
                fulfilledSelectors.push(selector);
              });
              selectorsSequence = selectorsSequence.map(function (selector) {
                return fulfilledSelectors.includes(selector) ? null : selector;
              });
              var allSelectorsFulfilled = selectorsSequence.every(function (selector) {
                return selector === null;
              });
              if (allSelectorsFulfilled) {
                observer.disconnect();
              }
            };
            var observer = new MutationObserver(throttle(findElements, THROTTLE_DELAY_MS));
            observer.observe(document.documentElement, {
              attributes: true,
              childList: true,
              subtree: true
            });
            if (parsedDelay) {
              setTimeout(function () {
                clickElementsBySequence();
                canClick = true;
              }, parsedDelay);
            }
            setTimeout(function () {
              return observer.disconnect();
            }, OBSERVER_TIMEOUT_MS);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function parseCookieString(cookieString) {
            var COOKIE_DELIMITER = "=";
            var COOKIE_PAIRS_DELIMITER = ";";
            var cookieChunks = cookieString.split(COOKIE_PAIRS_DELIMITER);
            var cookieData = {};
            cookieChunks.forEach(function (singleCookie) {
              var cookieKey;
              var cookieValue = "";
              var delimiterIndex = singleCookie.indexOf(COOKIE_DELIMITER);
              if (delimiterIndex === -1) {
                cookieKey = singleCookie.trim();
              } else {
                cookieKey = singleCookie.slice(0, delimiterIndex).trim();
                cookieValue = singleCookie.slice(delimiterIndex + 1);
              }
              cookieData[cookieKey] = cookieValue || null;
            });
            return cookieData;
          }
          function throttle(cb, delay) {
            var wait = false;
            var savedArgs;
            var wrapper = function wrapper() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              if (wait) {
                savedArgs = args;
                return;
              }
              cb(...args);
              wait = true;
              setTimeout(function () {
                wait = false;
                if (savedArgs) {
                  wrapper(...savedArgs);
                  savedArgs = null;
                }
              }, delay);
            };
            return wrapper;
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function parseMatchArg(match) {
            var INVERT_MARKER = "!";
            var isInvertedMatch = match ? match === null || match === void 0 ? void 0 : match.startsWith(INVERT_MARKER) : false;
            var matchValue = isInvertedMatch ? match.slice(1) : match;
            var matchRegexp = toRegExp(matchValue);
            return {
              isInvertedMatch: isInvertedMatch,
              matchRegexp: matchRegexp,
              matchValue: matchValue
            };
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            trustedClickElement.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function trustedPruneInboundObject(source, args) {
          function trustedPruneInboundObject(source, functionName, propsToRemove, requiredInitialProps) {
            var stack = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
            if (!functionName) {
              return;
            }
            var nativeObjects = {
              nativeStringify: window.JSON.stringify
            };
            var _getPropertyInChain = getPropertyInChain(window, functionName),
              base = _getPropertyInChain.base,
              prop = _getPropertyInChain.prop;
            if (!base || !prop || typeof base[prop] !== "function") {
              var message = "".concat(functionName, " is not a function");
              logMessage(source, message);
              return;
            }
            var prunePaths = getPrunePath(propsToRemove);
            var requiredPaths = getPrunePath(requiredInitialProps);
            var objectWrapper = function objectWrapper(target, thisArg, args) {
              var data = args[0];
              if (typeof data === "object") {
                data = jsonPruner(source, data, prunePaths, requiredPaths, stack, nativeObjects);
                args[0] = data;
              }
              return Reflect.apply(target, thisArg, args);
            };
            var objectHandler = {
              apply: objectWrapper
            };
            base[prop] = new Proxy(base[prop], objectHandler);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function matchStackTrace(stackMatch, stackTrace) {
            if (!stackMatch || stackMatch === "") {
              return true;
            }
            if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
              return true;
            }
            var stackRegexp = toRegExp(stackMatch);
            var refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
              return line.trim();
            }).join("\n");
            return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function getWildcardPropertyInChain(base, chain) {
            var lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
            var pos = chain.indexOf(".");
            if (pos === -1) {
              if (chain === "*" || chain === "[]") {
                for (var key in base) {
                  if (Object.prototype.hasOwnProperty.call(base, key)) {
                    output.push({
                      base: base,
                      prop: key
                    });
                  }
                }
              } else {
                output.push({
                  base: base,
                  prop: chain
                });
              }
              return output;
            }
            var prop = chain.slice(0, pos);
            var shouldLookThrough = prop === "[]" && Array.isArray(base) || prop === "*" && base instanceof Object;
            if (shouldLookThrough) {
              var nextProp = chain.slice(pos + 1);
              var baseKeys = Object.keys(base);
              baseKeys.forEach(function (key) {
                var item = base[key];
                getWildcardPropertyInChain(item, nextProp, lookThrough, output);
              });
            }
            if (Array.isArray(base)) {
              base.forEach(function (key) {
                var nextBase = key;
                if (nextBase !== undefined) {
                  getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
                }
              });
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if (nextBase !== undefined) {
              getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
            }
            return output;
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
            if (!root) {
              return false;
            }
            var nativeStringify = nativeObjects.nativeStringify;
            var shouldProcess;
            if (prunePaths.length === 0 && requiredPaths.length > 0) {
              var rootString = nativeStringify(root);
              var matchRegex = toRegExp(requiredPaths.join(""));
              var shouldLog = matchRegex.test(rootString);
              if (shouldLog) {
                logMessage(source, "".concat(window.location.hostname, "\n").concat(nativeStringify(root, null, 2), "\nStack trace:\n").concat(new Error().stack), true);
                if (root && typeof root === "object") {
                  logMessage(source, root, true, false);
                }
                shouldProcess = false;
                return shouldProcess;
              }
            }
            if (stack && !matchStackTrace(stack, new Error().stack || "")) {
              shouldProcess = false;
              return shouldProcess;
            }
            var wildcardSymbols = [".*.", "*.", ".*", ".[].", "[].", ".[]"];
            var _loop = function _loop() {
              var requiredPath = requiredPaths[i];
              var lastNestedPropName = requiredPath.split(".").pop();
              var hasWildcard = wildcardSymbols.some(function (symbol) {
                return requiredPath.includes(symbol);
              });
              var details = getWildcardPropertyInChain(root, requiredPath, hasWildcard);
              if (!details.length) {
                shouldProcess = false;
                return {
                  v: shouldProcess
                };
              }
              shouldProcess = !hasWildcard;
              for (var j = 0; j < details.length; j += 1) {
                var hasRequiredProp = typeof lastNestedPropName === "string" && details[j].base[lastNestedPropName] !== undefined;
                if (hasWildcard) {
                  shouldProcess = hasRequiredProp || shouldProcess;
                } else {
                  shouldProcess = hasRequiredProp && shouldProcess;
                }
              }
            };
            for (var i = 0; i < requiredPaths.length; i += 1) {
              var _ret = _loop();
              if (typeof _ret === "object") return _ret.v;
            }
            return shouldProcess;
          }
          function jsonPruner(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
            var nativeStringify = nativeObjects.nativeStringify;
            if (prunePaths.length === 0 && requiredPaths.length === 0) {
              logMessage(source, "".concat(window.location.hostname, "\n").concat(nativeStringify(root, null, 2), "\nStack trace:\n").concat(new Error().stack), true);
              if (root && typeof root === "object") {
                logMessage(source, root, true, false);
              }
              return root;
            }
            try {
              if (isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) === false) {
                return root;
              }
              prunePaths.forEach(function (path) {
                var ownerObjArr = getWildcardPropertyInChain(root, path, true);
                ownerObjArr.forEach(function (ownerObj) {
                  if (ownerObj !== undefined && ownerObj.base) {
                    delete ownerObj.base[ownerObj.prop];
                    hit(source);
                  }
                });
              });
            } catch (e) {
              logMessage(source, e);
            }
            return root;
          }
          function getPrunePath(props) {
            var validPropsString = typeof props === "string" && props !== undefined && props !== "";
            return validPropsString ? props.split(/ +/) : [];
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function getNativeRegexpTest() {
            var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
            var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
            if (descriptor && typeof descriptor.value === "function") {
              return nativeRegexTest;
            }
            throw new Error("RegExp.prototype.test is not a function");
          }
          function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
            var INLINE_SCRIPT_STRING = "inlineScript";
            var INJECTED_SCRIPT_STRING = "injectedScript";
            var INJECTED_SCRIPT_MARKER = "<anonymous>";
            var isInlineScript = function isInlineScript(match) {
              return match.includes(INLINE_SCRIPT_STRING);
            };
            var isInjectedScript = function isInjectedScript(match) {
              return match.includes(INJECTED_SCRIPT_STRING);
            };
            if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
              return false;
            }
            var documentURL = window.location.href;
            var pos = documentURL.indexOf("#");
            if (pos !== -1) {
              documentURL = documentURL.slice(0, pos);
            }
            var stackSteps = stackTrace.split("\n").slice(2).map(function (line) {
              return line.trim();
            });
            var stackLines = stackSteps.map(function (line) {
              var stack;
              var getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
              if (getStackTraceURL) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceURL[2];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                  stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                  var _stackFunction;
                  stackURL = INJECTED_SCRIPT_STRING;
                  var stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
                  if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                    stackFunction = stackFunction.slice(2).trim();
                  }
                  stack = "".concat(stackFunction, " ").concat(stackURL).trim();
                } else {
                  stack = stackURL;
                }
              } else {
                stack = line;
              }
              return stack;
            });
            if (stackLines) {
              for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
                  return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING)) {
                  return true;
                }
              }
            }
            return false;
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            trustedPruneInboundObject.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function trustedReplaceFetchResponse(source, args) {
          function trustedReplaceFetchResponse(source) {
            var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
            var propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
            if (typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
              return;
            }
            if (pattern === "" && replacement !== "") {
              logMessage(source, "Pattern argument should not be empty string");
              return;
            }
            var shouldLog = pattern === "" && replacement === "";
            var nativeRequestClone = Request.prototype.clone;
            var nativeFetch = fetch;
            var shouldReplace = false;
            var fetchData;
            var handlerWrapper = function handlerWrapper(target, thisArg, args) {
              fetchData = getFetchData(args, nativeRequestClone);
              if (shouldLog) {
                logMessage(source, "fetch( ".concat(objectToString(fetchData), " )"), true);
                hit(source);
                return Reflect.apply(target, thisArg, args);
              }
              shouldReplace = matchRequestProps(source, propsToMatch, fetchData);
              if (!shouldReplace) {
                return Reflect.apply(target, thisArg, args);
              }
              var forgeResponse = function forgeResponse(response, textContent) {
                var bodyUsed = response.bodyUsed,
                  headers = response.headers,
                  ok = response.ok,
                  redirected = response.redirected,
                  status = response.status,
                  statusText = response.statusText,
                  type = response.type,
                  url = response.url;
                var forgedResponse = new Response(textContent, {
                  status: status,
                  statusText: statusText,
                  headers: headers
                });
                Object.defineProperties(forgedResponse, {
                  url: {
                    value: url
                  },
                  type: {
                    value: type
                  },
                  ok: {
                    value: ok
                  },
                  bodyUsed: {
                    value: bodyUsed
                  },
                  redirected: {
                    value: redirected
                  }
                });
                return forgedResponse;
              };
              return nativeFetch.apply(null, args).then(function (response) {
                return response.text().then(function (bodyText) {
                  var patternRegexp = pattern === "*" ? /(\n|.)*/ : toRegExp(pattern);
                  var modifiedTextContent = bodyText.replace(patternRegexp, replacement);
                  var forgedResponse = forgeResponse(response, modifiedTextContent);
                  hit(source);
                  return forgedResponse;
                }).catch(function () {
                  var fetchDataStr = objectToString(fetchData);
                  var message = "Response body can't be converted to text: ".concat(fetchDataStr);
                  logMessage(source, message);
                  return Reflect.apply(target, thisArg, args);
                });
              }).catch(function () {
                return Reflect.apply(target, thisArg, args);
              });
            };
            var fetchHandler = {
              apply: handlerWrapper
            };
            fetch = new Proxy(fetch, fetchHandler);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function getFetchData(args, nativeRequestClone) {
            var fetchPropsObj = {};
            var resource = args[0];
            var fetchUrl;
            var fetchInit;
            if (resource instanceof Request) {
              var realData = nativeRequestClone.call(resource);
              var requestData = getRequestData(realData);
              fetchUrl = requestData.url;
              fetchInit = requestData;
            } else {
              fetchUrl = resource;
              fetchInit = args[1];
            }
            fetchPropsObj.url = fetchUrl;
            if (fetchInit instanceof Object) {
              var props = Object.keys(fetchInit);
              props.forEach(function (prop) {
                fetchPropsObj[prop] = fetchInit[prop];
              });
            }
            return fetchPropsObj;
          }
          function objectToString(obj) {
            if (!obj || typeof obj !== "object") {
              return String(obj);
            }
            return isEmptyObject(obj) ? "{}" : Object.entries(obj).map(function (pair) {
              var key = pair[0];
              var value = pair[1];
              var recordValueStr = value;
              if (value instanceof Object) {
                recordValueStr = "{ ".concat(objectToString(value), " }");
              }
              return "".concat(key, ':"').concat(recordValueStr, '"');
            }).join(" ");
          }
          function matchRequestProps(source, propsToMatch, requestData) {
            if (propsToMatch === "" || propsToMatch === "*") {
              return true;
            }
            var isMatched;
            var parsedData = parseMatchProps(propsToMatch);
            if (!isValidParsedData(parsedData)) {
              logMessage(source, "Invalid parameter: ".concat(propsToMatch));
              isMatched = false;
            } else {
              var matchData = getMatchPropsData(parsedData);
              var matchKeys = Object.keys(matchData);
              isMatched = matchKeys.every(function (matchKey) {
                var matchValue = matchData[matchKey];
                var dataValue = requestData[matchKey];
                return Object.prototype.hasOwnProperty.call(requestData, matchKey) && typeof dataValue === "string" && (matchValue === null || matchValue === void 0 ? void 0 : matchValue.test(dataValue));
              });
            }
            return isMatched;
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          function getRequestData(request) {
            var requestInitOptions = getRequestProps();
            var entries = requestInitOptions.map(function (key) {
              var value = request[key];
              return [key, value];
            });
            return Object.fromEntries(entries);
          }
          function getRequestProps() {
            return ["url", "method", "headers", "body", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal", "mode"];
          }
          function parseMatchProps(propsToMatchStr) {
            var PROPS_DIVIDER = " ";
            var PAIRS_MARKER = ":";
            var isRequestProp = function isRequestProp(prop) {
              return getRequestProps().includes(prop);
            };
            var propsObj = {};
            var props = propsToMatchStr.split(PROPS_DIVIDER);
            props.forEach(function (prop) {
              var dividerInd = prop.indexOf(PAIRS_MARKER);
              var key = prop.slice(0, dividerInd);
              if (isRequestProp(key)) {
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
              } else {
                propsObj.url = prop;
              }
            });
            return propsObj;
          }
          function isValidParsedData(data) {
            return Object.values(data).every(function (value) {
              return isValidStrPattern(value);
            });
          }
          function getMatchPropsData(data) {
            var matchData = {};
            var dataKeys = Object.keys(data);
            dataKeys.forEach(function (key) {
              matchData[key] = toRegExp(data[key]);
            });
            return matchData;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            trustedReplaceFetchResponse.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function trustedReplaceNodeText(source, args) {
          function trustedReplaceNodeText(source, nodeName, textMatch, pattern, replacement) {
            var uboAliases = ["replace-node-text.js", "rpnt.js", "sed.js"];
            if (uboAliases.includes(source.name)) {
              replacement = pattern;
              pattern = textMatch;
              for (var _len = arguments.length, extraArgs = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
                extraArgs[_key - 5] = arguments[_key];
              }
              for (var i = 0; i < extraArgs.length; i += 1) {
                var arg = extraArgs[i];
                if (arg === "condition") {
                  textMatch = extraArgs[i + 1];
                  break;
                }
              }
            }
            var _parseNodeTextParams = parseNodeTextParams(nodeName, textMatch, pattern),
              selector = _parseNodeTextParams.selector,
              nodeNameMatch = _parseNodeTextParams.nodeNameMatch,
              textContentMatch = _parseNodeTextParams.textContentMatch,
              patternMatch = _parseNodeTextParams.patternMatch;
            var handleNodes = function handleNodes(nodes) {
              return nodes.forEach(function (node) {
                var shouldReplace = isTargetNode(node, nodeNameMatch, textContentMatch);
                if (shouldReplace) {
                  replaceNodeText(source, node, patternMatch, replacement);
                }
              });
            };
            if (document.documentElement) {
              handleExistingNodes(selector, handleNodes);
            }
            observeDocumentWithTimeout(function (mutations) {
              return handleMutations(mutations, handleNodes);
            }, {
              childList: true,
              subtree: true
            });
          }
          function observeDocumentWithTimeout(callback, options) {
            var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e4;
            var documentObserver = new MutationObserver(function (mutations, observer) {
              observer.disconnect();
              callback(mutations, observer);
              observer.observe(document.documentElement, options);
            });
            documentObserver.observe(document.documentElement, options);
            if (typeof timeout === "number") {
              setTimeout(function () {
                return documentObserver.disconnect();
              }, timeout);
            }
          }
          function handleExistingNodes(selector, handler) {
            var nodeList = document.querySelectorAll(selector);
            var nodes = nodeListToArray(nodeList);
            handler(nodes);
          }
          function handleMutations(mutations, handler) {
            var addedNodes = getAddedNodes(mutations);
            handler(addedNodes);
          }
          function replaceNodeText(source, node, pattern, replacement) {
            var textContent = node.textContent;
            if (textContent) {
              node.textContent = textContent.replace(pattern, replacement);
              hit(source);
            }
          }
          function isTargetNode(node, nodeNameMatch, textContentMatch) {
            var nodeName = node.nodeName,
              textContent = node.textContent;
            var nodeNameLowerCase = nodeName.toLowerCase();
            return textContent !== null && textContent !== "" && (nodeNameMatch instanceof RegExp ? nodeNameMatch.test(nodeNameLowerCase) : nodeNameMatch === nodeNameLowerCase) && (textContentMatch instanceof RegExp ? textContentMatch.test(textContent) : textContent.includes(textContentMatch));
          }
          function parseNodeTextParams(nodeName, textMatch) {
            var pattern = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
            var REGEXP_START_MARKER = "/";
            var isStringNameMatch = !(nodeName.startsWith(REGEXP_START_MARKER) && nodeName.endsWith(REGEXP_START_MARKER));
            var selector = isStringNameMatch ? nodeName : "*";
            var nodeNameMatch = isStringNameMatch ? nodeName : toRegExp(nodeName);
            var textContentMatch = !textMatch.startsWith(REGEXP_START_MARKER) ? textMatch : toRegExp(textMatch);
            var patternMatch;
            if (pattern) {
              patternMatch = !pattern.startsWith(REGEXP_START_MARKER) ? pattern : toRegExp(pattern);
            }
            return {
              selector: selector,
              nodeNameMatch: nodeNameMatch,
              textContentMatch: textContentMatch,
              patternMatch: patternMatch
            };
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function nodeListToArray(nodeList) {
            var nodes = [];
            for (var i = 0; i < nodeList.length; i += 1) {
              nodes.push(nodeList[i]);
            }
            return nodes;
          }
          function getAddedNodes(mutations) {
            var nodes = [];
            for (var i = 0; i < mutations.length; i += 1) {
              var addedNodes = mutations[i].addedNodes;
              for (var j = 0; j < addedNodes.length; j += 1) {
                nodes.push(addedNodes[j]);
              }
            }
            return nodes;
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            trustedReplaceNodeText.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function trustedReplaceXhrResponse(source, args) {
          function trustedReplaceXhrResponse(source) {
            var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
            var propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
            if (typeof Proxy === "undefined") {
              return;
            }
            if (pattern === "" && replacement !== "") {
              var message = "Pattern argument should not be empty string.";
              logMessage(source, message);
              return;
            }
            var shouldLog = pattern === "" && replacement === "";
            var nativeOpen = window.XMLHttpRequest.prototype.open;
            var nativeSend = window.XMLHttpRequest.prototype.send;
            var xhrData;
            var openWrapper = function openWrapper(target, thisArg, args) {
              xhrData = getXhrData.apply(null, args);
              if (shouldLog) {
                var _message = "xhr( ".concat(objectToString(xhrData), " )");
                logMessage(source, _message, true);
                hit(source);
                return Reflect.apply(target, thisArg, args);
              }
              if (matchRequestProps(source, propsToMatch, xhrData)) {
                thisArg.shouldBePrevented = true;
                thisArg.headersReceived = !!thisArg.headersReceived;
              }
              if (thisArg.shouldBePrevented && !thisArg.headersReceived) {
                thisArg.headersReceived = true;
                thisArg.collectedHeaders = [];
                var setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
                  thisArg.collectedHeaders.push(args);
                  return Reflect.apply(target, thisArg, args);
                };
                var setRequestHeaderHandler = {
                  apply: setRequestHeaderWrapper
                };
                thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
              }
              return Reflect.apply(target, thisArg, args);
            };
            var sendWrapper = function sendWrapper(target, thisArg, args) {
              if (!thisArg.shouldBePrevented) {
                return Reflect.apply(target, thisArg, args);
              }
              var forgedRequest = new XMLHttpRequest();
              forgedRequest.addEventListener("readystatechange", function () {
                if (forgedRequest.readyState !== 4) {
                  return;
                }
                var readyState = forgedRequest.readyState,
                  response = forgedRequest.response,
                  responseText = forgedRequest.responseText,
                  responseURL = forgedRequest.responseURL,
                  responseXML = forgedRequest.responseXML,
                  status = forgedRequest.status,
                  statusText = forgedRequest.statusText;
                var content = responseText || response;
                if (typeof content !== "string") {
                  return;
                }
                var patternRegexp = pattern === "*" ? /(\n|.)*/ : toRegExp(pattern);
                var modifiedContent = content.replace(patternRegexp, replacement);
                Object.defineProperties(thisArg, {
                  readyState: {
                    value: readyState,
                    writable: false
                  },
                  responseURL: {
                    value: responseURL,
                    writable: false
                  },
                  responseXML: {
                    value: responseXML,
                    writable: false
                  },
                  status: {
                    value: status,
                    writable: false
                  },
                  statusText: {
                    value: statusText,
                    writable: false
                  },
                  response: {
                    value: modifiedContent,
                    writable: false
                  },
                  responseText: {
                    value: modifiedContent,
                    writable: false
                  }
                });
                setTimeout(function () {
                  var stateEvent = new Event("readystatechange");
                  thisArg.dispatchEvent(stateEvent);
                  var loadEvent = new Event("load");
                  thisArg.dispatchEvent(loadEvent);
                  var loadEndEvent = new Event("loadend");
                  thisArg.dispatchEvent(loadEndEvent);
                }, 1);
                hit(source);
              });
              nativeOpen.apply(forgedRequest, [xhrData.method, xhrData.url]);
              thisArg.collectedHeaders.forEach(function (header) {
                var name = header[0];
                var value = header[1];
                forgedRequest.setRequestHeader(name, value);
              });
              thisArg.collectedHeaders = [];
              try {
                nativeSend.call(forgedRequest, args);
              } catch (_unused) {
                return Reflect.apply(target, thisArg, args);
              }
              return undefined;
            };
            var openHandler = {
              apply: openWrapper
            };
            var sendHandler = {
              apply: sendWrapper
            };
            XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
            XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function objectToString(obj) {
            if (!obj || typeof obj !== "object") {
              return String(obj);
            }
            return isEmptyObject(obj) ? "{}" : Object.entries(obj).map(function (pair) {
              var key = pair[0];
              var value = pair[1];
              var recordValueStr = value;
              if (value instanceof Object) {
                recordValueStr = "{ ".concat(objectToString(value), " }");
              }
              return "".concat(key, ':"').concat(recordValueStr, '"');
            }).join(" ");
          }
          function matchRequestProps(source, propsToMatch, requestData) {
            if (propsToMatch === "" || propsToMatch === "*") {
              return true;
            }
            var isMatched;
            var parsedData = parseMatchProps(propsToMatch);
            if (!isValidParsedData(parsedData)) {
              logMessage(source, "Invalid parameter: ".concat(propsToMatch));
              isMatched = false;
            } else {
              var matchData = getMatchPropsData(parsedData);
              var matchKeys = Object.keys(matchData);
              isMatched = matchKeys.every(function (matchKey) {
                var matchValue = matchData[matchKey];
                var dataValue = requestData[matchKey];
                return Object.prototype.hasOwnProperty.call(requestData, matchKey) && typeof dataValue === "string" && (matchValue === null || matchValue === void 0 ? void 0 : matchValue.test(dataValue));
              });
            }
            return isMatched;
          }
          function getXhrData(method, url, async, user, password) {
            return {
              method: method,
              url: url,
              async: async,
              user: user,
              password: password
            };
          }
          function getMatchPropsData(data) {
            var matchData = {};
            var dataKeys = Object.keys(data);
            dataKeys.forEach(function (key) {
              matchData[key] = toRegExp(data[key]);
            });
            return matchData;
          }
          function getRequestProps() {
            return ["url", "method", "headers", "body", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal", "mode"];
          }
          function isValidParsedData(data) {
            return Object.values(data).every(function (value) {
              return isValidStrPattern(value);
            });
          }
          function parseMatchProps(propsToMatchStr) {
            var PROPS_DIVIDER = " ";
            var PAIRS_MARKER = ":";
            var isRequestProp = function isRequestProp(prop) {
              return getRequestProps().includes(prop);
            };
            var propsObj = {};
            var props = propsToMatchStr.split(PROPS_DIVIDER);
            props.forEach(function (prop) {
              var dividerInd = prop.indexOf(PAIRS_MARKER);
              var key = prop.slice(0, dividerInd);
              if (isRequestProp(key)) {
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
              } else {
                propsObj.url = prop;
              }
            });
            return propsObj;
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            trustedReplaceXhrResponse.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function trustedSetConstant(source, args) {
          function trustedSetConstant(source, property, value, stack) {
            if (!property || !matchStackTrace(stack, new Error().stack)) {
              return;
            }
            var constantValue;
            try {
              constantValue = inferValue(value);
            } catch (e) {
              logMessage(source, e);
              return;
            }
            var canceled = false;
            var mustCancel = function mustCancel(value) {
              if (canceled) {
                return canceled;
              }
              canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue && value !== null;
              return canceled;
            };
            var trapProp = function trapProp(base, prop, configurable, handler) {
              if (!handler.init(base[prop])) {
                return false;
              }
              var origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
              var prevSetter;
              if (origDescriptor instanceof Object) {
                if (!origDescriptor.configurable) {
                  var message = "Property '".concat(prop, "' is not configurable");
                  logMessage(source, message);
                  return false;
                }
                base[prop] = constantValue;
                if (origDescriptor.set instanceof Function) {
                  prevSetter = origDescriptor.set;
                }
              }
              Object.defineProperty(base, prop, {
                configurable: configurable,
                get() {
                  return handler.get();
                },
                set(a) {
                  if (prevSetter !== undefined) {
                    prevSetter(a);
                  }
                  handler.set(a);
                }
              });
              return true;
            };
            var setChainPropAccess = function setChainPropAccess(owner, property) {
              var chainInfo = getPropertyInChain(owner, property);
              var base = chainInfo.base;
              var prop = chainInfo.prop,
                chain = chainInfo.chain;
              var inChainPropHandler = {
                factValue: undefined,
                init(a) {
                  this.factValue = a;
                  return true;
                },
                get() {
                  return this.factValue;
                },
                set(a) {
                  if (this.factValue === a) {
                    return;
                  }
                  this.factValue = a;
                  if (a instanceof Object) {
                    setChainPropAccess(a, chain);
                  }
                }
              };
              var endPropHandler = {
                init(a) {
                  if (mustCancel(a)) {
                    return false;
                  }
                  return true;
                },
                get() {
                  return constantValue;
                },
                set(a) {
                  if (!mustCancel(a)) {
                    return;
                  }
                  constantValue = a;
                }
              };
              if (!chain) {
                var isTrapped = trapProp(base, prop, false, endPropHandler);
                if (isTrapped) {
                  hit(source);
                }
                return;
              }
              if (base !== undefined && base[prop] === null) {
                trapProp(base, prop, true, inChainPropHandler);
                return;
              }
              if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
                trapProp(base, prop, true, inChainPropHandler);
              }
              var propValue = owner[prop];
              if (propValue instanceof Object || typeof propValue === "object" && propValue !== null) {
                setChainPropAccess(propValue, chain);
              }
              trapProp(base, prop, true, inChainPropHandler);
            };
            setChainPropAccess(window, property);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function inferValue(value) {
            if (value === "undefined") {
              return undefined;
            }
            if (value === "false") {
              return false;
            }
            if (value === "true") {
              return true;
            }
            if (value === "null") {
              return null;
            }
            if (value === "NaN") {
              return NaN;
            }
            var MAX_ALLOWED_NUM = 32767;
            var numVal = Number(value);
            if (!nativeIsNaN(numVal)) {
              if (Math.abs(numVal) > MAX_ALLOWED_NUM) {
                throw new Error("number values bigger than 32767 are not allowed");
              }
              return numVal;
            }
            var errorMessage = "'".concat(value, "' value type can't be inferred");
            try {
              var parsableVal = JSON.parse(value);
              if (parsableVal instanceof Object || typeof parsableVal === "string") {
                return parsableVal;
              }
            } catch (e) {
              errorMessage += ": ".concat(e);
            }
            throw new TypeError(errorMessage);
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function getPropertyInChain(base, chain) {
            var pos = chain.indexOf(".");
            if (pos === -1) {
              return {
                base: base,
                prop: chain
              };
            }
            var prop = chain.slice(0, pos);
            if (base === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            var nextBase = base[prop];
            chain = chain.slice(pos + 1);
            if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase === null) {
              return {
                base: base,
                prop: prop,
                chain: chain
              };
            }
            if (nextBase !== undefined) {
              return getPropertyInChain(nextBase, chain);
            }
            Object.defineProperty(base, prop, {
              configurable: true
            });
            return {
              base: base,
              prop: prop,
              chain: chain
            };
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function matchStackTrace(stackMatch, stackTrace) {
            if (!stackMatch || stackMatch === "") {
              return true;
            }
            if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
              return true;
            }
            var stackRegexp = toRegExp(stackMatch);
            var refinedStackTrace = stackTrace.split("\n").slice(2).map(function (line) {
              return line.trim();
            }).join("\n");
            return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
          }
          function nativeIsNaN(num) {
            var native = Number.isNaN || window.isNaN;
            return native(num);
          }
          function isEmptyObject(obj) {
            return Object.keys(obj).length === 0 && !obj.prototype;
          }
          function getNativeRegexpTest() {
            var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
            var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
            if (descriptor && typeof descriptor.value === "function") {
              return nativeRegexTest;
            }
            throw new Error("RegExp.prototype.test is not a function");
          }
          function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
            var INLINE_SCRIPT_STRING = "inlineScript";
            var INJECTED_SCRIPT_STRING = "injectedScript";
            var INJECTED_SCRIPT_MARKER = "<anonymous>";
            var isInlineScript = function isInlineScript(match) {
              return match.includes(INLINE_SCRIPT_STRING);
            };
            var isInjectedScript = function isInjectedScript(match) {
              return match.includes(INJECTED_SCRIPT_STRING);
            };
            if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
              return false;
            }
            var documentURL = window.location.href;
            var pos = documentURL.indexOf("#");
            if (pos !== -1) {
              documentURL = documentURL.slice(0, pos);
            }
            var stackSteps = stackTrace.split("\n").slice(2).map(function (line) {
              return line.trim();
            });
            var stackLines = stackSteps.map(function (line) {
              var stack;
              var getStackTraceURL = /(.*?@)?(\S+)(:\d+):\d+\)?$/.exec(line);
              if (getStackTraceURL) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceURL[2];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                  stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                  var _stackFunction;
                  stackURL = INJECTED_SCRIPT_STRING;
                  var stackFunction = getStackTraceURL[1] !== undefined ? getStackTraceURL[1].slice(0, -1) : line.slice(0, getStackTraceURL.index).trim();
                  if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                    stackFunction = stackFunction.slice(2).trim();
                  }
                  stack = "".concat(stackFunction, " ").concat(stackURL).trim();
                } else {
                  stack = stackURL;
                }
              } else {
                stack = line;
              }
              return stack;
            });
            if (stackLines) {
              for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && documentURL === stackLines[index]) {
                  return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING)) {
                  return true;
                }
              }
            }
            return false;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            trustedSetConstant.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function trustedSetCookie(source, args) {
          function trustedSetCookie(source, name, value) {
            var offsetExpiresSec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
            var path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "/";
            if (typeof name === "undefined") {
              logMessage(source, "Cookie name should be specified");
              return;
            }
            if (typeof value === "undefined") {
              logMessage(source, "Cookie value should be specified");
              return;
            }
            var parsedValue = parseKeywordValue(value);
            if (!isValidCookiePath(path)) {
              logMessage(source, "Invalid cookie path: '".concat(path, "'"));
              return;
            }
            var cookieToSet = concatCookieNameValuePath(name, parsedValue, path, false);
            if (!cookieToSet) {
              logMessage(source, "Invalid cookie name or value");
              return;
            }
            if (offsetExpiresSec) {
              var parsedOffsetMs = getTrustedCookieOffsetMs(offsetExpiresSec);
              if (!parsedOffsetMs) {
                logMessage(source, "Invalid offsetExpiresSec value: ".concat(offsetExpiresSec));
                return;
              }
              var expires = Date.now() + parsedOffsetMs;
              cookieToSet += " expires=".concat(new Date(expires).toUTCString(), ";");
            }
            document.cookie = cookieToSet;
            hit(source);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function concatCookieNameValuePath(rawName, rawValue, rawPath) {
            var shouldEncode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var COOKIE_BREAKER = ";";
            if (!shouldEncode && (rawName.includes(COOKIE_BREAKER) || "".concat(rawValue).includes(COOKIE_BREAKER))) {
              return null;
            }
            var name = shouldEncode ? encodeURIComponent(rawName) : rawName;
            var value = shouldEncode ? encodeURIComponent(rawValue) : rawValue;
            return "".concat(name, "=").concat(value, "; ").concat(getCookiePath(rawPath), ";");
          }
          function isValidCookiePath(rawPath) {
            return rawPath === "/" || rawPath === "none";
          }
          function getTrustedCookieOffsetMs(offsetExpiresSec) {
            var ONE_YEAR_EXPIRATION_KEYWORD = "1year";
            var ONE_DAY_EXPIRATION_KEYWORD = "1day";
            var MS_IN_SEC = 1e3;
            var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
            var SECONDS_IN_DAY = 24 * 60 * 60;
            var parsedSec;
            if (offsetExpiresSec === ONE_YEAR_EXPIRATION_KEYWORD) {
              parsedSec = SECONDS_IN_YEAR;
            } else if (offsetExpiresSec === ONE_DAY_EXPIRATION_KEYWORD) {
              parsedSec = SECONDS_IN_DAY;
            } else {
              parsedSec = Number.parseInt(offsetExpiresSec, 10);
              if (Number.isNaN(parsedSec)) {
                return null;
              }
            }
            return parsedSec * MS_IN_SEC;
          }
          function parseKeywordValue(rawValue) {
            var NOW_VALUE_KEYWORD = "$now$";
            var CURRENT_DATE_KEYWORD = "$currentDate$";
            var parsedValue = rawValue;
            if (rawValue === NOW_VALUE_KEYWORD) {
              parsedValue = Date.now().toString();
            } else if (rawValue === CURRENT_DATE_KEYWORD) {
              parsedValue = Date();
            }
            return parsedValue;
          }
          function getCookiePath(rawPath) {
            if (rawPath === "/") {
              return "path=/";
            }
            return "";
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            trustedSetCookie.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function trustedSetCookieReload(source, args) {
          function trustedSetCookieReload(source, name, value) {
            var offsetExpiresSec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
            var path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "/";
            if (typeof name === "undefined") {
              logMessage(source, "Cookie name should be specified");
              return;
            }
            if (typeof value === "undefined") {
              logMessage(source, "Cookie value should be specified");
              return;
            }
            if (isCookieSetWithValue(document.cookie, name, value)) {
              return;
            }
            var parsedValue = parseKeywordValue(value);
            if (!isValidCookiePath(path)) {
              logMessage(source, "Invalid cookie path: '".concat(path, "'"));
              return;
            }
            var cookieToSet = concatCookieNameValuePath(name, parsedValue, path, false);
            if (!cookieToSet) {
              logMessage(source, "Invalid cookie name or value");
              return;
            }
            if (offsetExpiresSec) {
              var parsedOffsetMs = getTrustedCookieOffsetMs(offsetExpiresSec);
              if (!parsedOffsetMs) {
                logMessage(source, "Invalid offsetExpiresSec value: ".concat(offsetExpiresSec));
                return;
              }
              var expires = Date.now() + parsedOffsetMs;
              cookieToSet += " expires=".concat(new Date(expires).toUTCString(), ";");
            }
            document.cookie = cookieToSet;
            hit(source);
            var cookieValueToCheck = parseCookieString(document.cookie)[name];
            if (isCookieSetWithValue(document.cookie, name, cookieValueToCheck)) {
              window.location.reload();
            }
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function isCookieSetWithValue(cookieString, name, value) {
            return cookieString.split(";").some(function (cookieStr) {
              var pos = cookieStr.indexOf("=");
              if (pos === -1) {
                return false;
              }
              var cookieName = cookieStr.slice(0, pos).trim();
              var cookieValue = cookieStr.slice(pos + 1).trim();
              return name === cookieName && value === cookieValue;
            });
          }
          function concatCookieNameValuePath(rawName, rawValue, rawPath) {
            var shouldEncode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var COOKIE_BREAKER = ";";
            if (!shouldEncode && (rawName.includes(COOKIE_BREAKER) || "".concat(rawValue).includes(COOKIE_BREAKER))) {
              return null;
            }
            var name = shouldEncode ? encodeURIComponent(rawName) : rawName;
            var value = shouldEncode ? encodeURIComponent(rawValue) : rawValue;
            return "".concat(name, "=").concat(value, "; ").concat(getCookiePath(rawPath), ";");
          }
          function isValidCookiePath(rawPath) {
            return rawPath === "/" || rawPath === "none";
          }
          function getTrustedCookieOffsetMs(offsetExpiresSec) {
            var ONE_YEAR_EXPIRATION_KEYWORD = "1year";
            var ONE_DAY_EXPIRATION_KEYWORD = "1day";
            var MS_IN_SEC = 1e3;
            var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
            var SECONDS_IN_DAY = 24 * 60 * 60;
            var parsedSec;
            if (offsetExpiresSec === ONE_YEAR_EXPIRATION_KEYWORD) {
              parsedSec = SECONDS_IN_YEAR;
            } else if (offsetExpiresSec === ONE_DAY_EXPIRATION_KEYWORD) {
              parsedSec = SECONDS_IN_DAY;
            } else {
              parsedSec = Number.parseInt(offsetExpiresSec, 10);
              if (Number.isNaN(parsedSec)) {
                return null;
              }
            }
            return parsedSec * MS_IN_SEC;
          }
          function parseKeywordValue(rawValue) {
            var NOW_VALUE_KEYWORD = "$now$";
            var CURRENT_DATE_KEYWORD = "$currentDate$";
            var parsedValue = rawValue;
            if (rawValue === NOW_VALUE_KEYWORD) {
              parsedValue = Date.now().toString();
            } else if (rawValue === CURRENT_DATE_KEYWORD) {
              parsedValue = Date();
            }
            return parsedValue;
          }
          function parseCookieString(cookieString) {
            var COOKIE_DELIMITER = "=";
            var COOKIE_PAIRS_DELIMITER = ";";
            var cookieChunks = cookieString.split(COOKIE_PAIRS_DELIMITER);
            var cookieData = {};
            cookieChunks.forEach(function (singleCookie) {
              var cookieKey;
              var cookieValue = "";
              var delimiterIndex = singleCookie.indexOf(COOKIE_DELIMITER);
              if (delimiterIndex === -1) {
                cookieKey = singleCookie.trim();
              } else {
                cookieKey = singleCookie.slice(0, delimiterIndex).trim();
                cookieValue = singleCookie.slice(delimiterIndex + 1);
              }
              cookieData[cookieKey] = cookieValue || null;
            });
            return cookieData;
          }
          function getCookiePath(rawPath) {
            if (rawPath === "/") {
              return "path=/";
            }
            return "";
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            trustedSetCookieReload.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function trustedSetLocalStorageItem(source, args) {
          function trustedSetLocalStorageItem(source, key, value) {
            if (typeof key === "undefined") {
              logMessage(source, "Item key should be specified");
              return;
            }
            if (typeof value === "undefined") {
              logMessage(source, "Item value should be specified");
              return;
            }
            var parsedValue = parseKeywordValue(value);
            var _window = window,
              localStorage = _window.localStorage;
            setStorageItem(source, localStorage, key, parsedValue);
            hit(source);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function setStorageItem(source, storage, key, value) {
            try {
              storage.setItem(key, value);
            } catch (e) {
              var message = "Unable to set sessionStorage item due to: ".concat(e.message);
              logMessage(source, message);
            }
          }
          function parseKeywordValue(rawValue) {
            var NOW_VALUE_KEYWORD = "$now$";
            var CURRENT_DATE_KEYWORD = "$currentDate$";
            var parsedValue = rawValue;
            if (rawValue === NOW_VALUE_KEYWORD) {
              parsedValue = Date.now().toString();
            } else if (rawValue === CURRENT_DATE_KEYWORD) {
              parsedValue = Date();
            }
            return parsedValue;
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            trustedSetLocalStorageItem.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        function xmlPrune(source, args) {
          function xmlPrune(source, propsToRemove) {
            var optionalProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
            var urlToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
            if (typeof Reflect === "undefined" || typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
              return;
            }
            var shouldPruneResponse = false;
            var urlMatchRegexp = toRegExp(urlToMatch);
            var XPATH_MARKER = "xpath(";
            var isXpath = propsToRemove && propsToRemove.startsWith(XPATH_MARKER);
            var getXPathElements = function getXPathElements(contextNode) {
              var matchedElements = [];
              try {
                var elementsToRemove = propsToRemove.slice(XPATH_MARKER.length, -1);
                var xpathResult = contextNode.evaluate(elementsToRemove, contextNode, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
                for (var i = 0; i < xpathResult.snapshotLength; i += 1) {
                  matchedElements.push(xpathResult.snapshotItem(i));
                }
              } catch (ex) {
                var message = "Invalid XPath parameter: ".concat(propsToRemove, "\n").concat(ex);
                logMessage(source, message);
              }
              return matchedElements;
            };
            var xPathPruning = function xPathPruning(xPathElements) {
              xPathElements.forEach(function (element) {
                if (element.nodeType === 1) {
                  element.remove();
                } else if (element.nodeType === 2) {
                  element.ownerElement.removeAttribute(element.nodeName);
                }
              });
            };
            var isXML = function isXML(text) {
              if (typeof text === "string") {
                var trimmedText = text.trim();
                if (trimmedText.startsWith("<") && trimmedText.endsWith(">")) {
                  return true;
                }
              }
              return false;
            };
            var createXMLDocument = function createXMLDocument(text) {
              var xmlParser = new DOMParser();
              var xmlDocument = xmlParser.parseFromString(text, "text/xml");
              return xmlDocument;
            };
            var isPruningNeeded = function isPruningNeeded(response, propsToRemove) {
              if (!isXML(response)) {
                return false;
              }
              var docXML = createXMLDocument(response);
              return isXpath ? getXPathElements(docXML) : !!docXML.querySelector(propsToRemove);
            };
            var pruneXML = function pruneXML(text) {
              if (!isXML(text)) {
                shouldPruneResponse = false;
                return text;
              }
              var xmlDoc = createXMLDocument(text);
              var errorNode = xmlDoc.querySelector("parsererror");
              if (errorNode) {
                return text;
              }
              if (optionalProp !== "" && xmlDoc.querySelector(optionalProp) === null) {
                shouldPruneResponse = false;
                return text;
              }
              var elements = isXpath ? getXPathElements(xmlDoc) : xmlDoc.querySelectorAll(propsToRemove);
              if (!elements.length) {
                shouldPruneResponse = false;
                return text;
              }
              if (isXpath) {
                xPathPruning(elements);
              } else {
                elements.forEach(function (elem) {
                  elem.remove();
                });
              }
              var serializer = new XMLSerializer();
              text = serializer.serializeToString(xmlDoc);
              return text;
            };
            var nativeOpen = window.XMLHttpRequest.prototype.open;
            var nativeSend = window.XMLHttpRequest.prototype.send;
            var xhrData;
            var openWrapper = function openWrapper(target, thisArg, args) {
              xhrData = getXhrData.apply(null, args);
              if (matchRequestProps(source, urlToMatch, xhrData)) {
                thisArg.shouldBePruned = true;
              }
              if (thisArg.shouldBePruned) {
                thisArg.collectedHeaders = [];
                var setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
                  thisArg.collectedHeaders.push(args);
                  return Reflect.apply(target, thisArg, args);
                };
                var setRequestHeaderHandler = {
                  apply: setRequestHeaderWrapper
                };
                thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
              }
              return Reflect.apply(target, thisArg, args);
            };
            var sendWrapper = function sendWrapper(target, thisArg, args) {
              var allowedResponseTypeValues = ["", "text"];
              if (!thisArg.shouldBePruned || !allowedResponseTypeValues.includes(thisArg.responseType)) {
                return Reflect.apply(target, thisArg, args);
              }
              var forgedRequest = new XMLHttpRequest();
              forgedRequest.addEventListener("readystatechange", function () {
                if (forgedRequest.readyState !== 4) {
                  return;
                }
                var readyState = forgedRequest.readyState,
                  response = forgedRequest.response,
                  responseText = forgedRequest.responseText,
                  responseURL = forgedRequest.responseURL,
                  responseXML = forgedRequest.responseXML,
                  status = forgedRequest.status,
                  statusText = forgedRequest.statusText;
                var content = responseText || response;
                if (typeof content !== "string") {
                  return;
                }
                if (!propsToRemove) {
                  if (isXML(response)) {
                    var message = "XMLHttpRequest.open() URL: ".concat(responseURL, "\nresponse: ").concat(response);
                    logMessage(source, message);
                    logMessage(source, createXMLDocument(response), true, false);
                  }
                } else {
                  shouldPruneResponse = isPruningNeeded(response, propsToRemove);
                }
                var responseContent = shouldPruneResponse ? pruneXML(response) : response;
                Object.defineProperties(thisArg, {
                  readyState: {
                    value: readyState,
                    writable: false
                  },
                  responseURL: {
                    value: responseURL,
                    writable: false
                  },
                  responseXML: {
                    value: responseXML,
                    writable: false
                  },
                  status: {
                    value: status,
                    writable: false
                  },
                  statusText: {
                    value: statusText,
                    writable: false
                  },
                  response: {
                    value: responseContent,
                    writable: false
                  },
                  responseText: {
                    value: responseContent,
                    writable: false
                  }
                });
                setTimeout(function () {
                  var stateEvent = new Event("readystatechange");
                  thisArg.dispatchEvent(stateEvent);
                  var loadEvent = new Event("load");
                  thisArg.dispatchEvent(loadEvent);
                  var loadEndEvent = new Event("loadend");
                  thisArg.dispatchEvent(loadEndEvent);
                }, 1);
                hit(source);
              });
              nativeOpen.apply(forgedRequest, [xhrData.method, xhrData.url]);
              thisArg.collectedHeaders.forEach(function (header) {
                var name = header[0];
                var value = header[1];
                forgedRequest.setRequestHeader(name, value);
              });
              thisArg.collectedHeaders = [];
              try {
                nativeSend.call(forgedRequest, args);
              } catch (_unused) {
                return Reflect.apply(target, thisArg, args);
              }
              return undefined;
            };
            var openHandler = {
              apply: openWrapper
            };
            var sendHandler = {
              apply: sendWrapper
            };
            XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
            XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
            var nativeFetch = window.fetch;
            var fetchWrapper = async function fetchWrapper(target, thisArg, args) {
              var fetchURL = args[0] instanceof Request ? args[0].url : args[0];
              if (typeof fetchURL !== "string" || fetchURL.length === 0) {
                return Reflect.apply(target, thisArg, args);
              }
              if (urlMatchRegexp.test(fetchURL)) {
                var response = await nativeFetch(...args);
                var clonedResponse = response.clone();
                var responseText = await response.text();
                shouldPruneResponse = isPruningNeeded(responseText, propsToRemove);
                if (!shouldPruneResponse) {
                  var message = "fetch URL: ".concat(fetchURL, "\nresponse text: ").concat(responseText);
                  logMessage(source, message);
                  logMessage(source, createXMLDocument(responseText), true, false);
                  return clonedResponse;
                }
                var prunedText = pruneXML(responseText);
                if (shouldPruneResponse) {
                  hit(source);
                  return new Response(prunedText, {
                    status: response.status,
                    statusText: response.statusText,
                    headers: response.headers
                  });
                }
                return clonedResponse;
              }
              return Reflect.apply(target, thisArg, args);
            };
            var fetchHandler = {
              apply: fetchWrapper
            };
            window.fetch = new Proxy(window.fetch, fetchHandler);
          }
          function hit(source) {
            if (source.verbose !== true) {
              return;
            }
            try {
              var log = console.log.bind(console);
              var trace = console.trace.bind(console);
              var prefix = source.ruleText || "";
              if (source.domainName) {
                var AG_SCRIPTLET_MARKER = "#%#//";
                var UBO_SCRIPTLET_MARKER = "##+js";
                var ruleStartIndex;
                if (source.ruleText.includes(AG_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
                } else if (source.ruleText.includes(UBO_SCRIPTLET_MARKER)) {
                  ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
                }
                var rulePart = source.ruleText.slice(ruleStartIndex);
                prefix = "".concat(source.domainName).concat(rulePart);
              }
              log("".concat(prefix, " trace start"));
              if (trace) {
                trace();
              }
              log("".concat(prefix, " trace end"));
            } catch (e) {}
            if (typeof window.__debug === "function") {
              window.__debug(source);
            }
          }
          function logMessage(source, message) {
            var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var name = source.name,
              verbose = source.verbose;
            if (!forced && !verbose) {
              return;
            }
            var nativeConsole = console.log;
            if (!convertMessageToString) {
              nativeConsole("".concat(name, ":"), message);
              return;
            }
            nativeConsole("".concat(name, ": ").concat(message));
          }
          function toRegExp() {
            var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var DEFAULT_VALUE = ".?";
            var FORWARD_SLASH = "/";
            if (input === "") {
              return new RegExp(DEFAULT_VALUE);
            }
            var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
            var flagsPart = input.substring(delimiterIndex + 1);
            var regExpPart = input.substring(0, delimiterIndex + 1);
            var isValidRegExpFlag = function isValidRegExpFlag(flag) {
              if (!flag) {
                return false;
              }
              try {
                new RegExp("", flag);
                return true;
              } catch (ex) {
                return false;
              }
            };
            var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
              if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
              }
              return "";
            };
            var flags = getRegExpFlags(regExpPart, flagsPart);
            if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
              var regExpInput = flags ? regExpPart : input;
              return new RegExp(regExpInput.slice(1, -1), flags);
            }
            var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return new RegExp(escaped);
          }
          function getXhrData(method, url, async, user, password) {
            return {
              method: method,
              url: url,
              async: async,
              user: user,
              password: password
            };
          }
          function matchRequestProps(source, propsToMatch, requestData) {
            if (propsToMatch === "" || propsToMatch === "*") {
              return true;
            }
            var isMatched;
            var parsedData = parseMatchProps(propsToMatch);
            if (!isValidParsedData(parsedData)) {
              logMessage(source, "Invalid parameter: ".concat(propsToMatch));
              isMatched = false;
            } else {
              var matchData = getMatchPropsData(parsedData);
              var matchKeys = Object.keys(matchData);
              isMatched = matchKeys.every(function (matchKey) {
                var matchValue = matchData[matchKey];
                var dataValue = requestData[matchKey];
                return Object.prototype.hasOwnProperty.call(requestData, matchKey) && typeof dataValue === "string" && (matchValue === null || matchValue === void 0 ? void 0 : matchValue.test(dataValue));
              });
            }
            return isMatched;
          }
          function getMatchPropsData(data) {
            var matchData = {};
            var dataKeys = Object.keys(data);
            dataKeys.forEach(function (key) {
              matchData[key] = toRegExp(data[key]);
            });
            return matchData;
          }
          function getRequestProps() {
            return ["url", "method", "headers", "body", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal", "mode"];
          }
          function isValidParsedData(data) {
            return Object.values(data).every(function (value) {
              return isValidStrPattern(value);
            });
          }
          function parseMatchProps(propsToMatchStr) {
            var PROPS_DIVIDER = " ";
            var PAIRS_MARKER = ":";
            var isRequestProp = function isRequestProp(prop) {
              return getRequestProps().includes(prop);
            };
            var propsObj = {};
            var props = propsToMatchStr.split(PROPS_DIVIDER);
            props.forEach(function (prop) {
              var dividerInd = prop.indexOf(PAIRS_MARKER);
              var key = prop.slice(0, dividerInd);
              if (isRequestProp(key)) {
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
              } else {
                propsObj.url = prop;
              }
            });
            return propsObj;
          }
          function isValidStrPattern(input) {
            var FORWARD_SLASH = "/";
            var str = escapeRegExp(input);
            if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
              str = input.slice(1, -1);
            }
            var isValid;
            try {
              isValid = new RegExp(str);
              isValid = true;
            } catch (e) {
              isValid = false;
            }
            return isValid;
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          var updatedArgs = args ? [].concat(source).concat(args) : [source];
          try {
            xmlPrune.apply(this, updatedArgs);
          } catch (e) {
            console.log(e);
          }
        }
        var scriptletsMap = {
          "abort-current-inline-script": abortCurrentInlineScript,
          "abort-current-script.js": abortCurrentInlineScript,
          "ubo-abort-current-script.js": abortCurrentInlineScript,
          "acs.js": abortCurrentInlineScript,
          "ubo-acs.js": abortCurrentInlineScript,
          "ubo-abort-current-script": abortCurrentInlineScript,
          "ubo-acs": abortCurrentInlineScript,
          "abort-current-inline-script.js": abortCurrentInlineScript,
          "ubo-abort-current-inline-script.js": abortCurrentInlineScript,
          "acis.js": abortCurrentInlineScript,
          "ubo-acis.js": abortCurrentInlineScript,
          "ubo-abort-current-inline-script": abortCurrentInlineScript,
          "ubo-acis": abortCurrentInlineScript,
          "abp-abort-current-inline-script": abortCurrentInlineScript,
          "abort-on-property-read": abortOnPropertyRead,
          "abort-on-property-read.js": abortOnPropertyRead,
          "ubo-abort-on-property-read.js": abortOnPropertyRead,
          "aopr.js": abortOnPropertyRead,
          "ubo-aopr.js": abortOnPropertyRead,
          "ubo-abort-on-property-read": abortOnPropertyRead,
          "ubo-aopr": abortOnPropertyRead,
          "abp-abort-on-property-read": abortOnPropertyRead,
          "abort-on-property-write": abortOnPropertyWrite,
          "abort-on-property-write.js": abortOnPropertyWrite,
          "ubo-abort-on-property-write.js": abortOnPropertyWrite,
          "aopw.js": abortOnPropertyWrite,
          "ubo-aopw.js": abortOnPropertyWrite,
          "ubo-abort-on-property-write": abortOnPropertyWrite,
          "ubo-aopw": abortOnPropertyWrite,
          "abp-abort-on-property-write": abortOnPropertyWrite,
          "abort-on-stack-trace": abortOnStackTrace,
          "abort-on-stack-trace.js": abortOnStackTrace,
          "ubo-abort-on-stack-trace.js": abortOnStackTrace,
          "aost.js": abortOnStackTrace,
          "ubo-aost.js": abortOnStackTrace,
          "ubo-abort-on-stack-trace": abortOnStackTrace,
          "ubo-aost": abortOnStackTrace,
          "abp-abort-on-stack-trace": abortOnStackTrace,
          "adjust-setInterval": adjustSetInterval,
          "nano-setInterval-booster.js": adjustSetInterval,
          "ubo-nano-setInterval-booster.js": adjustSetInterval,
          "nano-sib.js": adjustSetInterval,
          "ubo-nano-sib.js": adjustSetInterval,
          "adjust-setInterval.js": adjustSetInterval,
          "ubo-adjust-setInterval.js": adjustSetInterval,
          "ubo-nano-setInterval-booster": adjustSetInterval,
          "ubo-nano-sib": adjustSetInterval,
          "ubo-adjust-setInterval": adjustSetInterval,
          "adjust-setTimeout": adjustSetTimeout,
          "adjust-setTimeout.js": adjustSetTimeout,
          "ubo-adjust-setTimeout.js": adjustSetTimeout,
          "nano-setTimeout-booster.js": adjustSetTimeout,
          "ubo-nano-setTimeout-booster.js": adjustSetTimeout,
          "nano-stb.js": adjustSetTimeout,
          "ubo-nano-stb.js": adjustSetTimeout,
          "ubo-adjust-setTimeout": adjustSetTimeout,
          "ubo-nano-setTimeout-booster": adjustSetTimeout,
          "ubo-nano-stb": adjustSetTimeout,
          "debug-current-inline-script": debugCurrentInlineScript,
          "debug-on-property-read": debugOnPropertyRead,
          "debug-on-property-write": debugOnPropertyWrite,
          "dir-string": dirString,
          "disable-newtab-links": disableNewtabLinks,
          "disable-newtab-links.js": disableNewtabLinks,
          "ubo-disable-newtab-links.js": disableNewtabLinks,
          "ubo-disable-newtab-links": disableNewtabLinks,
          "evaldata-prune": evalDataPrune,
          "evaldata-prune.js": evalDataPrune,
          "ubo-evaldata-prune.js": evalDataPrune,
          "ubo-evaldata-prune": evalDataPrune,
          "close-window": forceWindowClose,
          "window-close-if.js": forceWindowClose,
          "ubo-window-close-if.js": forceWindowClose,
          "ubo-window-close-if": forceWindowClose,
          "close-window.js": forceWindowClose,
          "ubo-close-window.js": forceWindowClose,
          "ubo-close-window": forceWindowClose,
          "hide-in-shadow-dom": hideInShadowDom,
          "inject-css-in-shadow-dom": injectCssInShadowDom,
          "json-prune": jsonPrune,
          "json-prune.js": jsonPrune,
          "ubo-json-prune.js": jsonPrune,
          "ubo-json-prune": jsonPrune,
          "abp-json-prune": jsonPrune,
          log: log,
          "abp-log": log,
          "log-addEventListener": logAddEventListener,
          "addEventListener-logger.js": logAddEventListener,
          "ubo-addEventListener-logger.js": logAddEventListener,
          "aell.js": logAddEventListener,
          "ubo-aell.js": logAddEventListener,
          "ubo-addEventListener-logger": logAddEventListener,
          "ubo-aell": logAddEventListener,
          "log-eval": logEval,
          "log-on-stack-trace": logOnStacktrace,
          "m3u-prune": m3uPrune,
          "m3u-prune.js": m3uPrune,
          "ubo-m3u-prune.js": m3uPrune,
          "ubo-m3u-prune": m3uPrune,
          "no-topics": noTopics,
          noeval: noeval,
          "noeval.js": noeval,
          "silent-noeval.js": noeval,
          "ubo-noeval.js": noeval,
          "ubo-silent-noeval.js": noeval,
          "ubo-noeval": noeval,
          "ubo-silent-noeval": noeval,
          nowebrtc: nowebrtc,
          "nowebrtc.js": nowebrtc,
          "ubo-nowebrtc.js": nowebrtc,
          "ubo-nowebrtc": nowebrtc,
          "prevent-addEventListener": preventAddEventListener,
          "addEventListener-defuser.js": preventAddEventListener,
          "ubo-addEventListener-defuser.js": preventAddEventListener,
          "aeld.js": preventAddEventListener,
          "ubo-aeld.js": preventAddEventListener,
          "ubo-addEventListener-defuser": preventAddEventListener,
          "ubo-aeld": preventAddEventListener,
          "abp-prevent-listener": preventAddEventListener,
          "prevent-adfly": preventAdfly,
          "adfly-defuser.js": preventAdfly,
          "ubo-adfly-defuser.js": preventAdfly,
          "ubo-adfly-defuser": preventAdfly,
          "prevent-bab": preventBab,
          "prevent-element-src-loading": preventElementSrcLoading,
          "prevent-eval-if": preventEvalIf,
          "noeval-if.js": preventEvalIf,
          "ubo-noeval-if.js": preventEvalIf,
          "ubo-noeval-if": preventEvalIf,
          "prevent-fab-3.2.0": preventFab,
          "nofab.js": preventFab,
          "ubo-nofab.js": preventFab,
          "fuckadblock.js-3.2.0": preventFab,
          "ubo-fuckadblock.js-3.2.0": preventFab,
          "ubo-nofab": preventFab,
          "prevent-fetch": preventFetch,
          "no-fetch-if.js": preventFetch,
          "ubo-no-fetch-if.js": preventFetch,
          "ubo-no-fetch-if": preventFetch,
          "prevent-popads-net": preventPopadsNet,
          "popads.net.js": preventPopadsNet,
          "ubo-popads.net.js": preventPopadsNet,
          "ubo-popads.net": preventPopadsNet,
          "prevent-refresh": preventRefresh,
          "prevent-refresh.js": preventRefresh,
          "refresh-defuser.js": preventRefresh,
          "refresh-defuser": preventRefresh,
          "ubo-prevent-refresh.js": preventRefresh,
          "ubo-prevent-refresh": preventRefresh,
          "ubo-refresh-defuser.js": preventRefresh,
          "ubo-refresh-defuser": preventRefresh,
          "prevent-requestAnimationFrame": preventRequestAnimationFrame,
          "no-requestAnimationFrame-if.js": preventRequestAnimationFrame,
          "ubo-no-requestAnimationFrame-if.js": preventRequestAnimationFrame,
          "norafif.js": preventRequestAnimationFrame,
          "ubo-norafif.js": preventRequestAnimationFrame,
          "ubo-no-requestAnimationFrame-if": preventRequestAnimationFrame,
          "ubo-norafif": preventRequestAnimationFrame,
          "prevent-setInterval": preventSetInterval,
          "no-setInterval-if.js": preventSetInterval,
          "ubo-no-setInterval-if.js": preventSetInterval,
          "setInterval-defuser.js": preventSetInterval,
          "ubo-setInterval-defuser.js": preventSetInterval,
          "nosiif.js": preventSetInterval,
          "ubo-nosiif.js": preventSetInterval,
          "sid.js": preventSetInterval,
          "ubo-sid.js": preventSetInterval,
          "ubo-no-setInterval-if": preventSetInterval,
          "ubo-setInterval-defuser": preventSetInterval,
          "ubo-nosiif": preventSetInterval,
          "ubo-sid": preventSetInterval,
          "prevent-setTimeout": preventSetTimeout,
          "no-setTimeout-if.js": preventSetTimeout,
          "ubo-no-setTimeout-if.js": preventSetTimeout,
          "nostif.js": preventSetTimeout,
          "ubo-nostif.js": preventSetTimeout,
          "ubo-no-setTimeout-if": preventSetTimeout,
          "ubo-nostif": preventSetTimeout,
          "setTimeout-defuser.js": preventSetTimeout,
          "ubo-setTimeout-defuser.js": preventSetTimeout,
          "ubo-setTimeout-defuser": preventSetTimeout,
          "std.js": preventSetTimeout,
          "ubo-std.js": preventSetTimeout,
          "ubo-std": preventSetTimeout,
          "prevent-window-open": preventWindowOpen,
          "window.open-defuser.js": preventWindowOpen,
          "ubo-window.open-defuser.js": preventWindowOpen,
          "ubo-window.open-defuser": preventWindowOpen,
          "nowoif.js": preventWindowOpen,
          "ubo-nowoif.js": preventWindowOpen,
          "ubo-nowoif": preventWindowOpen,
          "no-window-open-if.js": preventWindowOpen,
          "ubo-no-window-open-if.js": preventWindowOpen,
          "ubo-no-window-open-if": preventWindowOpen,
          "prevent-xhr": preventXHR,
          "no-xhr-if.js": preventXHR,
          "ubo-no-xhr-if.js": preventXHR,
          "ubo-no-xhr-if": preventXHR,
          "remove-attr": removeAttr,
          "remove-attr.js": removeAttr,
          "ubo-remove-attr.js": removeAttr,
          "ra.js": removeAttr,
          "ubo-ra.js": removeAttr,
          "ubo-remove-attr": removeAttr,
          "ubo-ra": removeAttr,
          "remove-class": removeClass,
          "remove-class.js": removeClass,
          "ubo-remove-class.js": removeClass,
          "rc.js": removeClass,
          "ubo-rc.js": removeClass,
          "ubo-remove-class": removeClass,
          "ubo-rc": removeClass,
          "remove-cookie": removeCookie,
          "cookie-remover.js": removeCookie,
          "ubo-cookie-remover.js": removeCookie,
          "ubo-cookie-remover": removeCookie,
          "remove-cookie.js": removeCookie,
          "ubo-remove-cookie.js": removeCookie,
          "ubo-remove-cookie": removeCookie,
          "abp-cookie-remover": removeCookie,
          "remove-in-shadow-dom": removeInShadowDom,
          "remove-node-text": removeNodeText,
          "remove-node-text.js": removeNodeText,
          "ubo-remove-node-text.js": removeNodeText,
          "rmnt.js": removeNodeText,
          "ubo-rmnt.js": removeNodeText,
          "ubo-remove-node-text": removeNodeText,
          "ubo-rmnt": removeNodeText,
          "set-attr": setAttr,
          "set-attr.js": setAttr,
          "ubo-set-attr.js": setAttr,
          "ubo-set-attr": setAttr,
          "set-constant": setConstant,
          "set-constant.js": setConstant,
          "ubo-set-constant.js": setConstant,
          "set.js": setConstant,
          "ubo-set.js": setConstant,
          "ubo-set-constant": setConstant,
          "ubo-set": setConstant,
          "abp-override-property-read": setConstant,
          "set-cookie": setCookie,
          "set-cookie.js": setCookie,
          "ubo-set-cookie.js": setCookie,
          "ubo-set-cookie": setCookie,
          "set-cookie-reload": setCookieReload,
          "set-local-storage-item": setLocalStorageItem,
          "set-local-storage-item.js": setLocalStorageItem,
          "ubo-set-local-storage-item.js": setLocalStorageItem,
          "ubo-set-local-storage-item": setLocalStorageItem,
          "set-popads-dummy": setPopadsDummy,
          "popads-dummy.js": setPopadsDummy,
          "ubo-popads-dummy.js": setPopadsDummy,
          "ubo-popads-dummy": setPopadsDummy,
          "set-session-storage-item": setSessionStorageItem,
          "set-session-storage-item.js": setSessionStorageItem,
          "ubo-set-session-storage-item.js": setSessionStorageItem,
          "ubo-set-session-storage-item": setSessionStorageItem,
          "trusted-click-element": trustedClickElement,
          "trusted-prune-inbound-object": trustedPruneInboundObject,
          "trusted-replace-fetch-response": trustedReplaceFetchResponse,
          "trusted-replace-node-text": trustedReplaceNodeText,
          "trusted-replace-xhr-response": trustedReplaceXhrResponse,
          "trusted-set-constant": trustedSetConstant,
          "trusted-set-cookie": trustedSetCookie,
          "trusted-set-cookie-reload": trustedSetCookieReload,
          "trusted-set-local-storage-item": trustedSetLocalStorageItem,
          "xml-prune": xmlPrune,
          "xml-prune.js": xmlPrune,
          "ubo-xml-prune.js": xmlPrune,
          "ubo-xml-prune": xmlPrune
        };
        var getScriptletFunction = function getScriptletFunction(name) {
          return scriptletsMap[name];
        };
        function getScriptletCode(source) {
          if (!validator.isValidScriptletName(source.name)) {
            return null;
          }
          var scriptletFunction = getScriptletFunction(source.name);
          if (typeof scriptletFunction !== 'function') {
            throw new Error("Error: cannot invoke scriptlet with name: '".concat(source.name, "'"));
          }
          var scriptletFunctionString = scriptletFunction.toString();
          var result = source.engine === 'corelibs' || source.engine === 'test' ? wrapInNonameFunc(scriptletFunctionString) : passSourceAndProps(source, scriptletFunctionString);
          return result;
        }
        var scriptletsObject = function () {
          return {
            invoke: getScriptletCode,
            getScriptletFunction,
            isValidScriptletName: validator.isValidScriptletName,
            isValidScriptletRule,
            isAdgScriptletRule: validator.isAdgScriptletRule,
            isUboScriptletRule: validator.isUboScriptletRule,
            isAbpSnippetRule: validator.isAbpSnippetRule,
            convertUboToAdg: convertUboScriptletToAdg,
            convertAbpToAdg: convertAbpSnippetToAdg,
            convertScriptletToAdg,
            convertAdgToUbo: convertAdgScriptletToUbo,
            redirects,
            SCRIPTLETS_VERSION: version
          };
        }();
        scriptlets_umd.exports = scriptletsObject;
    }));

    var NETWORK_RULE_OPTIONS = {
        THIRD_PARTY: 'third-party',
        FIRST_PARTY: 'first-party',
        MATCH_CASE: 'match-case',
        IMPORTANT: 'important',
        DOMAIN: 'domain',
        DENYALLOW: 'denyallow',
        ELEMHIDE: 'elemhide',
        GENERICHIDE: 'generichide',
        SPECIFICHIDE: 'specifichide',
        GENERICBLOCK: 'genericblock',
        JSINJECT: 'jsinject',
        URLBLOCK: 'urlblock',
        CONTENT: 'content',
        DOCUMENT: 'document',
        DOC: 'doc',
        STEALTH: 'stealth',
        POPUP: 'popup',
        EMPTY: 'empty',
        MP4: 'mp4',
        SCRIPT: 'script',
        STYLESHEET: 'stylesheet',
        SUBDOCUMENT: 'subdocument',
        OBJECT: 'object',
        IMAGE: 'image',
        XMLHTTPREQUEST: 'xmlhttprequest',
        MEDIA: 'media',
        FONT: 'font',
        WEBSOCKET: 'websocket',
        OTHER: 'other',
        PING: 'ping',
        BADFILTER: 'badfilter',
        CSP: 'csp',
        REPLACE: 'replace',
        COOKIE: 'cookie',
        REDIRECT: 'redirect',
        REDIRECTRULE: 'redirect-rule',
        REMOVEPARAM: 'removeparam',
        REMOVEHEADER: 'removeheader',
        JSONPRUNE: 'jsonprune',
        HLS: 'hls',
        REFERRERPOLICY: 'referrerpolicy',
        APP: 'app',
        NETWORK: 'network',
        EXTENSION: 'extension',
        NOOP: '_',
        CLIENT: 'client',
        DNSREWRITE: 'dnsrewrite',
        DNSTYPE: 'dnstype',
        CTAG: 'ctag',
        METHOD: 'method',
        TO: 'to',
        PERMISSIONS: 'permissions',
        ALL: 'all',
    };
    var OPTIONS_DELIMITER = '$';
    var MASK_ALLOWLIST = '@@';
    var NOT_MARK = '~';
    var ESCAPE_CHARACTER = '\\';

    /**
     * Redirect modifier class
     */
    var RedirectModifier = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param value
         * @param ruleText
         * @param isAllowlist
         * @param isRedirectingOnlyBlocked is redirect-rule modifier
         */
        function RedirectModifier(value, ruleText, isAllowlist, isRedirectingOnlyBlocked) {
            if (isRedirectingOnlyBlocked === void 0) { isRedirectingOnlyBlocked = false; }
            /**
             * Is redirecting only blocked requests
             * See $redirect-rule options
             */
            this.isRedirectingOnlyBlocked = false;
            RedirectModifier.validate(ruleText, value, isAllowlist);
            this.redirectTitle = value;
            this.isRedirectingOnlyBlocked = isRedirectingOnlyBlocked;
        }
        /**
         * Redirect title
         */
        RedirectModifier.prototype.getValue = function () {
            return this.redirectTitle;
        };
        /**
         * Validates redirect rule
         *
         * @param ruleText
         * @param redirectTitle
         * @param isAllowlist
         */
        RedirectModifier.validate = function (ruleText, redirectTitle, isAllowlist) {
            if (isAllowlist && !redirectTitle) {
                return;
            }
            if (!redirectTitle) {
                throw new SyntaxError('Invalid $redirect rule, redirect value must not be empty');
            }
            var redirects = scriptlets_umd.exports.redirects;
            var ruleTextToValidate = ruleText.replace(NETWORK_RULE_OPTIONS.REDIRECTRULE, NETWORK_RULE_OPTIONS.REDIRECT);
            if (!redirects.isAdgRedirectRule(ruleTextToValidate) || !redirects.isValidAdgRedirectRule(ruleTextToValidate)) {
                throw new SyntaxError('$redirect modifier is invalid');
            }
        };
        return RedirectModifier;
    }());

    /**
     * Splits url into parts
     *
     * @param url
     */
    function splitUrl(url) {
        var strippedUrl = url;
        var hash = '';
        var hashIndex = url.indexOf('#');
        if (hashIndex >= 0) {
            hash = url.slice(hashIndex);
            strippedUrl = url.slice(0, hashIndex);
        }
        var query = '';
        var queryIndex = url.indexOf('?');
        if (queryIndex >= 0) {
            query = strippedUrl.slice(queryIndex + 1);
            strippedUrl = strippedUrl.slice(0, queryIndex);
        }
        return {
            path: strippedUrl,
            query: query,
            hash: hash,
        };
    }
    /**
     * Normalizes url query parameters
     *
     * @param query
     */
    function normalizeQuery(query) {
        // Cleanup empty params (p0=0&=2&=3)
        var result = query
            .split('&')
            .filter(function (x) { return x && !x.startsWith('='); })
            .join('&');
        // If we've collapsed the URL to the point where there's an '&' against the '?'
        // then we need to get rid of that.
        while (result.charAt(0) === '&') {
            result = result.substr(1);
        }
        return result;
    }
    /**
     * Removes query params from url by regexp
     *
     * @param url
     * @param regExp
     * @param invert remove every parameter in url except the ones matched regexp
     */
    function cleanUrlParamByRegExp(url, regExp, invert) {
        if (invert === void 0) { invert = false; }
        var searchIndex = url.indexOf('?');
        // If no params, nothing to modify
        if (searchIndex === -1) {
            return url;
        }
        var split = splitUrl(url);
        var modifiedQuery;
        if (invert) {
            modifiedQuery = split.query
                .split('&')
                .filter(function (x) { return x; })
                .filter(function (x) { return x && x.match(regExp); })
                .join('&');
        }
        else {
            modifiedQuery = split.query
                .split('&')
                .filter(function (x) {
                var test = x.includes('=') ? x : "".concat(x, "=");
                return !test.match(regExp);
            })
                .join('&');
        }
        // Do not normalize if regexp is not applied
        if (modifiedQuery === split.query) {
            return url;
        }
        modifiedQuery = normalizeQuery(modifiedQuery);
        var result = split.path;
        if (modifiedQuery) {
            result += "?".concat(modifiedQuery);
        }
        return result + split.hash;
    }
    var DOMAIN_REGEX = /^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9](?:\.[a-zA-Z]{2,})+$/;
    /**
     * Check if the string could be a domain name
     *
     * @param text
     */
    var isDomainName = function (text) {
        if (text.indexOf('.') < 0 || text.endsWith('.')) {
            return false;
        }
        return DOMAIN_REGEX.test(text);
    };
    /**
     * Extract relative part from hierarchical structured URL
     * @param url
     */
    var getRelativeUrl = function (url) {
        var i = url.indexOf('/', url.indexOf('://') + 3);
        return i !== -1 ? url.substr(i) : null;
    };

    /**
     * Query parameters filtering modifier class
     * Works with '$removeparam' modifier
     */
    var RemoveParamModifier = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param value
         */
        function RemoveParamModifier(value) {
            /**
             * Is modifier valid for MV3 or not
             */
            this.mv3Valid = true;
            this.value = value;
            var rawValue = value;
            // TODO: Seems like negation not using in valueRegExp
            if (value.startsWith('~')) {
                rawValue = value.substring(1);
                this.mv3Valid = false;
            }
            if (rawValue.startsWith('/')) {
                this.valueRegExp = SimpleRegex.patternFromString(rawValue);
                this.mv3Valid = false;
            }
            else {
                if (rawValue.includes('|')) {
                    throw new Error('Unsupported option in $removeparam: multiple values are not allowed');
                }
                this.valueRegExp = new RegExp("((^|&)(".concat(SimpleRegex.escapeRegexSpecials(rawValue), ")=[^&#]*)"), 'g');
            }
        }
        /**
         * Modifier value
         */
        RemoveParamModifier.prototype.getValue = function () {
            return this.value;
        };
        /**
         * Is modifier valid for MV3 or not
         */
        RemoveParamModifier.prototype.getMV3Validity = function () {
            return this.mv3Valid;
        };
        /**
         * Removes query parameters from url
         *
         * @param url
         */
        RemoveParamModifier.prototype.removeParameters = function (url) {
            var sepIndex = url.indexOf('?');
            if (sepIndex < 0) {
                return url;
            }
            if (!this.value) {
                return url.substring(0, sepIndex);
            }
            if (sepIndex === url.length - 1) {
                return url;
            }
            if (this.value.startsWith('~')) {
                return cleanUrlParamByRegExp(url, this.valueRegExp, true);
            }
            return cleanUrlParamByRegExp(url, this.valueRegExp);
        };
        return RemoveParamModifier;
    }());

    /**
     * Headers filtering modifier class.
     * Rules with $removeheader modifier are intended to remove headers from HTTP requests and responses.
     */
    var RemoveHeaderModifier = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param value
         * @param isAllowlist
         */
        function RemoveHeaderModifier(value, isAllowlist) {
            this.value = value.toLowerCase();
            if (!isAllowlist && !this.value) {
                throw new SyntaxError('Invalid $removeheader rule, removeheader value must not be empty');
            }
            this.isRequestModifier = this.value.startsWith(RemoveHeaderModifier.REQUEST_PREFIX);
            var headerName = this.isRequestModifier
                ? this.value.substring(RemoveHeaderModifier.REQUEST_PREFIX.length)
                : this.value;
            // Values with ":" are not supported in MV3 declarative rules, e.g. "$removeheader=dnt:1"
            this.valid = RemoveHeaderModifier.isAllowedHeader(headerName) && !headerName.includes(':');
            this.applicableHeaderName = this.valid ? headerName : null;
        }
        /**
         * Modifier value
         */
        RemoveHeaderModifier.prototype.getValue = function () {
            return this.value;
        };
        Object.defineProperty(RemoveHeaderModifier.prototype, "isValid", {
            /**
             * Modifier validity
             */
            get: function () {
                return this.valid;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns effective header name to be removed
         *
         * @param isRequestHeaders
         */
        RemoveHeaderModifier.prototype.getApplicableHeaderName = function (isRequestHeaders) {
            if (!this.applicableHeaderName) {
                return null;
            }
            if (isRequestHeaders !== this.isRequestModifier) {
                return null;
            }
            return this.applicableHeaderName;
        };
        /**
         * Some headers are forbidden to remove
         *
         * @param headerName
         */
        RemoveHeaderModifier.isAllowedHeader = function (headerName) {
            return !this.FORBIDDEN_HEADERS.includes(headerName);
        };
        /**
         * List of forbidden headers
         */
        RemoveHeaderModifier.FORBIDDEN_HEADERS = [
            'access-control-allow-origin',
            'access-control-allow-credentials',
            'access-control-allow-headers',
            'access-control-allow-methods',
            'access-control-expose-headers',
            'access-control-max-age',
            'access-control-request-headers',
            'access-control-request-method',
            'origin',
            'timing-allow-origin',
            'allow',
            'cross-origin-embedder-policy',
            'cross-origin-opener-policy',
            'cross-origin-resource-policy',
            'content-security-policy',
            'content-security-policy-report-only',
            'expect-ct',
            'feature-policy',
            'origin-isolation',
            'strict-transport-security',
            'upgrade-insecure-requests',
            'x-content-type-options',
            'x-download-options',
            'x-frame-options',
            'x-permitted-cross-domain-policies',
            'x-powered-by',
            'x-xss-protection',
            'public-key-pins',
            'public-key-pins-report-only',
            'sec-websocket-key',
            'sec-websocket-extensions',
            'sec-websocket-accept',
            'sec-websocket-protocol',
            'sec-websocket-version',
            'p3p',
            'sec-fetch-mode',
            'sec-fetch-dest',
            'sec-fetch-site',
            'sec-fetch-user',
            'referrer-policy',
            'content-type',
            'content-length',
            'accept',
            'accept-encoding',
            'host',
            'connection',
            'transfer-encoding',
            'upgrade',
        ];
        /**
         * Request prefix
         */
        RemoveHeaderModifier.REQUEST_PREFIX = 'request:';
        return RemoveHeaderModifier;
    }());

    var ErrorStatusCodes;
    (function (ErrorStatusCodes) {
        ErrorStatusCodes[ErrorStatusCodes["ComplexRegex"] = 1001] = "ComplexRegex";
        ErrorStatusCodes[ErrorStatusCodes["RuleLimit"] = 1002] = "RuleLimit";
        ErrorStatusCodes[ErrorStatusCodes["RegexpRuleLimit"] = 1003] = "RegexpRuleLimit";
        ErrorStatusCodes[ErrorStatusCodes["RemoveparamRegexpIsNotSupported"] = 1004] = "RemoveparamRegexpIsNotSupported";
        ErrorStatusCodes[ErrorStatusCodes["RemoveparamInversionIsNotSupported"] = 1005] = "RemoveparamInversionIsNotSupported";
    })(ErrorStatusCodes || (ErrorStatusCodes = {}));
    var SEPARATOR = '|';

    /**
     * This is a helper class that is used specifically to work with app restrictions.
     *
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
     *
     * Examples:
     * ||baddomain.com^$app=org.example.app
     * ||baddomain.com^$app=org.example.app1|org.example.app2
     */
    var AppModifier = /** @class */ (function () {
        /**
         * Parses the `apps` string
         *
         * @param apps - apps string
         *
         * @throws an error if the app string is empty or invalid
         */
        function AppModifier(apps) {
            if (!apps) {
                throw new SyntaxError('$app modifier cannot be empty');
            }
            var permittedApps = [];
            var restrictedApps = [];
            var parts = apps.split(SEPARATOR);
            for (var i = 0; i < parts.length; i += 1) {
                var app = parts[i];
                var restricted = false;
                if (app.startsWith('~')) {
                    restricted = true;
                    app = app.substring(1).trim();
                }
                if (app === '') {
                    throw new SyntaxError("Empty app specified in \"".concat(apps, "\""));
                }
                if (restricted) {
                    restrictedApps.push(app);
                }
                else {
                    permittedApps.push(app);
                }
            }
            this.restrictedApps = restrictedApps.length > 0 ? restrictedApps : null;
            this.permittedApps = permittedApps.length > 0 ? permittedApps : null;
        }
        return AppModifier;
    }());

    exports.HTTPMethod = void 0;
    (function (HTTPMethod) {
        HTTPMethod["GET"] = "GET";
        HTTPMethod["POST"] = "POST";
        HTTPMethod["PUT"] = "PUT";
        HTTPMethod["DELETE"] = "DELETE";
        HTTPMethod["PATCH"] = "PATCH";
        HTTPMethod["HEAD"] = "HEAD";
        HTTPMethod["OPTIONS"] = "OPTIONS";
        HTTPMethod["CONNECT"] = "CONNECT";
        HTTPMethod["TRACE"] = "TRACE";
    })(exports.HTTPMethod || (exports.HTTPMethod = {}));
    /**
     * Method modifier class.
     * Rules with $method modifier will be applied only to requests with specified methods.
     *
     * Learn more about it here:
     * https://adguard.com/kb/general/ad-filtering/create-own-filters/#method-modifier
     */
    var MethodModifier = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param value
         */
        function MethodModifier(methodsStr) {
            if (methodsStr === '') {
                throw new SyntaxError('$method modifier value cannot be empty');
            }
            var permittedMethods = [];
            var restrictedMethods = [];
            var parts = methodsStr.toUpperCase().split(MethodModifier.PIPE_SEPARATOR);
            for (var i = 0; i < parts.length; i += 1) {
                var method = parts[i].trim();
                var restricted = false;
                if (method.startsWith('~')) {
                    restricted = true;
                    method = method.substring(1);
                }
                if (!MethodModifier.isHTTPMethod(method)) {
                    throw new SyntaxError("Invalid $method modifier value: ".concat(method));
                }
                if (restricted) {
                    restrictedMethods.push(method);
                }
                else {
                    permittedMethods.push(method);
                }
            }
            if (restrictedMethods.length > 0 && permittedMethods.length > 0) {
                throw new SyntaxError("Negated values cannot be mixed with non-negated values: ".concat(methodsStr));
            }
            this.restrictedValues = restrictedMethods.length > 0 ? restrictedMethods : null;
            this.permittedValues = permittedMethods.length > 0 ? permittedMethods : null;
        }
        /**
         * Request methods separator
         */
        MethodModifier.PIPE_SEPARATOR = '|';
        MethodModifier.isHTTPMethod = function (value) { return value in exports.HTTPMethod; };
        return MethodModifier;
    }());

    /**
     * To modifier class.
     * Rules with $to modifier are limited to requests made to the specified domains and their subdomains.
     *
     * Learn more about it here:
     * https://adguard.com/kb/general/ad-filtering/create-own-filters/#to-modifier
     */
    var ToModifier = /** @class */ (function () {
        /**
         * Constructor
         */
        function ToModifier(domainsStr) {
            if (!domainsStr) {
                throw new SyntaxError('$to modifier value cannot be empty');
            }
            var permittedDomains = [];
            var restrictedDomains = [];
            var parts = domainsStr.toLowerCase().split(ToModifier.PIPE_SEPARATOR);
            for (var i = 0; i < parts.length; i += 1) {
                var domain = parts[i].trim();
                var restricted = false;
                if (domain.startsWith('~')) {
                    restricted = true;
                    domain = domain.substring(1);
                }
                if (domain === '') {
                    throw new SyntaxError("Empty domain specified in \"".concat(domainsStr, "\""));
                }
                if (restricted) {
                    restrictedDomains.push(domain);
                }
                else {
                    permittedDomains.push(domain);
                }
            }
            this.restrictedValues = restrictedDomains.length > 0 ? restrictedDomains : null;
            this.permittedValues = permittedDomains.length > 0 ? permittedDomains : null;
        }
        /**
         * Domains separator
         */
        ToModifier.PIPE_SEPARATOR = '|';
        return ToModifier;
    }());

    /**
     * Checks if error has message.
     *
     * @param error Error object.
     * @returns If param is error.
     */
    function isErrorWithMessage(error) {
        return (typeof error === 'object'
            && error !== null
            && 'message' in error
            && typeof error.message === 'string');
    }
    /**
     * Converts error to the error with message.
     *
     * @param maybeError Possible error.
     * @returns Error with message.
     */
    function toErrorWithMessage(maybeError) {
        if (isErrorWithMessage(maybeError)) {
            return maybeError;
        }
        try {
            return new Error(JSON.stringify(maybeError));
        }
        catch (_a) {
            // fallback in case there's an error stringifying the maybeError
            // like with circular references for example.
            return new Error(String(maybeError));
        }
    }
    /**
     * Converts error object to error with message. This method might be helpful to handle thrown errors.
     *
     * @param error Error object.
     *
     * @returns Message of the error.
     */
    function getErrorMessage(error) {
        return toErrorWithMessage(error).message;
    }

    /**
     * RequestType is the request types enumeration.
     * Important: the enumeration is marked as const to avoid side effects when
     * importing it into an extension.
     */
    var RequestType = {
        /** No value is set. Syntax sugar to simplify code. */
        NotSet: 0,
        /** main frame */
        Document: 1,
        /** (iframe) $subdocument */
        SubDocument: 2,
        /** (javascript, etc) $script */
        Script: 4,
        /** (css) $stylesheet */
        Stylesheet: 8,
        /** (flash, etc) $object */
        Object: 16,
        /** (any image) $image */
        Image: 32,
        /** (ajax/fetch) $xmlhttprequest */
        XmlHttpRequest: 64,
        /** (video/music) $media */
        Media: 128,
        /** (any custom font) $font */
        Font: 256,
        /** (a websocket connection) $websocket */
        WebSocket: 512,
        /** (navigator.sendBeacon()) $ping */
        Ping: 1024,
        /** csp_report */
        CspReport: 2048,
        /** any other request type */
        Other: 4096, // 1 << 12
    };

    var isCidr$1 = {exports: {}};

    var cidrRegex$1 = {exports: {}};

    const word$2 = '[a-fA-F\\d:]';
    const b = options => options && options.includeBoundaries ?
    	`(?:(?<=\\s|^)(?=${word$2})|(?<=${word$2})(?=\\s|$))` :
    	'';
    const v4$3 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';
    const v6seg = '[a-fA-F\\d]{1,4}';
    const v6$3 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4$3}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4$3}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4$3}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4$3}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4$3}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4$3}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4$3}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim();
    const v46Exact$2 = new RegExp(`(?:^${v4$3}$)|(?:^${v6$3}$)`);
    const v4exact$4 = new RegExp(`^${v4$3}$`);
    const v6exact$4 = new RegExp(`^${v6$3}$`);
    const ip = options => options && options.exact ?
    	v46Exact$2 :
    	new RegExp(`(?:${b(options)}${v4$3}${b(options)})|(?:${b(options)}${v6$3}${b(options)})`, 'g');
    ip.v4 = options => options && options.exact ? v4exact$4 : new RegExp(`${b(options)}${v4$3}${b(options)}`, 'g');
    ip.v6 = options => options && options.exact ? v6exact$4 : new RegExp(`${b(options)}${v6$3}${b(options)}`, 'g');
    var ipRegex$4 = ip;

    const ipRegex$3 = ipRegex$4;
    const defaultOpts$1 = {exact: false};
    const v4str$1 = `${ipRegex$3.v4().source}\\/(3[0-2]|[12]?[0-9])`;
    const v6str$1 = `${ipRegex$3.v6().source}\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])`;
    const v4exact$3 = new RegExp(`^${v4str$1}$`);
    const v6exact$3 = new RegExp(`^${v6str$1}$`);
    const v46exact$1 = new RegExp(`(?:^${v4str$1}$)|(?:^${v6str$1}$)`);
    cidrRegex$1.exports = ({exact} = defaultOpts$1) => exact ? v46exact$1 : new RegExp(`(?:${v4str$1})|(?:${v6str$1})`, "g");
    cidrRegex$1.exports.v4 = ({exact} = defaultOpts$1) => exact ? v4exact$3 : new RegExp(v4str$1, "g");
    cidrRegex$1.exports.v6 = ({exact} = defaultOpts$1) => exact ? v6exact$3 : new RegExp(v6str$1, "g");

    const {v4: v4$2, v6: v6$2} = cidrRegex$1.exports;
    const re4 = v4$2({exact: true});
    const re6 = v6$2({exact: true});
    isCidr$1.exports = str => re4.test(str) ? 4 : (re6.test(str) ? 6 : 0);
    isCidr$1.exports.v4 = str => re4.test(str);
    isCidr$1.exports.v6 = str => re6.test(str);

    const ipRegex$2 = ipRegex$4;
    const isIp = string => ipRegex$2({exact: true}).test(string);
    isIp.v4 = string => ipRegex$2.v4({exact: true}).test(string);
    isIp.v6 = string => ipRegex$2.v6({exact: true}).test(string);
    isIp.version = string => isIp(string) ? (isIp.v4(string) ? 4 : 6) : undefined;
    var isIp_1 = isIp;

    const word$1 = '[a-fA-F\\d:]';
    const boundry$1 = options => options && options.includeBoundaries
    	? `(?:(?<=\\s|^)(?=${word$1})|(?<=${word$1})(?=\\s|$))`
    	: '';
    const v4$1 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';
    const v6segment$1 = '[a-fA-F\\d]{1,4}';
    const v6$1 = `
(?:
(?:${v6segment$1}:){7}(?:${v6segment$1}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment$1}:){6}(?:${v4$1}|:${v6segment$1}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment$1}:){5}(?::${v4$1}|(?::${v6segment$1}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment$1}:){4}(?:(?::${v6segment$1}){0,1}:${v4$1}|(?::${v6segment$1}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment$1}:){3}(?:(?::${v6segment$1}){0,2}:${v4$1}|(?::${v6segment$1}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment$1}:){2}(?:(?::${v6segment$1}){0,3}:${v4$1}|(?::${v6segment$1}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment$1}:){1}(?:(?::${v6segment$1}){0,4}:${v4$1}|(?::${v6segment$1}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment$1}){0,5}:${v4$1}|(?::${v6segment$1}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim();
    const v46Exact$1 = new RegExp(`(?:^${v4$1}$)|(?:^${v6$1}$)`);
    const v4exact$2 = new RegExp(`^${v4$1}$`);
    const v6exact$2 = new RegExp(`^${v6$1}$`);
    const ipRegex$1 = options => options && options.exact
    	? v46Exact$1
    	: new RegExp(`(?:${boundry$1(options)}${v4$1}${boundry$1(options)})|(?:${boundry$1(options)}${v6$1}${boundry$1(options)})`, 'g');
    ipRegex$1.v4 = options => options && options.exact ? v4exact$2 : new RegExp(`${boundry$1(options)}${v4$1}${boundry$1(options)}`, 'g');
    ipRegex$1.v6 = options => options && options.exact ? v6exact$2 : new RegExp(`${boundry$1(options)}${v6$1}${boundry$1(options)}`, 'g');

    const word = '[a-fA-F\\d:]';
    const boundry = options => options && options.includeBoundaries
    	? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))`
    	: '';
    const v4 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';
    const v6segment = '[a-fA-F\\d]{1,4}';
    const v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim();
    const v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
    const v4exact$1 = new RegExp(`^${v4}$`);
    const v6exact$1 = new RegExp(`^${v6}$`);
    const ipRegex = options => options && options.exact
    	? v46Exact
    	: new RegExp(`(?:${boundry(options)}${v4}${boundry(options)})|(?:${boundry(options)}${v6}${boundry(options)})`, 'g');
    ipRegex.v4 = options => options && options.exact ? v4exact$1 : new RegExp(`${boundry(options)}${v4}${boundry(options)}`, 'g');
    ipRegex.v6 = options => options && options.exact ? v6exact$1 : new RegExp(`${boundry(options)}${v6}${boundry(options)}`, 'g');

    const defaultOpts = {exact: false};
    const v4str = `${ipRegex.v4().source}\\/(3[0-2]|[12]?[0-9])`;
    const v6str = `${ipRegex.v6().source}\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])`;
    const v4exact = new RegExp(`^${v4str}$`);
    const v6exact = new RegExp(`^${v6str}$`);
    const v46exact = new RegExp(`(?:^${v4str}$)|(?:^${v6str}$)`);
    const cidrRegex = ({exact} = defaultOpts) => exact ? v46exact : new RegExp(`(?:${v4str})|(?:${v6str})`, "g");
    cidrRegex.v4 = ({exact} = defaultOpts) => exact ? v4exact : new RegExp(v4str, "g");
    cidrRegex.v6 = ({exact} = defaultOpts) => exact ? v6exact : new RegExp(v6str, "g");

    function parseIp(ip) {
      const version = ip.includes(":") ? 6 : ip.includes(".") ? 4 : 0;
      if (!version) throw new Error(`Invalid IP address: ${ip}`);
      let number = 0n;
      let exp = 0n;
      const res = Object.create(null);
      if (version === 4) {
        for (const n of ip.split(".").map(BigInt).reverse()) {
          number += n * (2n ** exp);
          exp += 8n;
        }
      } else {
        if (ip.includes(".")) {
          res.ipv4mapped = true;
          ip = ip.split(":").map(part => {
            if (part.includes(".")) {
              const digits = part.split(".").map(str => Number(str).toString(16).padStart(2, "0"));
              return `${digits[0]}${digits[1]}:${digits[2]}${digits[3]}`;
            } else {
              return part;
            }
          }).join(":");
        }
        if (ip.includes("%")) {
          let scopeid;
          [, ip, scopeid] = /(.+)%(.+)/.exec(ip);
          res.scopeid = scopeid;
        }
        const parts = ip.split(":");
        const index = parts.indexOf("");
        if (index !== -1) {
          while (parts.length < 8) {
            parts.splice(index, 0, "");
          }
        }
        for (const n of parts.map(part => BigInt(parseInt(part || 0, 16))).reverse()) {
          number += n * (2n ** exp);
          exp += 16n;
        }
      }
      res.number = number;
      res.version = version;
      return res;
    }

    const bits = {
      "v4": 32,
      "v6": 128,
    };
    const uniq = arr => Array.from(new Set(arr));
    function isIP(ip) {
      if (ipRegex$1.v4({exact: true}).test(ip)) return 4;
      if (ipRegex$1.v6({exact: true}).test(ip)) return 6;
      return 0;
    }
    function isCidr(ip) {
      if (cidrRegex.v4({exact: true}).test(ip)) return 4;
      if (cidrRegex.v6({exact: true}).test(ip)) return 6;
      return 0;
    }
    function parse(str) {
      const cidrVersion = isCidr(str);
      const parsed = Object.create(null);
      parsed.single = false;
      if (cidrVersion) {
        parsed.cidr = str;
        parsed.version = cidrVersion;
      } else {
        const version = isIP(str);
        if (version) {
          parsed.cidr = `${str}/${bits[`v${version}`]}`;
          parsed.version = version;
          parsed.single = true;
        } else {
          throw new Error(`Network is not a CIDR or IP: ${str}`);
        }
      }
      const [ip, prefix] = parsed.cidr.split("/");
      parsed.prefix = prefix;
      const {number, version} = parseIp(ip);
      const numBits = bits[`v${version}`];
      const ipBits = number.toString(2).padStart(numBits, "0");
      const prefixLen = Number(numBits - prefix);
      const startBits = ipBits.substring(0, numBits - prefixLen);
      parsed.start = BigInt(`0b${startBits}${"0".repeat(prefixLen)}`);
      parsed.end = BigInt(`0b${startBits}${"1".repeat(prefixLen)}`);
      return parsed;
    }
    function netContains(a, b) {
      if (b.start < a.start) return false;
      if (b.end > a.end) return false;
      return true;
    }
    function contains(a, b) {
      const aNets = uniq(Array.isArray(a) ? a : [a]);
      const bNets = uniq(Array.isArray(b) ? b : [b]);
      const numExpected = bNets.length;
      let numFound = 0;
      for (const a of aNets) {
        const aParsed = parse(a);
        for (const b of bNets) {
          const bParsed = parse(b);
          if (aParsed.version !== bParsed.version) {
            continue;
          }
          if (netContains(aParsed, bParsed)) {
            numFound++;
            continue;
          }
        }
      }
      return numFound === numExpected;
    }

    /**
     * This is the base class representing double values modifiers
     */
    var BaseValuesModifier = /** @class */ (function () {
        /**
         * Parses the values string
         *
         * @param values - values string
         *
         * @throws an error if the string is empty or invalid
         */
        function BaseValuesModifier(values) {
            if (!values) {
                throw new SyntaxError('Modifier cannot be empty');
            }
            this.value = values;
            var permittedValues = [];
            var restrictedValues = [];
            var parts = values.split(SEPARATOR);
            for (var i = 0; i < parts.length; i += 1) {
                var app = parts[i];
                var restricted = false;
                if (app.startsWith('~')) {
                    restricted = true;
                    app = app.substring(1).trim();
                }
                if (app === '') {
                    throw new SyntaxError("Empty values specified in \"".concat(values, "\""));
                }
                if (restricted) {
                    restrictedValues.push(app);
                }
                else {
                    permittedValues.push(app);
                }
            }
            this.restricted = restrictedValues.length > 0 ? restrictedValues : null;
            this.permitted = permittedValues.length > 0 ? permittedValues : null;
        }
        BaseValuesModifier.prototype.getPermitted = function () {
            return this.permitted;
        };
        BaseValuesModifier.prototype.getRestricted = function () {
            return this.restricted;
        };
        BaseValuesModifier.prototype.getValue = function () {
            return this.value;
        };
        BaseValuesModifier.prototype.match = function (value) {
            if (!this.restricted && !this.permitted) {
                return true;
            }
            if (this.restricted && this.restricted.includes(value)) {
                return false;
            }
            if (this.permitted) {
                return this.permitted.includes(value);
            }
            return true;
        };
        return BaseValuesModifier;
    }());

    /**
     * Netmasks class
     */
    var NetmasksCollection = /** @class */ (function () {
        function NetmasksCollection() {
            this.ipv4Masks = [];
            this.ipv6Masks = [];
        }
        /**
         * Returns true if any of the containing masks contains provided value
         *
         * @param value
         */
        NetmasksCollection.prototype.contains = function (value) {
            if (isIp_1.v4(value)) {
                return this.ipv4Masks.some(function (x) { return contains(x, value); });
            }
            return this.ipv6Masks.some(function (x) { return contains(x, value); });
        };
        return NetmasksCollection;
    }());
    /**
     * The client modifier allows specifying clients this rule will be working for.
     * It accepts client names (not ClientIDs), IP addresses, or CIDR ranges.
     */
    var ClientModifier = /** @class */ (function (_super) {
        __extends(ClientModifier, _super);
        /**
         * Constructor
         *
         * @param value
         */
        function ClientModifier(value) {
            var _this = _super.call(this, value) || this;
            var permitted = _this.getPermitted();
            if (permitted) {
                _this.permitted = ClientModifier.stripValues(permitted);
                _this.permittedNetmasks = ClientModifier.parseNetmasks(_this.permitted);
            }
            var restricted = _this.getRestricted();
            if (restricted) {
                _this.restricted = ClientModifier.stripValues(restricted);
                _this.restrictedNetmasks = ClientModifier.parseNetmasks(_this.restricted);
            }
            return _this;
        }
        /**
         * Unquotes and unescapes string
         *
         * @param values
         */
        ClientModifier.stripValues = function (values) {
            return values.map(function (v) {
                if ((v.startsWith('"') && v.endsWith('"'))
                    || (v.startsWith('\'') && v.endsWith('\''))) {
                    // eslint-disable-next-line no-param-reassign
                    v = v.substr(1, v.length - 2);
                }
                return v.replace(/\\/ig, '');
            });
        };
        /**
         * Checks if this modifier matches provided params
         *
         * @param clientName
         * @param clientIP
         */
        ClientModifier.prototype.matchAny = function (clientName, clientIP) {
            if (this.restricted) {
                if (clientName && this.restricted.includes(clientName)) {
                    return false;
                }
                if (clientIP && this.restricted.includes(clientIP)) {
                    return false;
                }
                return true;
            }
            if (this.restrictedNetmasks) {
                if (clientIP && this.restrictedNetmasks.contains(clientIP)) {
                    return false;
                }
                return true;
            }
            if (this.permitted) {
                if (clientName && this.permitted.includes(clientName)) {
                    return true;
                }
                if (clientIP && this.permitted.includes(clientIP)) {
                    return true;
                }
            }
            if (this.permittedNetmasks) {
                if (clientIP && this.permittedNetmasks.contains(clientIP)) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Parses netmasks from client's strings
         *
         * @param values
         */
        ClientModifier.parseNetmasks = function (values) {
            var result = new NetmasksCollection();
            values.forEach(function (x) {
                var cidrVersion = isCidr$1.exports(x);
                if (cidrVersion === 4) {
                    result.ipv4Masks.push(x);
                }
                else if (cidrVersion === 6) {
                    result.ipv6Masks.push(x);
                }
            });
            return result;
        };
        return ClientModifier;
    }(BaseValuesModifier));

    /**
     * The dnsrewrite response modifier allows replacing the content of the response
     * to the DNS request for the matching hosts.
     *
     * TODO: This modifier is not yet implemented
     * https://github.com/AdguardTeam/AdGuardHome/wiki/Hosts-Blocklists#dnsrewrite
     */
    var DnsRewriteModifier = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param value
         */
        function DnsRewriteModifier(value) {
            this.value = value;
        }
        /**
         * Modifier value
         */
        DnsRewriteModifier.prototype.getValue = function () {
            return this.value;
        };
        return DnsRewriteModifier;
    }());

    /**
     * The dnstype modifier allows specifying DNS request type on which this rule will be triggered.
     */
    var DnsTypeModifier = /** @class */ (function (_super) {
        __extends(DnsTypeModifier, _super);
        /**
         * Constructor
         *
         * @param value
         */
        function DnsTypeModifier(value) {
            var _this = _super.call(this, value) || this;
            if (_this.permitted) {
                _this.restricted = null;
            }
            return _this;
        }
        return DnsTypeModifier;
    }(BaseValuesModifier));

    /**
     * The ctag modifier allows to block domains only for specific types of DNS client tags.
     */
    var CtagModifier = /** @class */ (function (_super) {
        __extends(CtagModifier, _super);
        /**
         * Constructor
         *
         * @param value
         */
        function CtagModifier(value) {
            var _this = _super.call(this, value) || this;
            _this.validate();
            return _this;
        }
        /**
         * Validates tag values
         */
        CtagModifier.prototype.validate = function () {
            if (!this.getValue()) {
                throw new Error('Invalid rule: Ctag modifier must not be empty');
            }
            var tags = this.permitted ? this.permitted : this.restricted;
            if (tags && tags.some(function (x) { return !CtagModifier.ALLOWED_TAGS.includes(x); })) {
                throw new Error('Invalid rule: Invalid ctag modifier');
            }
        };
        /**
         * The list of allowed tags
         */
        CtagModifier.ALLOWED_TAGS = [
            // By device type:
            'device_audio',
            'device_camera',
            'device_gameconsole',
            'device_laptop',
            'device_nas',
            'device_pc',
            'device_phone',
            'device_printer',
            'device_securityalarm',
            'device_tablet',
            'device_tv',
            'device_other',
            // By operating system:
            'os_android',
            'os_ios',
            'os_linux',
            'os_macos',
            'os_windows',
            'os_other',
            // By user group:
            'user_admin',
            'user_regular',
            'user_child',
        ];
        return CtagModifier;
    }(BaseValuesModifier));

    /**
     * Rule pattern class
     *
     * This class parses rule pattern text to simple fields.
     */
    var Pattern = /** @class */ (function () {
        /**
         * Constructor
         * @param pattern
         * @param matchcase
         */
        function Pattern(pattern, matchcase) {
            if (matchcase === void 0) { matchcase = false; }
            this.pattern = pattern;
            this.shortcut = SimpleRegex.extractShortcut(this.pattern);
            this.matchcase = matchcase;
        }
        /**
         * Checks if this rule pattern matches the specified request.
         *
         * @param request - request to check
         * @param shortcutMatched if true, it means that the request already matches
         * this pattern's shortcut and we don't need to match it again.
         * @returns true if pattern matches
         */
        Pattern.prototype.matchPattern = function (request, shortcutMatched) {
            this.prepare();
            if (this.patternShortcut) {
                return shortcutMatched || this.matchShortcut(request.urlLowercase);
            }
            if (this.hostname) {
                // If we have a `||example.org^` rule, it's easier to match
                // against the request's hostname only without matching
                // a regular expression.
                return request.hostname === this.hostname
                    || ( // First light check without new string memory allocation
                    request.hostname.endsWith(this.hostname)
                        // Strict check
                        && request.hostname.endsWith(".".concat(this.hostname)));
            }
            // If the regular expression is invalid, just return false right away.
            if (this.regexInvalid || !this.regex) {
                return false;
            }
            // This is needed for DNS filtering only, not used in browser blocking.
            if (this.shouldMatchHostname(request)) {
                return this.regex.test(request.hostname);
            }
            return this.regex.test(request.url);
        };
        /**
         * Checks if this rule pattern matches the specified relative path string.
         * This method is used in cosmetic rules to implement the $path modifier matching logic.
         *
         * @param path - path to check
         * @returns true if pattern matches
         */
        Pattern.prototype.matchPathPattern = function (path) {
            this.prepare();
            if (this.hostname) {
                return false;
            }
            var pathIsEmptyString = this.pattern === '';
            // No-value $path should match root URL
            if (pathIsEmptyString && path === '/') {
                return true;
            }
            if (!pathIsEmptyString && this.patternShortcut) {
                return this.matchShortcut(path);
            }
            // If the regular expression is invalid, just return false right away.
            if (this.regexInvalid || !this.regex) {
                return false;
            }
            return this.regex.test(path);
        };
        /**
         * matchShortcut simply checks if shortcut is a substring of the URL.
         * @param request - request to check.
         */
        Pattern.prototype.matchShortcut = function (str) {
            return str.indexOf(this.shortcut) >= 0;
        };
        /**
         * Prepares this pattern
         */
        Pattern.prototype.prepare = function () {
            if (this.prepared) {
                return;
            }
            this.prepared = true;
            // If shortcut and pattern are the same, we don't need to actually compile
            // a regex and can simply use matchShortcut instead,
            // except for the $match-case modifier
            if (this.pattern === this.shortcut && !this.matchcase) {
                this.patternShortcut = true;
                return;
            }
            // Rules like `/example/*` are rather often in the real-life filters,
            // we might want to process them.
            if (this.pattern.startsWith(this.shortcut)
                && this.pattern.length === this.shortcut.length + 1
                && this.pattern.endsWith('*')) {
                this.patternShortcut = true;
                return;
            }
            if (this.pattern.startsWith(SimpleRegex.MASK_START_URL)
                && this.pattern.endsWith(SimpleRegex.MASK_SEPARATOR)
                && this.pattern.indexOf('*') < 0
                && this.pattern.indexOf('/') < 0) {
                this.hostname = this.pattern.slice(2, this.pattern.length - 1);
                return;
            }
            this.compileRegex();
        };
        /**
         * Compiles this pattern regex
         */
        Pattern.prototype.compileRegex = function () {
            var regexText = SimpleRegex.patternToRegexp(this.pattern);
            try {
                var flags = 'i';
                if (this.matchcase) {
                    flags = '';
                }
                this.regex = new RegExp(regexText, flags);
            }
            catch (e) {
                this.regexInvalid = true;
            }
        };
        /**
         * Checks if we should match hostnames and not the URL
         * this is important for the cases when we use urlfilter for DNS-level blocking
         * Note, that even though we may work on a DNS-level, we should still sometimes match full URL instead
         *
         * @param request
         */
        Pattern.prototype.shouldMatchHostname = function (request) {
            if (!request.isHostnameRequest) {
                return false;
            }
            return !this.isPatternDomainSpecific();
        };
        /**
         * In case pattern starts with the following it targets some specific domain
         */
        Pattern.prototype.isPatternDomainSpecific = function () {
            if (this.patternDomainSpecific === undefined) {
                this.patternDomainSpecific = this.pattern.startsWith(SimpleRegex.MASK_START_URL)
                    || this.pattern.startsWith('http://')
                    || this.pattern.startsWith('https:/')
                    || this.pattern.startsWith('://');
            }
            return this.patternDomainSpecific;
        };
        return Pattern;
    }());

    /**
     * Counts the number of bits in the number and returns it
     *
     * @param a number to count bits
     *
     * @returns The number of bits in the number.
     */
    function getBitCount(a) {
        var count = 0;
        var n = a;
        while (n > 0) {
            count += n & 1;
            n >>= 1;
        }
        return count;
    }
    /**
     * Count the number of bits enabled in a number based on a bit mask
     *
     * @param base Base number to check
     * @param mask Mask to check
     *
     * @returns The number of bits enabled in the base number based on the mask
     *
     * @example
     * countEnabledBits(0b100, 0b110); // 1
     * countEnabledBits(0b111, 0b000); // 0
     */
    function countEnabledBits(base, mask) {
        // Get the common bits between the base and the mask
        var common = base & mask;
        // Count the number of bits enabled in the common bits
        return getBitCount(common);
    }

    /**
     * NetworkRuleOption is the enumeration of various rule options.
     * In order to save memory, we store some options as a flag.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#modifiers
     */
    exports.NetworkRuleOption = void 0;
    (function (NetworkRuleOption) {
        /** No value is set. Syntax sugar to simplify code. */
        NetworkRuleOption[NetworkRuleOption["NotSet"] = 0] = "NotSet";
        /** $third-party modifier */
        NetworkRuleOption[NetworkRuleOption["ThirdParty"] = 1] = "ThirdParty";
        /** $match-case modifier */
        NetworkRuleOption[NetworkRuleOption["MatchCase"] = 2] = "MatchCase";
        /** $important modifier */
        NetworkRuleOption[NetworkRuleOption["Important"] = 4] = "Important";
        // Allowlist rules modifiers
        // Each of them can disable part of the functionality
        /** $elemhide modifier */
        NetworkRuleOption[NetworkRuleOption["Elemhide"] = 8] = "Elemhide";
        /** $generichide modifier */
        NetworkRuleOption[NetworkRuleOption["Generichide"] = 16] = "Generichide";
        /** $specifichide modifier */
        NetworkRuleOption[NetworkRuleOption["Specifichide"] = 32] = "Specifichide";
        /** $genericblock modifier */
        NetworkRuleOption[NetworkRuleOption["Genericblock"] = 64] = "Genericblock";
        /** $jsinject modifier */
        NetworkRuleOption[NetworkRuleOption["Jsinject"] = 128] = "Jsinject";
        /** $urlblock modifier */
        NetworkRuleOption[NetworkRuleOption["Urlblock"] = 256] = "Urlblock";
        /** $content modifier */
        NetworkRuleOption[NetworkRuleOption["Content"] = 512] = "Content";
        /** $extension modifier */
        NetworkRuleOption[NetworkRuleOption["Extension"] = 1024] = "Extension";
        /** $stealth modifier */
        NetworkRuleOption[NetworkRuleOption["Stealth"] = 2048] = "Stealth";
        // Other modifiers
        /** $popup modifier */
        NetworkRuleOption[NetworkRuleOption["Popup"] = 4096] = "Popup";
        /** $csp modifier */
        NetworkRuleOption[NetworkRuleOption["Csp"] = 8192] = "Csp";
        /** $replace modifier */
        NetworkRuleOption[NetworkRuleOption["Replace"] = 16384] = "Replace";
        /** $cookie modifier */
        NetworkRuleOption[NetworkRuleOption["Cookie"] = 32768] = "Cookie";
        /** $redirect modifier */
        NetworkRuleOption[NetworkRuleOption["Redirect"] = 65536] = "Redirect";
        /** $badfilter modifier */
        NetworkRuleOption[NetworkRuleOption["Badfilter"] = 131072] = "Badfilter";
        /** $removeparam modifier */
        NetworkRuleOption[NetworkRuleOption["RemoveParam"] = 262144] = "RemoveParam";
        /** $removeheader modifier */
        NetworkRuleOption[NetworkRuleOption["RemoveHeader"] = 524288] = "RemoveHeader";
        /** $jsonprune modifier */
        NetworkRuleOption[NetworkRuleOption["JsonPrune"] = 1048576] = "JsonPrune";
        /** $hls modifier */
        NetworkRuleOption[NetworkRuleOption["Hls"] = 2097152] = "Hls";
        // Compatibility dependent
        /** $network modifier */
        NetworkRuleOption[NetworkRuleOption["Network"] = 4194304] = "Network";
        /** dns modifiers */
        NetworkRuleOption[NetworkRuleOption["Client"] = 8388608] = "Client";
        NetworkRuleOption[NetworkRuleOption["DnsRewrite"] = 16777216] = "DnsRewrite";
        NetworkRuleOption[NetworkRuleOption["DnsType"] = 33554432] = "DnsType";
        NetworkRuleOption[NetworkRuleOption["Ctag"] = 67108864] = "Ctag";
        /* $method modifier */
        NetworkRuleOption[NetworkRuleOption["Method"] = 134217728] = "Method";
        /* $to modifier */
        NetworkRuleOption[NetworkRuleOption["To"] = 268435456] = "To";
        /* $permissions modifier */
        NetworkRuleOption[NetworkRuleOption["Permissions"] = 536870912] = "Permissions";
        // Groups (for validation)
        /** Allowlist-only modifiers */
        NetworkRuleOption[NetworkRuleOption["AllowlistOnly"] = 4088] = "AllowlistOnly";
        /** Options supported by host-level network rules * */
        NetworkRuleOption[NetworkRuleOption["OptionHostLevelRules"] = 125960196] = "OptionHostLevelRules";
        /**
         * Removeparam compatible modifiers
         *
         * $removeparam rules are compatible only with content type modifiers ($subdocument, $script, $stylesheet, etc)
         * except $document (using by default) and this list of modifiers:
         */
        NetworkRuleOption[NetworkRuleOption["RemoveParamCompatibleOptions"] = 393223] = "RemoveParamCompatibleOptions";
        /**
         * Removeheader compatible modifiers
         *
         * $removeheader rules are compatible only with content type modifiers ($subdocument, $script, $stylesheet, etc)
         * except $document (using by default) and this list of modifiers:
         */
        NetworkRuleOption[NetworkRuleOption["RemoveHeaderCompatibleOptions"] = 655367] = "RemoveHeaderCompatibleOptions";
    })(exports.NetworkRuleOption || (exports.NetworkRuleOption = {}));
    /**
     * Helper class that is used for passing {@link NetworkRule.parseRuleText}
     * result to the caller. Should not be used outside of this file.
     */
    var BasicRuleParts = /** @class */ (function () {
        function BasicRuleParts() {
        }
        return BasicRuleParts;
    }());
    /**
     * Basic network filtering rule.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules
     */
    var NetworkRule = /** @class */ (function () {
        /**
         * Creates an instance of the {@link NetworkRule}.
         * It parses this rule and extracts the rule pattern (see {@link SimpleRegex}),
         * and rule modifiers.
         *
         * @param ruleText - original rule text.
         * @param filterListId - ID of the filter list this rule belongs to.
         *
         * @throws error if it fails to parse the rule.
         */
        function NetworkRule(ruleText, filterListId) {
            this.permittedDomains = null;
            this.restrictedDomains = null;
            /**
             * Domains in denyallow modifier providing exceptions for permitted domains
             * https://github.com/AdguardTeam/CoreLibs/issues/1304
             */
            this.denyAllowDomains = null;
            /**
             * Flag with all enabled rule options.
             */
            this.enabledOptions = exports.NetworkRuleOption.NotSet;
            /**
             * Flag with all disabled rule options.
             */
            this.disabledOptions = exports.NetworkRuleOption.NotSet;
            /**
             * Flag with all permitted request types.
             */
            this.permittedRequestTypes = RequestType.NotSet;
            /**
             * Flag with all restricted request types.
             */
            this.restrictedRequestTypes = RequestType.NotSet;
            /**
             * Rule Advanced modifier
             */
            this.advancedModifier = null;
            /**
             * Rule App modifier
             */
            this.appModifier = null;
            /**
             * Rule Method modifier
             */
            this.methodModifier = null;
            /**
             * Rule To modifier
             */
            this.toModifier = null;
            /**
             * Rule priority, which is needed when the engine has to choose between
             * several rules matching the query. This value is calculated based on
             * the rule modifiers enabled or disabled and rounded up
             * to the smallest integer greater than or equal to the calculated weight
             * in the {@link calculatePriorityWeight}.
             *
             * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-1
             */
            this.priorityWeight = 1;
            this.ruleText = ruleText;
            this.filterListId = filterListId;
            var ruleParts = NetworkRule.parseRuleText(ruleText);
            this.allowlist = !!ruleParts.allowlist;
            var pattern = ruleParts.pattern;
            if (pattern && NetworkRule.hasSpaces(pattern)) {
                throw new SyntaxError('Rule has spaces, seems to be an host rule');
            }
            if (ruleParts.options) {
                this.loadOptions(ruleParts.options);
            }
            if (pattern === SimpleRegex.MASK_START_URL
                || pattern === SimpleRegex.MASK_ANY_CHARACTER
                || pattern === ''
                || pattern.length < SimpleRegex.MIN_GENERIC_RULE_LENGTH) {
                // Except cookie, removeparam rules and dns compatible rules, they have their own atmosphere
                var hasCookieModifier = this.advancedModifier instanceof CookieModifier;
                var hasRemoveParamModifier = this.advancedModifier instanceof RemoveParamModifier;
                // https://github.com/AdguardTeam/tsurlfilter/issues/56
                var isDnsCompatible = isCompatibleWith(exports.CompatibilityTypes.Dns);
                if (!hasCookieModifier && !hasRemoveParamModifier && !isDnsCompatible) {
                    if (!(this.hasPermittedDomains() || this.hasPermittedApps())) {
                        // Rule matches too much and does not have any domain restriction
                        // We should not allow this kind of rules
                        // eslint-disable-next-line max-len
                        throw new SyntaxError('The rule is too wide, add domain restriction or make the pattern more specific');
                    }
                }
            }
            this.calculatePriorityWeight();
            this.pattern = new Pattern(pattern, this.isOptionEnabled(exports.NetworkRuleOption.MatchCase));
        }
        /**
         * Returns the original text of the rule from which it was parsed.
         *
         * @returns Original text of the rule.
         */
        NetworkRule.prototype.getText = function () {
            return this.ruleText;
        };
        /**
         * Returns the identifier of the filter from which the rule was received.
         *
         * @returns Identifier of the filter from which the rule was received.
         */
        NetworkRule.prototype.getFilterListId = function () {
            return this.filterListId;
        };
        /**
         * Each rule has its own priority, which is necessary when several rules
         * match the request and the filtering system needs to select one of them.
         * Priority is measured as a positive integer.
         * In the case of a conflict between two rules with the same priority value,
         * it is not specified which one of them will be chosen.
         *
         * @returns Rule priority.
         */
        NetworkRule.prototype.getPriorityWeight = function () {
            return this.priorityWeight;
        };
        /**
         * Returns rule pattern,
         * which currently is used only in the rule validator module
         */
        NetworkRule.prototype.getPattern = function () {
            return this.pattern.pattern;
        };
        /**
         * Returns `true` if the rule is "allowlist", e.g. if it disables other
         * rules when the pattern matches the request.
         */
        NetworkRule.prototype.isAllowlist = function () {
            return this.allowlist;
        };
        /**
         * Checks if the rule is a document-level allowlist rule with $urlblock or
         * $genericblock or $content.
         * This means that the rule is supposed to disable or modify blocking
         * of the page subrequests.
         * For instance, `@@||example.org^$urlblock` unblocks all sub-requests.
         */
        NetworkRule.prototype.isDocumentLevelAllowlistRule = function () {
            if (!this.isAllowlist()) {
                return false;
            }
            return this.isOptionEnabled(exports.NetworkRuleOption.Urlblock)
                || this.isOptionEnabled(exports.NetworkRuleOption.Genericblock)
                || this.isOptionEnabled(exports.NetworkRuleOption.Content);
        };
        /**
         * Checks if the rule completely disables filtering.
         */
        NetworkRule.prototype.isFilteringDisabled = function () {
            if (!this.isAllowlist()) {
                return false;
            }
            return this.isOptionEnabled(exports.NetworkRuleOption.Elemhide)
                && this.isOptionEnabled(exports.NetworkRuleOption.Content)
                && this.isOptionEnabled(exports.NetworkRuleOption.Urlblock)
                && this.isOptionEnabled(exports.NetworkRuleOption.Jsinject);
        };
        /**
         * The longest part of pattern without any special characters.
         * It is used to improve the matching performance.
         */
        NetworkRule.prototype.getShortcut = function () {
            return this.pattern.shortcut;
        };
        /**
         * Gets list of permitted domains.
         * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
         */
        NetworkRule.prototype.getPermittedDomains = function () {
            return this.permittedDomains;
        };
        /**
         * Gets list of denyAllow domains.
         * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#denyallow-modifier
         */
        NetworkRule.prototype.getDenyAllowDomains = function () {
            return this.denyAllowDomains;
        };
        /**
         * Gets list of restricted domains.
         * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier
         */
        NetworkRule.prototype.getRestrictedDomains = function () {
            return this.restrictedDomains;
        };
        /**
         * Get list of permitted $to domains.
         * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#to-modifier
         */
        NetworkRule.prototype.getPermittedToDomains = function () {
            if (this.toModifier) {
                return this.toModifier.permittedValues;
            }
            return null;
        };
        /**
         * Get list of restricted $to domains.
         * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#to-modifier
         */
        NetworkRule.prototype.getRestrictedToDomains = function () {
            if (this.toModifier) {
                return this.toModifier.restrictedValues;
            }
            return null;
        };
        /**
         * Gets list of permitted domains.
         * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
         */
        NetworkRule.prototype.getPermittedApps = function () {
            if (this.appModifier) {
                return this.appModifier.permittedApps;
            }
            return null;
        };
        /**
         * Gets list of restricted domains.
         * See https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app
         */
        NetworkRule.prototype.getRestrictedApps = function () {
            if (this.appModifier) {
                return this.appModifier.restrictedApps;
            }
            return null;
        };
        /**
         * Gets list of permitted methods.
         * See https://kb.adguard.com/general/how-to-create-your-own-ad-filters#method-modifier
         */
        NetworkRule.prototype.getRestrictedMethods = function () {
            if (this.methodModifier) {
                return this.methodModifier.restrictedValues;
            }
            return null;
        };
        /**
         * Gets list of restricted methods.
         * See https://kb.adguard.com/general/how-to-create-your-own-ad-filters#method-modifier
         */
        NetworkRule.prototype.getPermittedMethods = function () {
            if (this.methodModifier) {
                return this.methodModifier.permittedValues;
            }
            return null;
        };
        /**
         * Flag with all permitted request types.
         * The value {@link RequestType.NotSet} here means "all request types are allowed".
         */
        NetworkRule.prototype.getPermittedRequestTypes = function () {
            return this.permittedRequestTypes;
        };
        /**
         * Flag with all restricted request types.
         * The value {@link RequestType.NotSet} here means "no type of request is restricted".
         */
        NetworkRule.prototype.getRestrictedRequestTypes = function () {
            return this.restrictedRequestTypes;
        };
        /**
         * Advanced modifier
         */
        NetworkRule.prototype.getAdvancedModifier = function () {
            return this.advancedModifier;
        };
        /**
         * Advanced modifier value
         */
        NetworkRule.prototype.getAdvancedModifierValue = function () {
            return this.advancedModifier && this.advancedModifier.getValue();
        };
        /**
         * isRegexRule returns true if rule's pattern is a regular expression.
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#regexp-support
         */
        NetworkRule.prototype.isRegexRule = function () {
            return (this.getPattern().startsWith(SimpleRegex.MASK_REGEX_RULE)
                && this.getPattern().endsWith(SimpleRegex.MASK_REGEX_RULE));
        };
        NetworkRule.prototype.matchesPermittedDomains = function (hostname) {
            if (this.hasPermittedDomains()
                && DomainModifier.isDomainOrSubdomainOfAny(hostname, this.permittedDomains)) {
                return true;
            }
            return false;
        };
        /**
         * Checks if this filtering rule matches the specified request.
         * @param request - request to check.
         * @param useShortcut - the flag to use this rule shortcut
         *
         * In case we use Trie in lookup table, we don't need to use shortcut cause we already check if request's url
         * includes full rule shortcut.
         */
        NetworkRule.prototype.match = function (request, useShortcut) {
            if (useShortcut === void 0) { useShortcut = true; }
            // Regex rules should not be tested by shortcut
            if (useShortcut && !this.matchShortcut(request)) {
                return false;
            }
            if (this.isOptionEnabled(exports.NetworkRuleOption.Method) && !this.matchMethod(request.method)) {
                return false;
            }
            if (this.isOptionEnabled(exports.NetworkRuleOption.ThirdParty) && !request.thirdParty) {
                return false;
            }
            if (this.isOptionDisabled(exports.NetworkRuleOption.ThirdParty) && request.thirdParty) {
                return false;
            }
            if (!this.matchRequestType(request.requestType)) {
                return false;
            }
            if (!this.matchDomainModifier(request)) {
                return false;
            }
            if (this.isOptionEnabled(exports.NetworkRuleOption.RemoveParam)) {
                if (!this.matchRequestTypeExplicit(request.requestType)) {
                    return false;
                }
            }
            if (!this.matchDenyAllowDomains(request.hostname)) {
                return false;
            }
            if (this.isOptionEnabled(exports.NetworkRuleOption.To) && !this.matchToModifier(request.hostname)) {
                return false;
            }
            if (!this.matchDnsType(request.dnsType)) {
                return false;
            }
            if (!this.matchClientTags(request.clientTags)) {
                return false;
            }
            if (!this.matchClient(request.clientName, request.clientIP)) {
                return false;
            }
            return this.pattern.matchPattern(request, true);
        };
        /**
         * matchShortcut simply checks if shortcut is a substring of the URL.
         * @param request - request to check.
         */
        NetworkRule.prototype.matchShortcut = function (request) {
            return request.urlLowercase.indexOf(this.getShortcut()) >= 0;
        };
        /**
         * matchDomain checks if the filtering rule is allowed on this domain.
         * @param domain - domain to check.
         */
        NetworkRule.prototype.matchDomain = function (domain) {
            if (this.hasRestrictedDomains()) {
                if (DomainModifier.isDomainOrSubdomainOfAny(domain, this.restrictedDomains)) {
                    // Domain or host is restricted
                    // i.e. $domain=~example.org
                    return false;
                }
            }
            if (this.hasPermittedDomains()) {
                if (!DomainModifier.isDomainOrSubdomainOfAny(domain, this.permittedDomains)) {
                    // Domain is not among permitted
                    // i.e. $domain=example.org and we're checking example.com
                    return false;
                }
            }
            return true;
        };
        /**
         * Check if request matches domain modifier by request referrer (general case) or by request target
         *
         * In some cases the $domain modifier can match not only the referrer domain, but also the target domain.
         * This happens when the following is true (1 AND ((2 AND 3) OR 4):
         *
         * 1) The request has document type
         * 2) The rule's pattern doesn't match any particular domain(s)
         * 3) The rule's pattern doesn't contain regular expressions
         * 4) The $domain modifier contains only excluded domains (e.g., $domain=~example.org|~example.com)
         *
         * When all these conditions are met, the domain modifier will match both the referrer domain and the target domain.
         * https://github.com/AdguardTeam/tsurlfilter/issues/45
         * @param request
         */
        NetworkRule.prototype.matchDomainModifier = function (request) {
            if (!this.permittedDomains && !this.restrictedDomains) {
                return true;
            }
            var isDocumentType = request.requestType === RequestType.Document
                || request.requestType === RequestType.SubDocument;
            var hasOnlyExcludedDomains = (!this.permittedDomains || this.permittedDomains.length === 0)
                && this.restrictedDomains
                && this.restrictedDomains.length > 0;
            var patternIsRegex = this.isRegexRule();
            var patternIsDomainSpecific = this.pattern.isPatternDomainSpecific();
            var matchesTargetByPatternCondition = !patternIsRegex && !patternIsDomainSpecific;
            if (isDocumentType && (hasOnlyExcludedDomains || matchesTargetByPatternCondition)) {
                // check if matches source hostname if exists or if matches target hostname
                return (request.sourceHostname && this.matchDomain(request.sourceHostname))
                    || this.matchDomain(request.hostname);
            }
            return this.matchDomain(request.sourceHostname || '');
        };
        /**
         * checks if the filtering rule is allowed on this domain.
         * @param domain
         */
        NetworkRule.prototype.matchDenyAllowDomains = function (domain) {
            if (!this.denyAllowDomains) {
                return true;
            }
            if (this.denyAllowDomains.length > 0) {
                if (DomainModifier.isDomainOrSubdomainOfAny(domain, this.denyAllowDomains)) {
                    return false;
                }
            }
            return true;
        };
        /**
         * Checks if request target matches with specified domains
         *
         * @param domain request's domain
         * @return true if request domain matches with specified domains
         */
        NetworkRule.prototype.matchToModifier = function (domain) {
            if (!this.toModifier) {
                return true;
            }
            /**
             * Request's domain must be either explicitly
             * permitted and not be included in list of restricted domains
             * for the rule to apply
             */
            var permittedDomains = this.getPermittedToDomains();
            var restrictedDomains = this.getRestrictedToDomains();
            var isPermittedDomain = !!permittedDomains
                && DomainModifier.isDomainOrSubdomainOfAny(domain, permittedDomains);
            var isRestrictedDomain = !!restrictedDomains
                && DomainModifier.isDomainOrSubdomainOfAny(domain, restrictedDomains);
            return isPermittedDomain && !isRestrictedDomain;
        };
        /**
         * Return TRUE if this rule matches with the tags associated with a client
         *
         * @param clientTags
         */
        NetworkRule.prototype.matchClientTags = function (clientTags) {
            var advancedModifier = this.getAdvancedModifier();
            if (!advancedModifier || !(advancedModifier instanceof CtagModifier)) {
                return true;
            }
            if (!clientTags) {
                return false;
            }
            var cTagsModifier = advancedModifier;
            return clientTags.every(function (x) { return cTagsModifier.match(x); });
        };
        /**
         * returns TRUE if the rule matches with the specified client
         *
         * @param clientName
         * @param clientIP
         */
        NetworkRule.prototype.matchClient = function (clientName, clientIP) {
            var advancedModifier = this.getAdvancedModifier();
            if (!advancedModifier || !(advancedModifier instanceof ClientModifier)) {
                return true;
            }
            if (!clientName && !clientIP) {
                return false;
            }
            var modifier = advancedModifier;
            return modifier.matchAny(clientName, clientIP);
        };
        /**
         * Return TRUE if this rule matches with the request dnstype
         *
         * @param dnstype
         */
        NetworkRule.prototype.matchDnsType = function (dnstype) {
            var advancedModifier = this.getAdvancedModifier();
            if (!advancedModifier || !(advancedModifier instanceof DnsTypeModifier)) {
                return true;
            }
            if (!dnstype) {
                return false;
            }
            var modifier = advancedModifier;
            return modifier.match(dnstype);
        };
        /**
         * Checks if rule has permitted domains
         */
        NetworkRule.prototype.hasPermittedDomains = function () {
            return this.permittedDomains != null && this.permittedDomains.length > 0;
        };
        /**
         * Checks if rule has restricted domains
         */
        NetworkRule.prototype.hasRestrictedDomains = function () {
            return this.restrictedDomains != null && this.restrictedDomains.length > 0;
        };
        /**
         * Checks if rule has permitted apps
         */
        NetworkRule.prototype.hasPermittedApps = function () {
            if (!this.appModifier) {
                return false;
            }
            return this.appModifier.permittedApps !== null && this.appModifier.permittedApps.length > 0;
        };
        /**
         * matchRequestType checks if the request's type matches the rule properties
         * @param requestType - request type to check.
         */
        NetworkRule.prototype.matchRequestType = function (requestType) {
            if (this.permittedRequestTypes !== RequestType.NotSet) {
                if ((this.permittedRequestTypes & requestType) !== requestType) {
                    return false;
                }
            }
            if (this.restrictedRequestTypes !== RequestType.NotSet) {
                if ((this.restrictedRequestTypes & requestType) === requestType) {
                    return false;
                }
            }
            return true;
        };
        /**
         * In case of $removeparam modifier,
         * we only allow it to target other content types if the rule has an explicit content-type modifier.
         */
        NetworkRule.prototype.matchRequestTypeExplicit = function (requestType) {
            if (this.permittedRequestTypes === RequestType.NotSet
                && this.restrictedRequestTypes === RequestType.NotSet
                && requestType !== RequestType.Document
                && requestType !== RequestType.SubDocument) {
                return false;
            }
            return this.matchRequestType(requestType);
        };
        /**
         * Checks if request's method matches with the rule
         *
         * @param method request's method
         * @returns true, if rule must be applied to the request
         */
        NetworkRule.prototype.matchMethod = function (method) {
            if (!method || !MethodModifier.isHTTPMethod(method)) {
                return false;
            }
            /**
             * Request's method must be either explicitly
             * permitted or not be included in list of restricted methods
             * for the rule to apply
             */
            var permittedMethods = this.getPermittedMethods();
            if (permittedMethods === null || permittedMethods === void 0 ? void 0 : permittedMethods.includes(method)) {
                return true;
            }
            var restrictedMethods = this.getRestrictedMethods();
            return !!restrictedMethods && !restrictedMethods.includes(method);
        };
        /**
         * Checks if pattern has spaces
         * Used in order to do not create network rules from host rules
         * @param pattern
         * @private
         */
        NetworkRule.hasSpaces = function (pattern) {
            return pattern.indexOf(' ') > -1;
        };
        /**
         * Parses the options string and saves them.
         * More on the rule modifiers:
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers
         *
         * @param options - string with the rule modifiers
         *
         * @throws an error if there is an unsupported modifier
         */
        NetworkRule.prototype.loadOptions = function (options) {
            var optionParts;
            try {
                optionParts = parseOptionsString(options);
            }
            catch (e) {
                var errorMessage = getErrorMessage(e);
                throw new Error("Cannot parse ".concat(options, ": ").concat(errorMessage));
            }
            for (var i = 0; i < optionParts.length; i += 1) {
                var option = optionParts[i];
                var valueIndex = option.indexOf('=');
                var optionName = option;
                var optionValue = '';
                if (valueIndex > 0) {
                    optionName = option.substring(0, valueIndex);
                    optionValue = option.substring(valueIndex + 1);
                }
                this.loadOption(optionName, optionValue);
            }
            this.validateOptions();
        };
        /**
         * Returns true if rule contains (enabled or disabled) specified option.
         * Please note, that options have three state: enabled, disabled, undefined.
         *
         * @param option - rule option to check.
         */
        NetworkRule.prototype.hasOption = function (option) {
            return this.isOptionEnabled(option) || this.isOptionDisabled(option);
        };
        /**
         * Returns true if the specified option is enabled.
         * Please note, that options have three state: enabled, disabled, undefined.
         *
         * @param option - rule option to check.
         */
        NetworkRule.prototype.isOptionEnabled = function (option) {
            return (this.enabledOptions & option) === option;
        };
        /**
         * Returns true if one and only option is enabled
         *
         * @param option
         */
        NetworkRule.prototype.isSingleOptionEnabled = function (option) {
            return this.enabledOptions === option;
        };
        /**
         * Returns true if the specified option is disabled.
         * Please note, that options have three state: enabled, disabled, undefined.
         *
         * @param option - rule option to check.
         */
        NetworkRule.prototype.isOptionDisabled = function (option) {
            return (this.disabledOptions & option) === option;
        };
        /**
         * Checks if the rule has higher priority that the specified rule
         * allowlist + $important > $important > redirect > allowlist > basic rules
         */
        NetworkRule.prototype.isHigherPriority = function (r) {
            return this.priorityWeight > r.priorityWeight;
        };
        /**
         * Returns true if the rule is considered "generic"
         * "generic" means that the rule is not restricted to a limited set of domains
         * Please note that it might be forbidden on some domains, though.
         *
         * @return {boolean}
         */
        NetworkRule.prototype.isGeneric = function () {
            return !this.hasPermittedDomains();
        };
        /**
         * Returns true if this rule negates the specified rule
         * Only makes sense when this rule has a `badfilter` modifier
         */
        NetworkRule.prototype.negatesBadfilter = function (specifiedRule) {
            if (!this.isOptionEnabled(exports.NetworkRuleOption.Badfilter)) {
                return false;
            }
            if (this.allowlist !== specifiedRule.allowlist) {
                return false;
            }
            if (this.pattern.pattern !== specifiedRule.pattern.pattern) {
                return false;
            }
            if (this.permittedRequestTypes !== specifiedRule.permittedRequestTypes) {
                return false;
            }
            if (this.restrictedRequestTypes !== specifiedRule.restrictedRequestTypes) {
                return false;
            }
            if ((this.enabledOptions ^ exports.NetworkRuleOption.Badfilter) !== specifiedRule.enabledOptions) {
                return false;
            }
            if (this.disabledOptions !== specifiedRule.disabledOptions) {
                return false;
            }
            if (!stringArraysEquals(this.restrictedDomains, specifiedRule.restrictedDomains)) {
                return false;
            }
            if (!stringArraysHaveIntersection(this.permittedDomains, specifiedRule.permittedDomains)) {
                return false;
            }
            return true;
        };
        /**
         * Checks if this rule can be used for hosts-level blocking
         */
        NetworkRule.prototype.isHostLevelNetworkRule = function () {
            if (this.hasPermittedDomains() || this.hasRestrictedDomains()) {
                return false;
            }
            if (this.permittedRequestTypes !== 0 && this.restrictedRequestTypes !== 0) {
                return false;
            }
            if (this.disabledOptions !== exports.NetworkRuleOption.NotSet) {
                return false;
            }
            if (this.enabledOptions !== exports.NetworkRuleOption.NotSet) {
                return ((this.enabledOptions
                    & exports.NetworkRuleOption.OptionHostLevelRules)
                    | (this.enabledOptions
                        ^ exports.NetworkRuleOption.OptionHostLevelRules)) === exports.NetworkRuleOption.OptionHostLevelRules;
            }
            return true;
        };
        /**
         * Enables or disables the specified option.
         *
         * @param option - option to enable or disable.
         * @param enabled - true to enable, false to disable.
         * @param skipRestrictions - skip options allowlist/blacklist restrictions
         *
         * @throws an error if the option we're trying to enable cannot be.
         * For instance, you cannot enable $elemhide for blacklist rules.
         */
        NetworkRule.prototype.setOptionEnabled = function (option, enabled, skipRestrictions) {
            if (skipRestrictions === void 0) { skipRestrictions = false; }
            if (!skipRestrictions) {
                if (!this.allowlist && (option & exports.NetworkRuleOption.AllowlistOnly) === option) {
                    throw new SyntaxError("Modifier ".concat(exports.NetworkRuleOption[option], " cannot be used in blacklist rule"));
                }
            }
            if (enabled) {
                this.enabledOptions |= option;
            }
            else {
                this.disabledOptions |= option;
            }
        };
        /**
         * Permits or forbids the specified request type.
         * "Permits" means that the rule will match **only** the types that are permitted.
         * "Restricts" means that the rule will match **all but restricted**.
         *
         * @param requestType - request type.
         * @param permitted - true if it's permitted (whic)
         */
        NetworkRule.prototype.setRequestType = function (requestType, permitted) {
            if (permitted) {
                this.permittedRequestTypes |= requestType;
            }
            else {
                this.restrictedRequestTypes |= requestType;
            }
        };
        /**
         * Sets and validates exceptionally allowed domains presented in $denyallow modifier
         *
         * @param optionValue
         */
        NetworkRule.prototype.setDenyAllowDomains = function (optionValue) {
            var domainModifier = new DomainModifier(optionValue, PIPE_SEPARATOR);
            if (domainModifier.restrictedDomains && domainModifier.restrictedDomains.length > 0) {
                throw new SyntaxError('Invalid modifier: $denyallow domains cannot be negated');
            }
            if (domainModifier.permittedDomains
                && domainModifier.permittedDomains.some(function (x) { return x.includes(SimpleRegex.MASK_ANY_CHARACTER); })) {
                throw new SyntaxError('Invalid modifier: $denyallow domains wildcards are not supported');
            }
            this.denyAllowDomains = domainModifier.permittedDomains;
        };
        /**
         * Loads the specified modifier:
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers
         *
         * @param optionName - modifier name.
         * @param optionValue - modifier value.
         *
         * @throws an error if there is an unsupported modifier
         */
        NetworkRule.prototype.loadOption = function (optionName, optionValue) {
            var _this = this;
            var OPTIONS = NetworkRule.OPTIONS;
            if (optionName.startsWith(OPTIONS.NOOP)) {
                /**
                 * A noop modifier does nothing and can be used to increase some rules readability.
                 * It consists of the sequence of underscore characters (_) of any length
                 * and can appear in a rule as many times as it's needed.
                 */
                if (!optionName.split(OPTIONS.NOOP).some(function (s) { return !!s; })) {
                    return;
                }
            }
            switch (optionName) {
                // General options
                // $third-party, $~first-party
                case OPTIONS.THIRD_PARTY:
                case NOT_MARK + OPTIONS.FIRST_PARTY:
                    this.setOptionEnabled(exports.NetworkRuleOption.ThirdParty, true);
                    break;
                // $first-party, $~third-party
                case NOT_MARK + OPTIONS.THIRD_PARTY:
                case OPTIONS.FIRST_PARTY:
                    this.setOptionEnabled(exports.NetworkRuleOption.ThirdParty, false);
                    break;
                // $match-case
                case OPTIONS.MATCH_CASE:
                    this.setOptionEnabled(exports.NetworkRuleOption.MatchCase, true);
                    break;
                // $~match-case
                case NOT_MARK + OPTIONS.MATCH_CASE:
                    this.setOptionEnabled(exports.NetworkRuleOption.MatchCase, false);
                    break;
                // $important
                case OPTIONS.IMPORTANT:
                    this.setOptionEnabled(exports.NetworkRuleOption.Important, true);
                    break;
                // $domain
                case OPTIONS.DOMAIN:
                    // eslint-disable-next-line no-case-declarations
                    var domainModifier = new DomainModifier(optionValue, PIPE_SEPARATOR);
                    this.permittedDomains = domainModifier.permittedDomains;
                    this.restrictedDomains = domainModifier.restrictedDomains;
                    break;
                // $denyallow
                case OPTIONS.DENYALLOW:
                    this.setDenyAllowDomains(optionValue);
                    break;
                // $method modifier
                case OPTIONS.METHOD: {
                    this.setOptionEnabled(exports.NetworkRuleOption.Method, true);
                    this.methodModifier = new MethodModifier(optionValue);
                    break;
                }
                // $to modifier
                case OPTIONS.TO: {
                    this.setOptionEnabled(exports.NetworkRuleOption.To, true);
                    this.toModifier = new ToModifier(optionValue);
                    break;
                }
                // Document-level allowlist rules
                // $elemhide
                case OPTIONS.ELEMHIDE:
                    this.setOptionEnabled(exports.NetworkRuleOption.Elemhide, true);
                    this.setRequestType(RequestType.Document, true);
                    this.setRequestType(RequestType.SubDocument, true);
                    break;
                // $generichide
                case OPTIONS.GENERICHIDE:
                    this.setOptionEnabled(exports.NetworkRuleOption.Generichide, true);
                    this.setRequestType(RequestType.Document, true);
                    this.setRequestType(RequestType.SubDocument, true);
                    break;
                // $specifichide
                case OPTIONS.SPECIFICHIDE:
                    this.setOptionEnabled(exports.NetworkRuleOption.Specifichide, true);
                    this.setRequestType(RequestType.Document, true);
                    this.setRequestType(RequestType.SubDocument, true);
                    break;
                // $genericblock
                case OPTIONS.GENERICBLOCK:
                    this.setOptionEnabled(exports.NetworkRuleOption.Genericblock, true);
                    this.setRequestType(RequestType.Document, true);
                    this.setRequestType(RequestType.SubDocument, true);
                    break;
                // $jsinject
                case OPTIONS.JSINJECT:
                    this.setOptionEnabled(exports.NetworkRuleOption.Jsinject, true);
                    this.setRequestType(RequestType.Document, true);
                    this.setRequestType(RequestType.SubDocument, true);
                    break;
                // $urlblock
                case OPTIONS.URLBLOCK:
                    this.setOptionEnabled(exports.NetworkRuleOption.Urlblock, true);
                    this.setRequestType(RequestType.Document, true);
                    this.setRequestType(RequestType.SubDocument, true);
                    break;
                // $content
                case OPTIONS.CONTENT:
                    this.setOptionEnabled(exports.NetworkRuleOption.Content, true);
                    this.setRequestType(RequestType.Document, true);
                    this.setRequestType(RequestType.SubDocument, true);
                    break;
                // $document, $doc
                case OPTIONS.DOCUMENT:
                case OPTIONS.DOC:
                    this.setRequestType(RequestType.Document, true);
                    // In the case of allowlist rules $document implicitly includes
                    // all these modifiers: `$content`, `$elemhide`, `$jsinject`,
                    // `$urlblock`.
                    if (this.isAllowlist()) {
                        this.setOptionEnabled(exports.NetworkRuleOption.Elemhide, true, true);
                        this.setOptionEnabled(exports.NetworkRuleOption.Jsinject, true, true);
                        this.setOptionEnabled(exports.NetworkRuleOption.Urlblock, true, true);
                        this.setOptionEnabled(exports.NetworkRuleOption.Content, true, true);
                    }
                    break;
                // $~document, $~doc
                case NOT_MARK + OPTIONS.DOCUMENT:
                case NOT_MARK + OPTIONS.DOC:
                    this.setRequestType(RequestType.Document, false);
                    break;
                // $stealh
                case OPTIONS.STEALTH:
                    this.setOptionEnabled(exports.NetworkRuleOption.Stealth, true);
                    break;
                // $popup
                case OPTIONS.POPUP:
                    this.setRequestType(RequestType.Document, true);
                    this.setOptionEnabled(exports.NetworkRuleOption.Popup, true);
                    break;
                // Content type options
                // $script
                case OPTIONS.SCRIPT:
                    this.setRequestType(RequestType.Script, true);
                    break;
                // $~script
                case NOT_MARK + OPTIONS.SCRIPT:
                    this.setRequestType(RequestType.Script, false);
                    break;
                // $stylesheet
                case OPTIONS.STYLESHEET:
                    this.setRequestType(RequestType.Stylesheet, true);
                    break;
                // $~stylesheet
                case NOT_MARK + OPTIONS.STYLESHEET:
                    this.setRequestType(RequestType.Stylesheet, false);
                    break;
                // $subdocument
                case OPTIONS.SUBDOCUMENT:
                    this.setRequestType(RequestType.SubDocument, true);
                    break;
                // $~subdocument
                case NOT_MARK + OPTIONS.SUBDOCUMENT:
                    this.setRequestType(RequestType.SubDocument, false);
                    break;
                // $object
                case OPTIONS.OBJECT:
                    this.setRequestType(RequestType.Object, true);
                    break;
                // $~object
                case NOT_MARK + OPTIONS.OBJECT:
                    this.setRequestType(RequestType.Object, false);
                    break;
                // $image
                case OPTIONS.IMAGE:
                    this.setRequestType(RequestType.Image, true);
                    break;
                // $~image
                case NOT_MARK + OPTIONS.IMAGE:
                    this.setRequestType(RequestType.Image, false);
                    break;
                // $xmlhttprequest
                case OPTIONS.XMLHTTPREQUEST:
                    this.setRequestType(RequestType.XmlHttpRequest, true);
                    break;
                // $~xmlhttprequest
                case NOT_MARK + OPTIONS.XMLHTTPREQUEST:
                    this.setRequestType(RequestType.XmlHttpRequest, false);
                    break;
                // $media
                case OPTIONS.MEDIA:
                    this.setRequestType(RequestType.Media, true);
                    break;
                // $~media
                case NOT_MARK + OPTIONS.MEDIA:
                    this.setRequestType(RequestType.Media, false);
                    break;
                // $font
                case OPTIONS.FONT:
                    this.setRequestType(RequestType.Font, true);
                    break;
                // $~font
                case NOT_MARK + OPTIONS.FONT:
                    this.setRequestType(RequestType.Font, false);
                    break;
                // $websocket
                case OPTIONS.WEBSOCKET:
                    this.setRequestType(RequestType.WebSocket, true);
                    break;
                // $~websocket
                case NOT_MARK + OPTIONS.WEBSOCKET:
                    this.setRequestType(RequestType.WebSocket, false);
                    break;
                // $other
                case OPTIONS.OTHER:
                    this.setRequestType(RequestType.Other, true);
                    break;
                // $~other
                case NOT_MARK + OPTIONS.OTHER:
                    this.setRequestType(RequestType.Other, false);
                    break;
                // $ping
                case OPTIONS.PING:
                    this.setRequestType(RequestType.Ping, true);
                    break;
                // $~ping
                case NOT_MARK + OPTIONS.PING:
                    this.setRequestType(RequestType.Ping, false);
                    break;
                // Special modifiers
                // $badfilter
                case OPTIONS.BADFILTER:
                    this.setOptionEnabled(exports.NetworkRuleOption.Badfilter, true);
                    break;
                // $csp
                case OPTIONS.CSP:
                    this.setOptionEnabled(exports.NetworkRuleOption.Csp, true);
                    this.advancedModifier = new CspModifier(optionValue, this.isAllowlist());
                    break;
                // $replace
                case OPTIONS.REPLACE:
                    this.setOptionEnabled(exports.NetworkRuleOption.Replace, true);
                    this.advancedModifier = new ReplaceModifier(optionValue);
                    break;
                // $cookie
                case OPTIONS.COOKIE:
                    this.setOptionEnabled(exports.NetworkRuleOption.Cookie, true);
                    this.advancedModifier = new CookieModifier(optionValue);
                    break;
                // $redirect
                case OPTIONS.REDIRECT:
                    this.setOptionEnabled(exports.NetworkRuleOption.Redirect, true);
                    this.advancedModifier = new RedirectModifier(optionValue, this.ruleText, this.isAllowlist());
                    break;
                // $redirect-rule
                case OPTIONS.REDIRECTRULE:
                    this.setOptionEnabled(exports.NetworkRuleOption.Redirect, true);
                    this.advancedModifier = new RedirectModifier(optionValue, this.ruleText, this.isAllowlist(), true);
                    break;
                // $removeparam
                case OPTIONS.REMOVEPARAM:
                    this.setOptionEnabled(exports.NetworkRuleOption.RemoveParam, true);
                    this.advancedModifier = new RemoveParamModifier(optionValue);
                    break;
                // $removeheader
                case OPTIONS.REMOVEHEADER:
                    this.setOptionEnabled(exports.NetworkRuleOption.RemoveHeader, true);
                    this.advancedModifier = new RemoveHeaderModifier(optionValue, this.isAllowlist());
                    break;
                // $permissions
                case OPTIONS.PERMISSIONS:
                    // simple validation of permissions rules for compiler.
                    // should be fully supported in tsurlfilter v2.3 and the browser extension v4.4. AG-17467
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension does not support $permissions modifier yet');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.Permissions, true);
                    break;
                // $jsonprune
                // simple validation of jsonprune rules for compiler
                // https://github.com/AdguardTeam/FiltersCompiler/issues/168
                case OPTIONS.JSONPRUNE:
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension does not support $jsonprune modifier yet');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.JsonPrune, true);
                    // TODO: should be properly implemented later
                    // https://github.com/AdguardTeam/tsurlfilter/issues/71
                    break;
                // $hls
                // simple validation of hls rules for compiler
                // https://github.com/AdguardTeam/FiltersCompiler/issues/169
                case OPTIONS.HLS:
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension does not support $hls modifier yet');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.Hls, true);
                    // TODO: should be properly implemented later
                    // https://github.com/AdguardTeam/tsurlfilter/issues/72
                    break;
                // $referrerpolicy
                // simple validation of referrerpolicy rules for compiler
                // https://github.com/AdguardTeam/FiltersCompiler/issues/191
                case OPTIONS.REFERRERPOLICY:
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension does not support $referrerpolicy modifier');
                    }
                    // do nothing as $referrerpolicy is supported by CoreLibs-based apps only.
                    // it is needed for proper rule conversion performed by FiltersCompiler
                    // so rules with $referrerpolicy modifier is not marked as invalid
                    break;
                // Dns modifiers
                // $client
                case OPTIONS.CLIENT:
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $client modifier');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.Client, true);
                    this.advancedModifier = new ClientModifier(optionValue);
                    break;
                // $dnsrewrite
                case OPTIONS.DNSREWRITE:
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $dnsrewrite modifier');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.DnsRewrite, true);
                    this.advancedModifier = new DnsRewriteModifier(optionValue);
                    break;
                // $dnstype
                case OPTIONS.DNSTYPE:
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $dnstype modifier');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.DnsType, true);
                    this.advancedModifier = new DnsTypeModifier(optionValue);
                    break;
                // $ctag
                case OPTIONS.CTAG:
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $ctag modifier');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.Ctag, true);
                    this.advancedModifier = new CtagModifier(optionValue);
                    break;
                // $app
                case OPTIONS.APP:
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $app modifier');
                    }
                    this.appModifier = new AppModifier(optionValue);
                    break;
                // $network
                case OPTIONS.NETWORK:
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $network modifier');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.Network, true);
                    break;
                // $extension
                case OPTIONS.EXTENSION:
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $extension modifier');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.Extension, true);
                    break;
                // $~extension
                case NOT_MARK + OPTIONS.EXTENSION:
                    if (isCompatibleWith(exports.CompatibilityTypes.Extension)) {
                        throw new SyntaxError('Extension doesn\'t support $extension modifier');
                    }
                    this.setOptionEnabled(exports.NetworkRuleOption.Extension, false);
                    break;
                // $all
                case OPTIONS.ALL:
                    if (this.isAllowlist()) {
                        throw new SyntaxError('Rule with $all modifier can not be allowlist rule');
                    }
                    // Set all request types
                    Object.values(RequestType).forEach(function (type) {
                        _this.setRequestType(type, true);
                    });
                    this.setOptionEnabled(exports.NetworkRuleOption.Popup, true);
                    break;
                // $empty and $mp4
                // Deprecated in favor of $redirect
                case OPTIONS.EMPTY:
                case OPTIONS.MP4:
                    // Do nothing.
                    break;
                default: {
                    // clear empty values
                    var modifierView = [optionName, optionValue]
                        .filter(function (i) { return i; })
                        .join('=');
                    throw new SyntaxError("Unknown modifier: ".concat(modifierView));
                }
            }
        };
        /**
         * To calculate priority, we've categorized modifiers into different groups.
         * These groups are ranked based on their priority, from lowest to highest.
         * A modifier that significantly narrows the scope of a rule adds more
         * weight to its total priority. Conversely, if a rule applies to a broader
         * range of requests, its priority decreases.
         *
         * It's worth noting that there are cases where a single-parameter modifier
         * has a higher priority than multi-parameter ones. For instance, in
         * the case of `$domain=example.com|example.org`, a rule that includes two
         * domains has a slightly broader effective area than a rule with one
         * specified domain, therefore its priority is lower.
         *
         * The base priority weight of any rule is 1. If the calculated priority
         * is a floating-point number, it will be **rounded up** to the smallest
         * integer greater than or equal to the calculated weight.
         *
         * @see {@link NetworkRule.PermittedRequestTypeWeight}
         * @see {@link NetworkRule.PermittedDomainWeight}
         * @see {@link NetworkRule.SpecificExceptionsWeight}
         * @see {@link NetworkRule.AllowlistRuleWeight}
         * @see {@link NetworkRule.RedirectRuleWeight}
         * @see {@link NetworkRule.ImportantRuleWeight}
         *
         * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-counting}
         */
        NetworkRule.prototype.calculatePriorityWeight = function () {
            var _a, _b;
            // Base modifiers, category 1.
            this.priorityWeight += countEnabledBits(this.enabledOptions, NetworkRule.CATEGORY_1_OPTIONS_MASK);
            this.priorityWeight += countEnabledBits(this.disabledOptions, NetworkRule.CATEGORY_1_OPTIONS_MASK);
            /**
             * When dealing with a negated domain, app, method, or content-type,
             * we add a point for the existence of the modifier itself, regardless
             * of the quantity of negated domains or content-types. This is because
             * the rule's scope is already infinitely broad. Put simply,
             * by prohibiting multiple domains, content-types, methods or apps,
             * the scope of the rule becomes only minimally smaller.
             */
            if (this.denyAllowDomains && this.denyAllowDomains.length > 0) {
                this.priorityWeight += 1;
            }
            if (this.restrictedDomains && this.restrictedDomains.length > 0) {
                this.priorityWeight += 1;
            }
            if (((_a = this.methodModifier) === null || _a === void 0 ? void 0 : _a.restrictedValues) && this.methodModifier.restrictedValues.length > 0) {
                this.priorityWeight += 1;
            }
            if (this.restrictedRequestTypes !== RequestType.NotSet) {
                this.priorityWeight += 1;
            }
            // $to modifier is basically a replacement for a regular expression
            // See https://github.com/AdguardTeam/KnowledgeBase/pull/196#discussion_r1221401215
            if (this.toModifier) {
                this.priorityWeight += 1;
            }
            /**
             * Category 2: permitted request types and methods.
             * Specified content-types add `50 + 50 / number_of_content_types`,
             * for example: `||example.com^$image,script` will add
             * `50 + 50 / 2 = 50 + 25 = 75` to the total weight of the rule.
             * The `$popup` also belongs to this category, because it implicitly
             * adds the modifier `$document`.
             * Similarly, specific exceptions add `$document,subdocument`.
             */
            if (this.permittedRequestTypes !== RequestType.NotSet) {
                var numberOfPermittedRequestTypes = getBitCount(this.permittedRequestTypes);
                // More permitted request types mean less priority weight.
                var relativeWeight = NetworkRule.CategoryTwoWeight / numberOfPermittedRequestTypes;
                this.priorityWeight += NetworkRule.CategoryTwoWeight + relativeWeight;
            }
            if (((_b = this.methodModifier) === null || _b === void 0 ? void 0 : _b.permittedValues) && this.methodModifier.permittedValues.length > 0) {
                // More permitted request methods mean less priority weight.
                var relativeWeight = NetworkRule.CategoryTwoWeight / this.methodModifier.permittedValues.length;
                this.priorityWeight += NetworkRule.CategoryTwoWeight + relativeWeight;
            }
            /**
             * Category 3: permitted domains.
             * Specified domains through `$domain` and specified applications
             * through `$app` add `100 + 100 / number_domains (or number_applications)`,
             * for example:
             * `||example.com^$domain=example.com|example.org|example.net`
             * will add `100 + 100 / 3 = 134.3 = 134` or
             * `||example.com^$app=org.example.app1|org.example.app2`
             * will add `100 + 100 / 2 = 151`.
             */
            if (this.permittedDomains && this.permittedDomains.length > 0) {
                // More permitted domains mean less priority weight.
                var relativeWeight = NetworkRule.CategoryThreeWeight / this.permittedDomains.length;
                this.priorityWeight += NetworkRule.CategoryThreeWeight + relativeWeight;
            }
            // Category 4: redirect rules.
            if (this.isOptionEnabled(exports.NetworkRuleOption.Redirect)) {
                this.priorityWeight += NetworkRule.CategoryFourWeight;
            }
            // Category 5: specific exceptions.
            this.priorityWeight += NetworkRule.CategoryFiveWeight * countEnabledBits(this.enabledOptions, NetworkRule.SPECIFIC_EXCLUSIONS_MASK);
            // Category 6: allowlist rules.
            if (this.isAllowlist()) {
                this.priorityWeight += NetworkRule.CategorySixWeight;
            }
            // Category 7: important rules.
            if (this.isOptionEnabled(exports.NetworkRuleOption.Important)) {
                this.priorityWeight += NetworkRule.CategorySevenWeight;
            }
            // Round up to avoid overlap between different categories of rules.
            this.priorityWeight = Math.ceil(this.priorityWeight);
        };
        /**
         * Validates rule options
         */
        NetworkRule.prototype.validateOptions = function () {
            if (this.advancedModifier instanceof RemoveParamModifier) {
                this.validateRemoveParamRule();
            }
            else if (this.advancedModifier instanceof RemoveHeaderModifier) {
                this.validateRemoveHeaderRule();
            }
            else if (this.toModifier !== null) {
                this.validateToRule();
            }
            else if (this.denyAllowDomains !== null) {
                this.validateDenyallowRule();
            }
        };
        /**
         * $removeparam rules are not compatible with any other modifiers except $domain,
         * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
         * The rules with any other modifiers are considered invalid and will be discarded.
         */
        NetworkRule.prototype.validateRemoveParamRule = function () {
            if ((this.enabledOptions | exports.NetworkRuleOption.RemoveParamCompatibleOptions)
                !== exports.NetworkRuleOption.RemoveParamCompatibleOptions) {
                throw new SyntaxError('$removeparam rules are not compatible with some other modifiers');
            }
        };
        /**
         * $removeheader rules are not compatible with any other modifiers except $domain,
         * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
         * The rules with any other modifiers are considered invalid and will be discarded.
         */
        NetworkRule.prototype.validateRemoveHeaderRule = function () {
            if ((this.enabledOptions | exports.NetworkRuleOption.RemoveHeaderCompatibleOptions)
                !== exports.NetworkRuleOption.RemoveHeaderCompatibleOptions) {
                throw new SyntaxError('$removeheader rules are not compatible with some other modifiers');
            }
        };
        /**
         * $to rules are not compatible $denyallow - these rules considered invalid
         * and will be discarded.
         */
        NetworkRule.prototype.validateToRule = function () {
            if (this.denyAllowDomains) {
                throw new SyntaxError('modifier $to is not compatible with $denyallow modifier');
            }
        };
        /**
         * $denyallow rules are not compatible $to - these rules considered invalid
         * and will be discarded.
         */
        NetworkRule.prototype.validateDenyallowRule = function () {
            if (this.toModifier) {
                throw new SyntaxError('modifier $to is not compatible with $denyallow modifier');
            }
        };
        /**
         * parseRuleText splits the rule text into multiple parts.
         * @param ruleText - original rule text
         * @returns basic rule parts
         *
         * @throws error if the rule is empty (for instance, empty string or `@@`)
         */
        NetworkRule.parseRuleText = function (ruleText) {
            var ruleParts = new BasicRuleParts();
            ruleParts.allowlist = false;
            var startIndex = 0;
            if (ruleText.startsWith(NetworkRule.MASK_ALLOWLIST)) {
                ruleParts.allowlist = true;
                startIndex = NetworkRule.MASK_ALLOWLIST.length;
            }
            if (ruleText.length <= startIndex) {
                throw new SyntaxError('Rule is too short');
            }
            // Setting pattern to rule text (for the case of empty options)
            ruleParts.pattern = ruleText.substring(startIndex);
            // Avoid parsing options inside of a regex rule
            if (ruleParts.pattern.startsWith(SimpleRegex.MASK_REGEX_RULE)
                && ruleParts.pattern.endsWith(SimpleRegex.MASK_REGEX_RULE)
                && !ruleParts.pattern.includes("".concat(NetworkRule.OPTIONS.REPLACE, "="))) {
                return ruleParts;
            }
            var removeParamIndex = ruleText.lastIndexOf("".concat(NetworkRule.OPTIONS.REMOVEPARAM, "="));
            var endIndex = removeParamIndex >= 0 ? removeParamIndex : ruleText.length - 2;
            var foundEscaped = false;
            for (var i = endIndex; i >= startIndex; i -= 1) {
                var c = ruleText.charAt(i);
                if (c === NetworkRule.OPTIONS_DELIMITER) {
                    if (i > startIndex && ruleText.charAt(i - 1) === NetworkRule.ESCAPE_CHARACTER) {
                        foundEscaped = true;
                    }
                    else {
                        ruleParts.pattern = ruleText.substring(startIndex, i);
                        ruleParts.options = ruleText.substring(i + 1);
                        if (foundEscaped) {
                            // Find and replace escaped options delimiter
                            ruleParts.options = ruleParts.options.replace(NetworkRule.RE_ESCAPED_OPTIONS_DELIMITER, NetworkRule.OPTIONS_DELIMITER);
                            // Reset the regexp state
                            NetworkRule.RE_ESCAPED_OPTIONS_DELIMITER.lastIndex = 0;
                        }
                        // Options delimiter was found, exiting loop
                        break;
                    }
                }
            }
            return ruleParts;
        };
        /**
         * Rules with base modifiers, from category 1, each of them adds 1
         * to the weight of the rule.
         *
         * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-1
         */
        NetworkRule.CATEGORY_1_OPTIONS_MASK = exports.NetworkRuleOption.ThirdParty
            | exports.NetworkRuleOption.MatchCase
            | exports.NetworkRuleOption.DnsRewrite;
        /**
         * The priority weight used in {@link calculatePriorityWeight} for rules
         * with permitted request types and methods.
         * The value 50 is chosen in order to cover (with a margin) all possible
         * combinations and variations of rules from categories with a lower
         * priority (each of them adds 1 to the rule priority).
         *
         * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-2
         */
        NetworkRule.CategoryTwoWeight = 50;
        /**
         * The priority weight used in {@link calculatePriorityWeight} for rules
         * with allowed domains.
         * The value 100 is chosen to cover all possible combinations and variations
         * of rules from categories with a lower priority, for example a rule with
         * one allowed query type will get priority 100 (50 + 50/1), but for allowed
         * domains with any number of domains we will get at least 101 (for 100
         * domains: 100 + 100/100; for 200 100 + 100/200; or even for 10000:
         * 100 + 100/10000) because the resulting weight is rounded up.
         *
         * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-3
         */
        NetworkRule.CategoryThreeWeight = 100;
        /**
         * The priority weight used in {@link calculatePriorityWeight}
         * for $redirect rules.
         *
         * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-6
         */
        NetworkRule.CategoryFourWeight = Math.pow(10, 3);
        /**
         * The priority weight used in {@link calculatePriorityWeight} for rules
         * with specific exceptions.
         *
         * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-4
         */
        NetworkRule.CategoryFiveWeight = Math.pow(10, 4);
        /**
         * Rules with specific exclusions, from category 4, each of them adds
         * {@link SpecificExceptionsWeight} to the weight of the rule.
         *
         * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-4
         */
        NetworkRule.SPECIFIC_EXCLUSIONS_MASK = exports.NetworkRuleOption.Elemhide
            | exports.NetworkRuleOption.Generichide
            | exports.NetworkRuleOption.Specifichide
            | exports.NetworkRuleOption.Content
            | exports.NetworkRuleOption.Urlblock
            | exports.NetworkRuleOption.Genericblock
            | exports.NetworkRuleOption.Jsinject
            | exports.NetworkRuleOption.Extension;
        /**
         * The priority weight used in {@link calculatePriorityWeight} for rules
         * with allowlist mark '@@'.
         *
         * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-5
         */
        NetworkRule.CategorySixWeight = Math.pow(10, 5);
        /**
         * The priority weight used in {@link calculatePriorityWeight}
         * for $important rules.
         *
         * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-7
         */
        NetworkRule.CategorySevenWeight = Math.pow(10, 6);
        /**
         * Separates the rule pattern from the list of modifiers.
         *
         * ```
         * rule = ["@@"] pattern [ "$" modifiers ]
         * modifiers = [modifier0, modifier1[, ...[, modifierN]]]
         * ```
         */
        NetworkRule.OPTIONS_DELIMITER = OPTIONS_DELIMITER;
        /**
         * This character is used to escape special characters in modifiers values
         */
        NetworkRule.ESCAPE_CHARACTER = ESCAPE_CHARACTER;
        // eslint-disable-next-line max-len
        NetworkRule.RE_ESCAPED_OPTIONS_DELIMITER = new RegExp("".concat(NetworkRule.ESCAPE_CHARACTER).concat(NetworkRule.OPTIONS_DELIMITER), 'g');
        /**
         * A marker that is used in rules of exception.
         * To turn off filtering for a request, start your rule with this marker.
         */
        NetworkRule.MASK_ALLOWLIST = MASK_ALLOWLIST;
        /**
         * Mark that negates options
         */
        NetworkRule.NOT_MARK = NOT_MARK;
        /**
         * Rule options
         */
        NetworkRule.OPTIONS = NETWORK_RULE_OPTIONS;
        return NetworkRule;
    }());

    /**
     * Implements a host rule.
     *
     * HostRule is a structure for simple host-level rules (i.e. /etc/hosts syntax).
     * http://man7.org/linux/man-pages/man5/hosts.5.html
     * It also supports "just domain" syntax. In this case, the IP will be set to 0.0.0.0.
     *
     * Rules syntax looks like this:
     * ```
     * IP_address canonical_hostname [aliases...]
     * ```
     *
     * Examples:
     * * `192.168.1.13 bar.mydomain.org bar` -- ipv4
     * * `ff02::1 ip6-allnodes` -- ipv6
     * * `::1 localhost ip6-localhost ip6-loopback` -- ipv6 aliases
     * * `example.org` -- "just domain" syntax
     */
    var HostRule = /** @class */ (function () {
        /**
         * Constructor
         *
         * Parses the rule and creates a new HostRule instance
         *
         * @param ruleText - original rule text.
         * @param filterListId - ID of the filter list this rule belongs to.
         *
         * @throws error if it fails to parse the rule.
         */
        function HostRule(ruleText, filterListId) {
            this.hostnames = [];
            this.ip = '';
            this.invalid = false;
            this.ruleText = ruleText;
            this.filterListId = filterListId;
            var commentIndex = ruleText.indexOf('#');
            var stripped = commentIndex >= 0 ? ruleText.substring(0, commentIndex) : ruleText;
            var parts = stripped.trim().split(' ');
            if (parts.length >= 2) {
                if (!isIp_1(parts[0])) {
                    this.invalid = true;
                    return;
                }
                // eslint-disable-next-line prefer-destructuring
                this.ip = parts[0];
                this.hostnames = parts.slice(1).filter(function (x) { return !!x; });
            }
            else if (parts.length === 1 && isDomainName(parts[0])) {
                this.hostnames = [parts[0]];
                this.ip = '0.0.0.0';
            }
            else {
                this.invalid = true;
            }
        }
        /**
         * Match returns true if this rule can be used on the specified hostname.
         *
         * @param hostname - hostname to check
         */
        HostRule.prototype.match = function (hostname) {
            return this.hostnames.includes(hostname);
        };
        /**
         * Returns list id
         */
        HostRule.prototype.getFilterListId = function () {
            return this.filterListId;
        };
        /**
         * Return rule text
         */
        HostRule.prototype.getText = function () {
            return this.ruleText;
        };
        /**
         * Returns ip address
         */
        HostRule.prototype.getIp = function () {
            return this.ip;
        };
        /**
         * Returns hostnames
         */
        HostRule.prototype.getHostnames = function () {
            return this.hostnames;
        };
        /**
         * Is invalid rule
         */
        HostRule.prototype.isInvalid = function () {
            return this.invalid;
        };
        return HostRule;
    }());

    /**
     * MatchingResult contains all the rules matching a web request, and provides methods
     * that define how a web request should be processed
     */
    var MatchingResult = /** @class */ (function () {
        /**
         * Creates an instance of the MatchingResult struct and fills it with the rules.
         *
         * @param rules A list of network rules that match the request.
         * @param sourceRule A rule that matches the document that is a source
         * of the request, i.e. document-level exclusions.
         */
        function MatchingResult(rules, sourceRule) {
            var _a;
            this.basicRule = null;
            this.documentRule = null;
            this.cspRules = null;
            this.cookieRules = null;
            this.replaceRules = null;
            this.removeParamRules = null;
            this.removeHeaderRules = null;
            this.redirectRules = null;
            this.stealthRule = null;
            // eslint-disable-next-line no-param-reassign
            rules = MatchingResult.removeBadfilterRules(rules);
            if (sourceRule) {
                this.documentRule = sourceRule;
            }
            // Second - check if blocking rules (generic or all of them) are allowed
            // generic blocking rules are allowed by default
            var genericAllowed = true;
            // basic blocking rules are allowed by default
            var basicAllowed = true;
            if (this.documentRule) {
                var documentRule = this.documentRule;
                if (documentRule.isOptionEnabled(exports.NetworkRuleOption.Urlblock)) {
                    basicAllowed = false;
                }
                else if (documentRule.isOptionEnabled(exports.NetworkRuleOption.Genericblock)) {
                    genericAllowed = false;
                }
            }
            // Iterate through the list of rules and fill the MatchingResult
            for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {
                var rule = rules_1[_i];
                if (rule.isOptionEnabled(exports.NetworkRuleOption.Cookie)) {
                    if (!this.cookieRules) {
                        this.cookieRules = [];
                    }
                    this.cookieRules.push(rule);
                    continue;
                }
                if (rule.isOptionEnabled(exports.NetworkRuleOption.Replace)) {
                    if (!this.replaceRules) {
                        this.replaceRules = [];
                    }
                    this.replaceRules.push(rule);
                    continue;
                }
                if (rule.isOptionEnabled(exports.NetworkRuleOption.RemoveParam)) {
                    if (!this.removeParamRules) {
                        this.removeParamRules = [];
                    }
                    this.removeParamRules.push(rule);
                    continue;
                }
                if (rule.isOptionEnabled(exports.NetworkRuleOption.RemoveHeader)) {
                    if (!this.removeHeaderRules) {
                        this.removeHeaderRules = [];
                    }
                    this.removeHeaderRules.push(rule);
                    continue;
                }
                if (rule.isOptionEnabled(exports.NetworkRuleOption.Redirect)) {
                    if (!this.redirectRules) {
                        this.redirectRules = [];
                    }
                    this.redirectRules.push(rule);
                    continue;
                }
                if (rule.isOptionEnabled(exports.NetworkRuleOption.Csp)) {
                    if (!this.cspRules) {
                        this.cspRules = [];
                    }
                    this.cspRules.push(rule);
                    continue;
                }
                if (rule.isOptionEnabled(exports.NetworkRuleOption.Stealth)) {
                    this.stealthRule = rule;
                    continue;
                }
                // Check blocking rules against $genericblock / $urlblock
                if (!rule.isAllowlist() && ((_a = this.documentRule) === null || _a === void 0 ? void 0 : _a.isHigherPriority(rule))) {
                    if (!basicAllowed) {
                        continue;
                    }
                    if (!genericAllowed && rule.isGeneric()) {
                        continue;
                    }
                }
                if (!this.basicRule || rule.isHigherPriority(this.basicRule)) {
                    this.basicRule = rule;
                }
            }
        }
        /**
         * GetBasicResult returns a rule that should be applied to the web request.
         * Possible outcomes are:
         * returns nil -- allow the request.
         * returns an allowlist rule -- allow the request.
         * returns a blocking rule -- block the request.
         * returns a redirect rule -- redirect the request.
         *
         * @return {NetworkRule | null} basic result rule
         */
        MatchingResult.prototype.getBasicResult = function () {
            var basic = this.basicRule;
            if (!basic) {
                // Only document-level frame rule would be returned as a basic result,
                // cause only those rules could block or modify page subrequests.
                // Other frame rules (generichide, elemhide etc) will be used in getCosmeticOption function.
                if (this.documentRule && this.documentRule.isDocumentLevelAllowlistRule()) {
                    basic = this.documentRule;
                }
            }
            // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#replace-modifier
            // https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-extra
            // $replace rules have a higher priority than other basic rules (including exception rules).
            // So if a request corresponds to two different rules one of which has the $replace modifier,
            // this rule will be applied.
            if (this.replaceRules) {
                var isReplaceOrContent = (basic === null || basic === void 0 ? void 0 : basic.isOptionEnabled(exports.NetworkRuleOption.Replace))
                    || (basic === null || basic === void 0 ? void 0 : basic.isOptionEnabled(exports.NetworkRuleOption.Content));
                // If basic rule is an exception with $replace or $content modifier,
                // then basic rule will disable $replace rules.
                if ((basic === null || basic === void 0 ? void 0 : basic.isAllowlist()) && isReplaceOrContent) {
                    return basic;
                }
                // Otherwise null is returned to allow the request, because we need
                // to get response first to then apply the $replace rules to
                // the response.
                return null;
            }
            // Redirect rules have a high priority
            // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#redirect-modifier
            // https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-6
            var redirectRule = this.getRedirectRule();
            if (redirectRule && (!basic || !basic.isHigherPriority(redirectRule))) {
                return redirectRule;
            }
            return basic;
        };
        /**
         * Returns a bit-flag with the list of cosmetic options
         *
         * @return {CosmeticOption} mask
         */
        MatchingResult.prototype.getCosmeticOption = function () {
            var _a = this, basicRule = _a.basicRule, documentRule = _a.documentRule;
            var rule = basicRule;
            // We choose a non-empty rule and the one of the two with the higher
            // priority in order to accurately calculate cosmetic options.
            if ((!rule && documentRule) || (rule && (documentRule === null || documentRule === void 0 ? void 0 : documentRule.isHigherPriority(rule)))) {
                rule = documentRule;
            }
            if (!rule || !rule.isAllowlist()) {
                return exports.CosmeticOption.CosmeticOptionAll;
            }
            var option = exports.CosmeticOption.CosmeticOptionAll;
            if (rule.isOptionEnabled(exports.NetworkRuleOption.Elemhide)) {
                option ^= exports.CosmeticOption.CosmeticOptionGenericCSS;
                option ^= exports.CosmeticOption.CosmeticOptionSpecificCSS;
            }
            if (rule.isOptionEnabled(exports.NetworkRuleOption.Generichide)) {
                option ^= exports.CosmeticOption.CosmeticOptionGenericCSS;
            }
            if (rule.isOptionEnabled(exports.NetworkRuleOption.Specifichide)) {
                option ^= exports.CosmeticOption.CosmeticOptionSpecificCSS;
            }
            if (rule.isOptionEnabled(exports.NetworkRuleOption.Jsinject)) {
                option ^= exports.CosmeticOption.CosmeticOptionJS;
            }
            if (rule.isOptionEnabled(exports.NetworkRuleOption.Content)) {
                option ^= exports.CosmeticOption.CosmeticOptionHtml;
            }
            return option;
        };
        /**
         * Return an array of replace rules
         */
        MatchingResult.prototype.getReplaceRules = function () {
            if (!this.replaceRules) {
                return [];
            }
            // TODO: Look up for allowlist $content rule
            return MatchingResult.filterAdvancedModifierRules(this.replaceRules, function (rule) { return (function (x) { return x.getAdvancedModifierValue() === rule.getAdvancedModifierValue(); }); });
        };
        /**
         * Filters array of rules according to allowlist rules contained.
         * Empty advanced modifier allowlists everything.
         *
         * @param rules
         * @param allowlistPredicate allowlist criteria
         * This function result will be called for testing if rule `x` allowlists rule `r`
         */
        MatchingResult.filterAdvancedModifierRules = function (rules, allowlistPredicate) {
            var _this = this;
            var blockingRules = [];
            var allowlistRules = [];
            for (var _i = 0, rules_2 = rules; _i < rules_2.length; _i++) {
                var rule = rules_2[_i];
                if (rule.isAllowlist()) {
                    allowlistRules.push(rule);
                }
                else {
                    blockingRules.push(rule);
                }
            }
            if (blockingRules.length === 0) {
                return [];
            }
            if (allowlistRules.length === 0) {
                return blockingRules;
            }
            if (allowlistRules.length > 0) {
                var allowlistRuleWithEmptyOption_1 = allowlistRules
                    .find(function (allowlistRule) { return allowlistRule.getAdvancedModifierValue() === ''; });
                var result_1 = [];
                blockingRules.forEach(function (blockRule) {
                    if (allowlistRuleWithEmptyOption_1
                        && !blockRule.isHigherPriority(allowlistRuleWithEmptyOption_1)) {
                        result_1.push(allowlistRuleWithEmptyOption_1);
                        return;
                    }
                    var allowlistingRule = allowlistRules.find(function (a) {
                        return !blockRule.isHigherPriority(a) && allowlistPredicate.call(_this, blockRule)(a);
                    });
                    if (allowlistingRule) {
                        result_1.push(allowlistingRule);
                    }
                    else {
                        result_1.push(blockRule);
                    }
                });
                return result_1.filter(function (item, pos) { return result_1.indexOf(item) === pos; });
            }
            return blockingRules;
        };
        /**
         * Returns an array of csp rules
         */
        MatchingResult.prototype.getCspRules = function () {
            if (!this.cspRules) {
                return [];
            }
            var blockingRules = [];
            var allowlistedRulesByDirective = new Map();
            for (var _i = 0, _a = this.cspRules; _i < _a.length; _i++) {
                var rule = _a[_i];
                if (rule.isAllowlist()) {
                    if (!rule.getAdvancedModifierValue()) { // Global allowlist rule
                        return [rule];
                    }
                    MatchingResult.putWithPriority(rule, undefined, allowlistedRulesByDirective);
                }
                else {
                    blockingRules.push(rule);
                }
            }
            var rulesByDirective = new Map();
            // Collect allowlist and blocking CSP rules in one array
            blockingRules.forEach(function (rule) {
                if (rule.getAdvancedModifierValue()) {
                    var allowlistRule = allowlistedRulesByDirective.get(rule.getAdvancedModifierValue());
                    MatchingResult.putWithPriority(rule, allowlistRule, rulesByDirective);
                }
            });
            return Array.from(rulesByDirective.values());
        };
        /**
         * Returns a redirect rule or null if redirect rules are empty.
         * $redirect-rule is only returned if there's a blocking rule also matching
         * this request.
         */
        MatchingResult.prototype.getRedirectRule = function () {
            if (!this.redirectRules) {
                return null;
            }
            // Apply allowlist $redirect rules.
            var result = MatchingResult.filterAdvancedModifierRules(this.redirectRules, function (rule) { return (function (x) { return x.getAdvancedModifierValue() === rule.getAdvancedModifierValue(); }); });
            // Filters only not allowlist rules.
            result = result.filter(function (r) { return !r.isAllowlist(); });
            // Splits $redirect and $redirect-rule into separate arrays.
            var conditionalRedirectRules = [];
            var allWeatherRedirectRules = [];
            result.forEach(function (rule) {
                var redirectModifier = rule.getAdvancedModifier();
                if (redirectModifier.isRedirectingOnlyBlocked) {
                    conditionalRedirectRules.push(rule);
                }
                else {
                    allWeatherRedirectRules.push(rule);
                }
            });
            if (allWeatherRedirectRules.length > 0) {
                return allWeatherRedirectRules
                    .sort(function (a, b) { return (b.isHigherPriority(a) ? 1 : -1); })[0];
            }
            if (conditionalRedirectRules.length > 0 && this.basicRule && !this.basicRule.isAllowlist()) {
                return conditionalRedirectRules
                    .sort(function (a, b) { return (b.isHigherPriority(a) ? 1 : -1); })[0];
            }
            return null;
        };
        /**
         * Returns an array of cookie rules
         */
        MatchingResult.prototype.getCookieRules = function () {
            if (!this.cookieRules) {
                return [];
            }
            var basic = this.getBasicResult();
            if ((basic === null || basic === void 0 ? void 0 : basic.isAllowlist()) && basic.isOptionEnabled(exports.NetworkRuleOption.Urlblock)) {
                return [];
            }
            var allowlistPredicate = function (rule) { return (function (allowlistRule) {
                var allowlistRuleCookieModifier = allowlistRule.getAdvancedModifier();
                var ruleCookieModifier = rule.getAdvancedModifier();
                if (allowlistRule.getAdvancedModifierValue() === rule.getAdvancedModifierValue()) {
                    return true;
                }
                // Matches by cookie name
                if (allowlistRuleCookieModifier.matches(ruleCookieModifier.getCookieName())) {
                    return true;
                }
                return false;
            }); };
            var filtered = MatchingResult.filterAdvancedModifierRules(this.cookieRules, allowlistPredicate);
            return filtered.concat(__spreadArray([], this.cookieRules.filter(function (r) { return r.isAllowlist(); }), true));
        };
        /**
         * Returns an array of removeparam rules
         */
        MatchingResult.prototype.getRemoveParamRules = function () {
            if (!this.removeParamRules) {
                return [];
            }
            return MatchingResult.filterAdvancedModifierRules(this.removeParamRules, 
            // eslint-disable-next-line arrow-body-style
            function (rule) { return (function (x) {
                return x.isHigherPriority(rule) && x.getAdvancedModifierValue() === rule.getAdvancedModifierValue();
            }); });
        };
        /**
         * Returns an array of removeheader rules
         */
        MatchingResult.prototype.getRemoveHeaderRules = function () {
            if (!this.removeHeaderRules) {
                return [];
            }
            if (this.basicRule
                && this.basicRule.isAllowlist()
                && this.basicRule.isOptionEnabled(exports.NetworkRuleOption.Urlblock)) {
                return [];
            }
            return MatchingResult.filterAdvancedModifierRules(this.removeHeaderRules, function (rule) { return (function (x) { return x.getAdvancedModifierValue() === rule.getAdvancedModifierValue(); }); });
        };
        /**
         * Decides which rule should be put into the given map.
         * Compares priorities of the two given rules with the equal CSP directive and the rule that may already in the map.
         *
         * @param rule CSP rule (not null)
         * @param allowlistRule CSP allowlist rule (may be null)
         * @param map Rules mapped by csp directive
         */
        // eslint-disable-next-line max-len
        MatchingResult.putWithPriority = function (rule, allowlistRule, map) {
            var cspDirective = rule.getAdvancedModifierValue();
            var currentRule = cspDirective ? map.get(cspDirective) : null;
            var newRule = rule;
            if (currentRule && !rule.isHigherPriority(currentRule)) {
                newRule = currentRule;
            }
            if (allowlistRule && allowlistRule.isHigherPriority(newRule)) {
                newRule = allowlistRule;
            }
            map.set(cspDirective, newRule);
        };
        /**
         * Looks if there are any matching $badfilter rules and removes
         * matching bad filters from the array (see the $badfilter description for more info)
         *
         * @param rules to filter
         * @return filtered rules
         */
        MatchingResult.removeBadfilterRules = function (rules) {
            var badfilterRules = [];
            for (var _i = 0, rules_3 = rules; _i < rules_3.length; _i++) {
                var rule = rules_3[_i];
                if (rule.isOptionEnabled(exports.NetworkRuleOption.Badfilter)) {
                    badfilterRules.push(rule);
                }
            }
            if (badfilterRules.length > 0) {
                return rules.filter(function (rule) {
                    if (rule.isOptionEnabled(exports.NetworkRuleOption.Badfilter)) {
                        return false;
                    }
                    var isRuleNegated = badfilterRules.some(function (badfilter) { return badfilter.negatesBadfilter(rule); });
                    return !isRuleNegated;
                });
            }
            return rules;
        };
        return MatchingResult;
    }());

    /**
     * Scanner types enum
     */
    var ScannerType;
    (function (ScannerType) {
        /**
         * Scanning for network rules
         */
        ScannerType[ScannerType["NetworkRules"] = 0] = "NetworkRules";
        /**
         * Scanning for cosmetic rules
         */
        ScannerType[ScannerType["CosmeticRules"] = 2] = "CosmeticRules";
        /**
         * Scanning for host rules
         */
        ScannerType[ScannerType["HostRules"] = 4] = "HostRules";
        /**
         * All
         */
        ScannerType[ScannerType["All"] = 6] = "All";
    })(ScannerType || (ScannerType = {}));

    /**
     * Prefix tree implementation
     */
    var TrieNode = /** @class */ (function () {
        /**
         * Creates an instance of a TrieNode with the specified char code.
         *
         * @param code
         */
        function TrieNode(code) {
            this.code = code;
        }
        /**
         * Attaches data to this TrieNode.
         *
         * @param data
         */
        TrieNode.prototype.attach = function (data) {
            if (!this.data) {
                this.data = [];
            }
            this.data.push(data);
        };
        /**
         * Adds the specified string to the Trie and attaches data to it.
         *
         * @param str string to add.
         * @param data data to attach to the leaf node.
         */
        TrieNode.prototype.add = function (str, data) {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var root = this;
            for (var i = 0; i < str.length; i += 1) {
                var c = str.charCodeAt(i);
                var next = root.getChild(c);
                if (!next) {
                    next = root.addChild(c);
                }
                root = next;
            }
            root.attach(data);
        };
        /**
         * Traverses this TrieNode and it's children using the specified search string.
         * This method collects all the data that's attached on the way and returns as
         * a result.
         *
         * @param str string to check.
         * @param start index in str where to start traversing from.
         */
        TrieNode.prototype.traverse = function (str, start) {
            var result = [];
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var current = this;
            for (var i = start; i < str.length; i += 1) {
                var c = str.charCodeAt(i);
                var next = current.getChild(c);
                if (!next) {
                    break;
                }
                if (next.data) {
                    result.push.apply(result, next.data);
                }
                current = next;
            }
            return result;
        };
        /**
         * Traverses this TrieNode and it's children using the specified search string and all substrings.
         *
         * @param str string to check
         * @param len max length to check
         */
        TrieNode.prototype.traverseAll = function (str, len) {
            var data = [];
            for (var i = 0; i <= len; i += 1) {
                var result = this.traverse(str, i);
                if (result) {
                    data.push.apply(data, result);
                }
            }
            return data;
        };
        /**
         * Returns a child node with the specified character code or
         * undefined if not found.
         *
         * @param code character code
         * @returns child node or undefined.
         */
        TrieNode.prototype.getChild = function (code) {
            var children = this.children;
            if (!children) {
                return undefined;
            }
            if (children instanceof TrieNode) {
                if (children.code === code) {
                    return children;
                }
                return undefined;
            }
            return children.get(code);
        };
        /**
         * Adds a new child node with the specified character code.
         *
         * @param code character code.
         * @returns the newly created TrieNode.
         */
        TrieNode.prototype.addChild = function (code) {
            var node = new TrieNode(code);
            if (!this.children) {
                this.children = node;
            }
            else if (this.children instanceof TrieNode) {
                var oldNode = this.children;
                this.children = new Map();
                this.children.set(oldNode.code, oldNode);
                this.children.set(code, node);
            }
            else {
                this.children.set(code, node);
            }
            return node;
        };
        return TrieNode;
    }());

    /**
     * Look up table with underlying prefix tree
     */
    var TrieLookupTable = /** @class */ (function () {
        /**
         * Creates a new instance of the TrieLookupTable.
         *
         * @param storage rules storage. We store "rule indexes" in the lookup table which
         * can be used to retrieve the full rules from the storage.
         */
        function TrieLookupTable(storage) {
            /**
             * Count of rules added to this lookup table.
             */
            this.rulesCount = 0;
            this.ruleStorage = storage;
            this.trie = new TrieNode(0);
        }
        /**
         * Finds all matching rules from the shortcuts lookup table
         *
         * @param request to check
         * @return array of matching rules
         */
        TrieLookupTable.prototype.matchAll = function (request) {
            var rulesIndexes = this.traverse(request);
            return this.matchRules(request, rulesIndexes);
        };
        /**
         * Tries to add the rule to the lookup table.
         * returns true if it was added
         *
         * @param rule to add
         * @param storageIdx index
         * @return {boolean} true if the rule been added
         */
        TrieLookupTable.prototype.addRule = function (rule, storageIdx) {
            var shortcut = rule.getShortcut();
            if (!shortcut || TrieLookupTable.isAnyURLShortcut(shortcut)
                || shortcut.length < SimpleRegex.MIN_SHORTCUT_LENGTH) {
                return false;
            }
            this.trie.add(shortcut, storageIdx);
            this.rulesCount += 1;
            return true;
        };
        /**
         * @return total rules count
         */
        TrieLookupTable.prototype.getRulesCount = function () {
            return this.rulesCount;
        };
        /**
         * For specified request finds matching rules from rules indexes array
         *
         * @param request
         * @param rulesIndexes
         */
        TrieLookupTable.prototype.matchRules = function (request, rulesIndexes) {
            if (!rulesIndexes) {
                return [];
            }
            var result = [];
            for (var j = 0; j < rulesIndexes.length; j += 1) {
                var idx = rulesIndexes[j];
                var rule = this.ruleStorage.retrieveNetworkRule(idx);
                if (rule && rule.match(request, false)) {
                    result.push(rule);
                }
            }
            return result;
        };
        /**
         * Traverses trie
         *
         * @param request
         */
        TrieLookupTable.prototype.traverse = function (request) {
            return this.trie.traverseAll(request.urlLowercase, request.urlLowercase.length);
        };
        /**
         * Checks if the rule potentially matches too many URLs.
         * We'd better use another type of lookup table for this kind of rules.
         *
         * @param shortcut to check
         * @return check result
         */
        TrieLookupTable.isAnyURLShortcut = function (shortcut) {
            // The numbers are basically ("PROTO://".length + 1)
            if (shortcut.length < 6 && shortcut.indexOf('ws:') === 0) {
                return true;
            }
            if (shortcut.length < 7 && shortcut.indexOf('|ws') === 0) {
                return true;
            }
            if (shortcut.length < 9 && shortcut.indexOf('http') === 0) {
                return true;
            }
            return !!(shortcut.length < 10 && shortcut.indexOf('|http') === 0);
        };
        return TrieLookupTable;
    }());

    /**
     * Domain lookup table. Key is the domain name hash.
     */
    var DomainsLookupTable = /** @class */ (function () {
        /**
         * Creates a new instance
         *
         * @param storage rules storage. We store "rule indexes" in the lookup table which
         * can be used to retrieve the full rules from the storage.
         */
        function DomainsLookupTable(storage) {
            /**
             * Count of rules added to this lookup table.
             */
            this.rulesCount = 0;
            /**
             * Domain lookup table. Key is the domain name hash.
             */
            this.domainsLookupTable = new Map();
            this.ruleStorage = storage;
        }
        /**
         * addRule implements the ILookupTable interface for DomainsLookupTable.
         * @param rule
         * @param storageIdx
         */
        DomainsLookupTable.prototype.addRule = function (rule, storageIdx) {
            var _this = this;
            var permittedDomains = rule.getPermittedDomains();
            if (!permittedDomains || permittedDomains.length === 0) {
                return false;
            }
            var hasWildcardDomain = permittedDomains.some(function (d) { return DomainModifier.isWildcardDomain(d); });
            if (hasWildcardDomain) {
                return false;
            }
            permittedDomains.forEach(function (domain) {
                var hash = fastHash(domain);
                // Add the rule to the lookup table
                var rulesIndexes = _this.domainsLookupTable.get(hash);
                if (!rulesIndexes) {
                    rulesIndexes = [];
                }
                rulesIndexes.push(storageIdx);
                _this.domainsLookupTable.set(hash, rulesIndexes);
            });
            this.rulesCount += 1;
            return true;
        };
        /**
         * Implements the ILookupTable interface method.
         */
        DomainsLookupTable.prototype.getRulesCount = function () {
            return this.rulesCount;
        };
        /**
         * Implements the ILookupTable interface method.
         * @param request
         */
        DomainsLookupTable.prototype.matchAll = function (request) {
            var result = [];
            if (!request.sourceHostname) {
                return result;
            }
            var domains = request.subdomains;
            if (request.hostname !== request.sourceHostname) {
                domains.push.apply(domains, request.sourceSubdomains);
            }
            for (var i = 0; i < domains.length; i += 1) {
                var hash = fastHash(domains[i]);
                var rulesIndexes = this.domainsLookupTable.get(hash);
                if (rulesIndexes) {
                    for (var j = 0; j < rulesIndexes.length; j += 1) {
                        var rule = this.ruleStorage.retrieveNetworkRule(rulesIndexes[j]);
                        if (rule && rule.match(request)) {
                            result.push(rule);
                        }
                    }
                }
            }
            return result;
        };
        return DomainsLookupTable;
    }());

    /**
     * Hostname lookup table.
     * For specific kind of rules like '||hostname^' and '||hostname/path' more simple algorithm with hashes is faster.
     */
    var HostnameLookupTable = /** @class */ (function () {
        /**
         * Creates a new instance
         *
         * @param storage rules storage. We store "rule indexes" in the lookup table which
         * can be used to retrieve the full rules from the storage.
         */
        function HostnameLookupTable(storage) {
            /**
             * Count of rules added to this lookup table.
             */
            this.rulesCount = 0;
            /**
             * Domain lookup table. Key is the domain name hash.
             */
            this.hostnameLookupTable = new Map();
            this.ruleStorage = storage;
        }
        /**
         * addRule implements the ILookupTable interface for DomainsLookupTable.
         * @param rule
         * @param storageIdx
         */
        HostnameLookupTable.prototype.addRule = function (rule, storageIdx) {
            var pattern = rule.getPattern();
            var hostname = '';
            // Pattern: '||example.org^'
            if (pattern.startsWith(SimpleRegex.MASK_START_URL) && pattern.endsWith(SimpleRegex.MASK_SEPARATOR)) {
                hostname = pattern.slice(SimpleRegex.MASK_START_URL.length, pattern.length - SimpleRegex.MASK_SEPARATOR.length);
            }
            // Pattern: '||example.org/path'
            if (pattern.startsWith(SimpleRegex.MASK_START_URL) && pattern.indexOf(SimpleRegex.MASK_BACKSLASH) !== -1) {
                var end = pattern.indexOf(SimpleRegex.MASK_BACKSLASH);
                hostname = pattern.slice(SimpleRegex.MASK_START_URL.length, end);
            }
            if (!HostnameLookupTable.isValidHostname(hostname)) {
                return false;
            }
            var hash = fastHash(hostname);
            var rulesIndexes = this.hostnameLookupTable.get(hash);
            if (!rulesIndexes) {
                rulesIndexes = new Array();
                this.hostnameLookupTable.set(hash, rulesIndexes);
            }
            rulesIndexes.push(storageIdx);
            this.rulesCount += 1;
            return true;
        };
        /**
         * Implements the ILookupTable interface method.
         */
        HostnameLookupTable.prototype.getRulesCount = function () {
            return this.rulesCount;
        };
        /**
         * Implements the ILookupTable interface method.
         * @param request
         */
        HostnameLookupTable.prototype.matchAll = function (request) {
            var result = [];
            var domains = request.subdomains;
            for (var i = 0; i < domains.length; i += 1) {
                var hash = fastHash(domains[i]);
                var rulesIndexes = this.hostnameLookupTable.get(hash);
                if (rulesIndexes) {
                    for (var j = 0; j < rulesIndexes.length; j += 1) {
                        var rule = this.ruleStorage.retrieveNetworkRule(rulesIndexes[j]);
                        if (rule && rule.match(request)) {
                            result.push(rule);
                        }
                    }
                }
            }
            return result;
        };
        /**
         * Checks if this hostname string is valid
         *
         * @param hostname
         */
        HostnameLookupTable.isValidHostname = function (hostname) {
            if (!hostname) {
                return false;
            }
            if (hostname.indexOf(SimpleRegex.MASK_ANY_CHARACTER) !== -1) {
                return false;
            }
            if (hostname.indexOf('.') < 0 || hostname.endsWith('.')) {
                return false;
            }
            return true;
        };
        return HostnameLookupTable;
    }());

    /**
     * Sequence scan lookup table of rules for which we could not find a shortcut
     * and could not place it to the shortcuts lookup table.
     * In common case of rule there is always a way to just check a rule.match().
     */
    var SeqScanLookupTable = /** @class */ (function () {
        function SeqScanLookupTable() {
            /**
             * Count of rules added to this lookup table.
             */
            this.rulesCount = 0;
            /**
             * Rules for which we could not find a shortcut and could not place it to the shortcuts lookup table.
             */
            this.rules = [];
        }
        /**
         * addRule implements the ILookupTable interface for SeqScanLookupTable.
         * @param rule
         */
        SeqScanLookupTable.prototype.addRule = function (rule) {
            if (!this.rules.includes(rule)) {
                this.rules.push(rule);
                this.rulesCount += 1;
                return true;
            }
            return false;
        };
        /**
         * Implements the ILookupTable interface method.
         */
        SeqScanLookupTable.prototype.getRulesCount = function () {
            return this.rulesCount;
        };
        /**
         * Implements the ILookupTable interface method.
         * @param request
         */
        SeqScanLookupTable.prototype.matchAll = function (request) {
            var result = [];
            for (var i = 0; i < this.rules.length; i += 1) {
                var r = this.rules[i];
                if (r.match(request)) {
                    result.push(r);
                }
            }
            return result;
        };
        return SeqScanLookupTable;
    }());

    /**
     * NetworkEngine is the engine that supports quick search over network rules
     */
    var NetworkEngine = /** @class */ (function () {
        /**
         * Builds an instance of the network engine
         *
         * @param storage an object for a rules storage.
         * @param skipStorageScan create an instance without storage scanning.
         */
        function NetworkEngine(storage, skipStorageScan) {
            if (skipStorageScan === void 0) { skipStorageScan = false; }
            this.ruleStorage = storage;
            this.rulesCount = 0;
            this.domainsLookupTable = new DomainsLookupTable(storage);
            this.hostnameLookupTable = new HostnameLookupTable(storage);
            this.shortcutsLookupTable = new TrieLookupTable(storage);
            this.seqScanLookupTable = new SeqScanLookupTable();
            if (skipStorageScan) {
                return;
            }
            var scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.NetworkRules);
            while (scanner.scan()) {
                var indexedRule = scanner.getRule();
                if (indexedRule
                    && indexedRule.rule instanceof NetworkRule) {
                    this.addRule(indexedRule.rule, indexedRule.index);
                }
            }
        }
        /**
         * Match searches over all filtering rules loaded to the engine
         * It returns rule if a match was found alongside the matching rule
         *
         * @param request to check
         * @return rule matching request or null
         */
        NetworkEngine.prototype.match = function (request) {
            var networkRules = this.matchAll(request);
            if (networkRules.length === 0) {
                return null;
            }
            var result = new MatchingResult(networkRules, null);
            return result.getBasicResult();
        };
        /**
         * Finds all rules matching the specified request regardless of the rule types
         * It will find both allowlist and blacklist rules
         *
         * @param request to check
         * @return array of matching rules
         */
        NetworkEngine.prototype.matchAll = function (request) {
            // First check by shortcuts
            var result = this.hostnameLookupTable.matchAll(request);
            result.push.apply(result, (this.shortcutsLookupTable.matchAll(request)));
            result.push.apply(result, (this.domainsLookupTable.matchAll(request)));
            result.push.apply(result, (this.seqScanLookupTable.matchAll(request)));
            return result;
        };
        /**
         * Adds rule to the network engine
         *
         * @param rule
         * @param storageIdx
         */
        NetworkEngine.prototype.addRule = function (rule, storageIdx) {
            if (!this.hostnameLookupTable.addRule(rule, storageIdx)) {
                if (!this.shortcutsLookupTable.addRule(rule, storageIdx)) {
                    if (!this.domainsLookupTable.addRule(rule, storageIdx)) {
                        this.seqScanLookupTable.addRule(rule, storageIdx);
                    }
                }
            }
            this.rulesCount += 1;
        };
        return NetworkEngine;
    }());

    /**
     * Request represents a web request with all it's necessary properties
     */
    var Request$1 = /** @class */ (function () {
        /**
         * Creates an instance of a Request
         *
         * @param url - request URL
         * @param sourceUrl - source URL
         * @param requestType - request type
         * @param method - request method
         *
         * @throws
         */
        function Request(url, sourceUrl, requestType, method) {
            /**
             * the request is for a given Hostname, and not for a URL, and we don't really know what protocol it is.
             * This can be true for DNS requests, or for HTTP CONNECT, or SNI matching.
             */
            this.isHostnameRequest = false;
            if (typeof url !== 'string') {
                throw new TypeError("Invalid request url: ".concat(url));
            }
            this.url = url;
            this.requestType = requestType;
            this.method = method;
            this.urlLowercase = Request.compactUrl(url).toLowerCase();
            this.sourceUrl = Request.compactUrl(sourceUrl);
            var tldResult = parse$1(url);
            this.hostname = tldResult.hostname;
            this.domain = tldResult.domain;
            this.subdomains = Request.getSubdomains(tldResult);
            var sourceTldResult;
            if (sourceUrl) {
                sourceTldResult = parse$1(sourceUrl);
                this.sourceHostname = sourceTldResult.hostname;
                this.sourceDomain = sourceTldResult.domain;
                this.sourceSubdomains = Request.getSubdomains(sourceTldResult);
            }
            else {
                this.sourceHostname = null;
                this.sourceDomain = null;
                this.sourceSubdomains = [];
            }
            if (this.sourceDomain) {
                this.thirdParty = this.domain !== this.sourceDomain;
            }
            else if (sourceTldResult && sourceTldResult.isIp) {
                this.thirdParty = this.hostname !== this.sourceHostname;
            }
            else {
                this.thirdParty = null;
            }
        }
        /**
         * We cut the url in performance purposes
         * @param url
         */
        Request.compactUrl = function (url) {
            var compacted = url;
            if (compacted && compacted.length > Request.MAX_URL_MATCH_LENGTH) {
                compacted = compacted.substring(0, Request.MAX_URL_MATCH_LENGTH);
            }
            return compacted;
        };
        /**
        * Splits subdomains and returns all subdomains (including the hostname itself)
        *
        * @param tldResult
        * @returns array of subdomains
        */
        Request.getSubdomains = function (tldResult) {
            var domain = tldResult.domain, hostname = tldResult.hostname, subdomain = tldResult.subdomain, publicSuffix = tldResult.publicSuffix;
            var subdomainsResult = [];
            if (!domain) {
                if (hostname) {
                    subdomainsResult.push(hostname);
                    return subdomainsResult;
                }
                return [];
            }
            if (publicSuffix) {
                subdomainsResult.push(publicSuffix);
                // Extract subdomains from complex suffixes
                // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/2037
                // https://github.com/AdguardTeam/tsurlfilter/issues/57
                for (var i = 0; i < publicSuffix.length; i += 1) {
                    if (publicSuffix[i] === '.') {
                        subdomainsResult.push(publicSuffix.slice(i + 1));
                    }
                }
            }
            subdomainsResult.push(domain);
            if (!subdomain) {
                return subdomainsResult;
            }
            var parts = subdomain.split('.');
            var incrementDomain = domain;
            for (var i = parts.length - 1; i >= 0; i -= 1) {
                incrementDomain = "".concat(parts[i], ".").concat(incrementDomain);
                subdomainsResult.push(incrementDomain);
            }
            return subdomainsResult;
        };
        /**
         * Max url length for matching
         * Some urls are really long and slow down matching, so we cut them to this length.
         */
        Request.MAX_URL_MATCH_LENGTH = 2000;
        return Request;
    }());

    /**
     * DnsResult contains a network rule and host rules matching request
     */
    var DnsResult = /** @class */ (function () {
        function DnsResult() {
            /**
             * BasicRule - a network rule matching the request.
             */
            this.basicRule = null;
            /**
             * Host rules
             */
            this.hostRules = [];
        }
        return DnsResult;
    }());

    /**
     * DNSEngine combines host rules and network rules and is supposed to quickly find
     * matching rules for hostnames.
     * First, it looks over network rules and returns first rule found.
     * Then, if nothing found, it looks up the host rules.
     */
    var DnsEngine = /** @class */ (function () {
        /**
         * Builds an instance of dns engine
         *
         * @param storage
         */
        function DnsEngine(storage) {
            this.ruleStorage = storage;
            this.rulesCount = 0;
            this.lookupTable = new Map();
            this.networkEngine = new NetworkEngine(storage, true);
            var scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.HostRules);
            while (scanner.scan()) {
                var indexedRule = scanner.getRule();
                if (indexedRule) {
                    if (indexedRule.rule instanceof HostRule) {
                        this.addRule(indexedRule.rule, indexedRule.index);
                    }
                    else if (indexedRule.rule instanceof NetworkRule
                        && indexedRule.rule.isHostLevelNetworkRule()) {
                        this.networkEngine.addRule(indexedRule.rule, indexedRule.index);
                    }
                }
            }
        }
        /**
         * Match searches over all filtering and host rules loaded to the engine
         *
         * @param hostname to check
         * @return dns result object
         */
        DnsEngine.prototype.match = function (hostname) {
            var result = new DnsResult();
            if (!hostname) {
                return result;
            }
            var url = "http://".concat(hostname, "/");
            var request = new Request$1(url, url, RequestType.Document);
            request.isHostnameRequest = true;
            var networkRule = this.networkEngine.match(request);
            if (networkRule) {
                // Network rules always have higher priority
                result.basicRule = networkRule;
                return result;
            }
            var hash = fastHash(hostname);
            var rulesIndexes = this.lookupTable.get(hash);
            if (rulesIndexes) {
                for (var j = 0; j < rulesIndexes.length; j += 1) {
                    var rule = this.ruleStorage.retrieveHostRule(rulesIndexes[j]);
                    if (rule && rule.match(hostname)) {
                        result.hostRules.push(rule);
                    }
                }
            }
            return result;
        };
        /**
         * Adds rule to engine
         *
         * @param rule
         * @param storageIdx
         */
        DnsEngine.prototype.addRule = function (rule, storageIdx) {
            var _this = this;
            rule.getHostnames().forEach(function (hostname) {
                var hash = fastHash(hostname);
                // Add the rule to the lookup table
                var rulesIndexes = _this.lookupTable.get(hash);
                if (!rulesIndexes) {
                    rulesIndexes = [];
                }
                rulesIndexes.push(storageIdx);
                _this.lookupTable.set(hash, rulesIndexes);
            });
            this.rulesCount += 1;
        };
        return DnsEngine;
    }());

    var lru = {exports: {}};

    (function (module, exports) {
    	!function(g,c){c(exports);}(commonjsGlobal,function(g){const c=Symbol("newer"),e=Symbol("older");class n{constructor(a,b){typeof a!=="number"&&(b=a,a=0),this.size=0,this.limit=a,this.oldest=this.newest=void 0,this._keymap=new Map(),b&&(this.assign(b),a<1&&(this.limit=this.size));}_markEntryAsUsed(a){if(a===this.newest)return;a[c]&&(a===this.oldest&&(this.oldest=a[c]),a[c][e]=a[e]),a[e]&&(a[e][c]=a[c]),a[c]=void 0,a[e]=this.newest,this.newest&&(this.newest[c]=a),this.newest=a;}assign(a){let b,d=this.limit||Number.MAX_VALUE;this._keymap.clear();let m=a[Symbol.iterator]();for(let h=m.next();!h.done;h=m.next()){let f=new l(h.value[0],h.value[1]);this._keymap.set(f.key,f),b?(b[c]=f,f[e]=b):this.oldest=f,b=f;if(d--==0)throw new Error("overflow")}this.newest=b,this.size=this._keymap.size;}get(a){var b=this._keymap.get(a);return b?(this._markEntryAsUsed(b),b.value):void 0}set(a,b){var d=this._keymap.get(a);return d?(d.value=b,this._markEntryAsUsed(d),this):(this._keymap.set(a,d=new l(a,b)),this.newest?(this.newest[c]=d,d[e]=this.newest):this.oldest=d,this.newest=d,++this.size,this.size>this.limit&&this.shift(),this)}shift(){var a=this.oldest;if(a)return this.oldest[c]?(this.oldest=this.oldest[c],this.oldest[e]=void 0):(this.oldest=void 0,this.newest=void 0),a[c]=a[e]=void 0,this._keymap.delete(a.key),--this.size,[a.key,a.value]}find(a){let b=this._keymap.get(a);return b?b.value:void 0}has(a){return this._keymap.has(a)}delete(a){var b=this._keymap.get(a);return b?(this._keymap.delete(b.key),b[c]&&b[e]?(b[e][c]=b[c],b[c][e]=b[e]):b[c]?(b[c][e]=void 0,this.oldest=b[c]):b[e]?(b[e][c]=void 0,this.newest=b[e]):this.oldest=this.newest=void 0,this.size--,b.value):void 0}clear(){this.oldest=this.newest=void 0,this.size=0,this._keymap.clear();}keys(){return new j(this.oldest)}values(){return new k(this.oldest)}entries(){return this}[Symbol.iterator](){return new i(this.oldest)}forEach(a,b){typeof b!=="object"&&(b=this);let d=this.oldest;for(;d;)a.call(b,d.value,d.key,this),d=d[c];}toJSON(){for(var a=new Array(this.size),b=0,d=this.oldest;d;)a[b++]={key:d.key,value:d.value},d=d[c];return a}toString(){for(var a="",b=this.oldest;b;)a+=String(b.key)+":"+b.value,b=b[c],b&&(a+=" < ");return a}}g.LRUMap=n;function l(a,b){this.key=a,this.value=b,this[c]=void 0,this[e]=void 0;}function i(a){this.entry=a;}i.prototype[Symbol.iterator]=function(){return this},i.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:[a.key,a.value]}):{done:!0,value:void 0}};function j(a){this.entry=a;}j.prototype[Symbol.iterator]=function(){return this},j.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.key}):{done:!0,value:void 0}};function k(a){this.entry=a;}k.prototype[Symbol.iterator]=function(){return this},k.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.value}):{done:!0,value:void 0}};});
    	
    } (lru, lru.exports));

    /**
     * CosmeticLookupTable lets quickly lookup cosmetic rules for the specified hostname.
     * It is primarily used by the {@see CosmeticEngine}.
     */
    var CosmeticLookupTable = /** @class */ (function () {
        /**
         * Creates a new instance
         *
         * @param storage rules storage. We store "rule indexes" in the lookup table which
         * can be used to retrieve the full rules from the storage.
         */
        function CosmeticLookupTable(storage) {
            this.byHostname = new Map();
            this.wildcardRules = [];
            this.genericRules = [];
            this.allowlist = new Map();
            this.ruleStorage = storage;
        }
        /**
         * Adds rule to the appropriate collection
         * @param rule
         * @param storageIdx
         */
        CosmeticLookupTable.prototype.addRule = function (rule, storageIdx) {
            if (rule.isAllowlist()) {
                var key = rule.getContent();
                var existingRules = this.allowlist.get(key) || [];
                existingRules.push(storageIdx);
                this.allowlist.set(key, existingRules);
                return;
            }
            if (rule.isGeneric()) {
                this.genericRules.push(rule);
                return;
            }
            var domains = rule.getPermittedDomains();
            if (domains) {
                var hasWildcardDomain = domains.some(function (d) { return DomainModifier.isWildcardDomain(d); });
                if (hasWildcardDomain) {
                    this.wildcardRules.push(rule);
                    return;
                }
                for (var _i = 0, domains_1 = domains; _i < domains_1.length; _i++) {
                    var domain = domains_1[_i];
                    var tldResult = parse$1(domain);
                    // tldResult.domain equals to eTLD domain,
                    // e.g. sub.example.uk.org would result in example.uk.org
                    var parsedDomain = tldResult.domain || domain;
                    var key = fastHash(parsedDomain);
                    var rules = this.byHostname.get(key) || [];
                    rules.push(storageIdx);
                    this.byHostname.set(key, rules);
                }
            }
        };
        /**
         * Finds rules by hostname
         * @param request
         * @param subdomains
         */
        CosmeticLookupTable.prototype.findByHostname = function (request) {
            var result = [];
            var subdomains = request.subdomains;
            var _loop_1 = function (i) {
                var subdomain = subdomains[i];
                var rulesIndexes = this_1.byHostname.get(fastHash(subdomain));
                if (rulesIndexes) {
                    // Filtering out duplicates
                    rulesIndexes = rulesIndexes.filter(function (v, index) { return rulesIndexes.indexOf(v) === index; });
                    for (var j = 0; j < rulesIndexes.length; j += 1) {
                        var rule = this_1.ruleStorage.retrieveRule(rulesIndexes[j]);
                        if (rule && rule.match(request)) {
                            result.push(rule);
                        }
                    }
                }
            };
            var this_1 = this;
            // Iterate over all sub-domains
            for (var i = 0; i < subdomains.length; i += 1) {
                _loop_1(i);
            }
            result.push.apply(result, this.wildcardRules.filter(function (r) { return r.match(request); }));
            return result.filter(function (rule) { return !rule.isAllowlist(); });
        };
        /**
         * Checks if the rule is disabled on the specified hostname.
         * @param request
         * @param rule
         */
        CosmeticLookupTable.prototype.isAllowlisted = function (request, rule) {
            var rulesIndexes = this.allowlist.get(rule.getContent());
            if (!rulesIndexes) {
                return false;
            }
            for (var j = 0; j < rulesIndexes.length; j += 1) {
                var r = this.ruleStorage.retrieveRule(rulesIndexes[j]);
                if (r && r.match(request)) {
                    return true;
                }
            }
            return false;
        };
        return CosmeticLookupTable;
    }());

    /**
     * Enumeration with the cosmetic rules markers.
     *
     * All cosmetic rules have similar structure:
     * ```
     * rule = [domains] "marker" content
     * domains = [domain0, domain1[, ...[, domainN]]]
     * ```
     *
     * For instance, element hiding rules look like:
     * `example.org##.banner`
     *
     * In this case:
     * * `[domains]` is `example.org` (comma-separated list of domains)
     * * `marker` is `##` (marker of element hiding rules)
     * * `content` is `.banner` (CSS selector)
     */
    exports.CosmeticRuleMarker = void 0;
    (function (CosmeticRuleMarker) {
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-elemhide-rules */
        CosmeticRuleMarker["ElementHiding"] = "##";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#element-hiding-rules-exceptions */
        CosmeticRuleMarker["ElementHidingException"] = "#@#";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#extended-css-selectors */
        CosmeticRuleMarker["ElementHidingExtCSS"] = "#?#";
        /** Basically the same as {@link CosmeticRuleMarker.ElementHidingException} */
        CosmeticRuleMarker["ElementHidingExtCSSException"] = "#@?#";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules */
        CosmeticRuleMarker["Css"] = "#$#";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules-exceptions */
        CosmeticRuleMarker["CssException"] = "#@$#";
        /**
         * CSS rules that use extended CSS selectors:
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#extended-css-selectors
         */
        CosmeticRuleMarker["CssExtCSS"] = "#$?#";
        /** Basically the same as {@link CosmeticRuleMarker.CssException} */
        CosmeticRuleMarker["CssExtCSSException"] = "#@$?#";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#javascript-rules */
        CosmeticRuleMarker["Js"] = "#%#";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#javascript-rules-exceptions-1 */
        CosmeticRuleMarker["JsException"] = "#@%#";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules */
        CosmeticRuleMarker["Html"] = "$$";
        /** https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules-exceptions-1 */
        CosmeticRuleMarker["HtmlException"] = "$@$";
    })(exports.CosmeticRuleMarker || (exports.CosmeticRuleMarker = {}));
    /**
     * findCosmeticRuleMarker looks for a cosmetic rule marker in the rule text
     * and returns the start index of the marker and the marker found.
     * If nothing found, it returns -1 and null.
     *
     * @privateRemarks
     *
     * The idea is to search for the rule marker as quickly as possible.
     * If we were simply using `Array.includes` we had to call it a dozen of times (for every marker),
     * and that'd have been much slower.
     *
     * @param ruleText - rule text to scan.
     */
    function findCosmeticRuleMarker(ruleText) {
        var maxIndex = ruleText.length - 1;
        for (var i = 0; i < maxIndex; i += 1) {
            var char = ruleText.charAt(i);
            switch (char) {
                case '#':
                    if (i + 4 <= maxIndex) {
                        if (ruleText.charAt(i + 1) === '@'
                            && ruleText.charAt(i + 2) === '$'
                            && ruleText.charAt(i + 3) === '?'
                            && ruleText.charAt(i + 4) === '#') {
                            return [i, exports.CosmeticRuleMarker.CssExtCSSException];
                        }
                    }
                    if (i + 3 <= maxIndex) {
                        if (ruleText.charAt(i + 1) === '@'
                            && ruleText.charAt(i + 2) === '?' && ruleText.charAt(i + 3) === '#') {
                            return [i, exports.CosmeticRuleMarker.ElementHidingExtCSSException];
                        }
                        if (ruleText.charAt(i + 1) === '@'
                            && ruleText.charAt(i + 2) === '$' && ruleText.charAt(i + 3) === '#') {
                            return [i, exports.CosmeticRuleMarker.CssException];
                        }
                        if (ruleText.charAt(i + 1) === '@'
                            && ruleText.charAt(i + 2) === '%' && ruleText.charAt(i + 3) === '#') {
                            return [i, exports.CosmeticRuleMarker.JsException];
                        }
                        if (ruleText.charAt(i + 1) === '$'
                            && ruleText.charAt(i + 2) === '?' && ruleText.charAt(i + 3) === '#') {
                            return [i, exports.CosmeticRuleMarker.CssExtCSS];
                        }
                    }
                    if (i + 2 <= maxIndex) {
                        if (ruleText.charAt(i + 1) === '@' && ruleText.charAt(i + 2) === '#') {
                            return [i, exports.CosmeticRuleMarker.ElementHidingException];
                        }
                        if (ruleText.charAt(i + 1) === '?' && ruleText.charAt(i + 2) === '#') {
                            return [i, exports.CosmeticRuleMarker.ElementHidingExtCSS];
                        }
                        if (ruleText.charAt(i + 1) === '%' && ruleText.charAt(i + 2) === '#') {
                            return [i, exports.CosmeticRuleMarker.Js];
                        }
                        if (ruleText.charAt(i + 1) === '$' && ruleText.charAt(i + 2) === '#') {
                            return [i, exports.CosmeticRuleMarker.Css];
                        }
                    }
                    if (i + 1 <= maxIndex) {
                        if (ruleText.charAt(i + 1) === '#') {
                            // Handling false positives while looking for cosmetic rules in host files.
                            //
                            // For instance, it could look like this:
                            // 127.0.0.1 localhost ## this is just a comment
                            if (i > 0 && ruleText.charAt(i - 1) === ' ') {
                                return [-1, null];
                            }
                            return [i, exports.CosmeticRuleMarker.ElementHiding];
                        }
                    }
                    break;
                case '$':
                    if (i + 2 <= maxIndex) {
                        if (ruleText.charAt(i + 1) === '@' && ruleText.charAt(i + 2) === '$') {
                            return [i, exports.CosmeticRuleMarker.HtmlException];
                        }
                    }
                    if (i + 1 <= maxIndex) {
                        if (ruleText.charAt(i + 1) === '$') {
                            return [i, exports.CosmeticRuleMarker.Html];
                        }
                    }
                    break;
            }
        }
        return [-1, null];
    }
    /**
     * Detects is the rule is extended css rule
     * @param marker - string to check
     */
    function isExtCssMarker(marker) {
        var EXTENDED_CSS_MARKERS = [
            exports.CosmeticRuleMarker.CssExtCSS,
            exports.CosmeticRuleMarker.CssExtCSSException,
            exports.CosmeticRuleMarker.ElementHidingExtCSS,
            exports.CosmeticRuleMarker.ElementHidingExtCSSException,
        ];
        return EXTENDED_CSS_MARKERS.indexOf(marker) !== -1;
    }
    /**
     * AdGuard scriptlet rule mask
     */
    var ADG_SCRIPTLET_MASK = '//scriptlet';

    var CosmeticRuleModifiers;
    (function (CosmeticRuleModifiers) {
        CosmeticRuleModifiers["Path"] = "path";
        CosmeticRuleModifiers["Domain"] = "domain";
    })(CosmeticRuleModifiers || (CosmeticRuleModifiers = {}));
    var CosmeticRuleModifiersSyntax = {
        OpenBracket: '[',
        CloseBracket: ']',
        SpecialSymbol: '$',
        Delimiter: ',',
        Assigner: '=',
        EscapeCharacter: '\\',
    };

    var cosmeticRuleModifiersList = Object.values(CosmeticRuleModifiers);
    /**
     * Helper class for parsing text of cosmetic rules
     * used by CosmeticRule and [Filter compiler](https://github.com/AdguardTeam/FiltersCompiler)
     *
     *
     * The cosmetic rule contains of the following parts:
     *
     * `pattern##content`
     *
     * `pattern` contains the list of the rule modifiers and domains.
     *
     * `##` is a marker (might be a different marker depending on the rule type).
     * You can find the list of markers in the CosmeticRuleMarker enumeration.
     *
     * `content` might be a CSS selector, a scriptlet or something else, depending on the rule type.
     */
    var CosmeticRuleParser = /** @class */ (function () {
        function CosmeticRuleParser() {
        }
        /**
         * Parse the rule's pattern, cosmetic marker and the content parts from the rule text.
         * If the content is empty, throws a SyntaxError.
         *
         * @param ruleText
         * @returns Object with pattern, marker and content text parts
         */
        CosmeticRuleParser.parseRuleTextByMarker = function (ruleText) {
            var _a = findCosmeticRuleMarker(ruleText), markerIndex = _a[0], marker = _a[1];
            if (marker === null) {
                throw new SyntaxError('Not a cosmetic rule');
            }
            var content = ruleText.substring(markerIndex + marker.length).trim();
            if (!content) {
                throw new SyntaxError('Rule content is empty');
            }
            var pattern;
            if (markerIndex > 0) {
                pattern = ruleText.substring(0, markerIndex);
            }
            return {
                pattern: pattern,
                marker: marker,
                content: content,
            };
        };
        /**
         * Extracts the rule modifiers and domains from the rule pattern.
         * @param rulePattern
         * @returns Object with modifiers and domains text parts
         */
        CosmeticRuleParser.parseRulePatternText = function (rulePattern) {
            var OpenBracket = CosmeticRuleModifiersSyntax.OpenBracket, CloseBracket = CosmeticRuleModifiersSyntax.CloseBracket, SpecialSymbol = CosmeticRuleModifiersSyntax.SpecialSymbol, EscapeCharacter = CosmeticRuleModifiersSyntax.EscapeCharacter;
            if (!rulePattern.startsWith("".concat(OpenBracket + SpecialSymbol))) {
                return { domainsText: rulePattern };
            }
            var closeBracketIndex;
            // The first two characters cannot be closing brackets
            for (var i = 2; i < rulePattern.length; i += 1) {
                if (rulePattern[i] === CloseBracket && rulePattern[i - 1] !== EscapeCharacter) {
                    closeBracketIndex = i;
                    break;
                }
            }
            if (!closeBracketIndex) {
                throw new SyntaxError('Can\'t parse modifiers list');
            }
            // Handle this case: `[$]`
            if (closeBracketIndex === 2) {
                throw new SyntaxError('Modifiers list can\'t be empty');
            }
            var modifiersText = rulePattern.slice(2, closeBracketIndex);
            var domainsText;
            if (closeBracketIndex < rulePattern.length - 1) {
                domainsText = rulePattern.slice(closeBracketIndex + 1);
            }
            return {
                modifiersText: modifiersText,
                domainsText: domainsText,
            };
        };
        /**
         * Parses the list of modifiers. Parsing is done in the same way as it's done in the NetworkRule, i.e.
         * we have a comma-separated list of modifier-value pairs.
         * If we encounter an invalid modifier, this method throws a SyntaxError.
         *
         * @param modifiersText - list of modifiers splited by comma
         * @returns - modifiers collection object
         */
        CosmeticRuleParser.parseRuleModifiers = function (modifiersText) {
            if (!modifiersText) {
                return null;
            }
            var Assigner = CosmeticRuleModifiersSyntax.Assigner;
            var modifiersTextArray = parseOptionsString(modifiersText, false);
            var modifiers = Object.create(null);
            for (var i = 0; i < modifiersTextArray.length; i += 1) {
                var modifierText = modifiersTextArray[i];
                var assignerIndex = modifierText.indexOf(Assigner);
                if (modifierText === 'path') {
                    // Empty path modifier without assigner and value will match only main page
                    modifiers[modifierText] = '';
                    continue;
                }
                if (assignerIndex === -1) {
                    throw new SyntaxError('Modifier must have assigned value');
                }
                var modifierKey = modifierText.substring(0, assignerIndex);
                if (cosmeticRuleModifiersList.includes(modifierKey)) {
                    var modifierValue = modifierText.substring(assignerIndex + 1);
                    modifiers[modifierKey] = modifierValue;
                }
                else {
                    throw new SyntaxError("'".concat(modifierKey, "' is not valid modifier"));
                }
            }
            return modifiers;
        };
        /**
         * Parses the rule pattern and extracts the permitted/restricted domains and the unescaped path modifier value,
         * If domains are declared through $domain modifier and pattern domain list, this method throws a SyntaxError.
         * @param rulePattern - rule pattern text
         *
         * @returns Object with permitted/restricted domains list and the path modifier string value
         */
        CosmeticRuleParser.parseRulePattern = function (rulePattern) {
            var _a = CosmeticRuleParser.parseRulePatternText(rulePattern), domainsText = _a.domainsText, modifiersText = _a.modifiersText;
            var domains = domainsText;
            var path;
            var modifiers = CosmeticRuleParser.parseRuleModifiers(modifiersText);
            if (modifiers) {
                if (modifiers.path || modifiers.path === '') {
                    path = modifiers.path;
                    if (SimpleRegex.isRegexPattern(path)) {
                        path = SimpleRegex.unescapeRegexSpecials(path, SimpleRegex.reModifierPatternEscapedSpecialCharacters);
                    }
                }
                if (modifiers.domain) {
                    if (domains) {
                        throw new SyntaxError('The $domain modifier is not allowed in a domain-specific rule');
                    }
                    else {
                        domains = modifiers.domain;
                    }
                }
            }
            var permittedDomains;
            var restrictedDomains;
            // Skip wildcard domain
            if (domains && domains !== SimpleRegex.MASK_ANY_CHARACTER) {
                var separator = (modifiers === null || modifiers === void 0 ? void 0 : modifiers.domain) ? PIPE_SEPARATOR : COMMA_SEPARATOR;
                var domainModifier = new DomainModifier(domains, separator);
                if (domainModifier.permittedDomains) {
                    permittedDomains = domainModifier.permittedDomains;
                }
                if (domainModifier.restrictedDomains) {
                    restrictedDomains = domainModifier.restrictedDomains;
                }
            }
            return {
                path: path,
                permittedDomains: permittedDomains,
                restrictedDomains: restrictedDomains,
            };
        };
        return CosmeticRuleParser;
    }());

    /* eslint-disable @typescript-eslint/no-explicit-any */
    /**
     * Scriptlets helper class
     */
    // eslint-disable-next-line max-classes-per-file
    var ScriptletParser = /** @class */ (function () {
        function ScriptletParser() {
        }
        /**
         * Iterate over iterable argument and evaluate current state with transitions
         *
         * @param {Array|Collection|string} iterable
         * @param {Object} transitions transition functions
         * @param {string} initState first transition name
         * @param {any} args arguments which should be passed to transition functions
         * @returns {string} transition
         */
        ScriptletParser.iterateWithTransitions = function (iterable, transitions, initState, args) {
            var state = initState;
            for (var i = 0; i < iterable.length; i += 1) {
                state = transitions[state](iterable, i, args);
            }
            return state;
        };
        /**
         * Parse and validate scriptlet rule
         * @param {*} ruleContent
         * @returns {{name: string, args: Array<string>}}
         */
        ScriptletParser.parseRule = function (ruleContent) {
            var _a;
            var transitions = (_a = {},
                _a[ScriptletParser.TRANSITION.OPENED] = ScriptletParser.opened,
                _a[ScriptletParser.TRANSITION.PARAM] = ScriptletParser.param,
                _a[ScriptletParser.TRANSITION.CLOSED] = function () { },
                _a);
            var sep = { symb: null };
            var saver = new ScriptletParser.WordSaver();
            var state = ScriptletParser.iterateWithTransitions(ruleContent, transitions, ScriptletParser.TRANSITION.OPENED, { sep: sep, saver: saver });
            if (state !== 'closed') {
                throw new Error("Invalid scriptlet ".concat(ruleContent));
            }
            var args = saver.getAll();
            return {
                name: args[0],
                args: args.slice(1),
            };
        };
        /**
         * Helper class to accumulate an array of strings char by char
         */
        ScriptletParser.WordSaver = /** @class */ (function () {
            function class_1() {
                /**
                 * String cursor
                 */
                this.str = '';
                /**
                 * Strings array
                 */
                this.collectedStrings = [];
            }
            /**
             * Saves symbol to cursor
             *
             * @param s
             */
            class_1.prototype.saveSymbol = function (s) {
                this.str += s;
            };
            /**
             * Saves cursor to strings
             */
            class_1.prototype.saveStr = function () {
                this.collectedStrings.push(this.str);
                this.str = '';
            };
            /**
             * Returns collected strings
             */
            class_1.prototype.getAll = function () {
                return __spreadArray([], this.collectedStrings, true);
            };
            return class_1;
        }());
        /**
         * Transition names
         */
        ScriptletParser.TRANSITION = {
            OPENED: 'opened',
            PARAM: 'param',
            CLOSED: 'closed',
        };
        /**
         * Transition function: the current index position in start, end or between params
         * @param {string} rule
         * @param {number} index
         * @param {Object} Object
         * @property {Object} Object.sep contains prop symb with current separator char
         * @returns {string} transition
         */
        ScriptletParser.opened = function (rule, index, _a) {
            var sep = _a.sep;
            var char = rule[index];
            switch (char) {
                case ' ':
                case '(':
                case ',':
                    return ScriptletParser.TRANSITION.OPENED;
                case '\'':
                case '"':
                    // eslint-disable-next-line no-param-reassign
                    sep.symb = char;
                    return ScriptletParser.TRANSITION.PARAM;
                case ')':
                    return index === rule.length - 1
                        ? ScriptletParser.TRANSITION.CLOSED
                        : ScriptletParser.TRANSITION.OPENED;
            }
            return undefined;
        };
        /**
         * Transition function: the current index position inside param
         *
         * @param {string} rule
         * @param {number} index
         * @param {Object} Object
         * @property {Object} Object.sep contains prop `symb` with current separator char
         * @property {Object} Object.saver helper which allow to save strings by car by char
         * @returns {string} transition
         */
        ScriptletParser.param = function (rule, index, _a) {
            var saver = _a.saver, sep = _a.sep;
            var char = rule[index];
            switch (char) {
                case '\'':
                case '"':
                    if (char === sep.symb && rule[index - 1] !== '\\') {
                        // eslint-disable-next-line no-param-reassign
                        sep.symb = null;
                        saver.saveStr();
                        return ScriptletParser.TRANSITION.OPENED;
                    }
                    saver.saveSymbol(char);
                    return ScriptletParser.TRANSITION.PARAM;
                default:
                    saver.saveSymbol(char);
                    return ScriptletParser.TRANSITION.PARAM;
            }
        };
        return ScriptletParser;
    }());

    /**
     * CosmeticRuleType is an enumeration of the possible
     * cosmetic rule types.
     * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-rules
     */
    exports.CosmeticRuleType = void 0;
    (function (CosmeticRuleType) {
        /**
         * Cosmetic rules that just hide page elements.
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#element-hiding-rules
         */
        CosmeticRuleType[CosmeticRuleType["ElementHiding"] = 0] = "ElementHiding";
        /**
         * Cosmetic rules that allow adding custom CSS styles.
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules
         */
        CosmeticRuleType[CosmeticRuleType["Css"] = 1] = "Css";
        /**
         * Cosmetic rules that allow executing custom JS scripts.
         * Some restrictions are applied to this type of rules by default.
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#javascript-rules
         */
        CosmeticRuleType[CosmeticRuleType["Js"] = 2] = "Js";
        /**
         * Special type of rules that allows filtering HTML code of web pages.
         * https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules
         */
        CosmeticRuleType[CosmeticRuleType["Html"] = 3] = "Html";
    })(exports.CosmeticRuleType || (exports.CosmeticRuleType = {}));
    /**
     * Pseudo class indicators. They are used to detect if rule is extended or not even if rule does not
     * have extended css marker
     */
    var EXT_CSS_PSEUDO_INDICATORS = [
        /**
         * Pseudo-classes :is(), and :not() may use native implementation
         * so they are not listed here
         * https://github.com/AdguardTeam/ExtendedCss#extended-css-is
         * https://github.com/AdguardTeam/ExtendedCss#extended-css-not
         */
        /**
         * :has() should also be conditionally considered as extended and should not be in this list
         * https://github.com/AdguardTeam/ExtendedCss#extended-css-has
         * but there is a bug with content blocker in safari
         * https://bugs.webkit.org/show_bug.cgi?id=248868
         *
         * TODO: remove ':has(' later
         */
        ':has(',
        ':contains(',
        ':matches-css(',
        ':matches-attr(',
        ':matches-property(',
        ':xpath(',
        ':upward(',
        ':nth-ancestor(',
        ':remove(',
        // aliases for :has()
        ':-abp-has(',
        // aliases for :contains()
        ':has-text(',
        ':-abp-contains(',
        // old syntax
        '[-ext-has=',
        '[-ext-contains=',
        '[-ext-has-text=',
        '[-ext-matches-css=',
        '[-ext-matches-css-before=',
        '[-ext-matches-css-after=',
        // obsolete since ExtendedCss v2.0.2 but still compatible
        // https://github.com/AdguardTeam/ExtendedCss/releases/tag/v2.0.2
        ':matches-css-before(',
        ':matches-css-after(',
    ];
    /**
     * Implements a basic cosmetic rule.
     *
     * Cosmetic rules syntax are almost similar and looks like this:
     * ```
     * rule = [domains] "marker" content
     * domains = [domain0, domain1[, ...[, domainN]]]
     * ```
     *
     * The rule type is defined by the `marker` value, you can find the list of them
     * in the {@see CosmeticRuleMarker} enumeration.
     *
     * What matters, though, is what's in the `content` part of it.
     *
     * Examples:
     * * `example.org##.banner` -- element hiding rule
     * * `example.org#$#.banner { display: block; }` -- CSS rule
     * * `example.org#%#window.x=1;` -- JS rule
     * * `example.org#%#//scriptlet('scriptlet-name')` -- Scriptlet rule
     * * `example.org$$div[id="test"]` -- HTML filtering rule
     */
    var CosmeticRule = /** @class */ (function () {
        /**
         * Creates an instance of the {@link CosmeticRule}.
         * It parses the rule and extracts the permitted/restricted domains,
         * and also the cosmetic rule's content.
         *
         * Depending on the rule type, the content might be transformed in
         * one of the helper classes, or kept as string when it's appropriate.
         *
         * @param ruleText - original rule text.
         * @param filterListId - ID of the filter list this rule belongs to.
         *
         * @throws error if it fails to parse the rule.
         */
        function CosmeticRule(ruleText, filterListId) {
            this.allowlist = false;
            this.extendedCss = false;
            this.permittedDomains = undefined;
            this.restrictedDomains = undefined;
            /**
             * Js script to execute
             */
            this.script = undefined;
            /**
             * Object with script code ready to execute and debug, domain values
             * @private
             */
            this.scriptData = null;
            /**
             * Object with scriptlet function and params
             * @private
             */
            this.scriptletData = null;
            /**
             * If the rule contains scriptlet content
             */
            this.isScriptlet = false;
            this.ruleText = ruleText;
            this.filterListId = filterListId;
            var _a = CosmeticRuleParser.parseRuleTextByMarker(ruleText), pattern = _a.pattern, marker = _a.marker, content = _a.content;
            this.content = content;
            this.type = CosmeticRule.parseType(marker);
            this.extendedCss = isExtCssMarker(marker);
            if (!this.extendedCss
                && (this.type === exports.CosmeticRuleType.ElementHiding
                    || this.type === exports.CosmeticRuleType.Css)) {
                // additional check if rule is extended css rule by pseudo class indicators
                for (var i = 0; i < EXT_CSS_PSEUDO_INDICATORS.length; i += 1) {
                    if (this.content.indexOf(EXT_CSS_PSEUDO_INDICATORS[i]) !== -1) {
                        this.extendedCss = true;
                        break;
                    }
                }
            }
            CosmeticRule.validate(ruleText, this.type, content, this.extendedCss);
            if (pattern) {
                // This means that the marker is preceded by the list of domains and modifiers
                // Now it's a good time to parse them.
                var _b = CosmeticRuleParser.parseRulePattern(pattern), path = _b.path, permittedDomains = _b.permittedDomains, restrictedDomains = _b.restrictedDomains;
                if (path || path === '') {
                    this.pathModifier = new Pattern(path);
                }
                if (permittedDomains) {
                    this.permittedDomains = permittedDomains;
                }
                if (restrictedDomains) {
                    this.restrictedDomains = restrictedDomains;
                }
            }
            this.allowlist = CosmeticRule.parseAllowlist(marker);
            this.isScriptlet = this.content.startsWith(ADG_SCRIPTLET_MASK);
        }
        /**
         * Parses first pseudo class from the specified CSS selector
         *
         * @param selector
         * @returns pseudo class name if found or null
         */
        CosmeticRule.parsePseudoClass = function (selector) {
            var beginIndex = 0;
            var nameStartIndex = -1;
            var squareBracketIndex = 0;
            while (squareBracketIndex >= 0) {
                nameStartIndex = selector.indexOf(':', beginIndex);
                if (nameStartIndex < 0) {
                    return null;
                }
                if (nameStartIndex > 0 && selector.charAt(nameStartIndex - 1) === '\\') {
                    // Escaped colon character
                    return null;
                }
                squareBracketIndex = selector.indexOf('[', beginIndex);
                while (squareBracketIndex >= 0) {
                    if (nameStartIndex > squareBracketIndex) {
                        var squareEndBracketIndex = selector.indexOf(']', squareBracketIndex + 1);
                        beginIndex = squareEndBracketIndex + 1;
                        if (nameStartIndex < squareEndBracketIndex) {
                            // Means that colon character is somewhere inside attribute selector
                            // Something like a[src^="http://domain.com"]
                            break;
                        }
                        if (squareEndBracketIndex > 0) {
                            squareBracketIndex = selector.indexOf('[', beginIndex);
                        }
                        else {
                            // bad rule, example: a[src="http:
                            return null;
                        }
                    }
                    else {
                        squareBracketIndex = -1;
                        break;
                    }
                }
            }
            var nameEndIndex = indexOfAny(selector, [' ', ',', '\t', '>', '(', '[', '.', '#', ':', '+', '~', '"', '\''], nameStartIndex + 1);
            if (nameEndIndex < 0) {
                nameEndIndex = selector.length;
            }
            var name = selector.substring(nameStartIndex, nameEndIndex);
            if (name.length <= 1) {
                // Either empty name or a pseudo element (like ::content)
                return null;
            }
            return name;
        };
        CosmeticRule.prototype.getText = function () {
            return this.ruleText;
        };
        CosmeticRule.prototype.getFilterListId = function () {
            return this.filterListId;
        };
        /**
         * Cosmetic rule type (always present)
         */
        CosmeticRule.prototype.getType = function () {
            return this.type;
        };
        /**
         * Allowlist means that this rule is meant to disable other rules.
         * For instance, https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#elemhide-exceptions
         */
        CosmeticRule.prototype.isAllowlist = function () {
            return this.allowlist;
        };
        /**
         * Gets the rule content. The meaning of this field depends on the rule type.
         * For instance, for an element hiding rule, this is just a CSS selector.
         * While, for a CSS rule, this is a CSS selector + style.
         */
        CosmeticRule.prototype.getContent = function () {
            return this.content;
        };
        /**
         * Returns script ready to execute or null
         * Rebuilds scriptlet script if debug or domain params change
         * @param options script options
         * @returns script code or null
         */
        CosmeticRule.prototype.getScript = function (options) {
            var _a, _b;
            if (options === void 0) { options = {}; }
            var _c = options.debug, debug = _c === void 0 ? false : _c, frameUrl = options.frameUrl;
            var scriptData = this.scriptData;
            if (scriptData && !this.isScriptlet) {
                return scriptData.code;
            }
            if (scriptData && scriptData.debug === debug) {
                if (frameUrl) {
                    if (frameUrl === scriptData.frameUrl) {
                        return scriptData.code;
                    }
                }
                else {
                    return scriptData.code;
                }
            }
            this.initScript(options);
            return (_b = (_a = this.scriptData) === null || _a === void 0 ? void 0 : _a.code) !== null && _b !== void 0 ? _b : null;
        };
        /**
         * Gets list of permitted domains.
         */
        CosmeticRule.prototype.getPermittedDomains = function () {
            return this.permittedDomains;
        };
        /**
         * Returns true if the rule is considered "generic"
         * "generic" means that the rule is not restricted to a limited set of domains
         * Please note that it might be forbidden on some domains, though.
         *
         * @return {boolean}
         */
        CosmeticRule.prototype.isGeneric = function () {
            return !this.permittedDomains || this.permittedDomains.length === 0;
        };
        /**
         * Gets list of restricted domains.
         */
        CosmeticRule.prototype.getRestrictedDomains = function () {
            return this.restrictedDomains;
        };
        CosmeticRule.prototype.isExtendedCss = function () {
            return this.extendedCss;
        };
        /**
         * Match returns true if this rule can be used on the specified request.
         *
         * @param request - request to check
         */
        CosmeticRule.prototype.match = function (request) {
            if (!this.permittedDomains && !this.restrictedDomains && !this.pathModifier) {
                return true;
            }
            if (this.matchesRestrictedDomains(request.hostname)) {
                /**
                 * Domain or host is restricted
                 * i.e. ~example.org##rule
                 */
                return false;
            }
            if (this.hasPermittedDomains()) {
                if (!DomainModifier.isDomainOrSubdomainOfAny(request.hostname, this.permittedDomains)) {
                    /**
                     * Domain is not among permitted
                     * i.e. example.org##rule and we're checking example.org
                     */
                    return false;
                }
            }
            if (this.pathModifier) {
                var path = getRelativeUrl(request.urlLowercase);
                if (path) {
                    return this.pathModifier.matchPathPattern(path);
                }
                return false;
            }
            return true;
        };
        CosmeticRule.parseType = function (marker) {
            switch (marker) {
                case exports.CosmeticRuleMarker.ElementHiding:
                case exports.CosmeticRuleMarker.ElementHidingExtCSS:
                    return exports.CosmeticRuleType.ElementHiding;
                case exports.CosmeticRuleMarker.ElementHidingException:
                case exports.CosmeticRuleMarker.ElementHidingExtCSSException:
                    return exports.CosmeticRuleType.ElementHiding;
                case exports.CosmeticRuleMarker.Css:
                case exports.CosmeticRuleMarker.CssExtCSS:
                    return exports.CosmeticRuleType.Css;
                case exports.CosmeticRuleMarker.CssException:
                case exports.CosmeticRuleMarker.CssExtCSSException:
                    return exports.CosmeticRuleType.Css;
                case exports.CosmeticRuleMarker.Js:
                    return exports.CosmeticRuleType.Js;
                case exports.CosmeticRuleMarker.JsException:
                    return exports.CosmeticRuleType.Js;
                case exports.CosmeticRuleMarker.Html:
                    return exports.CosmeticRuleType.Html;
                case exports.CosmeticRuleMarker.HtmlException:
                    return exports.CosmeticRuleType.Html;
                default:
                    throw new SyntaxError('Unsupported rule type');
            }
        };
        /**
         * Determines if rule is allowlist rule
         * @param marker
         * @private
         */
        CosmeticRule.parseAllowlist = function (marker) {
            switch (marker) {
                case exports.CosmeticRuleMarker.ElementHidingException:
                case exports.CosmeticRuleMarker.ElementHidingExtCSSException:
                case exports.CosmeticRuleMarker.CssException:
                case exports.CosmeticRuleMarker.CssExtCSSException:
                case exports.CosmeticRuleMarker.JsException:
                case exports.CosmeticRuleMarker.HtmlException:
                    return true;
                default:
                    return false;
            }
        };
        /**
         * Validate pseudo-classes
         *
         * @param ruleText
         * @param ruleContent
         * @throws SyntaxError
         */
        CosmeticRule.validatePseudoClasses = function (ruleText, ruleContent) {
            var pseudoClass = CosmeticRule.parsePseudoClass(ruleContent);
            if (pseudoClass !== null) {
                if (CosmeticRule.SUPPORTED_PSEUDO_CLASSES.indexOf(pseudoClass) < 0) {
                    throw new SyntaxError("Unknown pseudo-class '".concat(pseudoClass, "' in selector: '").concat(ruleContent, "'"));
                }
            }
        };
        /**
         * Simple validation for elemhide rules
         *
         * @param ruleText
         * @param ruleContent
         * @throws SyntaxError
         */
        CosmeticRule.validateElemhideRule = function (ruleText, ruleContent) {
            if (ruleText.startsWith(SimpleRegex.MASK_START_URL)) {
                throw new SyntaxError('Element hiding rule shouldn\'t start with "||"');
            }
            if (CosmeticRule.ELEMHIDE_VALIDATION_REGEX.test(ruleContent)) {
                throw new SyntaxError('Invalid elemhide rule, style presented');
            }
        };
        CosmeticRule.validateJsRules = function (ruleText, ruleContent) {
            if (ruleContent.startsWith(ADG_SCRIPTLET_MASK)) {
                if (!scriptlets_umd.exports.isValidScriptletRule(ruleText)) {
                    throw new SyntaxError('Invalid scriptlet');
                }
            }
        };
        /**
         * Validates css injection rules
         *
         * @param ruleText
         * @param ruleContent
         * @throws SyntaxError
         */
        CosmeticRule.validateCssRules = function (ruleText, ruleContent) {
            // Simple validation for css injection rules
            if (!/{.+}/.test(ruleContent)) {
                throw new SyntaxError('Invalid CSS modifying rule, no style presented');
            }
            // discard css inject rules containing "url"
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1196
            if (/{.*url\(.*\)/gi.test(ruleContent)) {
                throw new SyntaxError('CSS modifying rule with \'url\' was omitted');
            }
            // discard css inject rules containing other unsafe selectors
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1920
            if (/{.*image-set\(.*\)/gi.test(ruleContent)
                || /{.*image\(.*\)/gi.test(ruleContent)
                || /{.*cross-fade\(.*\)/gi.test(ruleContent)) {
                throw new SyntaxError('CSS modifying rule with unsafe style was omitted');
            }
            // Prohibit "\" character in style of CSS injection rules
            // Check slash character only after the index of last opening curly brackets
            if (ruleContent.indexOf('\\', ruleContent.lastIndexOf('{')) > -1) {
                throw new SyntaxError('CSS injection rule with \'\\\' was omitted');
            }
        };
        /**
         * Checks if the rule has permitted domains
         */
        CosmeticRule.prototype.hasPermittedDomains = function () {
            return this.permittedDomains != null && this.permittedDomains.length > 0;
        };
        /**
         * Checks if the rule has restricted domains
         */
        CosmeticRule.prototype.hasRestrictedDomains = function () {
            return this.restrictedDomains != null && this.restrictedDomains.length > 0;
        };
        /**
         * Checks if the hostname matches permitted domains
         * @param hostname
         */
        CosmeticRule.prototype.matchesPermittedDomains = function (hostname) {
            return this.hasPermittedDomains() && DomainModifier.isDomainOrSubdomainOfAny(hostname, this.permittedDomains);
        };
        /**
         * Checks if the hostname matches the restricted domains.
         * @param hostname
         */
        CosmeticRule.prototype.matchesRestrictedDomains = function (hostname) {
            return this.hasRestrictedDomains()
                && DomainModifier.isDomainOrSubdomainOfAny(hostname, this.restrictedDomains);
        };
        /**
         * Validates cosmetic rule text
         * @param ruleText
         * @param type
         * @param content
         * @param isExtCss
         * @private
         */
        CosmeticRule.validate = function (ruleText, type, content, isExtCss) {
            if (type !== exports.CosmeticRuleType.Css
                && type !== exports.CosmeticRuleType.Js
                && type !== exports.CosmeticRuleType.Html) {
                CosmeticRule.validatePseudoClasses(ruleText, content);
                if (hasUnquotedSubstring(content, '{')) {
                    throw new SyntaxError('Invalid cosmetic rule, wrong brackets');
                }
            }
            if (type === exports.CosmeticRuleType.ElementHiding) {
                CosmeticRule.validateElemhideRule(ruleText, content);
            }
            if (type === exports.CosmeticRuleType.Css) {
                CosmeticRule.validateCssRules(ruleText, content);
            }
            if (type === exports.CosmeticRuleType.Js) {
                CosmeticRule.validateJsRules(ruleText, content);
            }
            if ((!isExtCss && hasUnquotedSubstring(content, '/*'))
                || hasUnquotedSubstring(content, ' /*')
                || hasUnquotedSubstring(content, ' //')) {
                throw new SyntaxError('Cosmetic rule should not contain comments');
            }
        };
        /**
         * Returns the scriptlet's data consisting of the scriptlet function and its arguments.
         * This method is supposed to be used in the manifest V3 extension.
         */
        CosmeticRule.prototype.getScriptletData = function () {
            if (this.scriptletData) {
                return this.scriptletData;
            }
            this.initScript();
            return this.scriptletData;
        };
        /**
         * Updates this.scriptData and if scriptlet this.scriptletData with js ready to execute
         *
         * @param options
         */
        CosmeticRule.prototype.initScript = function (options) {
            var _a;
            if (options === void 0) { options = {}; }
            var _b = options.debug, debug = _b === void 0 ? false : _b, frameUrl = options.frameUrl;
            var ruleContent = this.getContent();
            if (!this.isScriptlet) {
                this.scriptData = {
                    code: ruleContent,
                };
                return;
            }
            var scriptletContent = ruleContent.substring(ADG_SCRIPTLET_MASK.length);
            var scriptletParams = ScriptletParser.parseRule(scriptletContent);
            var params = {
                args: scriptletParams.args,
                engine: exports.config.engine || '',
                name: scriptletParams.name,
                ruleText: this.getText(),
                verbose: debug,
                domainName: frameUrl,
                version: exports.config.version || '',
            };
            this.scriptData = {
                code: (_a = scriptlets_umd.exports.invoke(params)) !== null && _a !== void 0 ? _a : null,
                debug: debug,
                frameUrl: frameUrl,
            };
            this.scriptletData = {
                func: scriptlets_umd.exports.getScriptletFunction(params.name),
                params: params,
            };
        };
        /**
         * The problem with pseudo-classes is that any unknown pseudo-class makes browser ignore the whole CSS rule,
         * which contains a lot more selectors. So, if CSS selector contains a pseudo-class, we should try to validate it.
         * <p>
         * One more problem with pseudo-classes is that they are actively used in uBlock, hence it may mess AG styles.
         */
        CosmeticRule.SUPPORTED_PSEUDO_CLASSES = [':active',
            ':checked', ':contains', ':disabled', ':empty', ':enabled', ':first-child', ':first-of-type',
            ':focus', ':has', ':has-text', ':hover', ':if', ':if-not', ':in-range', ':invalid', ':lang',
            ':last-child', ':last-of-type', ':link', ':matches-css', ':matches-css-before', ':matches-css-after',
            ':not', ':nth-child', ':nth-last-child', ':nth-last-of-type', ':nth-of-type',
            ':only-child', ':only-of-type', ':optional', ':out-of-range', ':read-only',
            ':read-write', ':required', ':root', ':target', ':valid', ':visited',
            ':-abp-has', ':-abp-contains', ':xpath', ':nth-ancestor', ':upward', ':remove',
            ':matches-attr', ':matches-property', ':is', ':where'];
        CosmeticRule.ELEMHIDE_VALIDATION_REGEX = / {.+}/;
        return CosmeticRule;
    }());

    /**
     * CosmeticEngine combines all the cosmetic rules and allows to quickly
     * find all rules matching this or that hostname
     * It is primarily used by the {@see Engine}
     */
    var CosmeticEngine = /** @class */ (function () {
        /**
         * Builds instance of cosmetic engine
         *
         * @param ruleStorage
         * @param skipStorageScan create an instance without storage scanning
         */
        function CosmeticEngine(ruleStorage, skipStorageScan) {
            if (skipStorageScan === void 0) { skipStorageScan = false; }
            this.ruleStorage = ruleStorage;
            this.rulesCount = 0;
            this.elementHidingLookupTable = new CosmeticLookupTable(ruleStorage);
            this.cssLookupTable = new CosmeticLookupTable(ruleStorage);
            this.jsLookupTable = new CosmeticLookupTable(ruleStorage);
            this.htmlLookupTable = new CosmeticLookupTable(ruleStorage);
            if (skipStorageScan) {
                return;
            }
            var scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.CosmeticRules);
            while (scanner.scan()) {
                var indexedRule = scanner.getRule();
                if (indexedRule
                    && indexedRule.rule instanceof CosmeticRule) {
                    this.addRule(indexedRule.rule, indexedRule.index);
                }
            }
        }
        /**
         * Adds rules into appropriate tables
         * @param rule
         * @param storageIdx
         */
        CosmeticEngine.prototype.addRule = function (rule, storageIdx) {
            switch (rule.getType()) {
                case exports.CosmeticRuleType.ElementHiding: {
                    this.elementHidingLookupTable.addRule(rule, storageIdx);
                    break;
                }
                case exports.CosmeticRuleType.Css: {
                    this.cssLookupTable.addRule(rule, storageIdx);
                    break;
                }
                case exports.CosmeticRuleType.Js: {
                    this.jsLookupTable.addRule(rule, storageIdx);
                    break;
                }
                case exports.CosmeticRuleType.Html: {
                    this.htmlLookupTable.addRule(rule, storageIdx);
                    break;
                }
            }
            this.rulesCount += 1;
        };
        /**
         * Checks if bitwise mask matches option
         * @param option
         * @param targetOption
         */
        CosmeticEngine.matchOption = function (option, targetOption) {
            return (option & targetOption) === targetOption;
        };
        /**
         * Prepares cosmetic result by request
         *
         * @param request - request to match
         * @param option mask of enabled cosmetic types
         * @return CosmeticResult
         */
        CosmeticEngine.prototype.match = function (request, option) {
            var includeGeneric = CosmeticEngine.matchOption(option, exports.CosmeticOption.CosmeticOptionGenericCSS);
            var includeSpecific = CosmeticEngine.matchOption(option, exports.CosmeticOption.CosmeticOptionSpecificCSS);
            var includeJs = CosmeticEngine.matchOption(option, exports.CosmeticOption.CosmeticOptionJS);
            var includeHtml = CosmeticEngine.matchOption(option, exports.CosmeticOption.CosmeticOptionHtml);
            var cosmeticResult = new CosmeticResult();
            if (includeGeneric) {
                CosmeticEngine.appendGenericRules(cosmeticResult.elementHiding, this.elementHidingLookupTable, request);
                CosmeticEngine.appendGenericRules(cosmeticResult.CSS, this.cssLookupTable, request);
            }
            if (includeSpecific) {
                CosmeticEngine.appendSpecificRules(cosmeticResult.elementHiding, this.elementHidingLookupTable, request);
                CosmeticEngine.appendSpecificRules(cosmeticResult.CSS, this.cssLookupTable, request);
            }
            if (includeJs) {
                CosmeticEngine.appendGenericRules(cosmeticResult.JS, this.jsLookupTable, request);
                CosmeticEngine.appendSpecificRules(cosmeticResult.JS, this.jsLookupTable, request);
            }
            if (includeHtml) {
                if (includeGeneric) {
                    CosmeticEngine.appendGenericRules(cosmeticResult.Html, this.htmlLookupTable, request);
                }
                CosmeticEngine.appendSpecificRules(cosmeticResult.Html, this.htmlLookupTable, request);
            }
            return cosmeticResult;
        };
        /**
         * Selects generic rules and appends rules content to cosmetic result
         * @param cosmeticResult
         * @param lookupTable
         * @param request
         */
        CosmeticEngine.appendGenericRules = function (cosmeticResult, lookupTable, request) {
            for (var _i = 0, _a = lookupTable.genericRules; _i < _a.length; _i++) {
                var genericRule = _a[_i];
                if (!lookupTable.isAllowlisted(request, genericRule)
                    && genericRule.match(request)) {
                    cosmeticResult.append(genericRule, request);
                }
            }
        };
        /**
         * Selects specific rules and appends rules content to cosmetic result
         * @param cosmeticResult
         * @param lookupTable
         * @param request
         */
        CosmeticEngine.appendSpecificRules = function (cosmeticResult, lookupTable, request) {
            var hostnameRules = lookupTable.findByHostname(request);
            if (hostnameRules.length > 0) {
                for (var _i = 0, hostnameRules_1 = hostnameRules; _i < hostnameRules_1.length; _i++) {
                    var rule = hostnameRules_1[_i];
                    if (!lookupTable.isAllowlisted(request, rule)) {
                        cosmeticResult.append(rule, request);
                    }
                }
            }
        };
        return CosmeticEngine;
    }());

    /**
     * Engine represents the filtering engine with all the loaded rules
     */
    var Engine = /** @class */ (function () {
        /**
         * Creates an instance of an Engine
         * Parses the filtering rules and creates a filtering engine of them
         *
         * @param ruleStorage storage
         * @param skipStorageScan create an instance without storage scanning
         * @throws
         */
        function Engine(ruleStorage, skipStorageScan) {
            if (skipStorageScan === void 0) { skipStorageScan = false; }
            this.ruleStorage = ruleStorage;
            this.networkEngine = new NetworkEngine(ruleStorage, skipStorageScan);
            this.cosmeticEngine = new CosmeticEngine(ruleStorage, skipStorageScan);
            this.resultCache = new lru.exports.LRUMap(Engine.REQUEST_CACHE_SIZE);
        }
        /**
         * Loads rules to engine
         */
        Engine.prototype.loadRules = function () {
            var scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.NetworkRules | ScannerType.CosmeticRules);
            while (scanner.scan()) {
                this.addRule(scanner.getRule());
            }
        };
        /**
         * Async loads rules to engine
         *
         * @param chunkSize size of rules chunk to load at a time
         */
        Engine.prototype.loadRulesAsync = function (chunkSize) {
            return __awaiter(this, void 0, void 0, function () {
                var scanner, counter;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.NetworkRules | ScannerType.CosmeticRules);
                            counter = 0;
                            _a.label = 1;
                        case 1:
                            if (!scanner.scan()) return [3 /*break*/, 4];
                            counter += 1;
                            if (!(counter >= chunkSize)) return [3 /*break*/, 3];
                            counter = 0;
                            /**
                             * In some cases UI thread becomes blocked while adding rules to engine,
                             * that't why we create filter rules using chunks of the specified length
                             * Rules creation is rather slow operation so we should
                             * use setTimeout calls to give UI thread some time.
                             */
                            return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, 1); })];
                        case 2:
                            /**
                             * In some cases UI thread becomes blocked while adding rules to engine,
                             * that't why we create filter rules using chunks of the specified length
                             * Rules creation is rather slow operation so we should
                             * use setTimeout calls to give UI thread some time.
                             */
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            this.addRule(scanner.getRule());
                            return [3 /*break*/, 1];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Matches the specified request against the filtering engine and returns the matching result.
         *
         * @param request - request to check
         * @param frameRule - source document rule or null
         * @return matching result
         */
        Engine.prototype.matchRequest = function (request, frameRule) {
            if (frameRule === void 0) { frameRule = null; }
            var cacheKey = "".concat(request.url, "#").concat(request.sourceHostname, "#").concat(request.requestType);
            if (request.method) {
                cacheKey += "#".concat(request.method);
            }
            /**
             * Add frame url text to the key to avoid caching,
             * because allowlist rules are not stored in the engine
             * AG-12694
             */
            if (frameRule) {
                cacheKey += "#".concat(frameRule.getText());
            }
            var res = this.resultCache.get(cacheKey);
            if (res) {
                return res;
            }
            var networkRules = this.networkEngine.matchAll(request);
            var result = new MatchingResult(networkRules, frameRule);
            this.resultCache.set(cacheKey, result);
            return result;
        };
        /**
         * Matches current frame and returns document-level allowlist rule if found.
         *
         * @param frameUrl
         */
        Engine.prototype.matchFrame = function (frameUrl) {
            var sourceRequest = new Request$1(frameUrl, '', RequestType.Document);
            var sourceRules = this.networkEngine.matchAll(sourceRequest);
            sourceRules = MatchingResult.removeBadfilterRules(sourceRules);
            var result = null;
            sourceRules.forEach(function (r) {
                if (r.isDocumentLevelAllowlistRule()) {
                    if (!result || r.isHigherPriority(result)) {
                        result = r;
                    }
                }
            });
            return result;
        };
        /**
         * Gets cosmetic result for the specified hostname and cosmetic options
         *
         * @param request host to check
         * @param option mask of enabled cosmetic types
         * @return cosmetic result
         */
        Engine.prototype.getCosmeticResult = function (request, option) {
            return this.cosmeticEngine.match(request, option);
        };
        /**
         * Gets rules count
         */
        Engine.prototype.getRulesCount = function () {
            return this.networkEngine.rulesCount + this.cosmeticEngine.rulesCount;
        };
        /**
         * Adds rules to engines
         *
         * @param indexedRule
         */
        Engine.prototype.addRule = function (indexedRule) {
            if (indexedRule) {
                if (indexedRule.rule instanceof NetworkRule) {
                    this.networkEngine.addRule(indexedRule.rule, indexedRule.index);
                }
                else if (indexedRule.rule instanceof CosmeticRule) {
                    this.cosmeticEngine.addRule(indexedRule.rule, indexedRule.index);
                }
            }
        };
        /**
         * Request's cache size
         * Used as both source rules and others limit.
         * The value is based on benchmark runs.
         */
        Engine.REQUEST_CACHE_SIZE = 500;
        return Engine;
    }());

    /**
     * Rule with index
     */
    var IndexedRule = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param rule
         * @param index
         */
        function IndexedRule(rule, index) {
            this.rule = rule;
            this.index = index;
        }
        return IndexedRule;
    }());
    /**
     * Rule with storage index
     */
    var IndexedStorageRule = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param rule
         * @param index
         */
        function IndexedStorageRule(rule, index) {
            this.rule = rule;
            this.index = index;
        }
        return IndexedStorageRule;
    }());

    /**
     * Export logger implementation
     */
    exports.logger = console;
    /**
     * Set logger implementation
     *
     * @param loggerImpl
     */
    function setLogger(loggerImpl) {
        exports.logger = loggerImpl;
    }

    /**
     * Rule builder class
     */
    var RuleFactory = /** @class */ (function () {
        function RuleFactory() {
        }
        /**
         * Creates rule of suitable class from text string
         * It returns null if the line is empty or if it is a comment
         *
         * TODO: Pack `ignore*` parameters and `silent` into one object with flags.
         *
         * @param text rule string
         * @param filterListId list id
         * @param ignoreNetwork do not create network rules
         * @param ignoreCosmetic do not create cosmetic rules
         * @param ignoreHost do not create host rules
         * @param silent Log the error for `true`, otherwise throw an exception on
         * a rule creation
         *
         * @throws Error when `silent` flag is passed as false on rule creation error.
         *
         * @return IRule object or null
         */
        RuleFactory.createRule = function (text, filterListId, ignoreNetwork, ignoreCosmetic, ignoreHost, silent) {
            if (ignoreNetwork === void 0) { ignoreNetwork = false; }
            if (ignoreCosmetic === void 0) { ignoreCosmetic = false; }
            if (ignoreHost === void 0) { ignoreHost = true; }
            if (silent === void 0) { silent = true; }
            if (!text || RuleFactory.isComment(text)) {
                return null;
            }
            if (RuleFactory.isShort(text)) {
                exports.logger.info("The rule is too short: ".concat(text));
            }
            var line = text.trim();
            try {
                if (RuleFactory.isCosmetic(line)) {
                    if (ignoreCosmetic) {
                        return null;
                    }
                    return new CosmeticRule(line, filterListId);
                }
                if (!ignoreHost) {
                    var hostRule = RuleFactory.createHostRule(line, filterListId);
                    if (hostRule) {
                        return hostRule;
                    }
                }
                if (!ignoreNetwork) {
                    return new NetworkRule(line, filterListId);
                }
            }
            catch (e) {
                var msg = "\"".concat(getErrorMessage(e), "\" in the rule: \"").concat(line, "\"");
                if (silent) {
                    exports.logger.info("Error: ".concat(msg));
                }
                else {
                    throw new Error(msg);
                }
            }
            return null;
        };
        /**
         * Creates host rule from text
         *
         * @param ruleText
         * @param filterListId
         */
        RuleFactory.createHostRule = function (ruleText, filterListId) {
            var rule = new HostRule(ruleText, filterListId);
            return rule.isInvalid() ? null : rule;
        };
        /**
         * Checks if rule is short
         */
        RuleFactory.isShort = function (rule) {
            if (!rule) {
                return true;
            }
            return !!(rule && rule.length <= 3);
        };
        /**
         * Checks if the rule is cosmetic or not.
         * @param ruleText - rule text to check.
         */
        RuleFactory.isCosmetic = function (ruleText) {
            var marker = findCosmeticRuleMarker(ruleText);
            return marker[0] !== -1;
        };
        /**
         * If text is comment
         *
         * @param text
         */
        RuleFactory.isComment = function (text) {
            if (text.charAt(0) === '!') {
                return true;
            }
            if (text.charAt(0) === '#') {
                if (text.length === 1) {
                    return true;
                }
                // Now we should check that this is not a cosmetic rule
                return !RuleFactory.isCosmetic(text);
            }
            return false;
        };
        return RuleFactory;
    }());

    /**
     * Rule scanner implements an interface for reading filtering rules.
     */
    var RuleScanner = /** @class */ (function () {
        /**
         * NewRuleScanner returns a new RuleScanner to read from r.
         *
         * @param reader source of the filtering rules
         * @param listId filter list ID
         * @param configuration config object
         */
        function RuleScanner(reader, listId, configuration) {
            /**
             *  Current rule
             */
            this.currentRule = null;
            /**
             * Index of the beginning of the current rule
             */
            this.currentRuleIndex = 0;
            /**
             * Current position in the reader
             */
            this.currentPos = 0;
            this.reader = reader;
            this.listId = listId;
            this.ignoreCosmetic = !!configuration.ignoreCosmetic
                || ((configuration.scannerType & ScannerType.CosmeticRules) !== ScannerType.CosmeticRules);
            this.ignoreNetwork = (configuration.scannerType & ScannerType.NetworkRules) !== ScannerType.NetworkRules;
            this.ignoreHost = (configuration.scannerType & ScannerType.HostRules) !== ScannerType.HostRules;
            this.ignoreJS = !!configuration.ignoreJS;
            this.ignoreUnsafe = !!configuration.ignoreUnsafe;
        }
        /**
         * Scan advances the RuleScanner to the next rule, which will then be available
         * through the Rule method.
         *
         * @return false when the scan stops, either by
         * reaching the end of the input or an error.
        */
        RuleScanner.prototype.scan = function () {
            while (true) {
                var lineIndex = this.currentPos;
                var line = this.readNextLine();
                if (line === null) {
                    return false;
                }
                if (line) {
                    var rule = RuleFactory.createRule(line, this.listId, this.ignoreNetwork, this.ignoreCosmetic, this.ignoreHost);
                    if (rule && !this.isIgnored(rule)) {
                        this.currentRule = rule;
                        this.currentRuleIndex = lineIndex;
                        return true;
                    }
                }
            }
        };
        /**
         * @return the most recent rule generated by a call to Scan, and the index of this rule's text.
         */
        RuleScanner.prototype.getRule = function () {
            if (this.currentRule) {
                return new IndexedRule(this.currentRule, this.currentRuleIndex);
            }
            return null;
        };
        /**
         * Reads the next line and returns it
         *
         * @return next line string or null
         */
        RuleScanner.prototype.readNextLine = function () {
            var line = this.reader.readLine();
            if (line != null) {
                this.currentPos += line.length + 1;
                return line.trim();
            }
            return null;
        };
        /**
         * Checks if the rule should be ignored by this scanner
         *
         * @param rule to check
         * @return is rule ignored
         */
        RuleScanner.prototype.isIgnored = function (rule) {
            if (!this.ignoreCosmetic && !this.ignoreJS && !this.ignoreUnsafe) {
                return false;
            }
            if (rule instanceof CosmeticRule) {
                if (this.ignoreCosmetic) {
                    return true;
                }
                // Ignore JS type rules
                // TODO: in the future we may allow CSS rules and Scriptlets (except for "trusted" scriptlets)
                return (this.ignoreJS && rule.getType() === exports.CosmeticRuleType.Js);
            }
            if (this.ignoreUnsafe) {
                if (rule instanceof NetworkRule) {
                    if (rule.getAdvancedModifier() && (rule.getAdvancedModifier() instanceof RemoveHeaderModifier)) {
                        return true;
                    }
                }
            }
            return false;
        };
        return RuleScanner;
    }());

    /**
     * Reads string line by line
     */
    var StringLineReader = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param text
         */
        function StringLineReader(text) {
            /**
             * Current position
             */
            this.currentIndex = 0;
            this.text = text;
        }
        /**
         * Reads next line
         *
         * @return text or null on end
         */
        StringLineReader.prototype.readLine = function () {
            if (this.currentIndex === -1) {
                return null;
            }
            var startIndex = this.currentIndex;
            this.currentIndex = this.text.indexOf('\n', startIndex);
            if (this.currentIndex === -1) {
                return this.text.substring(startIndex);
            }
            this.currentIndex += 1;
            // - 1 in order to exclude EOL
            return this.text.substring(startIndex, this.currentIndex - 1);
        };
        return StringLineReader;
    }());

    /**
     * List identifier max value.
     * We use "number" type for storage indexes, so we have some limits for list identifiers,
     * We line number for rule index, so if we save 11 ranks for rules, then we have 6 ranks left for list ids.
     * Check RuleStorageScanner class for more info.
     */
    var LIST_ID_MAX_VALUE = Math.pow(10, 6);
    /**
     * StringRuleList represents a string-based rule list
     */
    var StringRuleList = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param listId
         * @param ruleText
         * @param ignoreCosmetic (Optional) default false
         * @param ignoreJS (Optional) default false
         * @param ignoreUnsafe (Optional) default false
         */
        function StringRuleList(listId, ruleText, ignoreCosmetic, ignoreJS, ignoreUnsafe) {
            if (listId >= LIST_ID_MAX_VALUE) {
                throw new Error("Invalid list identifier, it must be less than ".concat(LIST_ID_MAX_VALUE));
            }
            this.id = listId;
            this.rulesText = ruleText;
            this.ignoreCosmetic = !!ignoreCosmetic;
            this.ignoreJS = !!ignoreJS;
            this.ignoreUnsafe = !!ignoreUnsafe;
        }
        /**
         * Close does nothing as here's nothing to close in the StringRuleList
         */
        // eslint-disable-next-line class-methods-use-this
        StringRuleList.prototype.close = function () {
            // Empty
        };
        /**
         * @return the rule list identifier
         */
        StringRuleList.prototype.getId = function () {
            return this.id;
        };
        /**
         * Creates a new rules scanner that reads the list contents
         * @return scanner object
         */
        StringRuleList.prototype.newScanner = function (scannerType) {
            var reader = new StringLineReader(this.rulesText);
            return new RuleScanner(reader, this.id, {
                scannerType: scannerType,
                ignoreCosmetic: this.ignoreCosmetic,
                ignoreJS: this.ignoreJS,
                ignoreUnsafe: this.ignoreUnsafe,
            });
        };
        /**
         * Finds rule text by its index.
         * If there's no rule by that index or rule is invalid, it will return null
         *
         * @param ruleIdx
         * @return rule text or null
         */
        StringRuleList.prototype.retrieveRuleText = function (ruleIdx) {
            if (ruleIdx < 0 || ruleIdx >= this.rulesText.length) {
                return null;
            }
            var endOfLine = this.rulesText.indexOf('\n', ruleIdx);
            if (endOfLine === -1) {
                endOfLine = this.rulesText.length;
            }
            var line = this.rulesText.substring(ruleIdx, endOfLine).trim();
            if (!line) {
                return null;
            }
            return line;
        };
        return StringRuleList;
    }());

    /**
     * RuleStorageScanner scans multiple RuleScanner instances
     * The rule index is built from the rule index in the list + the list ID
     * In the index number we consider decimal part as listId and integer part as ruleId
    */
    var RuleStorageScanner = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param scanners
         */
        function RuleStorageScanner(scanners) {
            /**
             * Current scanner
             */
            this.currentScanner = null;
            /**
             * Index of the current scanner
             */
            this.currentScannerIdx = -1;
            this.scanners = scanners;
        }
        /**
         * Scan advances the RuleStorageScanner to the next rule, which will then be available
         * through the Rule method. It returns false when the scan stops, either by
         * reaching the end of the input or an error.
         *
         * @return true if there is some result
        */
        RuleStorageScanner.prototype.scan = function () {
            if (this.scanners.length === 0) {
                return false;
            }
            if (!this.currentScanner) {
                this.currentScannerIdx = 0;
                this.currentScanner = this.scanners[this.currentScannerIdx];
            }
            while (true) {
                if (this.currentScanner.scan()) {
                    return true;
                }
                // Take the next scanner or just return false if there's nothing more
                if (this.currentScannerIdx === (this.scanners.length - 1)) {
                    return false;
                }
                this.currentScannerIdx += 1;
                this.currentScanner = this.scanners[this.currentScannerIdx];
            }
        };
        /**
         * Rule returns the most recent rule generated by a call to Scan, and the index of this rule.
         * See ruleListIdxToStorageIdx for more information on what this index is.
        */
        RuleStorageScanner.prototype.getRule = function () {
            if (!this.currentScanner) {
                return null;
            }
            var rule = this.currentScanner.getRule();
            if (!rule) {
                return null;
            }
            var index = RuleStorageScanner.ruleListIdxToStorageIdx(rule.rule.getFilterListId(), rule.index);
            return new IndexedStorageRule(rule.rule, index);
        };
        /**
         * ruleListIdxToStorageIdx converts pair of listID and rule list index
         * to "storage index" number
         *
         * @param listId
         * @param ruleIdx
         */
        RuleStorageScanner.ruleListIdxToStorageIdx = function (listId, ruleIdx) {
            return listId / LIST_ID_MAX_VALUE + ruleIdx;
        };
        /**
         * Converts the "storage index" to two integers:
         * listID -- rule list identifier
         * ruleIdx -- index of the rule in the list
         *
         * @param storageIdx
         * @return [listId, ruleIdx]
         */
        RuleStorageScanner.storageIdxToRuleListIdx = function (storageIdx) {
            var listId = Math.round((storageIdx % 1) * LIST_ID_MAX_VALUE);
            var ruleIdx = Math.trunc(storageIdx);
            return [listId, ruleIdx];
        };
        return RuleStorageScanner;
    }());

    /**
     * Rule list's cache
     */
    var ListCache = /** @class */ (function () {
        /**
         * Constructor
         */
        function ListCache() {
            this.cache = new Map();
        }
        /**
         * @param key
         * @return rule for specified key
         */
        ListCache.prototype.get = function (key) {
            return this.cache.get(key);
        };
        /**
         * Sets rule for specified key
         *
         * @param key
         * @param rule
         */
        ListCache.prototype.set = function (key, rule) {
            this.cache.set(key, rule);
        };
        return ListCache;
    }());

    /**
     * RuleStorage is an abstraction that combines several rule lists
     * It can be scanned using RuleStorageScanner, and also it allows
     * retrieving rules by its index

     * The idea is to keep rules in a serialized format (even original format in the case of FileRuleList)
     * and create them in a lazy manner only when we really need them. When the filtering engine is
     * being initialized, we need to scan the rule lists once in order to fill up the lookup tables.
     * We use rule indexes as a unique rule identifier instead of the rule itself.
     * The rule is created (see RetrieveRule) only when there's a chance that it's needed.

     * Rule index is an int64 value that actually consists of two int32 values:
     * One is the rule list identifier, and the second is the index of the rule inside of that list.
    */
    var RuleStorage = /** @class */ (function () {
        /**
         * Constructor
         *
         * @param lists rule lists array
         *
         * @throws on duplicate lists
         */
        function RuleStorage(lists) {
            var _this = this;
            this.lists = lists;
            this.listsMap = new Map();
            this.cache = new Map();
            this.lists.forEach(function (list) {
                var filterListId = list.getId();
                if (_this.listsMap.get(filterListId)) {
                    throw new Error("Duplicate list ID: ".concat(filterListId));
                }
                _this.listsMap.set(filterListId, list);
            });
        }
        /**
         * Creates a new instance of RuleStorageScanner.
         * It can be used to read and parse all the storage contents.
         *
         * @return scanner instance
         */
        RuleStorage.prototype.createRuleStorageScanner = function (scannerType) {
            var scanners = this.lists.map(function (list) { return list.newScanner(scannerType); });
            return new RuleStorageScanner(scanners);
        };
        /**
         * Looks for the filtering rule in this storage
         *
         * @param storageIdx the lookup index that you can get from the rule storage scanner
         * @param ignoreHost rules could be retrieved as host rules
         */
        RuleStorage.prototype.retrieveRule = function (storageIdx, ignoreHost) {
            if (ignoreHost === void 0) { ignoreHost = true; }
            var _a = RuleStorageScanner.storageIdxToRuleListIdx(storageIdx), listId = _a[0], ruleIdx = _a[1];
            var rule = this.getFromCache(listId, ruleIdx);
            if (rule) {
                return rule;
            }
            var list = this.listsMap.get(listId);
            if (!list) {
                // List doesn't exist
                return null;
            }
            var ruleText = list.retrieveRuleText(ruleIdx);
            if (!ruleText) {
                return null;
            }
            var result = RuleFactory.createRule(ruleText, listId, false, false, ignoreHost);
            if (result) {
                this.saveToCache(listId, ruleIdx, result);
            }
            return result;
        };
        /**
         * RetrieveNetworkRule is a helper method that retrieves a network rule from the storage
         *
         * @param storageIdx
         * @return the rule or nil in any other case (not found or error)
         */
        RuleStorage.prototype.retrieveNetworkRule = function (storageIdx) {
            var rule = this.retrieveRule(storageIdx);
            if (!rule) {
                return null;
            }
            if (rule instanceof NetworkRule) {
                return rule;
            }
            return null;
        };
        /**
         * RetrieveHostRule is a helper method that retrieves a host rule from the storage
         *
         * @param storageIdx
         * @return the rule or nil in any other case (not found or error)
         */
        RuleStorage.prototype.retrieveHostRule = function (storageIdx) {
            var rule = this.retrieveRule(storageIdx, false);
            if (!rule) {
                return null;
            }
            if (rule instanceof HostRule) {
                return rule;
            }
            return null;
        };
        /**
         * Saves rule to cache
         *
         * @param listId
         * @param ruleIdx
         * @param rule
         */
        RuleStorage.prototype.saveToCache = function (listId, ruleIdx, rule) {
            var listCache = this.cache.get(listId);
            if (!listCache) {
                listCache = new ListCache();
                this.cache.set(listId, listCache);
            }
            listCache.set(ruleIdx, rule);
        };
        /**
         * Retrieves rule form cache
         *
         * @param listId
         * @param ruleIdx
         */
        RuleStorage.prototype.getFromCache = function (listId, ruleIdx) {
            var listCache = this.cache.get(listId);
            if (!listCache) {
                return undefined;
            }
            return listCache.get(ruleIdx);
        };
        return RuleStorage;
    }());

    /**
     * Rule converter class
     */
    var RuleConverter = /** @class */ (function () {
        function RuleConverter() {
        }
        /**
         * Converts rules text
         *
         * @param rulesText
         */
        RuleConverter.convertRules = function (rulesText) {
            var result = [];
            var lines = rulesText.split(/\r?\n/);
            for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
                var line = lines_1[_i];
                try {
                    result.push.apply(result, RuleConverter.convertRule(line));
                }
                catch (e) {
                    exports.logger.warn(e.message);
                }
            }
            return result.join('\n');
        };
        /**
         * TODO for more efficient conversion build AST. And then use the modified AST for creating a
         *  rule object.
         * Convert external scriptlet rule to AdGuard scriptlet syntax
         *
         * @param rawRule
         */
        RuleConverter.convertRule = function (rawRule) {
            var rule = rawRule.trim();
            if (rule.startsWith(SimpleRegex.MASK_COMMENT) || rule === '') {
                return [rule];
            }
            var comment = RuleConverter.convertUboComments(rule);
            if (comment) {
                return [comment];
            }
            var converted = rule;
            if (RuleFactory.isCosmetic(rule)) {
                converted = RuleConverter.convertCssInjection(converted);
                converted = RuleConverter.convertPseudoElements(converted);
                converted = RuleConverter.convertRemoveRule(converted);
                converted = RuleConverter.convertScriptHasTextToScriptTagContent(converted);
                converted = RuleConverter.convertUboMatchesPathRule(converted);
                // special case for ubo response header rule, it looks like cosmetic rule, but is converted to network rule
                var removeHeaderRule = RuleConverter.convertUboResponseHeaderRule(converted);
                if (removeHeaderRule) {
                    return [removeHeaderRule];
                }
            }
            else {
                var domainAndOptions = RuleConverter.splitIntoDomainAndOptions(converted);
                var domain = domainAndOptions[0];
                var optionsParts = domainAndOptions[1];
                if (optionsParts) {
                    optionsParts = RuleConverter.replaceOptions(optionsParts);
                    var ruleWithConvertedOptions = RuleConverter.convertOptions(domain, optionsParts);
                    if (ruleWithConvertedOptions) {
                        return ruleWithConvertedOptions;
                    }
                    converted = "".concat(domain, "$").concat(optionsParts.join(','));
                }
            }
            var scriptletRules = scriptlets_umd.exports.convertScriptletToAdg(converted);
            // TODO Check if isValidScriptletRule call is needed here, looks like convertScriptletToAdg
            //  should already return a valid scriptlet.
            if (scriptletRules && scriptletRules.every(function (x) { return RuleConverter.isValidScriptletRule(x); })) {
                return scriptletRules;
            }
            var adgRedirectRule = RuleConverter.convertUboAndAbpRedirectsToAdg(converted);
            if (adgRedirectRule) {
                return [adgRedirectRule];
            }
            if (converted.includes(RuleConverter.UBO_HTML_RULE_MASK)) {
                throw new SyntaxError("Invalid UBO script rule: ".concat(converted));
            }
            return [converted];
        };
        /**
         * Validates AdGuard syntax scriptlet rule.
         *
         * @param ruleText AdGuard scriptlet rule.
         */
        RuleConverter.isValidScriptletRule = function (ruleText) {
            try {
                // checks whether the ADG scriptlet rule name is valid
                return scriptlets_umd.exports.isValidScriptletRule(ruleText);
            }
            catch (e) {
                return false;
            }
        };
        /**
         * Converts UBO Script rule
         *
         * @param {string} ruleText rule text
         * @returns {string} converted rule
         */
        RuleConverter.convertScriptHasTextToScriptTagContent = function (ruleText) {
            if (ruleText.startsWith(SimpleRegex.MASK_COMMENT)
                || !RuleConverter.SCRIPT_HAS_TEXT_REGEX.test(ruleText)
                || RuleConverter.CSS_COMBINATORS_REGEX.test(ruleText)) {
                return ruleText;
            }
            var convertedRuleText = ruleText;
            var attributeStrings = [];
            // Cut all attributes substrings from rule text into array
            // https://github.com/AdguardTeam/tsurlfilter/issues/55
            if (RuleConverter.ATTRIBUTE_REGEX.test(ruleText)) {
                var globalAttributeRegExp = new RegExp(RuleConverter.ATTRIBUTE_REGEX, 'gi');
                attributeStrings = ruleText.match(globalAttributeRegExp);
                attributeStrings === null || attributeStrings === void 0 ? void 0 : attributeStrings.forEach(function (attrStr) {
                    convertedRuleText = convertedRuleText.replace(attrStr, '');
                });
            }
            // Convert base of the rule ##^script:has-text(text) to $$script[tag-content='text']
            convertedRuleText = "".concat(convertedRuleText
                .replace(RuleConverter.SCRIPT_HAS_TEXT_REGEX_SHORT, RuleConverter.SCRIPT_HAS_TEXT_REPLACEMENT)
                .slice(0, -1), "\"][max-length=\"262144\"]");
            // Escape double quotes inside tag-content, like it is required by AdGuard syntax
            // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#tag-content
            convertedRuleText = convertedRuleText.replace(RuleConverter.TAG_CONTENT_VALUE_REGEX, function (match, group) {
                return "[tag-content=\"".concat(group.replace(/"/g, '""'), "\"]");
            });
            // Return attributes if there were any
            attributeStrings === null || attributeStrings === void 0 ? void 0 : attributeStrings.forEach(function (attrStr) {
                convertedRuleText += attrStr;
            });
            return convertedRuleText;
        };
        /**
         * Converts UBO and ABP redirect rules to AdGuard redirect rules
         * @param rule
         * @return {string} convertedRule
         */
        RuleConverter.convertUboAndAbpRedirectsToAdg = function (rule) {
            var redirects = scriptlets_umd.exports.redirects;
            if (redirects.isUboRedirectCompatibleWithAdg(rule) || redirects.isAbpRedirectCompatibleWithAdg(rule)) {
                return redirects.convertRedirectToAdg(rule);
            }
            return null;
        };
        /**
         * Converts the rule options according to the conversion map and handles special cases.
         * @param domainPart - The domain part of the rule.
         * @param optionsParts - The options part of the rule as an array of strings.
         * @private
         */
        RuleConverter.convertOptions = function (domainPart, optionsParts) {
            var NAME_VALUE_SPLITTER = '=';
            var areOptionsConverted = false;
            var updatedOptionsParts = optionsParts.map(function (optionsPart) {
                var convertedOptionsPart = RuleConverter.OPTIONS_CONVERSION_MAP.get(optionsPart);
                // If option is $mp4, then it should go with $media option together
                if (optionsPart === 'mp4') {
                    // Check if media is not already among options
                    if (!optionsParts.some(function (option) { return option === 'media'; })) {
                        convertedOptionsPart = "".concat(convertedOptionsPart, ",media");
                    }
                }
                if (convertedOptionsPart) {
                    areOptionsConverted = true;
                    return convertedOptionsPart;
                }
                return optionsPart;
            });
            // If options have more than one csp modifiers, we merge them into one;
            var cspParts = updatedOptionsParts.filter(function (optionsPart) { return optionsPart.startsWith('csp'); });
            if (cspParts.length > 1) {
                var allButCsp = updatedOptionsParts.filter(function (optionsPart) { return !optionsPart.startsWith('csp'); });
                var cspValues = cspParts.map(function (cspPart) { return cspPart.split(NAME_VALUE_SPLITTER)[1]; });
                var updatedCspOption = "csp".concat(NAME_VALUE_SPLITTER).concat(cspValues.join('; '));
                updatedOptionsParts = allButCsp.concat(updatedCspOption);
            }
            if (areOptionsConverted) {
                var updatedOptions = updatedOptionsParts.join(',');
                return ["".concat(domainPart, "$").concat(updatedOptions)];
            }
            return null;
        };
        /**
         * Converts ubo syntax comments (rules starting with #)
         * Note: It's not possible to detect 100% cause rules starting with ## are valid elemhide rules
         *
         * @param rule
         * @return {string}
         */
        RuleConverter.convertUboComments = function (rule) {
            if (rule.startsWith('# ') || rule.startsWith('####')) {
                return "! ".concat(rule);
            }
            return null;
        };
        /**
         * Executes rule css conversion
         *
         * @param rule
         * @param parts
         * @param ruleMark
         */
        RuleConverter.executeConversion = function (rule, parts, ruleMark) {
            var result = rule;
            var domain = parts[0];
            if (domain) {
                var rulePart = parts[1];
                if (rulePart.match(RuleConverter.CSS_RULE_REPLACE_PATTERN)) {
                    var groups = RuleConverter.CSS_RULE_REPLACE_PATTERN.exec(rulePart);
                    if (groups != null) {
                        if (groups.length === 3) {
                            result = domain + ruleMark;
                            result += "".concat(groups[1], " { ").concat(groups[2], " }");
                        }
                    }
                }
            }
            return result;
        };
        /**
         * Adds colon to the pseudo elements written with one colon (:before, :after);
         * e.g.
         *  "hotline.ua##.reset-scroll:before" -> "hotline.ua##.reset-scroll::before"
         * @param rule
         * @private
         */
        RuleConverter.convertPseudoElements = function (rule) {
            var BEFORE = 'before';
            var AFTER = 'after';
            var SINGLE_COLON = ':';
            // does not have parts to convert
            if (!(rule.includes(SINGLE_COLON + BEFORE) || rule.includes(SINGLE_COLON + AFTER))) {
                return rule;
            }
            // not an css rule
            if (!(rule.includes(RuleConverter.MASK_ELEMENT_HIDING)
                || rule.includes(RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION)
                || rule.includes(RuleConverter.MASK_CSS)
                || rule.includes(RuleConverter.MASK_CSS_EXCEPTION))) {
                return rule;
            }
            var modifiedRule = '';
            for (var i = 0; i < rule.length; i += 1) {
                if (rule[i] !== SINGLE_COLON) {
                    modifiedRule += rule[i];
                    continue;
                }
                if ((rule.indexOf(BEFORE, i) === i + 1
                    || rule.indexOf(AFTER, i) === i + 1)
                    && rule[i - 1] !== SINGLE_COLON) {
                    modifiedRule += SINGLE_COLON;
                    modifiedRule += rule[i];
                    continue;
                }
                modifiedRule += rule[i];
            }
            return modifiedRule;
        };
        /**
         * Converts CSS injection
         * example.com##h1:style(background-color: blue !important)
         * into
         * example.com#$#h1 { background-color: blue !important }
         * <p>
         * OR (for exceptions):
         * example.com#@#h1:style(background-color: blue !important)
         * into
         * example.com#@$#h1 { background-color: blue !important }
         *
         * @param {string} rule
         * @return {string} convertedRule
         */
        RuleConverter.convertCssInjection = function (rule) {
            if (rule.includes(':style')) {
                var parts = void 0;
                var resultMask = void 0;
                var resultRule = rule;
                var isExtendedCss = false;
                for (var i = 0; i < EXT_CSS_PSEUDO_INDICATORS.length; i += 1) {
                    isExtendedCss = rule.indexOf(EXT_CSS_PSEUDO_INDICATORS[i]) !== -1;
                    if (isExtendedCss) {
                        break;
                    }
                }
                if (rule.includes(RuleConverter.MASK_CSS_EXTENDED_CSS_RULE)) {
                    parts = rule.split(RuleConverter.MASK_CSS_EXTENDED_CSS_RULE, 2);
                    resultMask = RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE;
                }
                else if (rule.includes(RuleConverter.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE)) {
                    parts = rule.split(RuleConverter.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE, 2);
                    resultMask = RuleConverter.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE;
                    // firstly we check for exception rule in order not to confuse with id selectors
                    // e.g. yourconroenews.com#@##siteNav:style(transform: none !important;)
                }
                else if (rule.includes(RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION)) {
                    parts = rule.split(RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION, 2);
                    if (isExtendedCss) {
                        resultMask = RuleConverter.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE;
                    }
                    else {
                        resultMask = RuleConverter.MASK_CSS_EXCEPTION;
                    }
                }
                else if (rule.includes(RuleConverter.MASK_ELEMENT_HIDING)) {
                    parts = rule.split(RuleConverter.MASK_ELEMENT_HIDING, 2);
                    if (isExtendedCss) {
                        resultMask = RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE;
                    }
                    else {
                        resultMask = RuleConverter.MASK_CSS;
                    }
                }
                if (parts && resultMask) {
                    resultRule = RuleConverter.executeConversion(rule, parts, resultMask);
                }
                return resultRule;
            }
            return rule;
        };
        /**
         * Converts ':remove()' rule to AdGuard extended css rule
         * example.com###banner:remove() -> example.com#$?##banner { remove: true; }
         * @param {string} rule
         * @return {string} rule or converted rule
         */
        RuleConverter.convertRemoveRule = function (rule) {
            // if rule is already extended css, do not convert it
            if (rule.includes(RuleConverter.MASK_CSS_EXTENDED_CSS_RULE)) {
                return rule;
            }
            if (rule.includes(RuleConverter.MASK_ELEMENT_HIDING) && rule.endsWith(RuleConverter.REMOVE_RULE_PATTERN)) {
                return rule
                    .replace(RuleConverter.MASK_ELEMENT_HIDING, RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE)
                    .replace(RuleConverter.REMOVE_RULE_PATTERN, RuleConverter.REMOVE_RULE_REPLACER);
            }
            return rule;
        };
        /**
         * Converts '^responseheader()' rule to AdGuard's $removeheader modifier
         * "ya.ru##^responseheader(header-name)" -> "||ya.ru^$removeheader=header-name"
         *
         * @param {string} ruleText
         * @return {string} ruleText or converted rule
         */
        RuleConverter.convertUboResponseHeaderRule = function (ruleText) {
            if (ruleText.startsWith(SimpleRegex.MASK_COMMENT) || !ruleText.includes(RuleConverter.UBO_RESPONSE_HEADER)) {
                return null;
            }
            if (RuleConverter.UBO_RESPONSE_HEADER_REGEX.test(ruleText)) {
                return "||".concat(ruleText.replace(RuleConverter.UBO_RESPONSE_HEADER_REGEX, RuleConverter.UBO_RESPONSE_HEADER_REPLACEMENT)
                    .slice(0, -1));
            }
            if (RuleConverter.UBO_RESPONSE_HEADER_EXCEPTION_REGEX.test(ruleText)) {
                return "@@||".concat(ruleText.replace(RuleConverter.UBO_RESPONSE_HEADER_EXCEPTION_REGEX, RuleConverter.UBO_RESPONSE_HEADER_REPLACEMENT).slice(0, -1));
            }
            return ruleText;
        };
        /**
         * Converts cosmetic 'matches-path()' rule to AdGuard's $path modifier
         * "ya.ru##:matches-path(/page) p" -> "[$path=/page]ya.ru##p"
         *
         * @param {string} ruleText
         * @return {string} ruleText or converted rule
         */
        RuleConverter.convertUboMatchesPathRule = function (ruleText) {
            if (ruleText.startsWith(SimpleRegex.MASK_COMMENT)) {
                return ruleText;
            }
            var _b = findCosmeticRuleMarker(ruleText), markerIndex = _b[0], marker = _b[1];
            if (!marker) {
                return ruleText;
            }
            var expressionStartIndex = markerIndex + marker.length;
            var matchesPathStartIndex = ruleText.indexOf(RuleConverter.UBO_MATCHES_PATH, expressionStartIndex);
            if (matchesPathStartIndex === -1) {
                return ruleText;
            }
            var reversedMatchesPathStartIndex = ruleText.indexOf(RuleConverter.UBO_REVERSED_MATCHES_PATH, expressionStartIndex);
            var isReversed = reversedMatchesPathStartIndex !== -1;
            var pathStartIndex = isReversed
                ? reversedMatchesPathStartIndex + RuleConverter.UBO_REVERSED_MATCHES_PATH.length
                : matchesPathStartIndex + RuleConverter.UBO_MATCHES_PATH.length;
            var matchPathOperatorCloseBracketIndex;
            var openBracketCounter = 1;
            var closeBracketCounter = 0;
            for (var i = pathStartIndex; i < ruleText.length; i += 1) {
                if (ruleText[i - 1] !== '\\') {
                    if (ruleText[i] === '(') {
                        openBracketCounter += 1;
                    }
                    else if (ruleText[i] === ')') {
                        closeBracketCounter += 1;
                        if (openBracketCounter === closeBracketCounter) {
                            matchPathOperatorCloseBracketIndex = i;
                            break;
                        }
                    }
                }
            }
            if (!matchPathOperatorCloseBracketIndex) {
                return ruleText;
            }
            var domains = ruleText.slice(0, markerIndex);
            var expressionMiddle = ruleText.slice(expressionStartIndex, isReversed ? reversedMatchesPathStartIndex : matchesPathStartIndex);
            var expressionTail = ruleText
                .slice(matchPathOperatorCloseBracketIndex + (isReversed ? 2 : 1))
                .trim();
            var path = ruleText.slice(pathStartIndex, matchPathOperatorCloseBracketIndex);
            var isRegex = SimpleRegex.isRegexPattern(path);
            if (isReversed) {
                path = "/^((?!".concat(isRegex ? path.slice(1, path.length - 1) : SimpleRegex.patternToRegexp(path), ").)*$/");
            }
            if (isRegex) {
                path = SimpleRegex.escapeRegexSpecials(path, SimpleRegex.reModifierPatternSpecialCharacters);
            }
            return "[$path=".concat(path, "]").concat(domains).concat(marker).concat(expressionMiddle).concat(expressionTail);
        };
        /**
         * Substitutes option aliases in the provided options array with their corresponding aliases.
         *
         * @param optionsParts - An array of options to replace aliases in.
         * @returns - An array of options with aliases replaced.
         */
        RuleConverter.replaceOptions = function (optionsParts) {
            var resultOptions = optionsParts.map(function (option) {
                var _b = option.split('=', 2), optionNameRaw = _b[0], optionValue = _b[1];
                var isNegated = optionNameRaw.startsWith('~');
                var optionName = isNegated ? optionNameRaw.slice(1) : optionNameRaw;
                var convertedOptionName = RuleConverter.OPTIONS_ALIASES[optionName];
                if (!convertedOptionName) {
                    return option;
                }
                var negationPrefix = isNegated ? '~' : '';
                return optionValue
                    ? "".concat(negationPrefix).concat(convertedOptionName, "=").concat(optionValue)
                    : "".concat(negationPrefix).concat(convertedOptionName);
            });
            return resultOptions;
        };
        var _a;
        _a = RuleConverter;
        RuleConverter.CSS_RULE_REPLACE_PATTERN = /(.*):style\((.*)\)/g;
        // eslint-disable-next-line max-len
        RuleConverter.SCRIPT_HAS_TEXT_REGEX = /##\^(script(\[[{a-z0-9-_.:}]*(="[{a-z0-9-_.:}]*")*\])*:(has-text|contains))\((?!\/.+\/\))/i;
        RuleConverter.SCRIPT_HAS_TEXT_REGEX_SHORT = /(##\^script:(has-text|contains))\((?!\/.+\/\))/i;
        RuleConverter.TAG_CONTENT_VALUE_REGEX = /\[tag-content="(.*?)"]/g;
        RuleConverter.ATTRIBUTE_REGEX = /(\[[{a-z0-9-_.:}]*(="[{a-z0-9-_.:}]*")*\])/i;
        RuleConverter.CSS_COMBINATORS_REGEX = />|\+|~/;
        RuleConverter.SCRIPT_HAS_TEXT_REPLACEMENT = '$$$$script[tag-content="';
        RuleConverter.UBO_RESPONSE_HEADER = '#^responseheader(';
        RuleConverter.UBO_RESPONSE_HEADER_REGEX = /##\^responseheader\((?!\/.+\/\))/i;
        RuleConverter.UBO_RESPONSE_HEADER_EXCEPTION_REGEX = /#@#\^responseheader\((?!\/.+\/\))/i;
        RuleConverter.UBO_RESPONSE_HEADER_REPLACEMENT = '^$removeheader=';
        RuleConverter.UBO_MATCHES_PATH = ':matches-path(';
        RuleConverter.UBO_REVERSED_MATCHES_PATH = ':not(:matches-path(';
        /**
         * Rule masks
         */
        RuleConverter.MASK_ELEMENT_HIDING = '##';
        RuleConverter.UBO_HTML_RULE_MASK = '##^';
        RuleConverter.MASK_ELEMENT_HIDING_EXCEPTION = '#@#';
        RuleConverter.MASK_CSS = '#$#';
        RuleConverter.MASK_CSS_EXCEPTION = '#@$#';
        RuleConverter.MASK_CSS_EXTENDED_CSS_RULE = '#?#';
        RuleConverter.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE = '#@?#';
        RuleConverter.MASK_CSS_INJECT_EXTENDED_CSS_RULE = '#$?#';
        RuleConverter.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE = '#@$?#';
        RuleConverter.REMOVE_RULE_PATTERN = ':remove()';
        RuleConverter.REMOVE_RULE_REPLACER = ' { remove: true; }';
        /**
         * Special characters
         */
        RuleConverter.REGEXP_DELIMITER = '/';
        RuleConverter.ESCAPING_SLASH = '\\';
        /**
         * Splits the given rule text into domain and options parts using the options delimiter ($).
         * Returns the domain part and an array of options, or null if no options are present.
         *
         * @param ruleText - The rule text to be split.
         * @returns [domain, options] or [domain, null] if no options are present.
         */
        RuleConverter.splitIntoDomainAndOptions = function (ruleText) {
            var optionsDelimiterIdx = -1;
            var inRegExp = false;
            for (var i = ruleText.length - 1; i >= 0; i -= 1) {
                if (!inRegExp && ruleText[i] === OPTIONS_DELIMITER) {
                    optionsDelimiterIdx = i;
                    break;
                }
                if (ruleText[i] === _a.REGEXP_DELIMITER
                    && (i === 0 || ruleText[i - 1] !== _a.ESCAPING_SLASH)) {
                    inRegExp = !inRegExp;
                }
            }
            if (optionsDelimiterIdx === -1) {
                return [ruleText, null];
            }
            var domainPart = ruleText.slice(0, optionsDelimiterIdx);
            var optionsPart = ruleText.slice(optionsDelimiterIdx + 1);
            // do not remove escape characters from regexp modifiers values
            var optionsParts = parseOptionsString(optionsPart, false);
            return [domainPart, optionsParts];
        };
        /**
         * These option shortcuts will be converted to a more wordy AdGuard options.
         * @private
         */
        RuleConverter.OPTIONS_CONVERSION_MAP = new Map([
            // See https://adguard.com/kb/general/ad-filtering/create-own-filters/#empty-modifier
            ['empty', 'redirect=nooptext'],
            // See https://adguard.com/kb/general/ad-filtering/create-own-filters/#mp4-modifier
            ['mp4', 'redirect=noopmp4-1s'],
            ['inline-script', "csp=script-src 'self' 'unsafe-eval' http: https: data: blob: mediastream: filesystem:"],
            ['inline-font', "csp=font-src 'self' 'unsafe-eval' http: https: data: blob: mediastream: filesystem:"],
        ]);
        /**
         * Options aliases, used to convert non-AdGuard options to AdGuard options
         */
        RuleConverter.OPTIONS_ALIASES = {
            'first-party': '~third-party',
            xhr: 'xmlhttprequest',
            css: 'stylesheet',
            frame: 'subdocument',
            queryprune: 'removeparam',
            doc: 'document',
            '1p': '~third-party',
            '3p': 'third-party',
            ghide: 'generichide',
            ehide: 'elemhide',
            shide: 'specifichide',
        };
        return RuleConverter;
    }());

    /**
     * Module, which can be used to validate filter rules in other libraries
     */
    var RuleValidator = /** @class */ (function () {
        function RuleValidator() {
        }
        /**
         * Creates validation result
         * @param valid
         * @param error
         * @private
         */
        RuleValidator.createValidationResult = function (valid, error) {
            if (error) {
                return { valid: valid, error: error };
            }
            return { valid: valid, error: null };
        };
        RuleValidator.validateRegexp = function (pattern, ruleText) {
            if (pattern.startsWith(SimpleRegex.MASK_REGEX_RULE)
                && pattern.endsWith(SimpleRegex.MASK_REGEX_RULE)) {
                try {
                    new RegExp(pattern.slice(1, -1));
                }
                catch (e) {
                    throw new SyntaxError("Rule has invalid regex pattern: \"".concat(ruleText, "\""));
                }
            }
        };
        /**
         * Validates raw rule string
         * @param rawRule
         */
        RuleValidator.validate = function (rawRule) {
            var ruleText = rawRule.trim();
            if (!ruleText || RuleFactory.isComment(ruleText)) {
                return RuleValidator.createValidationResult(true);
            }
            if (RuleFactory.isShort(ruleText)) {
                return RuleValidator.createValidationResult(false, "Rule is too short: ".concat(ruleText));
            }
            try {
                // Validate cosmetic rules
                if (RuleFactory.isCosmetic(ruleText)) {
                    new CosmeticRule(ruleText, 0);
                    return RuleValidator.createValidationResult(true);
                }
                // Validate network rules
                var rule = new NetworkRule(ruleText, 0);
                RuleValidator.validateRegexp(rule.getPattern(), rule.getText());
            }
            catch (e) {
                var errorMessage = "Error: \"".concat(e.message, "\" in the rule: \"").concat(ruleText, "\"");
                return RuleValidator.createValidationResult(false, errorMessage);
            }
            return RuleValidator.createValidationResult(true);
            // TODO validate host rules
        };
        return RuleValidator;
    }());

    /**
     * Module with miscellaneous syntax utils exposed in API
     */
    var RuleSyntaxUtils = /** @class */ (function () {
        function RuleSyntaxUtils() {
        }
        /**
         * Checks if rule can be matched by domain
         * @param ruleText
         * @param domain
         */
        RuleSyntaxUtils.isRuleForDomain = function (ruleText, domain) {
            var rule = RuleFactory.createRule(ruleText, this.DUMMY_FILTER_ID);
            if (!rule) {
                return false;
            }
            return rule.matchesPermittedDomains(domain);
        };
        /**
         * Checks if rule can be matched by url
         * @param ruleText
         * @param url
         */
        RuleSyntaxUtils.isRuleForUrl = function (ruleText, url) {
            var domain = getHostname(url);
            if (!domain) {
                return false;
            }
            return this.isRuleForDomain(ruleText, domain);
        };
        RuleSyntaxUtils.DUMMY_FILTER_ID = 0;
        return RuleSyntaxUtils;
    }());

    exports.CookieModifier = CookieModifier;
    exports.CosmeticResult = CosmeticResult;
    exports.CosmeticRule = CosmeticRule;
    exports.CosmeticRuleParser = CosmeticRuleParser;
    exports.DnsEngine = DnsEngine;
    exports.DnsResult = DnsResult;
    exports.EXT_CSS_PSEUDO_INDICATORS = EXT_CSS_PSEUDO_INDICATORS;
    exports.Engine = Engine;
    exports.HostRule = HostRule;
    exports.IndexedRule = IndexedRule;
    exports.IndexedStorageRule = IndexedStorageRule;
    exports.LIST_ID_MAX_VALUE = LIST_ID_MAX_VALUE;
    exports.MatchingResult = MatchingResult;
    exports.NETWORK_RULE_OPTIONS = NETWORK_RULE_OPTIONS;
    exports.NetworkRule = NetworkRule;
    exports.OPTIONS_DELIMITER = OPTIONS_DELIMITER;
    exports.RemoveHeaderModifier = RemoveHeaderModifier;
    exports.RemoveParamModifier = RemoveParamModifier;
    exports.ReplaceModifier = ReplaceModifier;
    exports.Request = Request$1;
    exports.RequestType = RequestType;
    exports.RuleConverter = RuleConverter;
    exports.RuleFactory = RuleFactory;
    exports.RuleStorage = RuleStorage;
    exports.RuleSyntaxUtils = RuleSyntaxUtils;
    exports.RuleValidator = RuleValidator;
    exports.SimpleRegex = SimpleRegex;
    exports.StringRuleList = StringRuleList;
    exports.cleanUrlParamByRegExp = cleanUrlParamByRegExp;
    exports.fastHash = fastHash;
    exports.getRelativeUrl = getRelativeUrl;
    exports.hasUnquotedSubstring = hasUnquotedSubstring;
    exports.indexOfAny = indexOfAny;
    exports.isCompatibleWith = isCompatibleWith;
    exports.isDomainName = isDomainName;
    exports.replaceAll = replaceAll;
    exports.setConfiguration = setConfiguration;
    exports.setLogger = setLogger;
    exports.splitByDelimiterWithEscapeCharacter = splitByDelimiterWithEscapeCharacter;
    exports.startsAtIndexWith = startsAtIndexWith;
    exports.stringArraysEquals = stringArraysEquals;
    exports.stringArraysHaveIntersection = stringArraysHaveIntersection;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
