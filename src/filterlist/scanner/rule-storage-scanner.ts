import { RuleScanner } from './rule-scanner';
import { IndexedStorageRule } from '../../rules/rule';

/**
 * RuleStorageScanner scans multiple RuleScanner instances
 * The rule index is built from the rule index in the list + the list ID
 * First 4 bytes is the rule index in the list
 * Second 4 bytes is the list ID
*/
export class RuleStorageScanner {
    /**
     * Scanners is the list of list scanners backing this combined scanner
     */
    private readonly scanners: RuleScanner[];

    /**
     * Current scanner
     */
    private currentScanner: RuleScanner | null = null;

    /**
     * Index of the current scanner
     */
    private currentScannerIdx = -1;

    /**
     * Constructor
     *
     * @param scanners
     */
    constructor(scanners: RuleScanner[]) {
        this.scanners = scanners;
    }

    /**
     * Scan advances the RuleStorageScanner to the next rule, which will then be available
     * through the Rule method. It returns false when the scan stops, either by
     * reaching the end of the input or an error.
     *
     * @return true if there is some result
    */
    public scan(): boolean {
        if (this.scanners.length === 0) {
            return false;
        }

        if (!this.currentScanner) {
            this.currentScannerIdx = 0;
            this.currentScanner = this.scanners[this.currentScannerIdx];
        }

        while (true) {
            if (this.currentScanner.scan()) {
                return true;
            }

            // Take the next scanner or just return false if there's nothing more
            if (this.currentScannerIdx === (this.scanners.length - 1)) {
                return false;
            }

            this.currentScannerIdx += 1;
            this.currentScanner = this.scanners[this.currentScannerIdx];
        }
    }

    /**
     * Rule returns the most recent rule generated by a call to Scan, and the index of this rule.
     * See ruleListIdxToStorageIdx for more information on what this index is.
    */
    public getRule(): IndexedStorageRule | null {
        if (!this.currentScanner) {
            return null;
        }

        const rule = this.currentScanner.getRule();
        if (!rule) {
            return null;
        }

        const index = RuleStorageScanner.ruleListIdxToStorageIdx(rule.rule.getFilterListId(), rule.index);
        return new IndexedStorageRule(rule.rule, index);
    }

    /**
     * ruleListIdxToStorageIdx converts pair of listID and rule list index
     * to a single int64 "storage index"
     *
     * @param listId
     * @param ruleIdx
     */
    private static ruleListIdxToStorageIdx(listId: number, ruleIdx: number): bigint {
        // eslint-disable-next-line no-mixed-operators
        return BigInt.asUintN(64, BigInt(listId) << BigInt(32) | BigInt(ruleIdx));
    }

    /**
     * Converts the "storage index" to two integers:
     * listID -- rule list identifier
     * ruleIdx -- index of the rule in the list
     *
     * @param storageIdx
     * @return [listId, ruleIdx]
     */
    public static storageIdxToRuleListIdx(storageIdx: bigint): [number, number] {
        return [Number(storageIdx >> BigInt(32)), Number(storageIdx & BigInt(0xFFFFFF))];
    }
}
