{"version":3,"file":"adguard-content.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;ACVA;AACA,MAAM,IAA0C;AAChD,IAAI,iCAAgC,CAAC,MAAQ,CAAC,oCAAE,OAAO;AAAA;AAAA;AAAA,kGAAC;AACxD,IAAI,KAAK,YAQN;AACH,CAAC;AACD;;AAEA,sCAAsC;;AAEtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wHAAwH;AACxH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG;AACpB,mBAAmB,SAAS;AAC5B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA,iBAAiB,UAAU;AAC3B;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;;AAGA;AACA;AACA;AACA,iDAAiD,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AAC5I;;AAEA;AACA,gDAAgD,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AAC3I;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB,gCAAgC,MAAM;AACtC,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,iBAAiB,QAAQ,cAAc;AACvC;AACA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA,iBAAiB,QAAQ,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mBAAmB;AACnB;;AAEA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA,eAAe;AACf;AACA;;AAEA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oCAAoC;AACrD;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;;AAGA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,aAAa;AAChC;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA,0EAA0E;AAC1E;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA,YAAY;;;AAGZ;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AAC1I;;AAEA;AACA,8CAA8C,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AACzI;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;;;;;;;UCpvCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;;AAEpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,wEAAwE;AACjF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0BAA0B;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,UAAU;AACpD,0CAA0C,UAAU;AACpD,aAAa,KAAK,GAAG,MAAM;AAC3B,GAAG;AACH;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,oBAAoB,EAAE,yBAAyB,EAAE,qBAAqB,EAAE,MAAM;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,kMAAkM;AAClM;;AAEA;AACA,kEAAkE,SAAS;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,GAAG;;AAEZ;AACA,QAAQ;;;AAGR;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;;;AAGN;AACA,GAAG,GAAG;;AAEN;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oEAAoE,MAAM;AAC1E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+DAA+D,6BAA6B;AAC5F;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,0DAA0D,gBAAgB;AAC1E,mDAAmD,4BAA4B,kBAAkB,WAAW;AAC5G,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;;AAGA,qEAAqE;;AAErE;AACA;AACA;AACA,oHAAoH;AACpH;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB,sCAAsC,oBAAoB;AAC3G;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,wBAAwB,sCAAsC,WAAW;AAClG;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA,gEAAgE;;AAEhE,qHAAqH;AACrH;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;;AAGA,yBAAyB,wBAAwB;AACjD,IAAI;AACJ;AACA;;;AAGA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,QAAQ;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kEAAkE,SAAS;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mCAAmC,KAAK,SAAS;AAC1E,MAAM;AACN;AACA;;;AAGA,2CAA2C;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe,yDAAyD,0CAA0C;AACrJ,MAAM;AACN;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;;AAEA;;AAEA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,sCAAsC,MAAM,EAAE,MAAM;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4DAA4D;AAC5D;;AAEA;AACA;AACA;AACA,+GAA+G;;AAE/G;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA,QAAQ;AACR;;;AAGA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6DAA6D;;AAE7D,oCAAoC,MAAM,EAAE,WAAW,EAAE,yBAAyB,EAAE,wBAAwB,EAAE,0BAA0B;AACxI,uCAAuC,sCAAsC,EAAE,qBAAqB;AACpG;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,sBAAsB,uBAAuB,EAAE,MAAM,EAAE,sBAAsB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,yDAAyD;;AAEzD;AACA,wBAAwB;;AAExB;AACA,oHAAoH;;AAEpH;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,8CAA8C;;AAE9C,iFAAiF;AACjF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,iEAAiE;;AAEjE;AACA,yEAAyE;AACzE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA,MAAM,SAAS;;AAEf;AACA;AACA,kGAAkG;AAClG;AACA;AACA;;AAEA;AACA,0HAA0H;AAC1H;AACA;;AAEA;AACA;AACA,8GAA8G;AAC9G;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B,KAAK,SAAS;AACxE;;AAEA,gEAAgE;;AAEhE,sEAAsE;AACtE;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA,wFAAwF;;AAExF;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS;AAC3C,cAAc;AACd;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,eAAe;AAC7E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C,gBAAgB;AAChB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,+BAA+B;AAC/B,oCAAoC,SAAS;AAC7C,gBAAgB;;;AAGhB;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,qDAAqD;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,wDAAwD;;AAExD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS,oCAAoC,WAAW,WAAW,yBAAyB;AAChI,gBAAgB;AAChB;;;AAGA;AACA,yDAAyD;;AAEzD;AACA,gBAAgB;;;AAGhB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2BAA2B,KAAK,SAAS;AAC1E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mCAAmC,0BAA0B,UAAU,eAAe;AACtF,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;;;AAGhB;AACA;;AAEA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;;AAEA,gEAAgE;;AAEhE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8EAA8E,SAAS;AACvF,gBAAgB;AAChB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mCAAmC,mCAAmC,KAAK,SAAS;AACpF,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0FAA0F,SAAS;AACnG,gBAAgB;AAChB;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,qFAAqF,SAAS;AAC9F,gBAAgB;AAChB;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA,gBAAgB;AAChB;AACA;AACA,sEAAsE;;AAEtE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0DAA0D;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,uDAAuD;;AAEvD;AACA;;AAEA;AACA;AACA;AACA,sEAAsE,SAAS;AAC/E,kBAAkB;AAClB;;;AAGA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qBAAqB,oEAAoE,mBAAmB;AAC3J;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;;AAEzC;AACA;AACA;AACA,qDAAqD,iBAAiB;AACtE;AACA;AACA;AACA,cAAc;AACd;AACA,kCAAkC,SAAS;AAC3C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,WAAW;AAC9D;;AAEA;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC;;AAEA;AACA;AACA,uEAAuE,0CAA0C;AACjH;;AAEA;AACA,mEAAmE,SAAS;AAC5E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU,IAAI,gCAAgC;AAC7D,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;;AAEA;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,IAAI;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iDAAiD,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,0BAA0B,EAAE,OAAO,EAAE;AACrC,uCAAuC;AACvC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA,0CAA0C,KAAK;AAC/C,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4EAA4E,WAAW,WAAW,OAAO;AACzG,IAAI;;;AAGJ;AACA;AACA;AACA;AACA,8BAA8B,MAAM,EAAE,MAAM,EAAE,qBAAqB;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;;AAEJ;AACA,sEAAsE,WAAW,WAAW,cAAc;AAC1G;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,4CAA4C,WAAW,oBAAoB,cAAc;AACzF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,0CAA0C,OAAO;AACjD;AACA,IAAI;AACJ;AACA;AACA,+DAA+D,OAAO;AACtE;;AAEA;AACA;AACA,IAAI;AACJ;AACA,4CAA4C,OAAO;AACnD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,8DAA8D,YAAY,OAAO,UAAU;AAC3F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,mDAAmD;;AAEnD;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+EAA+E,MAAM;;AAErF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,+BAA+B;AAC/B,0BAA0B,IAAI;;AAE9B,2BAA2B,MAAM;AACjC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wDAAwD,MAAM;AAC9D;;AAEA;AACA;AACA;AACA,wCAAwC,QAAQ,yBAAyB,MAAM;AAC/E;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA,mDAAmD,QAAQ,uBAAuB,MAAM;AACxF;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI,6CAA6C;AACjD;;AAEA;AACA,gCAAgC,YAAY,gBAAgB,gBAAgB;AAC5E;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,wBAAwB;AAC9C;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,8CAA8C,WAAW,mBAAmB,UAAU;AACtF;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,YAAY,iBAAiB,OAAO;AAChF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kDAAkD,WAAW,gCAAgC,IAAI;AACjG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,+BAA+B,EAAE,SAAS,oBAAoB,WAAW,wBAAwB,UAAU;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD,WAAW;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,uEAAuE,aAAa;AACpF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,aAAa;AACjF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,uBAAuB,EAAE,iBAAiB;AACzE;AACA;AACA;;AAEA,4BAA4B,uBAAuB,EAAE,sBAAsB;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,WAAW;AACnG,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,6BAA6B,oBAAoB,EAAE,oBAAoB,EAAE,gBAAgB;AACzF,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB,EAAE,SAAS;AACzD,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB,EAAE,gBAAgB;AAChE;AACA;;AAEA;AACA,uCAAuC,WAAW;AAClD;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN,wCAAwC;;AAExC,+CAA+C,WAAW,oBAAoB,gBAAgB;AAC9F;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4DAA4D,WAAW;AACvE;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,oBAAoB,EAAE,sCAAsC;AAC7F;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;;AAGA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4DAA4D,WAAW;AACvE;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,oBAAoB,EAAE,sCAAsC;AAC7F;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,wCAAwC;;AAExC,+CAA+C,WAAW,oBAAoB,sCAAsC;AACpH,MAAM;AACN;AACA;;;AAGA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wBAAwB;AAC1D;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,mDAAmD,aAAa,MAAM,mBAAmB;AACzF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wFAAwF,WAAW;;AAEnG;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR,gDAAgD,WAAW,oBAAoB,kBAAkB;AACjG;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA,2DAA2D,WAAW;AACtE;;AAEA;AACA,IAAI;AACJ;AACA,uDAAuD,WAAW;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,uBAAuB,EAAE,MAAM;AAClE;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,oBAAoB,EAAE,oBAAoB,EAAE,MAAM;AACrF;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA,mCAAmC,iBAAiB,EAAE,kCAAkC;AACxF;AACA,KAAK;AACL,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA,GAAG,GAAG;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,MAAM,EAAE,qBAAqB,EAAE,yBAAyB,EAAE,0BAA0B,GAAG;;AAExH,mCAAmC,MAAM,EAAE,qBAAqB,EAAE,yBAAyB;AAC3F;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,uCAAuC,KAAK,YAAY;AAC/E,IAAI;AACJ;AACA;AACA;AACA,yBAAyB,mCAAmC,KAAK,YAAY;AAC7E,MAAM;AACN;AACA;AACA,yBAAyB,qCAAqC,KAAK,YAAY;AAC/E,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,uBAAuB,mCAAmC,KAAK,YAAY;AAC3E,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,wBAAwB,KAAK,SAAS;AAC7D;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,uBAAuB,mCAAmC,KAAK,SAAS;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D;AAC5D;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,2DAA2D,SAAS;AACpE;;AAEA;AACA,oDAAoD,SAAS;AAC7D;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,2DAA2D,SAAS;AACpE;;AAEA;AACA,8DAA8D,SAAS;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8EAA8E;AAC9E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,4EAA4E,QAAQ;AACpF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,GAAG,GAAG;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,gCAAgC;AAChC,mEAAmE,WAAW;AAC9E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD,gFAAgF,WAAW;AAC3F,UAAU;;;AAGV,gEAAgE;;AAEhE,qDAAqD;AACrD,QAAQ,wDAAwD;AAChE;AACA;AACA,sEAAsE,WAAW;AACjF;;AAEA;;AAEA;AACA,gEAAgE,WAAW,qBAAqB,WAAW;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,uBAAuB,qBAAqB,WAAW;AACtH,UAAU;AACV;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,eAAe;AACf,kCAAkC;AAClC;AACA,UAAU;AACV;AACA;AACA,iCAAiC;;AAEjC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,+DAA+D,uBAAuB,qBAAqB,WAAW;AACtH,UAAU;AACV;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;;AAEA;AACA,6DAA6D,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA,IAAI;AACJ,2BAA2B;;;AAG3B;AACA,4EAA4E,WAAW;AACvF,IAAI;AACJ;AACA,+BAA+B,eAAe;;;AAG9C;AACA;AACA;AACA,cAAc,WAAW;AACzB,cAAc,QAAQ;AACtB;AACA,2DAA2D,uBAAuB,oBAAoB,WAAW;AACjH;;AAEA;AACA,IAAI;AACJ,kBAAkB;;;AAGlB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,sBAAsB;AACtB;AACA,+CAA+C,uBAAuB;AACtE,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA,0BAA0B,MAAM,EAAE,SAAS,0BAA0B,SAAS,EAAE,MAAM;AACtF;AACA;;AAEA,uEAAuE;AACvE,aAAa,gBAAgB;;AAE7B;AACA;AACA;;AAEA,oBAAoB,iBAAiB,oBAAoB;;AAEzD;AACA,uBAAuB,6BAA6B,KAAK,kCAAkC;AAC3F;;AAEA,2BAA2B;AAC3B,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL,mDAAmD,QAAQ;AAC3D;;AAEA;AACA,oDAAoD,0BAA0B,QAAQ;AACtF,MAAM,wBAAwB;;;AAG9B,8CAA8C;;AAE9C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6DAA6D;AAC7D;;AAEA;AACA,2JAA2J;;AAE3J;AACA,MAAM;AACN;AACA,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,wBAAwB,KAAK,cAAc,aAAa;AACxD;AACA,GAAG,GAAG;;AAEN;AACA,qCAAqC,sBAAsB;AAC3D;;AAEA;AACA;;AAEA,mCAAmC;AACnC,sCAAsC,EAAE;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,uBAAuB,wBAAwB,KAAK,SAAS;AAC7D;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,uBAAuB,mCAAmC,KAAK,SAAS;AACxE;;AAEA;AACA;AACA;AACA,yBAAyB,sCAAsC,KAAK,mBAAmB;AACvF,MAAM;;;AAGN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D;AAC5D;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;;;AAGA;AACA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA,uBAAuB,iCAAiC,KAAK,mBAAmB;AAChF;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA,2BAA2B,4BAA4B,KAAK,mBAAmB;AAC/E,QAAQ;AACR,iBAAiB,gBAAgB,yBAAyB;;AAE1D,MAAM;AACN,iCAAiC;AACjC,4DAA4D,QAAQ;AACpE,wBAAwB,cAAc,eAAe,SAAS,sBAAsB;AACpF,yBAAyB,iCAAiC,KAAK,mBAAmB;AAClF;;AAEA;AACA;;AAEA;AACA,iCAAiC,aAAa,QAAQ;;AAEtD;AACA;;AAEA;AACA,yBAAyB,kCAAkC,KAAK,mBAAmB;AACnF;;AAEA;AACA,wBAAwB;;AAExB;;AAEA;AACA,yBAAyB,+BAA+B,KAAK,mBAAmB;AAChF;;AAEA;;AAEA;AACA,yBAAyB,4BAA4B,KAAK,mBAAmB;AAC7E;;AAEA;AACA;AACA;AACA,KAAK,GAAG,6BAA6B;AACrC,eAAe,eAAe,UAAU;;AAExC;AACA;AACA;AACA,IAAI,0CAA0C;AAC9C;;;AAGA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,iEAAiE;;AAEjE;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,uDAAuD;AACvD;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,6BAA6B,MAAM,EAAE,SAAS,6BAA6B,SAAS,EAAE,MAAM;AAC5F,uBAAuB,+BAA+B,kBAAkB,WAAW;AACnF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA,0EAA0E;AAC1E,iBAAiB,gBAAgB;;AAEjC;AACA,2BAA2B,+BAA+B,KAAK,mBAAmB;AAClF;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA,6DAA6D;;AAE7D;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,sDAAsD,YAAY;;AAElE;AACA;AACA,MAAM;AACN;;AAEA;AACA,oDAAoD;AACpD,kCAAkC,cAAc;;AAEhD,mKAAmK;;AAEnK;AACA,6BAA6B;;AAE7B,+BAA+B;;AAE/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,gBAAgB,wCAAwC,wCAAwC;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA,YAAY,eAAe;AAC3B;AACA,YAAY,mBAAmB;AAC/B,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,uMAAuM;AACvM;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,mCAAmC;AAChD;AACA;AACA;;;AAGA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;;;AAGA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;;AAGJ;;AAEA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,wDAAwD;;AAExD,kFAAkF;;AAElF;AACA,yEAAyE,gBAAgB;AACzF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;;;AAGA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA,0EAA0E;AAC1E,4BAA4B,aAAa;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA,qEAAqE,SAAS;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,YAAY;AAClB,4BAA4B,aAAa;AACzC;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,YAAY;AACpB,8BAA8B,aAAa;;AAE3C;AACA,6EAA6E,SAAS;AACtF;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,qCAAqC;AACrC,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,IAAI;;;AAGJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA;AACA,4DAA4D;AAC5D;;AAEA;AACA;AACA;AACA,GAAG,GAAG;;AAEN,mDAAmD;;AAEnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA,MAAM;AACN;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,iIAAiI,mBAAmB;AACpJ;AACA;;AAEA;AACA;AACA,MAAM;AACN;;;AAGA;AACA;AACA,KAAK;;AAEL;AACA;AACA,8GAA8G,uCAAuC;AACrJ;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA,SAAS,uBAAuB;AAChC;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA,8CAA8C,kCAAkC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,iDAAiD,cAAc,OAAO,mBAAmB;AACzF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEuB;;;ACvoMqB;AACQ;;AAEpD;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8CAA2B,iBAAiB,mCAAmC;AAC1F,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,2BAA2B,SAAS,SAAS;AAC7C,2BAA2B,UAAU,SAAS;AAC9C,wBAAwB;AACxB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,kBAAkB,WAAW,SAAS;AACzF,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB,WAAW,UAAU,YAAY;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uBAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sCAAsC;AACtE;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB,8BAA8B,uBAAuB,4BAA4B;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI,MAAM,SAAS,GAAG,IAAI,KAAK,aAAa;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA,sBAAsB,mCAAmC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mCAAmC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,mCAAmC;AACnD;AACA,WAAW,iCAAiC;AAC5C,sBAAsB,0CAA0C;AAChE,2CAA2C;AAC3C,mBAAmB,sBAAsB,IAAI,0CAA0C;AACvF;AACA;AACA;AACA;AACA,gBAAgB,oDAAoD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA,mBAAmB,wBAAwB,KAAK,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,sBAAsB,mCAAmC;AACzD;AACA;AACA;AACA,QAAQ,mCAAmC;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wDAAqC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,yBAAyB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6DAA6D,8EAA8E;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAE0D;;;AChqC3D;;;;;;;;;;;;;;;;CAgBC,GAE+C","sources":["webpack://@adguard/api/webpack/universalModuleDefinition","webpack://@adguard/api/../tswebextension/node_modules/webextension-polyfill/dist/browser-polyfill.js","webpack://@adguard/api/webpack/bootstrap","webpack://@adguard/api/webpack/runtime/compat get default export","webpack://@adguard/api/webpack/runtime/define property getters","webpack://@adguard/api/webpack/runtime/hasOwnProperty shorthand","webpack://@adguard/api/webpack/runtime/make namespace object","webpack://@adguard/api/../tswebextension/node_modules/@adguard/extended-css/dist/extended-css.esm.js","webpack://@adguard/api/../tswebextension/dist/content-script.js","webpack://@adguard/api/./src/content-script/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(\"webextension-polyfill\", [\"module\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(module);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod);\n    global.browser = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (module) {\n  /* webextension-polyfill - v0.10.0 - Fri Aug 12 2022 19:42:44 */\n\n  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */\n\n  /* vim: set sts=2 sw=2 et tw=80: */\n\n  /* This Source Code Form is subject to the terms of the Mozilla Public\n   * License, v. 2.0. If a copy of the MPL was not distributed with this\n   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n  \"use strict\";\n\n  if (!globalThis.chrome?.runtime?.id) {\n    throw new Error(\"This script should only be loaded in a browser extension.\");\n  }\n\n  if (typeof globalThis.browser === \"undefined\" || Object.getPrototypeOf(globalThis.browser) !== Object.prototype) {\n    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = \"The message port closed before a response was received.\"; // Wrapping the bulk of this polyfill in a one-time-use function is a minor\n    // optimization for Firefox. Since Spidermonkey does not fully parse the\n    // contents of a function until the first time it's called, and since it will\n    // never actually need to be called, this allows the polyfill to be included\n    // in Firefox nearly for free.\n\n    const wrapAPIs = extensionAPIs => {\n      // NOTE: apiMetadata is associated to the content of the api-metadata.json file\n      // at build time by replacing the following \"include\" with the content of the\n      // JSON file.\n      const apiMetadata = {\n        \"alarms\": {\n          \"clear\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"clearAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"bookmarks\": {\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getChildren\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getRecent\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getSubTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTree\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"browserAction\": {\n          \"disable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"enable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"getBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"openPopup\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"browsingData\": {\n          \"remove\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"removeCache\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCookies\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeDownloads\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFormData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeHistory\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeLocalStorage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePasswords\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePluginData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"settings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"commands\": {\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"contextMenus\": {\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"cookies\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAllCookieStores\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"set\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"devtools\": {\n          \"inspectedWindow\": {\n            \"eval\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 2,\n              \"singleCallbackArg\": false\n            }\n          },\n          \"panels\": {\n            \"create\": {\n              \"minArgs\": 3,\n              \"maxArgs\": 3,\n              \"singleCallbackArg\": true\n            },\n            \"elements\": {\n              \"createSidebarPane\": {\n                \"minArgs\": 1,\n                \"maxArgs\": 1\n              }\n            }\n          }\n        },\n        \"downloads\": {\n          \"cancel\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"download\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"erase\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFileIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"open\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"pause\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFile\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"resume\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"extension\": {\n          \"isAllowedFileSchemeAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"isAllowedIncognitoAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"history\": {\n          \"addUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"deleteRange\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getVisits\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"i18n\": {\n          \"detectLanguage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAcceptLanguages\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"identity\": {\n          \"launchWebAuthFlow\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"idle\": {\n          \"queryState\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"management\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setEnabled\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"uninstallSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"notifications\": {\n          \"clear\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPermissionLevel\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"pageAction\": {\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"hide\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"permissions\": {\n          \"contains\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"request\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"runtime\": {\n          \"getBackgroundPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPlatformInfo\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"openOptionsPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"requestUpdateCheck\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"sendMessage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 3\n          },\n          \"sendNativeMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"setUninstallURL\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"sessions\": {\n          \"getDevices\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getRecentlyClosed\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"restore\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"storage\": {\n          \"local\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          },\n          \"managed\": {\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            }\n          },\n          \"sync\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          }\n        },\n        \"tabs\": {\n          \"captureVisibleTab\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"detectLanguage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"discard\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"duplicate\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"executeScript\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getZoom\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getZoomSettings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goBack\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goForward\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"highlight\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"insertCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"query\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"reload\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"sendMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 3\n          },\n          \"setZoom\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"setZoomSettings\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"update\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          }\n        },\n        \"topSites\": {\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"webNavigation\": {\n          \"getAllFrames\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFrame\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"webRequest\": {\n          \"handlerBehaviorChanged\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"windows\": {\n          \"create\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getLastFocused\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        }\n      };\n\n      if (Object.keys(apiMetadata).length === 0) {\n        throw new Error(\"api-metadata.json has not been included in browser-polyfill\");\n      }\n      /**\n       * A WeakMap subclass which creates and stores a value for any key which does\n       * not exist when accessed, but behaves exactly as an ordinary WeakMap\n       * otherwise.\n       *\n       * @param {function} createItem\n       *        A function which will be called in order to create the value for any\n       *        key which does not exist, the first time it is accessed. The\n       *        function receives, as its only argument, the key being created.\n       */\n\n\n      class DefaultWeakMap extends WeakMap {\n        constructor(createItem, items = undefined) {\n          super(items);\n          this.createItem = createItem;\n        }\n\n        get(key) {\n          if (!this.has(key)) {\n            this.set(key, this.createItem(key));\n          }\n\n          return super.get(key);\n        }\n\n      }\n      /**\n       * Returns true if the given object is an object with a `then` method, and can\n       * therefore be assumed to behave as a Promise.\n       *\n       * @param {*} value The value to test.\n       * @returns {boolean} True if the value is thenable.\n       */\n\n\n      const isThenable = value => {\n        return value && typeof value === \"object\" && typeof value.then === \"function\";\n      };\n      /**\n       * Creates and returns a function which, when called, will resolve or reject\n       * the given promise based on how it is called:\n       *\n       * - If, when called, `chrome.runtime.lastError` contains a non-null object,\n       *   the promise is rejected with that value.\n       * - If the function is called with exactly one argument, the promise is\n       *   resolved to that value.\n       * - Otherwise, the promise is resolved to an array containing all of the\n       *   function's arguments.\n       *\n       * @param {object} promise\n       *        An object containing the resolution and rejection functions of a\n       *        promise.\n       * @param {function} promise.resolve\n       *        The promise's resolution function.\n       * @param {function} promise.reject\n       *        The promise's rejection function.\n       * @param {object} metadata\n       *        Metadata about the wrapped method which has created the callback.\n       * @param {boolean} metadata.singleCallbackArg\n       *        Whether or not the promise is resolved with only the first\n       *        argument of the callback, alternatively an array of all the\n       *        callback arguments is resolved. By default, if the callback\n       *        function is invoked with only a single argument, that will be\n       *        resolved to the promise, while all arguments will be resolved as\n       *        an array if multiple are given.\n       *\n       * @returns {function}\n       *        The generated callback function.\n       */\n\n\n      const makeCallback = (promise, metadata) => {\n        return (...callbackArgs) => {\n          if (extensionAPIs.runtime.lastError) {\n            promise.reject(new Error(extensionAPIs.runtime.lastError.message));\n          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {\n            promise.resolve(callbackArgs[0]);\n          } else {\n            promise.resolve(callbackArgs);\n          }\n        };\n      };\n\n      const pluralizeArguments = numArgs => numArgs == 1 ? \"argument\" : \"arguments\";\n      /**\n       * Creates a wrapper function for a method with the given name and metadata.\n       *\n       * @param {string} name\n       *        The name of the method which is being wrapped.\n       * @param {object} metadata\n       *        Metadata about the method being wrapped.\n       * @param {integer} metadata.minArgs\n       *        The minimum number of arguments which must be passed to the\n       *        function. If called with fewer than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {integer} metadata.maxArgs\n       *        The maximum number of arguments which may be passed to the\n       *        function. If called with more than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {boolean} metadata.singleCallbackArg\n       *        Whether or not the promise is resolved with only the first\n       *        argument of the callback, alternatively an array of all the\n       *        callback arguments is resolved. By default, if the callback\n       *        function is invoked with only a single argument, that will be\n       *        resolved to the promise, while all arguments will be resolved as\n       *        an array if multiple are given.\n       *\n       * @returns {function(object, ...*)}\n       *       The generated wrapper function.\n       */\n\n\n      const wrapAsyncFunction = (name, metadata) => {\n        return function asyncFunctionWrapper(target, ...args) {\n          if (args.length < metadata.minArgs) {\n            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n          }\n\n          if (args.length > metadata.maxArgs) {\n            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n          }\n\n          return new Promise((resolve, reject) => {\n            if (metadata.fallbackToNoCallback) {\n              // This API method has currently no callback on Chrome, but it return a promise on Firefox,\n              // and so the polyfill will try to call it with a callback first, and it will fallback\n              // to not passing the callback if the first call fails.\n              try {\n                target[name](...args, makeCallback({\n                  resolve,\n                  reject\n                }, metadata));\n              } catch (cbError) {\n                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + \"falling back to call it without a callback: \", cbError);\n                target[name](...args); // Update the API method metadata, so that the next API calls will not try to\n                // use the unsupported callback anymore.\n\n                metadata.fallbackToNoCallback = false;\n                metadata.noCallback = true;\n                resolve();\n              }\n            } else if (metadata.noCallback) {\n              target[name](...args);\n              resolve();\n            } else {\n              target[name](...args, makeCallback({\n                resolve,\n                reject\n              }, metadata));\n            }\n          });\n        };\n      };\n      /**\n       * Wraps an existing method of the target object, so that calls to it are\n       * intercepted by the given wrapper function. The wrapper function receives,\n       * as its first argument, the original `target` object, followed by each of\n       * the arguments passed to the original method.\n       *\n       * @param {object} target\n       *        The original target object that the wrapped method belongs to.\n       * @param {function} method\n       *        The method being wrapped. This is used as the target of the Proxy\n       *        object which is created to wrap the method.\n       * @param {function} wrapper\n       *        The wrapper function which is called in place of a direct invocation\n       *        of the wrapped method.\n       *\n       * @returns {Proxy<function>}\n       *        A Proxy object for the given method, which invokes the given wrapper\n       *        method in its place.\n       */\n\n\n      const wrapMethod = (target, method, wrapper) => {\n        return new Proxy(method, {\n          apply(targetMethod, thisObj, args) {\n            return wrapper.call(thisObj, target, ...args);\n          }\n\n        });\n      };\n\n      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\n      /**\n       * Wraps an object in a Proxy which intercepts and wraps certain methods\n       * based on the given `wrappers` and `metadata` objects.\n       *\n       * @param {object} target\n       *        The target object to wrap.\n       *\n       * @param {object} [wrappers = {}]\n       *        An object tree containing wrapper functions for special cases. Any\n       *        function present in this object tree is called in place of the\n       *        method in the same location in the `target` object tree. These\n       *        wrapper methods are invoked as described in {@see wrapMethod}.\n       *\n       * @param {object} [metadata = {}]\n       *        An object tree containing metadata used to automatically generate\n       *        Promise-based wrapper functions for asynchronous. Any function in\n       *        the `target` object tree which has a corresponding metadata object\n       *        in the same location in the `metadata` tree is replaced with an\n       *        automatically-generated wrapper function, as described in\n       *        {@see wrapAsyncFunction}\n       *\n       * @returns {Proxy<object>}\n       */\n\n      const wrapObject = (target, wrappers = {}, metadata = {}) => {\n        let cache = Object.create(null);\n        let handlers = {\n          has(proxyTarget, prop) {\n            return prop in target || prop in cache;\n          },\n\n          get(proxyTarget, prop, receiver) {\n            if (prop in cache) {\n              return cache[prop];\n            }\n\n            if (!(prop in target)) {\n              return undefined;\n            }\n\n            let value = target[prop];\n\n            if (typeof value === \"function\") {\n              // This is a method on the underlying object. Check if we need to do\n              // any wrapping.\n              if (typeof wrappers[prop] === \"function\") {\n                // We have a special-case wrapper for this method.\n                value = wrapMethod(target, target[prop], wrappers[prop]);\n              } else if (hasOwnProperty(metadata, prop)) {\n                // This is an async method that we have metadata for. Create a\n                // Promise wrapper for it.\n                let wrapper = wrapAsyncFunction(prop, metadata[prop]);\n                value = wrapMethod(target, target[prop], wrapper);\n              } else {\n                // This is a method that we don't know or care about. Return the\n                // original method, bound to the underlying object.\n                value = value.bind(target);\n              }\n            } else if (typeof value === \"object\" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {\n              // This is an object that we need to do some wrapping for the children\n              // of. Create a sub-object wrapper for it with the appropriate child\n              // metadata.\n              value = wrapObject(value, wrappers[prop], metadata[prop]);\n            } else if (hasOwnProperty(metadata, \"*\")) {\n              // Wrap all properties in * namespace.\n              value = wrapObject(value, wrappers[prop], metadata[\"*\"]);\n            } else {\n              // We don't need to do any wrapping for this property,\n              // so just forward all access to the underlying object.\n              Object.defineProperty(cache, prop, {\n                configurable: true,\n                enumerable: true,\n\n                get() {\n                  return target[prop];\n                },\n\n                set(value) {\n                  target[prop] = value;\n                }\n\n              });\n              return value;\n            }\n\n            cache[prop] = value;\n            return value;\n          },\n\n          set(proxyTarget, prop, value, receiver) {\n            if (prop in cache) {\n              cache[prop] = value;\n            } else {\n              target[prop] = value;\n            }\n\n            return true;\n          },\n\n          defineProperty(proxyTarget, prop, desc) {\n            return Reflect.defineProperty(cache, prop, desc);\n          },\n\n          deleteProperty(proxyTarget, prop) {\n            return Reflect.deleteProperty(cache, prop);\n          }\n\n        }; // Per contract of the Proxy API, the \"get\" proxy handler must return the\n        // original value of the target if that value is declared read-only and\n        // non-configurable. For this reason, we create an object with the\n        // prototype set to `target` instead of using `target` directly.\n        // Otherwise we cannot return a custom object for APIs that\n        // are declared read-only and non-configurable, such as `chrome.devtools`.\n        //\n        // The proxy handlers themselves will still use the original `target`\n        // instead of the `proxyTarget`, so that the methods and properties are\n        // dereferenced via the original targets.\n\n        let proxyTarget = Object.create(target);\n        return new Proxy(proxyTarget, handlers);\n      };\n      /**\n       * Creates a set of wrapper functions for an event object, which handles\n       * wrapping of listener functions that those messages are passed.\n       *\n       * A single wrapper is created for each listener function, and stored in a\n       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`\n       * retrieve the original wrapper, so that  attempts to remove a\n       * previously-added listener work as expected.\n       *\n       * @param {DefaultWeakMap<function, function>} wrapperMap\n       *        A DefaultWeakMap object which will create the appropriate wrapper\n       *        for a given listener function when one does not exist, and retrieve\n       *        an existing one when it does.\n       *\n       * @returns {object}\n       */\n\n\n      const wrapEvent = wrapperMap => ({\n        addListener(target, listener, ...args) {\n          target.addListener(wrapperMap.get(listener), ...args);\n        },\n\n        hasListener(target, listener) {\n          return target.hasListener(wrapperMap.get(listener));\n        },\n\n        removeListener(target, listener) {\n          target.removeListener(wrapperMap.get(listener));\n        }\n\n      });\n\n      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {\n        if (typeof listener !== \"function\") {\n          return listener;\n        }\n        /**\n         * Wraps an onRequestFinished listener function so that it will return a\n         * `getContent()` property which returns a `Promise` rather than using a\n         * callback API.\n         *\n         * @param {object} req\n         *        The HAR entry object representing the network request.\n         */\n\n\n        return function onRequestFinished(req) {\n          const wrappedReq = wrapObject(req, {}\n          /* wrappers */\n          , {\n            getContent: {\n              minArgs: 0,\n              maxArgs: 0\n            }\n          });\n          listener(wrappedReq);\n        };\n      });\n      const onMessageWrappers = new DefaultWeakMap(listener => {\n        if (typeof listener !== \"function\") {\n          return listener;\n        }\n        /**\n         * Wraps a message listener function so that it may send responses based on\n         * its return value, rather than by returning a sentinel value and calling a\n         * callback. If the listener function returns a Promise, the response is\n         * sent when the promise either resolves or rejects.\n         *\n         * @param {*} message\n         *        The message sent by the other end of the channel.\n         * @param {object} sender\n         *        Details about the sender of the message.\n         * @param {function(*)} sendResponse\n         *        A callback which, when called with an arbitrary argument, sends\n         *        that value as a response.\n         * @returns {boolean}\n         *        True if the wrapped listener returned a Promise, which will later\n         *        yield a response. False otherwise.\n         */\n\n\n        return function onMessage(message, sender, sendResponse) {\n          let didCallSendResponse = false;\n          let wrappedSendResponse;\n          let sendResponsePromise = new Promise(resolve => {\n            wrappedSendResponse = function (response) {\n              didCallSendResponse = true;\n              resolve(response);\n            };\n          });\n          let result;\n\n          try {\n            result = listener(message, sender, wrappedSendResponse);\n          } catch (err) {\n            result = Promise.reject(err);\n          }\n\n          const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called\n          // wrappedSendResponse synchronously, we can exit earlier\n          // because there will be no response sent from this listener.\n\n          if (result !== true && !isResultThenable && !didCallSendResponse) {\n            return false;\n          } // A small helper to send the message if the promise resolves\n          // and an error if the promise rejects (a wrapped sendMessage has\n          // to translate the message into a resolved promise or a rejected\n          // promise).\n\n\n          const sendPromisedResult = promise => {\n            promise.then(msg => {\n              // send the message value.\n              sendResponse(msg);\n            }, error => {\n              // Send a JSON representation of the error if the rejected value\n              // is an instance of error, or the object itself otherwise.\n              let message;\n\n              if (error && (error instanceof Error || typeof error.message === \"string\")) {\n                message = error.message;\n              } else {\n                message = \"An unexpected error occurred\";\n              }\n\n              sendResponse({\n                __mozWebExtensionPolyfillReject__: true,\n                message\n              });\n            }).catch(err => {\n              // Print an error on the console if unable to send the response.\n              console.error(\"Failed to send onMessage rejected reply\", err);\n            });\n          }; // If the listener returned a Promise, send the resolved value as a\n          // result, otherwise wait the promise related to the wrappedSendResponse\n          // callback to resolve and send it as a response.\n\n\n          if (isResultThenable) {\n            sendPromisedResult(result);\n          } else {\n            sendPromisedResult(sendResponsePromise);\n          } // Let Chrome know that the listener is replying.\n\n\n          return true;\n        };\n      });\n\n      const wrappedSendMessageCallback = ({\n        reject,\n        resolve\n      }, reply) => {\n        if (extensionAPIs.runtime.lastError) {\n          // Detect when none of the listeners replied to the sendMessage call and resolve\n          // the promise to undefined as in Firefox.\n          // See https://github.com/mozilla/webextension-polyfill/issues/130\n          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {\n            resolve();\n          } else {\n            reject(new Error(extensionAPIs.runtime.lastError.message));\n          }\n        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {\n          // Convert back the JSON representation of the error into\n          // an Error instance.\n          reject(new Error(reply.message));\n        } else {\n          resolve(reply);\n        }\n      };\n\n      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {\n        if (args.length < metadata.minArgs) {\n          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        if (args.length > metadata.maxArgs) {\n          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        return new Promise((resolve, reject) => {\n          const wrappedCb = wrappedSendMessageCallback.bind(null, {\n            resolve,\n            reject\n          });\n          args.push(wrappedCb);\n          apiNamespaceObj.sendMessage(...args);\n        });\n      };\n\n      const staticWrappers = {\n        devtools: {\n          network: {\n            onRequestFinished: wrapEvent(onRequestFinishedWrappers)\n          }\n        },\n        runtime: {\n          onMessage: wrapEvent(onMessageWrappers),\n          onMessageExternal: wrapEvent(onMessageWrappers),\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 1,\n            maxArgs: 3\n          })\n        },\n        tabs: {\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 2,\n            maxArgs: 3\n          })\n        }\n      };\n      const settingMetadata = {\n        clear: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        get: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        set: {\n          minArgs: 1,\n          maxArgs: 1\n        }\n      };\n      apiMetadata.privacy = {\n        network: {\n          \"*\": settingMetadata\n        },\n        services: {\n          \"*\": settingMetadata\n        },\n        websites: {\n          \"*\": settingMetadata\n        }\n      };\n      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);\n    }; // The build process adds a UMD wrapper around this file, which makes the\n    // `module` variable available.\n\n\n    module.exports = wrapAPIs(chrome);\n  } else {\n    module.exports = globalThis.browser;\n  }\n});\n//# sourceMappingURL=browser-polyfill.js.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @adguard/extended-css - v2.0.52 - Fri Apr 14 2023\n * https://github.com/AdguardTeam/ExtendedCss#homepage\n * Copyright (c) 2023 AdGuard. Licensed GPL-3.0\n */\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n/**\n * Possible ast node types.\n *\n * IMPORTANT: it is used as 'const' instead of 'enum' to avoid side effects\n * during ExtendedCss import into other libraries.\n */\nconst NODE = {\n  SELECTOR_LIST: 'SelectorList',\n  SELECTOR: 'Selector',\n  REGULAR_SELECTOR: 'RegularSelector',\n  EXTENDED_SELECTOR: 'ExtendedSelector',\n  ABSOLUTE_PSEUDO_CLASS: 'AbsolutePseudoClass',\n  RELATIVE_PSEUDO_CLASS: 'RelativePseudoClass'\n};\n\n/**\n * Class needed for creating ast nodes while selector parsing.\n * Used for SelectorList, Selector, ExtendedSelector.\n */\nclass AnySelectorNode {\n  /**\n   * Creates new ast node.\n   *\n   * @param type Ast node type.\n   */\n  constructor(type) {\n    _defineProperty(this, \"children\", []);\n\n    this.type = type;\n  }\n  /**\n   * Adds child node to children array.\n   *\n   * @param child Ast node.\n   */\n\n\n  addChild(child) {\n    this.children.push(child);\n  }\n\n}\n/**\n * Class needed for creating RegularSelector ast node while selector parsing.\n */\n\nclass RegularSelectorNode extends AnySelectorNode {\n  /**\n   * Creates RegularSelector ast node.\n   *\n   * @param value Value of RegularSelector node.\n   */\n  constructor(value) {\n    super(NODE.REGULAR_SELECTOR);\n    this.value = value;\n  }\n\n}\n/**\n * Class needed for creating RelativePseudoClass ast node while selector parsing.\n */\n\nclass RelativePseudoClassNode extends AnySelectorNode {\n  /**\n   * Creates RegularSelector ast node.\n   *\n   * @param name Name of RelativePseudoClass node.\n   */\n  constructor(name) {\n    super(NODE.RELATIVE_PSEUDO_CLASS);\n    this.name = name;\n  }\n\n}\n/**\n * Class needed for creating AbsolutePseudoClass ast node while selector parsing.\n */\n\nclass AbsolutePseudoClassNode extends AnySelectorNode {\n  /**\n   * Creates AbsolutePseudoClass ast node.\n   *\n   * @param name Name of AbsolutePseudoClass node.\n   */\n  constructor(name) {\n    super(NODE.ABSOLUTE_PSEUDO_CLASS);\n\n    _defineProperty(this, \"value\", '');\n\n    this.name = name;\n  }\n\n}\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * Root node.\n *\n * SelectorList\n *   : Selector\n *     ...\n *   ;\n */\n\n/**\n * Selector node.\n *\n * Selector\n *   : RegularSelector\n *   | ExtendedSelector\n *     ...\n *   ;\n */\n\n/**\n * Regular selector node.\n * It can be selected by querySelectorAll().\n *\n * RegularSelector\n *   : type\n *   : value\n *   ;\n */\n\n/**\n * Extended selector node.\n *\n * ExtendedSelector\n *   : AbsolutePseudoClass\n *   | RelativePseudoClass\n *   ;\n */\n\n/**\n * Absolute extended pseudo-class node,\n * i.e. none-selector args.\n *\n * AbsolutePseudoClass\n *   : type\n *   : name\n *   : value\n *   ;\n */\n\n/**\n * Relative extended pseudo-class node\n * i.e. selector as arg.\n *\n * RelativePseudoClass\n *   : type\n *   : name\n *   : SelectorList\n *   ;\n */\n//\n//  ast example\n//\n//  div.banner > div:has(span, p), a img.ad\n//\n//  SelectorList - div.banner > div:has(span, p), a img.ad\n//      Selector - div.banner > div:has(span, p)\n//          RegularSelector - div.banner > div\n//          ExtendedSelector - :has(span, p)\n//              PseudoClassSelector - :has\n//              SelectorList - span, p\n//                  Selector - span\n//                      RegularSelector - span\n//                  Selector - p\n//                      RegularSelector - p\n//      Selector - a img.ad\n//          RegularSelector - a img.ad\n//\n\nconst LEFT_SQUARE_BRACKET = '[';\nconst RIGHT_SQUARE_BRACKET = ']';\nconst LEFT_PARENTHESIS = '(';\nconst RIGHT_PARENTHESIS = ')';\nconst LEFT_CURLY_BRACKET = '{';\nconst RIGHT_CURLY_BRACKET = '}';\nconst BRACKET = {\n  SQUARE: {\n    LEFT: LEFT_SQUARE_BRACKET,\n    RIGHT: RIGHT_SQUARE_BRACKET\n  },\n  PARENTHESES: {\n    LEFT: LEFT_PARENTHESIS,\n    RIGHT: RIGHT_PARENTHESIS\n  },\n  CURLY: {\n    LEFT: LEFT_CURLY_BRACKET,\n    RIGHT: RIGHT_CURLY_BRACKET\n  }\n};\nconst SLASH = '/';\nconst BACKSLASH = '\\\\';\nconst SPACE = ' ';\nconst COMMA = ',';\nconst DOT = '.';\nconst SEMICOLON = ';';\nconst COLON = ':';\nconst SINGLE_QUOTE = '\\'';\nconst DOUBLE_QUOTE = '\"'; // do not consider hyphen `-` as separated mark\n// to avoid pseudo-class names splitting\n// e.g. 'matches-css' or 'if-not'\n\nconst CARET = '^';\nconst DOLLAR_SIGN = '$';\nconst EQUAL_SIGN = '=';\nconst TAB = '\\t';\nconst CARRIAGE_RETURN = '\\r';\nconst LINE_FEED = '\\n';\nconst FORM_FEED = '\\f';\nconst WHITE_SPACE_CHARACTERS = [SPACE, TAB, CARRIAGE_RETURN, LINE_FEED, FORM_FEED]; // for universal selector and attributes\n\nconst ASTERISK = '*';\nconst ID_MARKER = '#';\nconst CLASS_MARKER = DOT;\nconst DESCENDANT_COMBINATOR = SPACE;\nconst CHILD_COMBINATOR = '>';\nconst NEXT_SIBLING_COMBINATOR = '+';\nconst SUBSEQUENT_SIBLING_COMBINATOR = '~';\nconst COMBINATORS = [DESCENDANT_COMBINATOR, CHILD_COMBINATOR, NEXT_SIBLING_COMBINATOR, SUBSEQUENT_SIBLING_COMBINATOR];\nconst SUPPORTED_SELECTOR_MARKS = [LEFT_SQUARE_BRACKET, RIGHT_SQUARE_BRACKET, LEFT_PARENTHESIS, RIGHT_PARENTHESIS, LEFT_CURLY_BRACKET, RIGHT_CURLY_BRACKET, SLASH, BACKSLASH, SEMICOLON, COLON, COMMA, SINGLE_QUOTE, DOUBLE_QUOTE, CARET, DOLLAR_SIGN, ASTERISK, ID_MARKER, CLASS_MARKER, DESCENDANT_COMBINATOR, CHILD_COMBINATOR, NEXT_SIBLING_COMBINATOR, SUBSEQUENT_SIBLING_COMBINATOR, TAB, CARRIAGE_RETURN, LINE_FEED, FORM_FEED];\nconst SUPPORTED_STYLE_DECLARATION_MARKS = [// divider between property and value in declaration\nCOLON, // divider between declarations\nSEMICOLON, // sometimes is needed for value wrapping\n// e.g. 'content: \"-\"'\nSINGLE_QUOTE, DOUBLE_QUOTE, // needed for quote escaping inside the same-type quotes\nBACKSLASH, // whitespaces\nSPACE, TAB, CARRIAGE_RETURN, LINE_FEED, FORM_FEED]; // absolute:\n\nconst CONTAINS_PSEUDO = 'contains';\nconst HAS_TEXT_PSEUDO = 'has-text';\nconst ABP_CONTAINS_PSEUDO = '-abp-contains';\nconst MATCHES_CSS_PSEUDO = 'matches-css';\nconst MATCHES_CSS_BEFORE_PSEUDO = 'matches-css-before';\nconst MATCHES_CSS_AFTER_PSEUDO = 'matches-css-after';\nconst MATCHES_ATTR_PSEUDO_CLASS_MARKER = 'matches-attr';\nconst MATCHES_PROPERTY_PSEUDO_CLASS_MARKER = 'matches-property';\nconst XPATH_PSEUDO_CLASS_MARKER = 'xpath';\nconst NTH_ANCESTOR_PSEUDO_CLASS_MARKER = 'nth-ancestor';\nconst CONTAINS_PSEUDO_NAMES = [CONTAINS_PSEUDO, HAS_TEXT_PSEUDO, ABP_CONTAINS_PSEUDO];\n/**\n * Pseudo-class :upward() can get number or selector arg\n * and if the arg is selector it should be standard, not extended\n * so :upward pseudo-class is always absolute.\n */\n\nconst UPWARD_PSEUDO_CLASS_MARKER = 'upward';\n/**\n * Pseudo-class `:remove()` and pseudo-property `remove`\n * are used for element actions, not for element selecting.\n *\n * Selector text should not contain the pseudo-class\n * so selector parser should consider it as invalid\n * and both are handled by stylesheet parser.\n */\n\nconst REMOVE_PSEUDO_MARKER = 'remove'; // relative:\n\nconst HAS_PSEUDO_CLASS_MARKER = 'has';\nconst ABP_HAS_PSEUDO_CLASS_MARKER = '-abp-has';\nconst HAS_PSEUDO_CLASS_MARKERS = [HAS_PSEUDO_CLASS_MARKER, ABP_HAS_PSEUDO_CLASS_MARKER];\nconst IS_PSEUDO_CLASS_MARKER = 'is';\nconst NOT_PSEUDO_CLASS_MARKER = 'not';\nconst ABSOLUTE_PSEUDO_CLASSES = [CONTAINS_PSEUDO, HAS_TEXT_PSEUDO, ABP_CONTAINS_PSEUDO, MATCHES_CSS_PSEUDO, MATCHES_CSS_BEFORE_PSEUDO, MATCHES_CSS_AFTER_PSEUDO, MATCHES_ATTR_PSEUDO_CLASS_MARKER, MATCHES_PROPERTY_PSEUDO_CLASS_MARKER, XPATH_PSEUDO_CLASS_MARKER, NTH_ANCESTOR_PSEUDO_CLASS_MARKER, UPWARD_PSEUDO_CLASS_MARKER];\nconst RELATIVE_PSEUDO_CLASSES = [...HAS_PSEUDO_CLASS_MARKERS, IS_PSEUDO_CLASS_MARKER, NOT_PSEUDO_CLASS_MARKER];\nconst SUPPORTED_PSEUDO_CLASSES = [...ABSOLUTE_PSEUDO_CLASSES, ...RELATIVE_PSEUDO_CLASSES]; // these pseudo-classes should be part of RegularSelector value\n// if its arg does not contain extended selectors.\n// the ast will be checked after the selector is completely parsed\n\nconst OPTIMIZATION_PSEUDO_CLASSES = [NOT_PSEUDO_CLASS_MARKER, IS_PSEUDO_CLASS_MARKER];\n/**\n * ':scope' is used for extended pseudo-class :has(), if-not(), :is() and :not().\n */\n\nconst SCOPE_CSS_PSEUDO_CLASS = ':scope';\n/**\n * ':after' and ':before' are needed for :matches-css() pseudo-class\n * all other are needed for :has() limitation after regular pseudo-elements.\n *\n * @see {@link https://bugs.chromium.org/p/chromium/issues/detail?id=669058#c54} [case 3]\n */\n\nconst REGULAR_PSEUDO_ELEMENTS = {\n  AFTER: 'after',\n  BACKDROP: 'backdrop',\n  BEFORE: 'before',\n  CUE: 'cue',\n  CUE_REGION: 'cue-region',\n  FIRST_LETTER: 'first-letter',\n  FIRST_LINE: 'first-line',\n  FILE_SELECTION_BUTTON: 'file-selector-button',\n  GRAMMAR_ERROR: 'grammar-error',\n  MARKER: 'marker',\n  PART: 'part',\n  PLACEHOLDER: 'placeholder',\n  SELECTION: 'selection',\n  SLOTTED: 'slotted',\n  SPELLING_ERROR: 'spelling-error',\n  TARGET_TEXT: 'target-text'\n}; // ExtendedCss does not support at-rules\n// https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule\n\nconst AT_RULE_MARKER = '@';\nconst CONTENT_CSS_PROPERTY = 'content';\nconst PSEUDO_PROPERTY_POSITIVE_VALUE = 'true';\nconst DEBUG_PSEUDO_PROPERTY_GLOBAL_VALUE = 'global';\nconst NO_SELECTOR_ERROR_PREFIX = 'Selector should be defined';\nconst STYLE_ERROR_PREFIX = {\n  NO_STYLE: 'No style declaration found',\n  NO_SELECTOR: `${NO_SELECTOR_ERROR_PREFIX} before style declaration in stylesheet`,\n  INVALID_STYLE: 'Invalid style declaration',\n  UNCLOSED_STYLE: 'Unclosed style declaration',\n  NO_PROPERTY: 'Missing style property in declaration',\n  NO_VALUE: 'Missing style value in declaration',\n  NO_STYLE_OR_REMOVE: 'Style should be declared or :remove() pseudo-class should used',\n  NO_COMMENT: 'Comments are not supported'\n};\nconst NO_AT_RULE_ERROR_PREFIX = 'At-rules are not supported';\nconst REMOVE_ERROR_PREFIX = {\n  INVALID_REMOVE: 'Invalid :remove() pseudo-class in selector',\n  NO_TARGET_SELECTOR: `${NO_SELECTOR_ERROR_PREFIX} before :remove() pseudo-class`,\n  MULTIPLE_USAGE: 'Pseudo-class :remove() appears more than once in selector',\n  INVALID_POSITION: 'Pseudo-class :remove() should be at the end of selector'\n};\nconst MATCHING_ELEMENT_ERROR_PREFIX = 'Error while matching element';\nconst MAX_STYLE_PROTECTION_COUNT = 50;\n\n/**\n * Regexp that matches backward compatible syntaxes.\n */\n\nconst REGEXP_VALID_OLD_SYNTAX = /\\[-(?:ext)-([a-z-_]+)=([\"'])((?:(?=(\\\\?))\\4.)*?)\\2\\]/g;\n/**\n * Marker for checking invalid selector after old-syntax normalizing by selector converter.\n */\n\nconst INVALID_OLD_SYNTAX_MARKER = '[-ext-';\n/**\n * Complex replacement function.\n * Undo quote escaping inside of an extended selector.\n *\n * @param match     Whole matched string.\n * @param name      Group 1.\n * @param quoteChar Group 2.\n * @param rawValue  Group 3.\n *\n * @returns Converted string.\n */\n\nconst evaluateMatch = (match, name, quoteChar, rawValue) => {\n  // Unescape quotes\n  const re = new RegExp(`([^\\\\\\\\]|^)\\\\\\\\${quoteChar}`, 'g');\n  const value = rawValue.replace(re, `$1${quoteChar}`);\n  return `:${name}(${value})`;\n}; // ':scope' pseudo may be at start of :has() argument\n// but ExtCssDocument.querySelectorAll() already use it for selecting exact element descendants\n\n\nconst SCOPE_MARKER_REGEXP = /\\(:scope >/g;\nconst SCOPE_REPLACER = '(>';\nconst MATCHES_CSS_PSEUDO_ELEMENT_REGEXP = /(:matches-css)-(before|after)\\(/g;\n\nconst convertMatchesCss = (match, extendedPseudoClass, regularPseudoElement) => {\n  // ':matches-css-before('  -->  ':matches-css(before, '\n  // ':matches-css-after('   -->  ':matches-css(after, '\n  return `${extendedPseudoClass}${BRACKET.PARENTHESES.LEFT}${regularPseudoElement}${COMMA}`;\n};\n/**\n * Handles old syntax and :scope inside :has().\n *\n * @param selector Trimmed selector to normalize.\n *\n * @returns Normalized selector.\n * @throws An error on invalid old extended syntax selector.\n */\n\n\nconst normalize = selector => {\n  const normalizedSelector = selector.replace(REGEXP_VALID_OLD_SYNTAX, evaluateMatch).replace(SCOPE_MARKER_REGEXP, SCOPE_REPLACER).replace(MATCHES_CSS_PSEUDO_ELEMENT_REGEXP, convertMatchesCss); // validate old syntax after normalizing\n  // e.g. '[-ext-matches-css-before=\\'content:  /^[A-Z][a-z]'\n\n  if (normalizedSelector.includes(INVALID_OLD_SYNTAX_MARKER)) {\n    throw new Error(`Invalid extended-css old syntax selector: '${selector}'`);\n  }\n\n  return normalizedSelector;\n};\n/**\n * Prepares the rawSelector before tokenization:\n * 1. Trims it.\n * 2. Converts old syntax `[-ext-pseudo-class=\"...\"]` to new one `:pseudo-class(...)`.\n * 3. Handles :scope pseudo inside :has() pseudo-class arg.\n *\n * @param rawSelector Selector with no style declaration.\n * @returns Prepared selector with no style declaration.\n */\n\n\nconst convert = rawSelector => {\n  const trimmedSelector = rawSelector.trim();\n  return normalize(trimmedSelector);\n};\n\n/**\n * Possible token types.\n *\n * IMPORTANT: it is used as 'const' instead of 'enum' to avoid side effects\n * during ExtendedCss import into other libraries.\n */\nconst TOKEN_TYPE = {\n  MARK: 'mark',\n  WORD: 'word'\n};\n\n/**\n * Splits `input` string into tokens.\n *\n * @param input Input string to tokenize.\n * @param supportedMarks Array of supported marks to considered as `TOKEN_TYPE.MARK`;\n * all other will be considered as `TOKEN_TYPE.WORD`.\n *\n * @returns Array of tokens.\n */\nconst tokenize = (input, supportedMarks) => {\n  // buffer is needed for words collecting while iterating\n  let wordBuffer = ''; // result collection\n\n  const tokens = [];\n  const selectorSymbols = input.split(''); // iterate through selector chars and collect tokens\n\n  selectorSymbols.forEach(symbol => {\n    if (supportedMarks.includes(symbol)) {\n      // if anything was collected to the buffer before\n      if (wordBuffer.length > 0) {\n        // now it is time to stop buffer collecting and save is as \"word\"\n        tokens.push({\n          type: TOKEN_TYPE.WORD,\n          value: wordBuffer\n        }); // reset the buffer\n\n        wordBuffer = '';\n      } // save current symbol as \"mark\"\n\n\n      tokens.push({\n        type: TOKEN_TYPE.MARK,\n        value: symbol\n      });\n      return;\n    } // otherwise collect symbol to the buffer\n\n\n    wordBuffer += symbol;\n  }); // save the last collected word\n\n  if (wordBuffer.length > 0) {\n    tokens.push({\n      type: TOKEN_TYPE.WORD,\n      value: wordBuffer\n    });\n  }\n\n  return tokens;\n};\n\n/**\n * Prepares `rawSelector` and splits it into tokens.\n *\n * @param rawSelector Raw css selector.\n *\n * @returns Array of tokens supported for selector.\n */\n\nconst tokenizeSelector = rawSelector => {\n  const selector = convert(rawSelector);\n  return tokenize(selector, SUPPORTED_SELECTOR_MARKS);\n};\n/**\n * Splits `attribute` into tokens.\n *\n * @param attribute Input attribute.\n *\n * @returns Array of tokens supported for attribute.\n */\n\nconst tokenizeAttribute = attribute => {\n  // equal sigh `=` in attribute is considered as `TOKEN_TYPE.MARK`\n  return tokenize(attribute, [...SUPPORTED_SELECTOR_MARKS, EQUAL_SIGN]);\n};\n\n/**\n * Some browsers do not support Array.prototype.flat()\n * e.g. Opera 42 which is used for browserstack tests.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat}\n *\n * @param input Array needed to be flatten.\n *\n * @returns Flatten array.\n * @throws An error if array cannot be flatten.\n */\nconst flatten = input => {\n  const stack = [];\n  input.forEach(el => stack.push(el));\n  const res = [];\n\n  while (stack.length) {\n    // pop value from stack\n    const next = stack.pop();\n\n    if (!next) {\n      throw new Error('Unable to make array flat');\n    }\n\n    if (Array.isArray(next)) {\n      // push back array items, won't modify the original input\n      next.forEach(el => stack.push(el));\n    } else {\n      res.push(next);\n    }\n  } // reverse to restore input order\n\n\n  return res.reverse();\n};\n/**\n * Returns first item from `array`.\n *\n * @param array Input array.\n *\n * @returns First array item, or `undefined` if there is no such item.\n */\n\nconst getFirst = array => {\n  return array[0];\n};\n/**\n * Returns last item from array.\n *\n * @param array Input array.\n *\n * @returns Last array item, or `undefined` if there is no such item.\n */\n\nconst getLast = array => {\n  return array[array.length - 1];\n};\n/**\n * Returns array item which is previous to the last one\n * e.g. for `[5, 6, 7, 8]` returns `7`.\n *\n * @param array Input array.\n *\n * @returns Previous to last array item, or `undefined` if there is no such item.\n */\n\nconst getPrevToLast = array => {\n  return array[array.length - 2];\n};\n/**\n * Takes array of ast node `children` and returns the child by the `index`.\n *\n * @param array Array of ast node children.\n * @param index Index of needed child in the array.\n * @param errorMessage Optional error message to throw.\n *\n * @returns Array item at `index` position.\n * @throws An error if there is no child with specified `index` in array.\n */\n\nconst getItemByIndex = (array, index, errorMessage) => {\n  const indexChild = array[index];\n\n  if (!indexChild) {\n    throw new Error(errorMessage || `No array item found by index ${index}`);\n  }\n\n  return indexChild;\n};\n\nconst NO_REGULAR_SELECTOR_ERROR = 'At least one of Selector node children should be RegularSelector';\n/**\n * Checks whether the type of `astNode` is SelectorList.\n *\n * @param astNode Ast node.\n *\n * @returns True if astNode.type === SelectorList.\n */\n\nconst isSelectorListNode = astNode => {\n  return (astNode === null || astNode === void 0 ? void 0 : astNode.type) === NODE.SELECTOR_LIST;\n};\n/**\n * Checks whether the type of `astNode` is Selector.\n *\n * @param astNode Ast node.\n *\n * @returns True if astNode.type === Selector.\n */\n\nconst isSelectorNode = astNode => {\n  return (astNode === null || astNode === void 0 ? void 0 : astNode.type) === NODE.SELECTOR;\n};\n/**\n * Checks whether the type of `astNode` is RegularSelector.\n *\n * @param astNode Ast node.\n *\n * @returns True if astNode.type === RegularSelector.\n */\n\nconst isRegularSelectorNode = astNode => {\n  return (astNode === null || astNode === void 0 ? void 0 : astNode.type) === NODE.REGULAR_SELECTOR;\n};\n/**\n * Checks whether the type of `astNode` is ExtendedSelector.\n *\n * @param astNode Ast node.\n *\n * @returns True if astNode.type === ExtendedSelector.\n */\n\nconst isExtendedSelectorNode = astNode => {\n  return astNode.type === NODE.EXTENDED_SELECTOR;\n};\n/**\n * Checks whether the type of `astNode` is AbsolutePseudoClass.\n *\n * @param astNode Ast node.\n *\n * @returns True if astNode.type === AbsolutePseudoClass.\n */\n\nconst isAbsolutePseudoClassNode = astNode => {\n  return (astNode === null || astNode === void 0 ? void 0 : astNode.type) === NODE.ABSOLUTE_PSEUDO_CLASS;\n};\n/**\n * Checks whether the type of `astNode` is RelativePseudoClass.\n *\n * @param astNode Ast node.\n *\n * @returns True if astNode.type === RelativePseudoClass.\n */\n\nconst isRelativePseudoClassNode = astNode => {\n  return (astNode === null || astNode === void 0 ? void 0 : astNode.type) === NODE.RELATIVE_PSEUDO_CLASS;\n};\n/**\n * Returns name of `astNode`.\n *\n * @param astNode AbsolutePseudoClass or RelativePseudoClass node.\n *\n * @returns Name of `astNode`.\n * @throws An error on unsupported ast node or no name found.\n */\n\nconst getNodeName = astNode => {\n  if (astNode === null) {\n    throw new Error('Ast node should be defined');\n  }\n\n  if (!isAbsolutePseudoClassNode(astNode) && !isRelativePseudoClassNode(astNode)) {\n    throw new Error('Only AbsolutePseudoClass or RelativePseudoClass ast node can have a name');\n  }\n\n  if (!astNode.name) {\n    throw new Error('Extended pseudo-class should have a name');\n  }\n\n  return astNode.name;\n};\n/**\n * Returns value of `astNode`.\n *\n * @param astNode RegularSelector or AbsolutePseudoClass node.\n * @param errorMessage Optional error message if no value found.\n *\n * @returns Value of `astNode`.\n * @throws An error on unsupported ast node or no value found.\n */\n\nconst getNodeValue = (astNode, errorMessage) => {\n  if (astNode === null) {\n    throw new Error('Ast node should be defined');\n  }\n\n  if (!isRegularSelectorNode(astNode) && !isAbsolutePseudoClassNode(astNode)) {\n    throw new Error('Only RegularSelector ot AbsolutePseudoClass ast node can have a value');\n  }\n\n  if (!astNode.value) {\n    throw new Error(errorMessage || 'Ast RegularSelector ot AbsolutePseudoClass node should have a value');\n  }\n\n  return astNode.value;\n};\n/**\n * Returns only RegularSelector nodes from `children`.\n *\n * @param children Array of ast node children.\n *\n * @returns Array of RegularSelector nodes.\n */\n\nconst getRegularSelectorNodes = children => {\n  return children.filter(isRegularSelectorNode);\n};\n/**\n * Returns the first RegularSelector node from `children`.\n *\n * @param children Array of ast node children.\n * @param errorMessage Optional error message if no value found.\n *\n * @returns Ast RegularSelector node.\n * @throws An error if no RegularSelector node found.\n */\n\n\nconst getFirstRegularChild = (children, errorMessage) => {\n  const regularSelectorNodes = getRegularSelectorNodes(children);\n  const firstRegularSelectorNode = getFirst(regularSelectorNodes);\n\n  if (!firstRegularSelectorNode) {\n    throw new Error(errorMessage || NO_REGULAR_SELECTOR_ERROR);\n  }\n\n  return firstRegularSelectorNode;\n};\n/**\n * Returns the last RegularSelector node from `children`.\n *\n * @param children Array of ast node children.\n *\n * @returns Ast RegularSelector node.\n * @throws An error if no RegularSelector node found.\n */\n\nconst getLastRegularChild = children => {\n  const regularSelectorNodes = getRegularSelectorNodes(children);\n  const lastRegularSelectorNode = getLast(regularSelectorNodes);\n\n  if (!lastRegularSelectorNode) {\n    throw new Error(NO_REGULAR_SELECTOR_ERROR);\n  }\n\n  return lastRegularSelectorNode;\n};\n/**\n * Returns the only child of `node`.\n *\n * @param node Ast node.\n * @param errorMessage Error message.\n *\n * @returns The only child of ast node.\n * @throws An error if none or more than one child found.\n */\n\nconst getNodeOnlyChild = (node, errorMessage) => {\n  if (node.children.length !== 1) {\n    throw new Error(errorMessage);\n  }\n\n  const onlyChild = getFirst(node.children);\n\n  if (!onlyChild) {\n    throw new Error(errorMessage);\n  }\n\n  return onlyChild;\n};\n/**\n * Takes ExtendedSelector node and returns its only child.\n *\n * @param extendedSelectorNode ExtendedSelector ast node.\n *\n * @returns AbsolutePseudoClass or RelativePseudoClass.\n * @throws An error if there is no specific pseudo-class ast node.\n */\n\nconst getPseudoClassNode = extendedSelectorNode => {\n  return getNodeOnlyChild(extendedSelectorNode, 'Extended selector should be specified');\n};\n/**\n * Takes RelativePseudoClass node and returns its only child\n * which is relative SelectorList node.\n *\n * @param pseudoClassNode RelativePseudoClass.\n *\n * @returns Relative SelectorList node.\n * @throws An error if no selector list found.\n */\n\nconst getRelativeSelectorListNode = pseudoClassNode => {\n  if (!isRelativePseudoClassNode(pseudoClassNode)) {\n    throw new Error('Only RelativePseudoClass node can have relative SelectorList node as child');\n  }\n\n  return getNodeOnlyChild(pseudoClassNode, `Missing arg for :${getNodeName(pseudoClassNode)}() pseudo-class`);\n};\n\nconst ATTRIBUTE_CASE_INSENSITIVE_FLAG = 'i';\n/**\n * Limited list of available symbols before slash `/`\n * to check whether it is valid regexp pattern opening.\n */\n\nconst POSSIBLE_MARKS_BEFORE_REGEXP = {\n  COMMON: [// e.g. ':matches-attr(/data-/)'\n  BRACKET.PARENTHESES.LEFT, // e.g. `:matches-attr('/data-/')`\n  SINGLE_QUOTE, // e.g. ':matches-attr(\"/data-/\")'\n  DOUBLE_QUOTE, // e.g. ':matches-attr(check=/data-v-/)'\n  EQUAL_SIGN, // e.g. ':matches-property(inner./_test/=null)'\n  DOT, // e.g. ':matches-css(height:/20px/)'\n  COLON, // ':matches-css-after( content  :   /(\\\\d+\\\\s)*me/  )'\n  SPACE],\n  CONTAINS: [// e.g. ':contains(/text/)'\n  BRACKET.PARENTHESES.LEFT, // e.g. `:contains('/text/')`\n  SINGLE_QUOTE, // e.g. ':contains(\"/text/\")'\n  DOUBLE_QUOTE]\n};\n/**\n * Checks whether the passed token is supported extended pseudo-class.\n *\n * @param tokenValue Token value to check.\n *\n * @returns True if `tokenValue` is one of supported extended pseudo-class names.\n */\n\nconst isSupportedPseudoClass = tokenValue => {\n  return SUPPORTED_PSEUDO_CLASSES.includes(tokenValue);\n};\n/**\n * Checks whether the passed pseudo-class `name` should be optimized,\n * i.e. :not() and :is().\n *\n * @param name Pseudo-class name.\n *\n * @returns True if `name` is one if pseudo-class which should be optimized.\n */\n\nconst isOptimizationPseudoClass = name => {\n  return OPTIMIZATION_PSEUDO_CLASSES.includes(name);\n};\n/**\n * Checks whether next to \"space\" token is a continuation of regular selector being processed.\n *\n * @param nextTokenType Type of token next to current one.\n * @param nextTokenValue Value of token next to current one.\n *\n * @returns True if next token seems to be a part of current regular selector.\n */\n\nconst doesRegularContinueAfterSpace = (nextTokenType, nextTokenValue) => {\n  // regular selector does not continues after the current token\n  if (!nextTokenType || !nextTokenValue) {\n    return false;\n  }\n\n  return COMBINATORS.includes(nextTokenValue) || nextTokenType === TOKEN_TYPE.WORD // e.g. '#main *:has(> .ad)'\n  || nextTokenValue === ASTERISK || nextTokenValue === ID_MARKER || nextTokenValue === CLASS_MARKER // e.g. 'div :where(.content)'\n  || nextTokenValue === COLON // e.g. \"div[class*=' ']\"\n  || nextTokenValue === SINGLE_QUOTE // e.g. 'div[class*=\" \"]'\n  || nextTokenValue === DOUBLE_QUOTE || nextTokenValue === BRACKET.SQUARE.LEFT;\n};\n/**\n * Checks whether the regexp pattern for pseudo-class arg starts.\n * Needed for `context.isRegexpOpen` flag.\n *\n * @param context Selector parser context.\n * @param prevTokenValue Value of previous token.\n * @param bufferNodeValue Value of bufferNode.\n *\n * @returns True if current token seems to be a start of regexp pseudo-class arg pattern.\n * @throws An error on invalid regexp pattern.\n */\n\nconst isRegexpOpening = (context, prevTokenValue, bufferNodeValue) => {\n  const lastExtendedPseudoClassName = getLast(context.extendedPseudoNamesStack);\n\n  if (!lastExtendedPseudoClassName) {\n    throw new Error('Regexp pattern allowed only in arg of extended pseudo-class');\n  } // for regexp pattens the slash should not be escaped\n  // const isRegexpPatternSlash = prevTokenValue !== BACKSLASH;\n  // regexp pattern can be set as arg of pseudo-class\n  // which means limited list of available symbols before slash `/`;\n  // for :contains() pseudo-class regexp pattern should be at the beginning of arg\n\n\n  if (CONTAINS_PSEUDO_NAMES.includes(lastExtendedPseudoClassName)) {\n    return POSSIBLE_MARKS_BEFORE_REGEXP.CONTAINS.includes(prevTokenValue);\n  }\n\n  if (prevTokenValue === SLASH && lastExtendedPseudoClassName !== XPATH_PSEUDO_CLASS_MARKER) {\n    const rawArgDesc = bufferNodeValue ? `in arg part: '${bufferNodeValue}'` : 'arg';\n    throw new Error(`Invalid regexp pattern for :${lastExtendedPseudoClassName}() pseudo-class ${rawArgDesc}`);\n  } // for other pseudo-classes regexp pattern can be either the whole arg or its part\n\n\n  return POSSIBLE_MARKS_BEFORE_REGEXP.COMMON.includes(prevTokenValue);\n};\n/**\n * Checks whether the attribute starts.\n *\n * @param tokenValue Value of current token.\n * @param prevTokenValue Previous token value.\n *\n * @returns True if combination of current and previous token seems to be **a start** of attribute.\n */\n\nconst isAttributeOpening = (tokenValue, prevTokenValue) => {\n  return tokenValue === BRACKET.SQUARE.LEFT && prevTokenValue !== BACKSLASH;\n};\n/**\n * Checks whether the attribute ends.\n *\n * @param context Selector parser context.\n *\n * @returns True if combination of current and previous token seems to be **an end** of attribute.\n * @throws An error on invalid attribute.\n */\n\nconst isAttributeClosing = context => {\n  var _getPrevToLast;\n\n  if (!context.isAttributeBracketsOpen) {\n    return false;\n  } // valid attributes may have extra spaces inside.\n  // we get rid of them just to simplify the checking and they are skipped only here:\n  //   - spaces will be collected to the ast with spaces as they were declared is selector\n  //   - extra spaces in attribute are not relevant to attribute syntax validity\n  //     e.g. 'a[ title ]' is the same as 'a[title]'\n  //          'div[style *= \"MARGIN\" i]' is the same as 'div[style*=\"MARGIN\"i]'\n\n\n  const noSpaceAttr = context.attributeBuffer.split(SPACE).join(''); // tokenize the prepared attribute string\n\n  const attrTokens = tokenizeAttribute(noSpaceAttr);\n  const firstAttrToken = getFirst(attrTokens);\n  const firstAttrTokenType = firstAttrToken === null || firstAttrToken === void 0 ? void 0 : firstAttrToken.type;\n  const firstAttrTokenValue = firstAttrToken === null || firstAttrToken === void 0 ? void 0 : firstAttrToken.value; // signal an error on any mark-type token except backslash\n  // e.g. '[=\"margin\"]'\n\n  if (firstAttrTokenType === TOKEN_TYPE.MARK // backslash is allowed at start of attribute\n  // e.g. '[\\\\:data-service-slot]'\n  && firstAttrTokenValue !== BACKSLASH) {\n    // eslint-disable-next-line max-len\n    throw new Error(`'[${context.attributeBuffer}]' is not a valid attribute due to '${firstAttrTokenValue}' at start of it`);\n  }\n\n  const lastAttrToken = getLast(attrTokens);\n  const lastAttrTokenType = lastAttrToken === null || lastAttrToken === void 0 ? void 0 : lastAttrToken.type;\n  const lastAttrTokenValue = lastAttrToken === null || lastAttrToken === void 0 ? void 0 : lastAttrToken.value;\n\n  if (lastAttrTokenValue === EQUAL_SIGN) {\n    // e.g. '[style=]'\n    throw new Error(`'[${context.attributeBuffer}]' is not a valid attribute due to '${EQUAL_SIGN}'`);\n  }\n\n  const equalSignIndex = attrTokens.findIndex(token => {\n    return token.type === TOKEN_TYPE.MARK && token.value === EQUAL_SIGN;\n  });\n  const prevToLastAttrTokenValue = (_getPrevToLast = getPrevToLast(attrTokens)) === null || _getPrevToLast === void 0 ? void 0 : _getPrevToLast.value;\n\n  if (equalSignIndex === -1) {\n    // if there is no '=' inside attribute,\n    // it must be just attribute name which means the word-type token before closing bracket\n    // e.g. 'div[style]'\n    if (lastAttrTokenType === TOKEN_TYPE.WORD) {\n      return true;\n    }\n\n    return prevToLastAttrTokenValue === BACKSLASH // some weird attribute are valid too\n    // e.g. '[class\\\\\"ads-article\\\\\"]'\n    && (lastAttrTokenValue === DOUBLE_QUOTE // e.g. \"[class\\\\'ads-article\\\\']\"\n    || lastAttrTokenValue === SINGLE_QUOTE);\n  } // get the value of token next to `=`\n\n\n  const nextToEqualSignToken = getItemByIndex(attrTokens, equalSignIndex + 1);\n  const nextToEqualSignTokenValue = nextToEqualSignToken.value; // check whether the attribute value wrapper in quotes\n\n  const isAttrValueQuote = nextToEqualSignTokenValue === SINGLE_QUOTE || nextToEqualSignTokenValue === DOUBLE_QUOTE; // for no quotes after `=` the last token before `]` should be a word-type one\n  // e.g. 'div[style*=margin]'\n  //      'div[style*=MARGIN i]'\n\n  if (!isAttrValueQuote) {\n    if (lastAttrTokenType === TOKEN_TYPE.WORD) {\n      return true;\n    } // otherwise signal an error\n    // e.g. 'table[style*=border: 0px\"]'\n\n\n    throw new Error(`'[${context.attributeBuffer}]' is not a valid attribute`);\n  } // otherwise if quotes for value are present\n  // the last token before `]` can still be word-type token\n  // e.g. 'div[style*=\"MARGIN\" i]'\n\n\n  if (lastAttrTokenType === TOKEN_TYPE.WORD && (lastAttrTokenValue === null || lastAttrTokenValue === void 0 ? void 0 : lastAttrTokenValue.toLocaleLowerCase()) === ATTRIBUTE_CASE_INSENSITIVE_FLAG) {\n    return prevToLastAttrTokenValue === nextToEqualSignTokenValue;\n  } // eventually if there is quotes for attribute value and last token is not a word,\n  // the closing mark should be the same quote as opening one\n\n\n  return lastAttrTokenValue === nextToEqualSignTokenValue;\n};\n/**\n * Checks whether the `tokenValue` is a whitespace character.\n *\n * @param tokenValue Token value.\n *\n * @returns True if `tokenValue` is a whitespace character.\n */\n\nconst isWhiteSpaceChar = tokenValue => {\n  if (!tokenValue) {\n    return false;\n  }\n\n  return WHITE_SPACE_CHARACTERS.includes(tokenValue);\n};\n\n/**\n * Checks whether the passed `str` is a name of supported absolute extended pseudo-class,\n * e.g. :contains(), :matches-css() etc.\n *\n * @param str Token value to check.\n *\n * @returns True if `str` is one of absolute extended pseudo-class names.\n */\n\nconst isAbsolutePseudoClass = str => {\n  return ABSOLUTE_PSEUDO_CLASSES.includes(str);\n};\n/**\n * Checks whether the passed `str` is a name of supported relative extended pseudo-class,\n * e.g. :has(), :not() etc.\n *\n * @param str Token value to check.\n *\n * @returns True if `str` is one of relative extended pseudo-class names.\n */\n\nconst isRelativePseudoClass = str => {\n  return RELATIVE_PSEUDO_CLASSES.includes(str);\n};\n\n/**\n * Returns the node which is being collected\n * or null if there is no such one.\n *\n * @param context Selector parser context.\n *\n * @returns Buffer node or null.\n */\n\nconst getBufferNode = context => {\n  if (context.pathToBufferNode.length === 0) {\n    return null;\n  } // buffer node is always the last in the pathToBufferNode stack\n\n\n  return getLast(context.pathToBufferNode) || null;\n};\n/**\n * Returns the parent node to the 'buffer node'  which is the one being collected \n * or null if there is no such one.\n *\n * @param context Selector parser context.\n *\n * @returns Parent node of buffer node or null.\n */\n\nconst getBufferNodeParent = context => {\n  // at least two nodes should exist  the buffer node and its parent\n  // otherwise return null\n  if (context.pathToBufferNode.length < 2) {\n    return null;\n  } // since the buffer node is always the last in the pathToBufferNode stack\n  // its parent is previous to it in the stack\n\n\n  return getPrevToLast(context.pathToBufferNode) || null;\n};\n/**\n * Returns last RegularSelector ast node.\n * Needed for parsing of the complex selector with extended pseudo-class inside it.\n *\n * @param context Selector parser context.\n *\n * @returns Ast RegularSelector node.\n * @throws An error if:\n * - bufferNode is absent;\n * - type of bufferNode is unsupported;\n * - no RegularSelector in bufferNode.\n */\n\nconst getContextLastRegularSelectorNode = context => {\n  const bufferNode = getBufferNode(context);\n\n  if (!bufferNode) {\n    throw new Error('No bufferNode found');\n  }\n\n  if (!isSelectorNode(bufferNode)) {\n    throw new Error('Unsupported bufferNode type');\n  }\n\n  const lastRegularSelectorNode = getLastRegularChild(bufferNode.children);\n  context.pathToBufferNode.push(lastRegularSelectorNode);\n  return lastRegularSelectorNode;\n};\n/**\n * Updates needed buffer node value while tokens iterating.\n * For RegularSelector also collects token values to context.attributeBuffer\n * for proper attribute parsing.\n *\n * @param context Selector parser context.\n * @param tokenValue Value of current token.\n *\n * @throws An error if:\n * - no bufferNode;\n * - bufferNode.type is not RegularSelector or AbsolutePseudoClass.\n */\n\nconst updateBufferNode = (context, tokenValue) => {\n  const bufferNode = getBufferNode(context);\n\n  if (bufferNode === null) {\n    throw new Error('No bufferNode to update');\n  }\n\n  if (isAbsolutePseudoClassNode(bufferNode)) {\n    bufferNode.value += tokenValue;\n  } else if (isRegularSelectorNode(bufferNode)) {\n    bufferNode.value += tokenValue;\n\n    if (context.isAttributeBracketsOpen) {\n      context.attributeBuffer += tokenValue;\n    }\n  } else {\n    // eslint-disable-next-line max-len\n    throw new Error(`${bufferNode.type} node cannot be updated. Only RegularSelector and AbsolutePseudoClass are supported`);\n  }\n};\n/**\n * Adds SelectorList node to context.ast at the start of ast collecting.\n *\n * @param context Selector parser context.\n */\n\nconst addSelectorListNode = context => {\n  const selectorListNode = new AnySelectorNode(NODE.SELECTOR_LIST);\n  context.ast = selectorListNode;\n  context.pathToBufferNode.push(selectorListNode);\n};\n/**\n * Adds new node to buffer node children.\n * New added node will be considered as buffer node after it.\n *\n * @param context Selector parser context.\n * @param type Type of node to add.\n * @param tokenValue Optional, defaults to `''`, value of processing token.\n *\n * @throws An error if no bufferNode.\n */\n\nconst addAstNodeByType = function (context, type) {\n  let tokenValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  const bufferNode = getBufferNode(context);\n\n  if (bufferNode === null) {\n    throw new Error('No buffer node');\n  }\n\n  let node;\n\n  if (type === NODE.REGULAR_SELECTOR) {\n    node = new RegularSelectorNode(tokenValue);\n  } else if (type === NODE.ABSOLUTE_PSEUDO_CLASS) {\n    node = new AbsolutePseudoClassNode(tokenValue);\n  } else if (type === NODE.RELATIVE_PSEUDO_CLASS) {\n    node = new RelativePseudoClassNode(tokenValue);\n  } else {\n    // SelectorList || Selector || ExtendedSelector\n    node = new AnySelectorNode(type);\n  }\n\n  bufferNode.addChild(node);\n  context.pathToBufferNode.push(node);\n};\n/**\n * The very beginning of ast collecting.\n *\n * @param context Selector parser context.\n * @param tokenValue Value of regular selector.\n */\n\nconst initAst = (context, tokenValue) => {\n  addSelectorListNode(context);\n  addAstNodeByType(context, NODE.SELECTOR); // RegularSelector node is always the first child of Selector node\n\n  addAstNodeByType(context, NODE.REGULAR_SELECTOR, tokenValue);\n};\n/**\n * Inits selector list subtree for relative extended pseudo-classes, e.g. :has(), :not().\n *\n * @param context Selector parser context.\n * @param tokenValue Optional, defaults to `''`, value of inner regular selector.\n */\n\nconst initRelativeSubtree = function (context) {\n  let tokenValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  addAstNodeByType(context, NODE.SELECTOR_LIST);\n  addAstNodeByType(context, NODE.SELECTOR);\n  addAstNodeByType(context, NODE.REGULAR_SELECTOR, tokenValue);\n};\n/**\n * Goes to closest parent specified by type.\n * Actually updates path to buffer node for proper ast collecting of selectors while parsing.\n *\n * @param context Selector parser context.\n * @param parentType Type of needed parent node in ast.\n */\n\nconst upToClosest = (context, parentType) => {\n  for (let i = context.pathToBufferNode.length - 1; i >= 0; i -= 1) {\n    var _context$pathToBuffer;\n\n    if (((_context$pathToBuffer = context.pathToBufferNode[i]) === null || _context$pathToBuffer === void 0 ? void 0 : _context$pathToBuffer.type) === parentType) {\n      context.pathToBufferNode = context.pathToBufferNode.slice(0, i + 1);\n      break;\n    }\n  }\n};\n/**\n * Returns needed buffer node updated due to complex selector parsing.\n *\n * @param context Selector parser context.\n *\n * @returns Ast node for following selector parsing.\n * @throws An error if there is no upper SelectorNode is ast.\n */\n\nconst getUpdatedBufferNode = context => {\n  // it may happen during the parsing of selector list\n  // which is an argument of relative pseudo-class\n  // e.g. '.banner:has(~span, ~p)'\n  // parser position is here  \n  // so if after the comma the buffer node type is SelectorList and parent type is RelativePseudoClass\n  // we should simply return the current buffer node\n  const bufferNode = getBufferNode(context);\n\n  if (bufferNode && isSelectorListNode(bufferNode) && isRelativePseudoClassNode(getBufferNodeParent(context))) {\n    return bufferNode;\n  }\n\n  upToClosest(context, NODE.SELECTOR);\n  const selectorNode = getBufferNode(context);\n\n  if (!selectorNode) {\n    throw new Error('No SelectorNode, impossible to continue selector parsing by ExtendedCss');\n  }\n\n  const lastSelectorNodeChild = getLast(selectorNode.children);\n  const hasExtended = lastSelectorNodeChild && isExtendedSelectorNode(lastSelectorNodeChild) // parser position might be inside standard pseudo-class brackets which has space\n  // e.g. 'div:contains(//):nth-child(100n + 2)'\n  && context.standardPseudoBracketsStack.length === 0;\n  const supposedPseudoClassNode = hasExtended && getFirst(lastSelectorNodeChild.children);\n  let newNeededBufferNode = selectorNode;\n\n  if (supposedPseudoClassNode) {\n    // name of pseudo-class for last extended-node child for Selector node\n    const lastExtendedPseudoName = hasExtended && supposedPseudoClassNode.name;\n    const isLastExtendedNameRelative = lastExtendedPseudoName && isRelativePseudoClass(lastExtendedPseudoName);\n    const isLastExtendedNameAbsolute = lastExtendedPseudoName && isAbsolutePseudoClass(lastExtendedPseudoName);\n    const hasRelativeExtended = isLastExtendedNameRelative && context.extendedPseudoBracketsStack.length > 0 && context.extendedPseudoBracketsStack.length === context.extendedPseudoNamesStack.length;\n    const hasAbsoluteExtended = isLastExtendedNameAbsolute && lastExtendedPseudoName === getLast(context.extendedPseudoNamesStack);\n\n    if (hasRelativeExtended) {\n      // return relative selector node to update later\n      context.pathToBufferNode.push(lastSelectorNodeChild);\n      newNeededBufferNode = supposedPseudoClassNode;\n    } else if (hasAbsoluteExtended) {\n      // return absolute selector node to update later\n      context.pathToBufferNode.push(lastSelectorNodeChild);\n      newNeededBufferNode = supposedPseudoClassNode;\n    }\n  } else if (hasExtended) {\n    // return selector node to add new regular selector node later\n    newNeededBufferNode = selectorNode;\n  } else {\n    // otherwise return last regular selector node to update later\n    newNeededBufferNode = getContextLastRegularSelectorNode(context);\n  } // update the path to buffer node properly\n\n\n  context.pathToBufferNode.push(newNeededBufferNode);\n  return newNeededBufferNode;\n};\n/**\n * Checks values of few next tokens on colon token `:` and:\n *  - updates buffer node for following standard pseudo-class;\n *  - adds extended selector ast node for following extended pseudo-class;\n *  - validates some cases of `:remove()` and `:has()` usage.\n *\n * @param context Selector parser context.\n * @param selector Selector.\n * @param tokenValue Value of current token.\n * @param nextTokenValue Value of token next to current one.\n * @param nextToNextTokenValue Value of token next to next to current one.\n *\n * @throws An error on :remove() pseudo-class in selector\n * or :has() inside regular pseudo limitation.\n */\n\nconst handleNextTokenOnColon = (context, selector, tokenValue, nextTokenValue, nextToNextTokenValue) => {\n  if (!nextTokenValue) {\n    throw new Error(`Invalid colon ':' at the end of selector: '${selector}'`);\n  }\n\n  if (!isSupportedPseudoClass(nextTokenValue.toLowerCase())) {\n    if (nextTokenValue.toLowerCase() === REMOVE_PSEUDO_MARKER) {\n      // :remove() pseudo-class should be handled before\n      // as it is not about element selecting but actions with elements\n      // e.g. 'body > div:empty:remove()'\n      throw new Error(`${REMOVE_ERROR_PREFIX.INVALID_REMOVE}: '${selector}'`);\n    } // if following token is not an extended pseudo\n    // the colon should be collected to value of RegularSelector\n    // e.g. '.entry_text:nth-child(2)'\n\n\n    updateBufferNode(context, tokenValue); // check the token after the pseudo and do balance parentheses later\n    // only if it is functional pseudo-class (standard with brackets, e.g. ':lang()').\n    // no brackets balance needed for such case,\n    // parser position is on first colon after the 'div':\n    // e.g. 'div:last-child:has(button.privacy-policy__btn)'\n\n    if (nextToNextTokenValue && nextToNextTokenValue === BRACKET.PARENTHESES.LEFT // no brackets balance needed for parentheses inside attribute value\n    // e.g. 'a[href=\"javascript:void(0)\"]'   <-- parser position is on colon `:`\n    // before `void`           \n    && !context.isAttributeBracketsOpen) {\n      context.standardPseudoNamesStack.push(nextTokenValue);\n    }\n  } else {\n    // it is supported extended pseudo-class.\n    // Disallow :has() inside the pseudos accepting only compound selectors\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=669058#c54 [2]\n    if (HAS_PSEUDO_CLASS_MARKERS.includes(nextTokenValue) && context.standardPseudoNamesStack.length > 0) {\n      // eslint-disable-next-line max-len\n      throw new Error(`Usage of :${nextTokenValue}() pseudo-class is not allowed inside regular pseudo: '${getLast(context.standardPseudoNamesStack)}'`);\n    } else {\n      // stop RegularSelector value collecting\n      upToClosest(context, NODE.SELECTOR); // add ExtendedSelector to Selector children\n\n      addAstNodeByType(context, NODE.EXTENDED_SELECTOR);\n    }\n  }\n};\n\n// e.g. ':is(.page, .main) > .banner' or '*:not(span):not(p)'\n\nconst IS_OR_NOT_PSEUDO_SELECTING_ROOT = `html ${ASTERISK}`;\n/**\n * Checks if there are any ExtendedSelector node in selector list.\n *\n * @param selectorList Ast SelectorList node.\n *\n * @returns True if `selectorList` has any inner ExtendedSelector node.\n */\n\nconst hasExtendedSelector = selectorList => {\n  return selectorList.children.some(selectorNode => {\n    return selectorNode.children.some(selectorNodeChild => {\n      return isExtendedSelectorNode(selectorNodeChild);\n    });\n  });\n};\n/**\n * Converts selector list of RegularSelector nodes to string.\n *\n * @param selectorList Ast SelectorList node.\n *\n * @returns String representation for selector list of regular selectors.\n */\n\n\nconst selectorListOfRegularsToString = selectorList => {\n  // if there is no ExtendedSelector in relative SelectorList\n  // it means that each Selector node has single child  RegularSelector node\n  // and their values should be combined to string\n  const standardCssSelectors = selectorList.children.map(selectorNode => {\n    const selectorOnlyChild = getNodeOnlyChild(selectorNode, 'Ast Selector node should have RegularSelector node');\n    return getNodeValue(selectorOnlyChild);\n  });\n  return standardCssSelectors.join(`${COMMA}${SPACE}`);\n};\n/**\n * Updates children of `node` replacing them with `newChildren`.\n * Important: modifies input `node` which is passed by reference.\n *\n * @param node Ast node to update.\n * @param newChildren Array of new children for ast node.\n *\n * @returns Updated ast node.\n */\n\n\nconst updateNodeChildren = (node, newChildren) => {\n  node.children = newChildren;\n  return node;\n};\n/**\n * Recursively checks whether the ExtendedSelector node should be optimized.\n * It has to be recursive because RelativePseudoClass has inner SelectorList node.\n *\n * @param currExtendedSelectorNode Ast ExtendedSelector node.\n *\n * @returns True is ExtendedSelector should be optimized.\n */\n\n\nconst shouldOptimizeExtendedSelector = currExtendedSelectorNode => {\n  if (currExtendedSelectorNode === null) {\n    return false;\n  }\n\n  const extendedPseudoClassNode = getPseudoClassNode(currExtendedSelectorNode);\n  const pseudoName = getNodeName(extendedPseudoClassNode);\n\n  if (isAbsolutePseudoClass(pseudoName)) {\n    return false;\n  }\n\n  const relativeSelectorList = getRelativeSelectorListNode(extendedPseudoClassNode);\n  const innerSelectorNodes = relativeSelectorList.children; // simple checking for standard selectors in arg of :not() or :is() pseudo-class\n  // e.g. 'div > *:is(div, a, span)'\n\n  if (isOptimizationPseudoClass(pseudoName)) {\n    const areAllSelectorNodeChildrenRegular = innerSelectorNodes.every(selectorNode => {\n      try {\n        const selectorOnlyChild = getNodeOnlyChild(selectorNode, 'Selector node should have RegularSelector'); // it means that the only child is RegularSelector and it can be optimized\n\n        return isRegularSelectorNode(selectorOnlyChild);\n      } catch (e) {\n        return false;\n      }\n    });\n\n    if (areAllSelectorNodeChildrenRegular) {\n      return true;\n    }\n  } // for other extended pseudo-classes than :not() and :is()\n\n\n  return innerSelectorNodes.some(selectorNode => {\n    return selectorNode.children.some(selectorNodeChild => {\n      if (!isExtendedSelectorNode(selectorNodeChild)) {\n        return false;\n      } // check inner ExtendedSelector recursively\n      // e.g. 'div:has(*:not(.header))'\n\n\n      return shouldOptimizeExtendedSelector(selectorNodeChild);\n    });\n  });\n};\n/**\n * Returns optimized ExtendedSelector node if it can be optimized\n * or null if ExtendedSelector is fully optimized while function execution\n * which means that value of `prevRegularSelectorNode` is updated.\n *\n * @param currExtendedSelectorNode Current ExtendedSelector node to optimize.\n * @param prevRegularSelectorNode Previous RegularSelector node.\n *\n * @returns Ast node or null.\n */\n\n\nconst getOptimizedExtendedSelector = (currExtendedSelectorNode, prevRegularSelectorNode) => {\n  if (!currExtendedSelectorNode) {\n    return null;\n  }\n\n  const extendedPseudoClassNode = getPseudoClassNode(currExtendedSelectorNode);\n  const relativeSelectorList = getRelativeSelectorListNode(extendedPseudoClassNode);\n  const hasInnerExtendedSelector = hasExtendedSelector(relativeSelectorList);\n\n  if (!hasInnerExtendedSelector) {\n    // if there is no extended selectors for :not() or :is()\n    // e.g. 'div:not(.content, .main)'\n    const relativeSelectorListStr = selectorListOfRegularsToString(relativeSelectorList);\n    const pseudoName = getNodeName(extendedPseudoClassNode); // eslint-disable-next-line max-len\n\n    const optimizedExtendedStr = `${COLON}${pseudoName}${BRACKET.PARENTHESES.LEFT}${relativeSelectorListStr}${BRACKET.PARENTHESES.RIGHT}`;\n    prevRegularSelectorNode.value = `${getNodeValue(prevRegularSelectorNode)}${optimizedExtendedStr}`;\n    return null;\n  } // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n\n  const optimizedRelativeSelectorList = optimizeSelectorListNode(relativeSelectorList);\n  const optimizedExtendedPseudoClassNode = updateNodeChildren(extendedPseudoClassNode, [optimizedRelativeSelectorList]);\n  return updateNodeChildren(currExtendedSelectorNode, [optimizedExtendedPseudoClassNode]);\n};\n/**\n * Combines values of `previous` and `current` RegularSelector nodes.\n * It may happen during the optimization when ExtendedSelector between RegularSelector node was optimized.\n *\n * @param current Current RegularSelector node.\n * @param previous Previous RegularSelector node.\n */\n\n\nconst optimizeCurrentRegularSelector = (current, previous) => {\n  previous.value = `${getNodeValue(previous)}${SPACE}${getNodeValue(current)}`;\n};\n/**\n * Optimizes ast Selector node.\n *\n * @param selectorNode Ast Selector node.\n *\n * @returns Optimized ast node.\n * @throws An error while collecting optimized nodes.\n */\n\n\nconst optimizeSelectorNode = selectorNode => {\n  // non-optimized list of SelectorNode children\n  const rawSelectorNodeChildren = selectorNode.children; // for collecting optimized children list\n\n  const optimizedChildrenList = [];\n  let currentIndex = 0; // iterate through all children in non-optimized ast Selector node\n\n  while (currentIndex < rawSelectorNodeChildren.length) {\n    const currentChild = getItemByIndex(rawSelectorNodeChildren, currentIndex, 'currentChild should be specified'); // no need to optimize the very first child which is always RegularSelector node\n\n    if (currentIndex === 0) {\n      optimizedChildrenList.push(currentChild);\n    } else {\n      const prevRegularChild = getLastRegularChild(optimizedChildrenList);\n\n      if (isExtendedSelectorNode(currentChild)) {\n        // start checking with point is null\n        let optimizedExtendedSelector = null; // check whether the optimization is needed\n\n        let isOptimizationNeeded = shouldOptimizeExtendedSelector(currentChild); // update optimizedExtendedSelector so it can be optimized recursively\n        // i.e. `getOptimizedExtendedSelector(optimizedExtendedSelector)` below\n\n        optimizedExtendedSelector = currentChild;\n\n        while (isOptimizationNeeded) {\n          // recursively optimize ExtendedSelector until no optimization needed\n          // e.g. div > *:is(.banner:not(.block))\n          optimizedExtendedSelector = getOptimizedExtendedSelector(optimizedExtendedSelector, prevRegularChild);\n          isOptimizationNeeded = shouldOptimizeExtendedSelector(optimizedExtendedSelector);\n        } // if it was simple :not() of :is() with standard selector arg\n        // e.g. 'div:not([class][id])'\n        // or   '.main > *:is([data-loaded], .banner)'\n        // after the optimization the ExtendedSelector node become part of RegularSelector\n        // so nothing to save eventually\n        // otherwise the optimized ExtendedSelector should be saved\n        // e.g. 'div:has(:not([class]))'\n\n\n        if (optimizedExtendedSelector !== null) {\n          optimizedChildrenList.push(optimizedExtendedSelector); // if optimization is not needed\n\n          const optimizedPseudoClass = getPseudoClassNode(optimizedExtendedSelector);\n          const optimizedPseudoName = getNodeName(optimizedPseudoClass); // parent element checking is used to apply :is() and :not() pseudo-classes as extended.\n          // as there is no parentNode for root element (html)\n          // so element selection should be limited to it's children\n          // e.g. '*:is(:has(.page))' -> 'html *:is(has(.page))'\n          // or   '*:not(:has(span))' -> 'html *:not(:has(span))'\n\n          if (getNodeValue(prevRegularChild) === ASTERISK && isOptimizationPseudoClass(optimizedPseudoName)) {\n            prevRegularChild.value = IS_OR_NOT_PSEUDO_SELECTING_ROOT;\n          }\n        }\n      } else if (isRegularSelectorNode(currentChild)) {\n        // in non-optimized ast, RegularSelector node may follow ExtendedSelector which should be optimized\n        // for example, for 'div:not(.content) > .banner' schematically it looks like\n        // non-optimized ast: [\n        //   1. RegularSelector: 'div'\n        //   2. ExtendedSelector: 'not(.content)'\n        //   3. RegularSelector: '> .banner'\n        // ]\n        // which after the ExtendedSelector looks like\n        // partly optimized ast: [\n        //   1. RegularSelector: 'div:not(.content)'\n        //   2. RegularSelector: '> .banner'\n        // ]\n        // so second RegularSelector value should be combined with first one\n        // optimized ast: [\n        //   1. RegularSelector: 'div:not(.content) > .banner'\n        // ]\n        // here we check **children of selectorNode** after previous optimization if it was\n        const lastOptimizedChild = getLast(optimizedChildrenList) || null;\n\n        if (isRegularSelectorNode(lastOptimizedChild)) {\n          optimizeCurrentRegularSelector(currentChild, prevRegularChild);\n        }\n      }\n    }\n\n    currentIndex += 1;\n  }\n\n  return updateNodeChildren(selectorNode, optimizedChildrenList);\n};\n/**\n * Optimizes ast SelectorList node.\n *\n * @param selectorListNode SelectorList node.\n *\n * @returns Optimized ast node.\n */\n\n\nconst optimizeSelectorListNode = selectorListNode => {\n  return updateNodeChildren(selectorListNode, selectorListNode.children.map(s => optimizeSelectorNode(s)));\n};\n/**\n * Optimizes ast:\n * If arg of :not() and :is() pseudo-classes does not contain extended selectors,\n * native Document.querySelectorAll() can be used to query elements.\n * It means that ExtendedSelector ast nodes can be removed\n * and value of relevant RegularSelector node should be updated accordingly.\n *\n * @param ast Non-optimized ast.\n *\n * @returns Optimized ast.\n */\n\n\nconst optimizeAst = ast => {\n  // ast is basically the selector list of selectors\n  return optimizeSelectorListNode(ast);\n};\n\n// https://github.com/AdguardTeam/ExtendedCss/issues/115\n\nconst XPATH_PSEUDO_SELECTING_ROOT = 'body';\nconst NO_WHITESPACE_ERROR_PREFIX = 'No white space is allowed before or after extended pseudo-class name in selector';\n/**\n * Parses selector into ast for following element selection.\n *\n * @param selector Selector to parse.\n *\n * @returns Parsed ast.\n * @throws An error on invalid selector.\n */\n\nconst parse = selector => {\n  const tokens = tokenizeSelector(selector);\n  const context = {\n    ast: null,\n    pathToBufferNode: [],\n    extendedPseudoNamesStack: [],\n    extendedPseudoBracketsStack: [],\n    standardPseudoNamesStack: [],\n    standardPseudoBracketsStack: [],\n    isAttributeBracketsOpen: false,\n    attributeBuffer: '',\n    isRegexpOpen: false,\n    shouldOptimize: false\n  };\n  let i = 0;\n\n  while (i < tokens.length) {\n    const token = tokens[i];\n\n    if (!token) {\n      break;\n    } // Token to process\n\n\n    const {\n      type: tokenType,\n      value: tokenValue\n    } = token; // needed for SPACE and COLON tokens checking\n\n    const nextToken = tokens[i + 1];\n    const nextTokenType = nextToken === null || nextToken === void 0 ? void 0 : nextToken.type;\n    const nextTokenValue = nextToken === null || nextToken === void 0 ? void 0 : nextToken.value; // needed for limitations\n    // - :not() and :is() root element\n    // - :has() usage\n    // - white space before and after pseudo-class name\n\n    const nextToNextToken = tokens[i + 2];\n    const nextToNextTokenValue = nextToNextToken === null || nextToNextToken === void 0 ? void 0 : nextToNextToken.value; // needed for COLON token checking for none-specified regular selector before extended one\n    // e.g. 'p, :hover'\n    // or   '.banner, :contains(ads)'\n\n    const previousToken = tokens[i - 1];\n    const prevTokenType = previousToken === null || previousToken === void 0 ? void 0 : previousToken.type;\n    const prevTokenValue = previousToken === null || previousToken === void 0 ? void 0 : previousToken.value; // needed for proper parsing of regexp pattern arg\n    // e.g. ':matches-css(background-image: /^url\\(https:\\/\\/example\\.org\\//)'\n\n    const previousToPreviousToken = tokens[i - 2];\n    const prevToPrevTokenValue = previousToPreviousToken === null || previousToPreviousToken === void 0 ? void 0 : previousToPreviousToken.value;\n    let bufferNode = getBufferNode(context);\n\n    switch (tokenType) {\n      case TOKEN_TYPE.WORD:\n        if (bufferNode === null) {\n          // there is no buffer node only in one case  no ast collecting has been started\n          initAst(context, tokenValue);\n        } else if (isSelectorListNode(bufferNode)) {\n          // add new selector to selector list\n          addAstNodeByType(context, NODE.SELECTOR);\n          addAstNodeByType(context, NODE.REGULAR_SELECTOR, tokenValue);\n        } else if (isRegularSelectorNode(bufferNode)) {\n          updateBufferNode(context, tokenValue);\n        } else if (isExtendedSelectorNode(bufferNode)) {\n          // No white space is allowed between the name of extended pseudo-class\n          // and its opening parenthesis\n          // https://www.w3.org/TR/selectors-4/#pseudo-classes\n          // e.g. 'span:contains (text)'\n          if (isWhiteSpaceChar(nextTokenValue) && nextToNextTokenValue === BRACKET.PARENTHESES.LEFT) {\n            throw new Error(`${NO_WHITESPACE_ERROR_PREFIX}: '${selector}'`);\n          }\n\n          const lowerCaseTokenValue = tokenValue.toLowerCase(); // save pseudo-class name for brackets balance checking\n\n          context.extendedPseudoNamesStack.push(lowerCaseTokenValue); // extended pseudo-class name are parsed in lower case\n          // as they should be case-insensitive\n          // https://www.w3.org/TR/selectors-4/#pseudo-classes\n\n          if (isAbsolutePseudoClass(lowerCaseTokenValue)) {\n            addAstNodeByType(context, NODE.ABSOLUTE_PSEUDO_CLASS, lowerCaseTokenValue);\n          } else {\n            // if it is not absolute pseudo-class, it must be relative one\n            // add RelativePseudoClass with tokenValue as pseudo-class name to ExtendedSelector children\n            addAstNodeByType(context, NODE.RELATIVE_PSEUDO_CLASS, lowerCaseTokenValue); // for :not() and :is() pseudo-classes parsed ast should be optimized later\n\n            if (isOptimizationPseudoClass(lowerCaseTokenValue)) {\n              context.shouldOptimize = true;\n            }\n          }\n        } else if (isAbsolutePseudoClassNode(bufferNode)) {\n          // collect absolute pseudo-class arg\n          updateBufferNode(context, tokenValue);\n        } else if (isRelativePseudoClassNode(bufferNode)) {\n          initRelativeSubtree(context, tokenValue);\n        }\n\n        break;\n\n      case TOKEN_TYPE.MARK:\n        switch (tokenValue) {\n          case COMMA:\n            if (!bufferNode || typeof bufferNode !== 'undefined' && !nextTokenValue) {\n              // consider the selector is invalid if there is no bufferNode yet (e.g. ', a')\n              // or there is nothing after the comma while bufferNode is defined (e.g. 'div, ')\n              throw new Error(`'${selector}' is not a valid selector`);\n            } else if (isRegularSelectorNode(bufferNode)) {\n              if (context.isAttributeBracketsOpen) {\n                // the comma might be inside element attribute value\n                // e.g. 'div[data-comma=\"0,1\"]'\n                updateBufferNode(context, tokenValue);\n              } else {\n                // new Selector should be collected to upper SelectorList\n                upToClosest(context, NODE.SELECTOR_LIST);\n              }\n            } else if (isAbsolutePseudoClassNode(bufferNode)) {\n              // the comma inside arg of absolute extended pseudo\n              // e.g. 'div:xpath(//h3[contains(text(),\"Share it!\")]/..)'\n              updateBufferNode(context, tokenValue);\n            } else if (isSelectorNode(bufferNode)) {\n              // new Selector should be collected to upper SelectorList\n              // if parser position is on Selector node\n              upToClosest(context, NODE.SELECTOR_LIST);\n            }\n\n            break;\n\n          case SPACE:\n            // it might be complex selector with extended pseudo-class inside it\n            // and the space is between that complex selector and following regular selector\n            // parser position is on ` ` before `span` now:\n            // e.g. 'div:has(img).banner span'\n            // so we need to check whether the new ast node should be added (example above)\n            // or previous regular selector node should be updated\n            if (isRegularSelectorNode(bufferNode) // no need to update the buffer node if attribute value is being parsed\n            // e.g. 'div:not([id])[style=\"position: absolute; z-index: 10000;\"]'\n            // parser position inside attribute    \n            && !context.isAttributeBracketsOpen) {\n              bufferNode = getUpdatedBufferNode(context);\n            }\n\n            if (isRegularSelectorNode(bufferNode)) {\n              // standard selectors with white space between colon and name of pseudo\n              // are invalid for native document.querySelectorAll() anyway,\n              // so throwing the error here is better\n              // than proper parsing of invalid selector and passing it further.\n              // first of all do not check attributes\n              // e.g. div[style=\"text-align: center\"]\n              if (!context.isAttributeBracketsOpen // check the space after the colon and before the pseudo\n              // e.g. '.block: nth-child(2)\n              && (prevTokenValue === COLON && nextTokenType === TOKEN_TYPE.WORD // or after the pseudo and before the opening parenthesis\n              // e.g. '.block:nth-child (2)\n              || prevTokenType === TOKEN_TYPE.WORD && nextTokenValue === BRACKET.PARENTHESES.LEFT)) {\n                throw new Error(`'${selector}' is not a valid selector`);\n              } // collect current tokenValue to value of RegularSelector\n              // if it is the last token or standard selector continues after the space.\n              // otherwise it will be skipped\n\n\n              if (!nextTokenValue || doesRegularContinueAfterSpace(nextTokenType, nextTokenValue) // we also should collect space inside attribute value\n              // e.g. `[onclick^=\"window.open ('https://example.com/share?url=\"]`\n              // parser position             \n              || context.isAttributeBracketsOpen) {\n                updateBufferNode(context, tokenValue);\n              }\n            }\n\n            if (isAbsolutePseudoClassNode(bufferNode)) {\n              // space inside extended pseudo-class arg\n              // e.g. 'span:contains(some text)'\n              updateBufferNode(context, tokenValue);\n            }\n\n            if (isRelativePseudoClassNode(bufferNode)) {\n              // init with empty value RegularSelector\n              // as the space is not needed for selector value\n              // e.g. 'p:not( .content )'\n              initRelativeSubtree(context);\n            }\n\n            if (isSelectorNode(bufferNode)) {\n              // do NOT add RegularSelector if parser position on space BEFORE the comma in selector list\n              // e.g. '.block:has(> img) , .banner)'\n              if (doesRegularContinueAfterSpace(nextTokenType, nextTokenValue)) {\n                // regular selector might be after the extended one.\n                // extra space before combinator or selector should not be collected\n                // e.g. '.banner:upward(2) .block'\n                //      '.banner:upward(2) > .block'\n                // so no tokenValue passed to addAnySelectorNode()\n                addAstNodeByType(context, NODE.REGULAR_SELECTOR);\n              }\n            }\n\n            break;\n\n          case DESCENDANT_COMBINATOR:\n          case CHILD_COMBINATOR:\n          case NEXT_SIBLING_COMBINATOR:\n          case SUBSEQUENT_SIBLING_COMBINATOR:\n          case SEMICOLON:\n          case SLASH:\n          case BACKSLASH:\n          case SINGLE_QUOTE:\n          case DOUBLE_QUOTE:\n          case CARET:\n          case DOLLAR_SIGN:\n          case BRACKET.CURLY.LEFT:\n          case BRACKET.CURLY.RIGHT:\n          case ASTERISK:\n          case ID_MARKER:\n          case CLASS_MARKER:\n          case BRACKET.SQUARE.LEFT:\n            // it might be complex selector with extended pseudo-class inside it\n            // and the space is between that complex selector and following regular selector\n            // e.g. 'div:has(img).banner'   // parser position is on `.` before `banner` now\n            //      'div:has(img)[attr]'    // parser position is on `[` before `attr` now\n            // so we need to check whether the new ast node should be added (example above)\n            // or previous regular selector node should be updated\n            if (COMBINATORS.includes(tokenValue)) {\n              if (bufferNode === null) {\n                // cases where combinator at very beginning of a selector\n                // e.g. '> div'\n                // or   '~ .banner'\n                // or even '+js(overlay-buster)' which not a selector at all\n                // but may be validated by FilterCompiler so error message should be appropriate\n                throw new Error(`'${selector}' is not a valid selector`);\n              }\n\n              bufferNode = getUpdatedBufferNode(context);\n            }\n\n            if (bufferNode === null) {\n              // no ast collecting has been started\n              // e.g. '.banner > p'\n              // or   '#top > div.ad'\n              // or   '[class][style][attr]'\n              // or   '*:not(span)'\n              initAst(context, tokenValue);\n\n              if (isAttributeOpening(tokenValue, prevTokenValue)) {\n                // e.g. '[class^=\"banner-\"]'\n                context.isAttributeBracketsOpen = true;\n              }\n            } else if (isRegularSelectorNode(bufferNode)) {\n              if (tokenValue === BRACKET.CURLY.LEFT && !(context.isAttributeBracketsOpen || context.isRegexpOpen)) {\n                // e.g. 'div { content: \"'\n                throw new Error(`'${selector}' is not a valid selector`);\n              } // collect the mark to the value of RegularSelector node\n\n\n              updateBufferNode(context, tokenValue);\n\n              if (isAttributeOpening(tokenValue, prevTokenValue)) {\n                // needed for proper handling element attribute value with comma\n                // e.g. 'div[data-comma=\"0,1\"]'\n                context.isAttributeBracketsOpen = true;\n              }\n            } else if (isAbsolutePseudoClassNode(bufferNode)) {\n              // collect the mark to the arg of AbsolutePseudoClass node\n              updateBufferNode(context, tokenValue); // 'isRegexpOpen' flag is needed for brackets balancing inside extended pseudo-class arg\n\n              if (tokenValue === SLASH && context.extendedPseudoNamesStack.length > 0) {\n                if (prevTokenValue === SLASH && prevToPrevTokenValue === BACKSLASH) {\n                  // it may be specific url regexp pattern in arg of pseudo-class\n                  // e.g. ':matches-css(background-image: /^url\\(https:\\/\\/example\\.org\\//)'\n                  // parser position is on final slash before `)`                        \n                  context.isRegexpOpen = false;\n                } else if (prevTokenValue && prevTokenValue !== BACKSLASH) {\n                  if (isRegexpOpening(context, prevTokenValue, getNodeValue(bufferNode))) {\n                    context.isRegexpOpen = !context.isRegexpOpen;\n                  } else {\n                    // otherwise force `isRegexpOpen` flag to `false`\n                    context.isRegexpOpen = false;\n                  }\n                }\n              }\n            } else if (isRelativePseudoClassNode(bufferNode)) {\n              // add SelectorList to children of RelativePseudoClass node\n              initRelativeSubtree(context, tokenValue);\n\n              if (isAttributeOpening(tokenValue, prevTokenValue)) {\n                // besides of creating the relative subtree\n                // opening square bracket means start of attribute\n                // e.g. 'div:not([class=\"content\"])'\n                //      'div:not([href*=\"window.print()\"])'\n                context.isAttributeBracketsOpen = true;\n              }\n            } else if (isSelectorNode(bufferNode)) {\n              // after the extended pseudo closing parentheses\n              // parser position is on Selector node\n              // and regular selector can be after the extended one\n              // e.g. '.banner:upward(2)> .block'\n              // or   '.inner:nth-ancestor(1)~ .banner'\n              if (COMBINATORS.includes(tokenValue)) {\n                addAstNodeByType(context, NODE.REGULAR_SELECTOR, tokenValue);\n              } else if (!context.isRegexpOpen) {\n                // it might be complex selector with extended pseudo-class inside it.\n                // parser position is on `.` now:\n                // e.g. 'div:has(img).banner'\n                // so we need to get last regular selector node and update its value\n                bufferNode = getContextLastRegularSelectorNode(context);\n                updateBufferNode(context, tokenValue);\n\n                if (isAttributeOpening(tokenValue, prevTokenValue)) {\n                  // handle attribute in compound selector after extended pseudo-class\n                  // e.g. 'div:not(.top)[style=\"z-index: 10000;\"]'\n                  // parser position    \n                  context.isAttributeBracketsOpen = true;\n                }\n              }\n            } else if (isSelectorListNode(bufferNode)) {\n              // add Selector to SelectorList\n              addAstNodeByType(context, NODE.SELECTOR); // and RegularSelector as it is always the first child of Selector\n\n              addAstNodeByType(context, NODE.REGULAR_SELECTOR, tokenValue);\n\n              if (isAttributeOpening(tokenValue, prevTokenValue)) {\n                // handle simple attribute selector in selector list\n                // e.g. '.banner, [class^=\"ad-\"]'\n                context.isAttributeBracketsOpen = true;\n              }\n            }\n\n            break;\n\n          case BRACKET.SQUARE.RIGHT:\n            if (isRegularSelectorNode(bufferNode)) {\n              // unescaped `]` in regular selector allowed only inside attribute value\n              if (!context.isAttributeBracketsOpen && prevTokenValue !== BACKSLASH) {\n                // e.g. 'div]'\n                // eslint-disable-next-line max-len\n                throw new Error(`'${selector}' is not a valid selector due to '${tokenValue}' after '${getNodeValue(bufferNode)}'`);\n              } // needed for proper parsing regular selectors after the attributes with comma\n              // e.g. 'div[data-comma=\"0,1\"] > img'\n\n\n              if (isAttributeClosing(context)) {\n                context.isAttributeBracketsOpen = false; // reset attribute buffer on closing `]`\n\n                context.attributeBuffer = '';\n              } // collect the bracket to the value of RegularSelector node\n\n\n              updateBufferNode(context, tokenValue);\n            }\n\n            if (isAbsolutePseudoClassNode(bufferNode)) {\n              // :xpath() expended pseudo-class arg might contain square bracket\n              // so it should be collected\n              // e.g. 'div:xpath(//h3[contains(text(),\"Share it!\")]/..)'\n              updateBufferNode(context, tokenValue);\n            }\n\n            break;\n\n          case COLON:\n            // No white space is allowed between the colon and the following name of the pseudo-class\n            // https://www.w3.org/TR/selectors-4/#pseudo-classes\n            // e.g. 'span: contains(text)'\n            if (isWhiteSpaceChar(nextTokenValue) && nextToNextTokenValue && SUPPORTED_PSEUDO_CLASSES.includes(nextToNextTokenValue)) {\n              throw new Error(`${NO_WHITESPACE_ERROR_PREFIX}: '${selector}'`);\n            }\n\n            if (bufferNode === null) {\n              // no ast collecting has been started\n              if (nextTokenValue === XPATH_PSEUDO_CLASS_MARKER) {\n                // limit applying of \"naked\" :xpath pseudo-class\n                // https://github.com/AdguardTeam/ExtendedCss/issues/115\n                initAst(context, XPATH_PSEUDO_SELECTING_ROOT);\n              } else if (nextTokenValue === UPWARD_PSEUDO_CLASS_MARKER || nextTokenValue === NTH_ANCESTOR_PSEUDO_CLASS_MARKER) {\n                // selector should be specified before :nth-ancestor() or :upward()\n                // e.g. ':nth-ancestor(3)'\n                // or   ':upward(span)'\n                throw new Error(`${NO_SELECTOR_ERROR_PREFIX} before :${nextTokenValue}() pseudo-class`);\n              } else {\n                // make it more obvious if selector starts with pseudo with no tag specified\n                // e.g. ':has(a)' -> '*:has(a)'\n                // or   ':empty'  -> '*:empty'\n                initAst(context, ASTERISK);\n              } // bufferNode should be updated for following checking\n\n\n              bufferNode = getBufferNode(context);\n            }\n\n            if (isSelectorListNode(bufferNode)) {\n              // bufferNode is SelectorList after comma has been parsed.\n              // parser position is on colon now:\n              // e.g. 'img,:not(.content)'\n              addAstNodeByType(context, NODE.SELECTOR); // add empty value RegularSelector anyway as any selector should start with it\n              // and check previous token on the next step\n\n              addAstNodeByType(context, NODE.REGULAR_SELECTOR); // bufferNode should be updated for following checking\n\n              bufferNode = getBufferNode(context);\n            }\n\n            if (isRegularSelectorNode(bufferNode)) {\n              // it can be extended or standard pseudo\n              // e.g. '#share, :contains(share it)'\n              // or   'div,:hover'\n              // of   'div:has(+:contains(text))'  // position is after '+'\n              if (prevTokenValue && COMBINATORS.includes(prevTokenValue) || prevTokenValue === COMMA) {\n                // case with colon at the start of string - e.g. ':contains(text)'\n                // is covered by 'bufferNode === null' above at start of COLON checking\n                updateBufferNode(context, ASTERISK);\n              }\n\n              handleNextTokenOnColon(context, selector, tokenValue, nextTokenValue, nextToNextTokenValue);\n            }\n\n            if (isSelectorNode(bufferNode)) {\n              // e.g. 'div:contains(text):'\n              if (!nextTokenValue) {\n                throw new Error(`Invalid colon ':' at the end of selector: '${selector}'`);\n              } // after the extended pseudo closing parentheses\n              // parser position is on Selector node\n              // and there is might be another extended selector.\n              // parser position is on colon before 'upward':\n              // e.g. 'p:contains(PR):upward(2)'\n\n\n              if (isSupportedPseudoClass(nextTokenValue.toLowerCase())) {\n                // if supported extended pseudo-class is next to colon\n                // add ExtendedSelector to Selector children\n                addAstNodeByType(context, NODE.EXTENDED_SELECTOR);\n              } else if (nextTokenValue.toLowerCase() === REMOVE_PSEUDO_MARKER) {\n                // :remove() pseudo-class should be handled before\n                // as it is not about element selecting but actions with elements\n                // e.g. '#banner:upward(2):remove()'\n                throw new Error(`${REMOVE_ERROR_PREFIX.INVALID_REMOVE}: '${selector}'`);\n              } else {\n                // otherwise it is standard pseudo after extended pseudo-class in complex selector\n                // and colon should be collected to value of previous RegularSelector\n                // e.g. 'body *:not(input)::selection'\n                //      'input:matches-css(padding: 10):checked'\n                bufferNode = getContextLastRegularSelectorNode(context);\n                handleNextTokenOnColon(context, selector, tokenValue, nextTokenType, nextToNextTokenValue);\n              }\n            }\n\n            if (isAbsolutePseudoClassNode(bufferNode)) {\n              // :xpath() pseudo-class should be the last of extended pseudo-classes\n              if (getNodeName(bufferNode) === XPATH_PSEUDO_CLASS_MARKER && nextTokenValue && SUPPORTED_PSEUDO_CLASSES.includes(nextTokenValue) && nextToNextTokenValue === BRACKET.PARENTHESES.LEFT) {\n                throw new Error(`:xpath() pseudo-class should be the last in selector: '${selector}'`);\n              } // collecting arg for absolute pseudo-class\n              // e.g. 'div:matches-css(width:400px)'\n\n\n              updateBufferNode(context, tokenValue);\n            }\n\n            if (isRelativePseudoClassNode(bufferNode)) {\n              if (!nextTokenValue) {\n                // e.g. 'div:has(:'\n                throw new Error(`Invalid pseudo-class arg at the end of selector: '${selector}'`);\n              } // make it more obvious if selector starts with pseudo with no tag specified\n              // parser position is on colon inside :has() arg\n              // e.g. 'div:has(:contains(text))'\n              // or   'div:not(:empty)'\n\n\n              initRelativeSubtree(context, ASTERISK);\n\n              if (!isSupportedPseudoClass(nextTokenValue.toLowerCase())) {\n                // collect the colon to value of RegularSelector\n                // e.g. 'div:not(:empty)'\n                updateBufferNode(context, tokenValue); // parentheses should be balanced only for functional pseudo-classes\n                // e.g. '.yellow:not(:nth-child(3))'\n\n                if (nextToNextTokenValue === BRACKET.PARENTHESES.LEFT) {\n                  context.standardPseudoNamesStack.push(nextTokenValue);\n                }\n              } else {\n                // add ExtendedSelector to Selector children\n                // e.g. 'div:has(:contains(text))'\n                upToClosest(context, NODE.SELECTOR);\n                addAstNodeByType(context, NODE.EXTENDED_SELECTOR);\n              }\n            }\n\n            break;\n\n          case BRACKET.PARENTHESES.LEFT:\n            // start of pseudo-class arg\n            if (isAbsolutePseudoClassNode(bufferNode)) {\n              // no brackets balancing needed inside\n              // 1. :xpath() extended pseudo-class arg\n              // 2. regexp arg for other extended pseudo-classes\n              if (getNodeName(bufferNode) !== XPATH_PSEUDO_CLASS_MARKER && context.isRegexpOpen) {\n                // if the parentheses is escaped it should be part of regexp\n                // collect it to arg of AbsolutePseudoClass\n                // e.g. 'div:matches-css(background-image: /^url\\\\(\"data:image\\\\/gif;base64.+/)'\n                updateBufferNode(context, tokenValue);\n              } else {\n                // otherwise brackets should be balanced\n                // e.g. 'div:xpath(//h3[contains(text(),\"Share it!\")]/..)'\n                context.extendedPseudoBracketsStack.push(tokenValue); // eslint-disable-next-line max-len\n\n                if (context.extendedPseudoBracketsStack.length > context.extendedPseudoNamesStack.length) {\n                  updateBufferNode(context, tokenValue);\n                }\n              }\n            }\n\n            if (isRegularSelectorNode(bufferNode)) {\n              // continue RegularSelector value collecting for standard pseudo-classes\n              // e.g. '.banner:where(div)'\n              if (context.standardPseudoNamesStack.length > 0) {\n                updateBufferNode(context, tokenValue);\n                context.standardPseudoBracketsStack.push(tokenValue);\n              } // parentheses inside attribute value should be part of RegularSelector value\n              // e.g. 'div:not([href*=\"window.print()\"])'   <-- parser position\n              // is on the `(` after `print`       \n\n\n              if (context.isAttributeBracketsOpen) {\n                updateBufferNode(context, tokenValue);\n              }\n            }\n\n            if (isRelativePseudoClassNode(bufferNode)) {\n              // save opening bracket for balancing\n              // e.g. 'div:not()'  // position is on `(`\n              context.extendedPseudoBracketsStack.push(tokenValue);\n            }\n\n            break;\n\n          case BRACKET.PARENTHESES.RIGHT:\n            if (isAbsolutePseudoClassNode(bufferNode)) {\n              // no brackets balancing needed inside\n              // 1. :xpath() extended pseudo-class arg\n              // 2. regexp arg for other extended pseudo-classes\n              if (getNodeName(bufferNode) !== XPATH_PSEUDO_CLASS_MARKER && context.isRegexpOpen) {\n                // if closing bracket is part of regexp\n                // simply save it to pseudo-class arg\n                updateBufferNode(context, tokenValue);\n              } else {\n                // remove stacked open parentheses for brackets balance\n                // e.g. 'h3:contains((Ads))'\n                // or   'div:xpath(//h3[contains(text(),\"Share it!\")]/..)'\n                context.extendedPseudoBracketsStack.pop();\n\n                if (getNodeName(bufferNode) !== XPATH_PSEUDO_CLASS_MARKER) {\n                  // for all other absolute pseudo-classes except :xpath()\n                  // remove stacked name of extended pseudo-class\n                  context.extendedPseudoNamesStack.pop(); // eslint-disable-next-line max-len\n\n                  if (context.extendedPseudoBracketsStack.length > context.extendedPseudoNamesStack.length) {\n                    // if brackets stack is not empty yet,\n                    // save tokenValue to arg of AbsolutePseudoClass\n                    // parser position on first closing bracket after 'Ads':\n                    // e.g. 'h3:contains((Ads))'\n                    updateBufferNode(context, tokenValue);\n                  } else if (context.extendedPseudoBracketsStack.length >= 0 && context.extendedPseudoNamesStack.length >= 0) {\n                    // assume it is combined extended pseudo-classes\n                    // parser position on first closing bracket after 'advert':\n                    // e.g. 'div:has(.banner, :contains(advert))'\n                    upToClosest(context, NODE.SELECTOR);\n                  }\n                } else {\n                  // for :xpath()\n                  // eslint-disable-next-line max-len\n                  if (context.extendedPseudoBracketsStack.length < context.extendedPseudoNamesStack.length) {\n                    // remove stacked name of extended pseudo-class\n                    // if there are less brackets than pseudo-class names\n                    // with means last removes bracket was closing for pseudo-class\n                    context.extendedPseudoNamesStack.pop();\n                  } else {\n                    // otherwise the bracket is part of arg\n                    updateBufferNode(context, tokenValue);\n                  }\n                }\n              }\n            }\n\n            if (isRegularSelectorNode(bufferNode)) {\n              if (context.isAttributeBracketsOpen) {\n                // parentheses inside attribute value should be part of RegularSelector value\n                // e.g. 'div:not([href*=\"window.print()\"])'   <-- parser position\n                // is on the `)` after `print(`       \n                updateBufferNode(context, tokenValue);\n              } else if (context.standardPseudoNamesStack.length > 0 && context.standardPseudoBracketsStack.length > 0) {\n                // standard pseudo-class was processing.\n                // collect the closing bracket to value of RegularSelector\n                // parser position is on bracket after 'class' now:\n                // e.g. 'div:where(.class)'\n                updateBufferNode(context, tokenValue); // remove bracket and pseudo name from stacks\n\n                context.standardPseudoBracketsStack.pop();\n                const lastStandardPseudo = context.standardPseudoNamesStack.pop();\n\n                if (!lastStandardPseudo) {\n                  // standard pseudo should be in standardPseudoNamesStack\n                  // as related to standardPseudoBracketsStack\n                  throw new Error(`Parsing error. Invalid selector: ${selector}`);\n                } // Disallow :has() after regular pseudo-elements\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=669058#c54 [3]\n\n\n                if (Object.values(REGULAR_PSEUDO_ELEMENTS).includes(lastStandardPseudo) // check token which is next to closing parentheses and token after it\n                // parser position is on bracket after 'foo' now:\n                // e.g. '::part(foo):has(.a)'\n                && nextTokenValue === COLON && nextToNextTokenValue && HAS_PSEUDO_CLASS_MARKERS.includes(nextToNextTokenValue)) {\n                  // eslint-disable-next-line max-len\n                  throw new Error(`Usage of :${nextToNextTokenValue}() pseudo-class is not allowed after any regular pseudo-element: '${lastStandardPseudo}'`);\n                }\n              } else {\n                // extended pseudo-class was processing.\n                // e.g. 'div:has(h3)'\n                // remove bracket and pseudo name from stacks\n                context.extendedPseudoBracketsStack.pop();\n                context.extendedPseudoNamesStack.pop();\n                upToClosest(context, NODE.EXTENDED_SELECTOR); // go to upper selector for possible selector continuation after extended pseudo-class\n                // e.g. 'div:has(h3) > img'\n\n                upToClosest(context, NODE.SELECTOR);\n              }\n            }\n\n            if (isSelectorNode(bufferNode)) {\n              // after inner extended pseudo-class bufferNode is Selector.\n              // parser position is on last bracket now:\n              // e.g. 'div:has(.banner, :contains(ads))'\n              context.extendedPseudoBracketsStack.pop();\n              context.extendedPseudoNamesStack.pop();\n              upToClosest(context, NODE.EXTENDED_SELECTOR);\n              upToClosest(context, NODE.SELECTOR);\n            }\n\n            if (isRelativePseudoClassNode(bufferNode)) {\n              // save opening bracket for balancing\n              // e.g. 'div:not()'  // position is on `)`\n              // context.extendedPseudoBracketsStack.push(tokenValue);\n              if (context.extendedPseudoNamesStack.length > 0 && context.extendedPseudoBracketsStack.length > 0) {\n                context.extendedPseudoBracketsStack.pop();\n                context.extendedPseudoNamesStack.pop();\n              }\n            }\n\n            break;\n\n          case LINE_FEED:\n          case FORM_FEED:\n          case CARRIAGE_RETURN:\n            // such characters at start and end of selector should be trimmed\n            // so is there is one them among tokens, it is not valid selector\n            throw new Error(`'${selector}' is not a valid selector`);\n\n          case TAB:\n            // allow tab only inside attribute value\n            // as there are such valid rules in filter lists\n            // e.g. 'div[style^=\"margin-right: auto;\ttext-align: left;',\n            // parser position                      \n            if (isRegularSelectorNode(bufferNode) && context.isAttributeBracketsOpen) {\n              updateBufferNode(context, tokenValue);\n            } else {\n              // otherwise not valid\n              throw new Error(`'${selector}' is not a valid selector`);\n            }\n\n        }\n\n        break;\n      // no default statement for Marks as they are limited to SUPPORTED_SELECTOR_MARKS\n      // and all other symbol combinations are tokenized as Word\n      // so error for invalid Word will be thrown later while element selecting by parsed ast\n\n      default:\n        throw new Error(`Unknown type of token: '${tokenValue}'`);\n    }\n\n    i += 1;\n  }\n\n  if (context.ast === null) {\n    throw new Error(`'${selector}' is not a valid selector`);\n  }\n\n  if (context.extendedPseudoNamesStack.length > 0 || context.extendedPseudoBracketsStack.length > 0) {\n    // eslint-disable-next-line max-len\n    throw new Error(`Unbalanced brackets for extended pseudo-class: '${getLast(context.extendedPseudoNamesStack)}'`);\n  }\n\n  if (context.isAttributeBracketsOpen) {\n    throw new Error(`Unbalanced attribute brackets in selector: '${selector}'`);\n  }\n\n  return context.shouldOptimize ? optimizeAst(context.ast) : context.ast;\n};\n\nconst natives = {\n  MutationObserver: window.MutationObserver || window.WebKitMutationObserver\n};\n/**\n * Class NativeTextContent is needed to intercept and save the native Node textContent getter\n * for proper work of :contains() pseudo-class as it may be mocked.\n *\n * @see {@link https://github.com/AdguardTeam/ExtendedCss/issues/127}\n */\n\nclass NativeTextContent {\n  /**\n   * Native Node.\n   */\n\n  /**\n   * Native Node textContent getter.\n   */\n\n  /**\n   * Stores native node.\n   */\n  constructor() {\n    this.nativeNode = window.Node || Node;\n  }\n  /**\n   * Sets native Node textContext getter to `getter` class field.\n   */\n\n\n  setGetter() {\n    var _Object$getOwnPropert;\n\n    this.getter = (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(this.nativeNode.prototype, 'textContent')) === null || _Object$getOwnPropert === void 0 ? void 0 : _Object$getOwnPropert.get;\n  }\n\n}\nconst nativeTextContent = new NativeTextContent();\n\n/**\n * Returns textContent of passed domElement.\n *\n * @param domElement DOM element.\n *\n * @returns DOM element textContent.\n */\n\nconst getNodeTextContent = domElement => {\n  if (nativeTextContent.getter) {\n    return nativeTextContent.getter.apply(domElement);\n  } // if ExtendedCss.init() has not been executed and there is no nodeTextContentGetter,\n  // use simple approach, especially when init() is not really needed, e.g. local tests\n\n\n  return domElement.textContent || '';\n};\n/**\n * Returns element selector text based on it's tagName and attributes.\n *\n * @param element DOM element.\n *\n * @returns String representation of `element`.\n */\n\nconst getElementSelectorDesc = element => {\n  let selectorText = element.tagName.toLowerCase();\n  selectorText += Array.from(element.attributes).map(attr => {\n    return `[${attr.name}=\"${element.getAttribute(attr.name)}\"]`;\n  }).join('');\n  return selectorText;\n};\n/**\n * Returns path to a DOM element as a selector string.\n *\n * @param inputEl Input element.\n *\n * @returns String path to a DOM element.\n * @throws An error if `inputEl` in not instance of `Element`.\n */\n\nconst getElementSelectorPath = inputEl => {\n  if (!(inputEl instanceof Element)) {\n    throw new Error('Function received argument with wrong type');\n  }\n\n  let el;\n  el = inputEl;\n  const path = []; // we need to check '!!el' first because it is possible\n  // that some ancestor of the inputEl was removed before it\n\n  while (!!el && el.nodeType === Node.ELEMENT_NODE) {\n    let selector = el.nodeName.toLowerCase();\n\n    if (el.id && typeof el.id === 'string') {\n      selector += `#${el.id}`;\n      path.unshift(selector);\n      break;\n    }\n\n    let sibling = el;\n    let nth = 1;\n\n    while (sibling.previousElementSibling) {\n      sibling = sibling.previousElementSibling;\n\n      if (sibling.nodeType === Node.ELEMENT_NODE && sibling.nodeName.toLowerCase() === selector) {\n        nth += 1;\n      }\n    }\n\n    if (nth !== 1) {\n      selector += `:nth-of-type(${nth})`;\n    }\n\n    path.unshift(selector);\n    el = el.parentElement;\n  }\n\n  return path.join(' > ');\n};\n/**\n * Checks whether the element is instance of HTMLElement.\n *\n * @param element Element to check.\n *\n * @returns True if `element` is HTMLElement.\n */\n\nconst isHtmlElement = element => {\n  return element instanceof HTMLElement;\n};\n/**\n * Takes `element` and returns its parent element.\n *\n * @param element Element.\n * @param errorMessage Optional error message to throw.\n *\n * @returns Parent of `element`.\n * @throws An error if element has no parent element.\n */\n\nconst getParent = (element, errorMessage) => {\n  const {\n    parentElement\n  } = element;\n\n  if (!parentElement) {\n    throw new Error(errorMessage || 'Element does no have parent element');\n  }\n\n  return parentElement;\n};\n\n/**\n * Checks whether the `error` has `message` property which type is string.\n *\n * @param error Error object.\n *\n * @returns True if `error` has message.\n */\nconst isErrorWithMessage = error => {\n  return typeof error === 'object' && error !== null && 'message' in error && typeof error.message === 'string';\n};\n/**\n * Converts `maybeError` to error object with message.\n *\n * @param maybeError Possible error.\n *\n * @returns Error object with defined `message` property.\n */\n\n\nconst toErrorWithMessage = maybeError => {\n  if (isErrorWithMessage(maybeError)) {\n    return maybeError;\n  }\n\n  try {\n    return new Error(JSON.stringify(maybeError));\n  } catch {\n    // fallback in case if there is an error happened during the maybeError stringifying\n    // like with circular references for example\n    return new Error(String(maybeError));\n  }\n};\n/**\n * Returns error message from `error`.\n * May be helpful to handle caught errors.\n *\n * @param error Error object.\n *\n * @returns Message of `error`.\n */\n\n\nconst getErrorMessage = error => {\n  return toErrorWithMessage(error).message;\n};\n\nconst logger = {\n  /**\n   * Safe console.error version.\n   */\n  error: typeof console !== 'undefined' && console.error && console.error.bind ? console.error.bind(window.console) : console.error,\n\n  /**\n   * Safe console.info version.\n   */\n  info: typeof console !== 'undefined' && console.info && console.info.bind ? console.info.bind(window.console) : console.info\n};\n\n/**\n * Returns string without suffix.\n *\n * @param str Input string.\n * @param suffix Needed to remove.\n *\n * @returns String without suffix.\n */\n\nconst removeSuffix = (str, suffix) => {\n  const index = str.indexOf(suffix, str.length - suffix.length);\n\n  if (index >= 0) {\n    return str.substring(0, index);\n  }\n\n  return str;\n};\n/**\n * Replaces all `pattern`s with `replacement` in `input` string.\n * String.replaceAll() polyfill because it is not supported by old browsers, e.g. Chrome 55.\n *\n * @see {@link https://caniuse.com/?search=String.replaceAll}\n *\n * @param input Input string to process.\n * @param pattern Find in the input string.\n * @param replacement Replace the pattern with.\n *\n * @returns Modified string.\n */\n\nconst replaceAll = (input, pattern, replacement) => {\n  if (!input) {\n    return input;\n  }\n\n  return input.split(pattern).join(replacement);\n};\n/**\n * Converts string pattern to regular expression.\n *\n * @param str String to convert.\n *\n * @returns Regular expression converted from pattern `str`.\n */\n\nconst toRegExp = str => {\n  if (str.startsWith(SLASH) && str.endsWith(SLASH)) {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  const escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n};\n/**\n * Converts any simple type value to string type,\n * e.g. `undefined` -> `'undefined'`.\n *\n * @param value Any type value.\n *\n * @returns String representation of `value`.\n */\n\nconst convertTypeIntoString = value => {\n  let output;\n\n  switch (value) {\n    case undefined:\n      output = 'undefined';\n      break;\n\n    case null:\n      output = 'null';\n      break;\n\n    default:\n      output = value.toString();\n  }\n\n  return output;\n};\n/**\n * Converts instance of string value into other simple types,\n * e.g. `'null'` -> `null`, `'true'` -> `true`.\n *\n * @param value String-type value.\n *\n * @returns Its own type representation of string-type `value`.\n */\n\nconst convertTypeFromString = value => {\n  const numValue = Number(value);\n  let output;\n\n  if (!Number.isNaN(numValue)) {\n    output = numValue;\n  } else {\n    switch (value) {\n      case 'undefined':\n        output = undefined;\n        break;\n\n      case 'null':\n        output = null;\n        break;\n\n      case 'true':\n        output = true;\n        break;\n\n      case 'false':\n        output = false;\n        break;\n\n      default:\n        output = value;\n    }\n  }\n\n  return output;\n};\n\nconst SAFARI_USER_AGENT_REGEXP = /\\sVersion\\/(\\d{2}\\.\\d)(.+\\s|\\s)(Safari)\\//;\nconst isSafariBrowser = SAFARI_USER_AGENT_REGEXP.test(navigator.userAgent);\n/**\n * Checks whether the browser userAgent is supported.\n *\n * @param userAgent User agent of browser.\n *\n * @returns False only for Internet Explorer.\n */\n\nconst isUserAgentSupported = userAgent => {\n  // do not support Internet Explorer\n  if (userAgent.includes('MSIE') || userAgent.includes('Trident/')) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Checks whether the current browser is supported.\n *\n * @returns False for Internet Explorer, otherwise true.\n */\n\nconst isBrowserSupported = () => {\n  return isUserAgentSupported(navigator.userAgent);\n};\n\n/**\n * CSS_PROPERTY is needed for style values normalization.\n *\n * IMPORTANT: it is used as 'const' instead of 'enum' to avoid side effects\n * during ExtendedCss import into other libraries.\n */\n\nconst CSS_PROPERTY = {\n  BACKGROUND: 'background',\n  BACKGROUND_IMAGE: 'background-image',\n  CONTENT: 'content',\n  OPACITY: 'opacity'\n};\nconst REGEXP_ANY_SYMBOL = '.*';\nconst REGEXP_WITH_FLAGS_REGEXP = /^\\s*\\/.*\\/[gmisuy]*\\s*$/;\n\n/**\n * Removes quotes for specified content value.\n *\n * For example, content style declaration with `::before` can be set as '-' (e.g. unordered list)\n * which displayed as simple dash `-` with no quotes.\n * But CSSStyleDeclaration.getPropertyValue('content') will return value\n * wrapped into quotes, e.g. '\"-\"', which should be removed\n * because filters maintainers does not use any quotes in real rules.\n *\n * @param str Input string.\n *\n * @returns String with no quotes for content value.\n */\nconst removeContentQuotes = str => {\n  return str.replace(/^([\"'])([\\s\\S]*)\\1$/, '$2');\n};\n/**\n * Adds quotes for specified background url value.\n *\n * If background-image is specified **without** quotes:\n * e.g. 'background: url(data:image/gif;base64,R0lGODlhAQA7)'.\n *\n * CSSStyleDeclaration.getPropertyValue('background-image') may return value **with** quotes:\n * e.g. 'background: url(\"data:image/gif;base64,R0lGODlhAQA7\")'.\n *\n * So we add quotes for compatibility since filters maintainers might use quotes in real rules.\n *\n * @param str Input string.\n *\n * @returns String with unified quotes for background url value.\n */\n\n\nconst addUrlPropertyQuotes = str => {\n  if (!str.includes('url(\"')) {\n    const re = /url\\((.*?)\\)/g;\n    return str.replace(re, 'url(\"$1\")');\n  }\n\n  return str;\n};\n/**\n * Adds quotes to url arg for consistent property value matching.\n */\n\n\nconst addUrlQuotesTo = {\n  regexpArg: str => {\n    // e.g. /^url\\\\([a-z]{4}:[a-z]{5}/\n    // or /^url\\\\(data\\\\:\\\\image\\\\/gif;base64.+/\n    const re = /(\\^)?url(\\\\)?\\\\\\((\\w|\\[\\w)/g;\n    return str.replace(re, '$1url$2\\\\(\\\\\"?$3');\n  },\n  noneRegexpArg: addUrlPropertyQuotes\n};\n/**\n * Escapes regular expression string.\n *\n * @see {@link https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp}\n *\n * @param str Input string.\n *\n * @returns Escaped regular expression string.\n */\n\nconst escapeRegExp = str => {\n  // should be escaped . * + ? ^ $ { } ( ) | [ ] / \\\n  // except of * | ^\n  const specials = ['.', '+', '?', '$', '{', '}', '(', ')', '[', ']', '\\\\', '/'];\n  const specialsRegex = new RegExp(`[${specials.join('\\\\')}]`, 'g');\n  return str.replace(specialsRegex, '\\\\$&');\n};\n/**\n * Converts :matches-css() arg property value match to regexp.\n *\n * @param rawValue Style match value pattern.\n *\n * @returns Arg of :matches-css() converted to regular expression.\n */\n\n\nconst convertStyleMatchValueToRegexp = rawValue => {\n  let value;\n\n  if (rawValue.startsWith(SLASH) && rawValue.endsWith(SLASH)) {\n    // For regex patterns double quotes `\"` and backslashes `\\` should be escaped\n    value = addUrlQuotesTo.regexpArg(rawValue);\n    value = value.slice(1, -1);\n  } else {\n    // For non-regex patterns parentheses `(` `)` and square brackets `[` `]`\n    // should be unescaped, because their escaping in filter rules is required\n    value = addUrlQuotesTo.noneRegexpArg(rawValue);\n    value = value.replace(/\\\\([\\\\()[\\]\"])/g, '$1');\n    value = escapeRegExp(value); // e.g. div:matches-css(background-image: url(data:*))\n\n    value = replaceAll(value, ASTERISK, REGEXP_ANY_SYMBOL);\n  }\n\n  return new RegExp(value, 'i');\n};\n/**\n * Makes some properties values compatible.\n *\n * @param propertyName Name of style property.\n * @param propertyValue Value of style property.\n *\n * @returns Normalized values for some CSS properties.\n */\n\n\nconst normalizePropertyValue = (propertyName, propertyValue) => {\n  let normalized = '';\n\n  switch (propertyName) {\n    case CSS_PROPERTY.BACKGROUND:\n    case CSS_PROPERTY.BACKGROUND_IMAGE:\n      // sometimes url property does not have quotes\n      // so we add them for consistent matching\n      normalized = addUrlPropertyQuotes(propertyValue);\n      break;\n\n    case CSS_PROPERTY.CONTENT:\n      normalized = removeContentQuotes(propertyValue);\n      break;\n\n    case CSS_PROPERTY.OPACITY:\n      // https://bugs.webkit.org/show_bug.cgi?id=93445\n      normalized = isSafariBrowser ? (Math.round(parseFloat(propertyValue) * 100) / 100).toString() : propertyValue;\n      break;\n\n    default:\n      normalized = propertyValue;\n  }\n\n  return normalized;\n};\n/**\n * Returns domElement style property value\n * by css property name and standard pseudo-element.\n *\n * @param domElement DOM element.\n * @param propertyName CSS property name.\n * @param regularPseudoElement Standard pseudo-element  '::before', '::after' etc.\n *\n * @returns String containing the value of a specified CSS property.\n */\n\n\nconst getComputedStylePropertyValue = (domElement, propertyName, regularPseudoElement) => {\n  const style = window.getComputedStyle(domElement, regularPseudoElement);\n  const propertyValue = style.getPropertyValue(propertyName);\n  return normalizePropertyValue(propertyName, propertyValue);\n};\n\n/**\n * Parses arg of absolute pseudo-class into 'name' and 'value' if set.\n *\n * Used for :matches-css() - with COLON as separator,\n * for :matches-attr() and :matches-property() - with EQUAL_SIGN as separator.\n *\n * @param pseudoArg Arg of pseudo-class.\n * @param separator Divider symbol.\n *\n * @returns Parsed 'matches' pseudo-class arg data.\n */\nconst getPseudoArgData = (pseudoArg, separator) => {\n  const index = pseudoArg.indexOf(separator);\n  let name;\n  let value;\n\n  if (index > -1) {\n    name = pseudoArg.substring(0, index).trim();\n    value = pseudoArg.substring(index + 1).trim();\n  } else {\n    name = pseudoArg;\n  }\n\n  return {\n    name,\n    value\n  };\n};\n\n/**\n * Parses :matches-css() pseudo-class arg\n * where regular pseudo-element can be a part of arg\n * e.g. 'div:matches-css(before, color: rgb(255, 255, 255))'    <-- obsolete `:matches-css-before()`.\n *\n * @param pseudoName Pseudo-class name.\n * @param rawArg Pseudo-class arg.\n *\n * @returns Parsed :matches-css() pseudo-class arg data.\n * @throws An error on invalid `rawArg`.\n */\nconst parseStyleMatchArg = (pseudoName, rawArg) => {\n  const {\n    name,\n    value\n  } = getPseudoArgData(rawArg, COMMA);\n  let regularPseudoElement = name;\n  let styleMatchArg = value; // check whether the string part before the separator is valid regular pseudo-element,\n  // otherwise `regularPseudoElement` is null, and `styleMatchArg` is rawArg\n\n  if (!Object.values(REGULAR_PSEUDO_ELEMENTS).includes(name)) {\n    regularPseudoElement = null;\n    styleMatchArg = rawArg;\n  }\n\n  if (!styleMatchArg) {\n    throw new Error(`Required style property argument part is missing in :${pseudoName}() arg: '${rawArg}'`);\n  } // if regularPseudoElement is not `null`\n\n\n  if (regularPseudoElement) {\n    // pseudo-element should have two colon marks for Window.getComputedStyle() due to the syntax:\n    // https://www.w3.org/TR/selectors-4/#pseudo-element-syntax\n    // ':matches-css(before, content: ads)' ->> '::before'\n    regularPseudoElement = `${COLON}${COLON}${regularPseudoElement}`;\n  }\n\n  return {\n    regularPseudoElement,\n    styleMatchArg\n  };\n};\n/**\n * Checks whether the domElement is matched by :matches-css() arg.\n *\n * @param argsData Pseudo-class name, arg, and dom element to check.\n *\n @returns True if DOM element is matched.\n * @throws An error on invalid pseudo-class arg.\n */\n\n\nconst isStyleMatched = argsData => {\n  const {\n    pseudoName,\n    pseudoArg,\n    domElement\n  } = argsData;\n  const {\n    regularPseudoElement,\n    styleMatchArg\n  } = parseStyleMatchArg(pseudoName, pseudoArg);\n  const {\n    name: matchName,\n    value: matchValue\n  } = getPseudoArgData(styleMatchArg, COLON);\n\n  if (!matchName || !matchValue) {\n    throw new Error(`Required property name or value is missing in :${pseudoName}() arg: '${styleMatchArg}'`);\n  }\n\n  let valueRegexp;\n\n  try {\n    valueRegexp = convertStyleMatchValueToRegexp(matchValue);\n  } catch (e) {\n    logger.error(getErrorMessage(e));\n    throw new Error(`Invalid argument of :${pseudoName}() pseudo-class: '${styleMatchArg}'`);\n  }\n\n  const value = getComputedStylePropertyValue(domElement, matchName, regularPseudoElement);\n  return valueRegexp && valueRegexp.test(value);\n};\n/**\n * Validates string arg for :matches-attr() and :matches-property().\n *\n * @param arg Pseudo-class arg.\n *\n * @returns True if 'matches' pseudo-class string arg is valid.\n */\n\nconst validateStrMatcherArg = arg => {\n  if (arg.includes(SLASH)) {\n    return false;\n  }\n\n  if (!/^[\\w-]+$/.test(arg)) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Returns valid arg for :matches-attr() and :matcher-property().\n *\n * @param rawArg Arg pattern.\n * @param [isWildcardAllowed=false] Flag for wildcard (`*`) using as pseudo-class arg.\n *\n * @returns Valid arg for :matches-attr() and :matcher-property().\n * @throws An error on invalid `rawArg`.\n */\n\n\nconst getValidMatcherArg = function (rawArg) {\n  let isWildcardAllowed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  // if rawArg is missing for pseudo-class\n  // e.g. :matches-attr()\n  // error will be thrown before getValidMatcherArg() is called:\n  // name or arg is missing in AbsolutePseudoClass\n  let arg;\n\n  if (rawArg.length > 1 && rawArg.startsWith(DOUBLE_QUOTE) && rawArg.endsWith(DOUBLE_QUOTE)) {\n    rawArg = rawArg.slice(1, -1);\n  }\n\n  if (rawArg === '') {\n    // e.g. :matches-property(\"\")\n    throw new Error('Argument should be specified. Empty arg is invalid.');\n  }\n\n  if (rawArg.startsWith(SLASH) && rawArg.endsWith(SLASH)) {\n    // e.g. :matches-property(\"//\")\n    if (rawArg.length > 2) {\n      arg = toRegExp(rawArg);\n    } else {\n      throw new Error(`Invalid regexp: '${rawArg}'`);\n    }\n  } else if (rawArg.includes(ASTERISK)) {\n    if (rawArg === ASTERISK && !isWildcardAllowed) {\n      // e.g. :matches-attr(*)\n      throw new Error(`Argument should be more specific than ${rawArg}`);\n    }\n\n    arg = replaceAll(rawArg, ASTERISK, REGEXP_ANY_SYMBOL);\n    arg = new RegExp(arg);\n  } else {\n    if (!validateStrMatcherArg(rawArg)) {\n      throw new Error(`Invalid argument: '${rawArg}'`);\n    }\n\n    arg = rawArg;\n  }\n\n  return arg;\n};\n\n/**\n * Parses pseudo-class argument and returns parsed data.\n *\n * @param pseudoName Extended pseudo-class name.\n * @param pseudoArg Extended pseudo-class argument.\n *\n * @returns Parsed pseudo-class argument data.\n * @throws An error if attribute name is missing in pseudo-class arg.\n */\nconst getRawMatchingData = (pseudoName, pseudoArg) => {\n  const {\n    name: rawName,\n    value: rawValue\n  } = getPseudoArgData(pseudoArg, EQUAL_SIGN);\n\n  if (!rawName) {\n    throw new Error(`Required attribute name is missing in :${pseudoName} arg: ${pseudoArg}`);\n  }\n\n  return {\n    rawName,\n    rawValue\n  };\n};\n/**\n * Checks whether the domElement is matched by :matches-attr() arg.\n *\n * @param argsData Pseudo-class name, arg, and dom element to check.\n *\n @returns True if DOM element is matched.\n * @throws An error on invalid arg of pseudo-class.\n */\n\nconst isAttributeMatched = argsData => {\n  const {\n    pseudoName,\n    pseudoArg,\n    domElement\n  } = argsData;\n  const elementAttributes = domElement.attributes; // no match if dom element has no attributes\n\n  if (elementAttributes.length === 0) {\n    return false;\n  }\n\n  const {\n    rawName: rawAttrName,\n    rawValue: rawAttrValue\n  } = getRawMatchingData(pseudoName, pseudoArg);\n  let attrNameMatch;\n\n  try {\n    attrNameMatch = getValidMatcherArg(rawAttrName);\n  } catch (e) {\n    const errorMessage = getErrorMessage(e);\n    logger.error(errorMessage);\n    throw new SyntaxError(errorMessage);\n  }\n\n  let isMatched = false;\n  let i = 0;\n\n  while (i < elementAttributes.length && !isMatched) {\n    const attr = elementAttributes[i];\n\n    if (!attr) {\n      break;\n    }\n\n    const isNameMatched = attrNameMatch instanceof RegExp ? attrNameMatch.test(attr.name) : attrNameMatch === attr.name;\n\n    if (!rawAttrValue) {\n      // for rules with no attribute value specified\n      // e.g. :matches-attr(\"/regex/\") or :matches-attr(\"attr-name\")\n      isMatched = isNameMatched;\n    } else {\n      let attrValueMatch;\n\n      try {\n        attrValueMatch = getValidMatcherArg(rawAttrValue);\n      } catch (e) {\n        const errorMessage = getErrorMessage(e);\n        logger.error(errorMessage);\n        throw new SyntaxError(errorMessage);\n      }\n\n      const isValueMatched = attrValueMatch instanceof RegExp ? attrValueMatch.test(attr.value) : attrValueMatch === attr.value;\n      isMatched = isNameMatched && isValueMatched;\n    }\n\n    i += 1;\n  }\n\n  return isMatched;\n};\n/**\n * Parses raw :matches-property() arg which may be chain of properties.\n *\n * @param input Argument of :matches-property().\n *\n * @returns Arg of :matches-property() as array of strings or regular expressions.\n * @throws An error on invalid chain.\n */\n\nconst parseRawPropChain = input => {\n  if (input.length > 1 && input.startsWith(DOUBLE_QUOTE) && input.endsWith(DOUBLE_QUOTE)) {\n    input = input.slice(1, -1);\n  }\n\n  const chainChunks = input.split(DOT);\n  const chainPatterns = [];\n  let patternBuffer = '';\n  let isRegexpPattern = false;\n  let i = 0;\n\n  while (i < chainChunks.length) {\n    const chunk = getItemByIndex(chainChunks, i, `Invalid pseudo-class arg: '${input}'`);\n\n    if (chunk.startsWith(SLASH) && chunk.endsWith(SLASH) && chunk.length > 2) {\n      // regexp pattern with no dot in it, e.g. /propName/\n      chainPatterns.push(chunk);\n    } else if (chunk.startsWith(SLASH)) {\n      // if chunk is a start of regexp pattern\n      isRegexpPattern = true;\n      patternBuffer += chunk;\n    } else if (chunk.endsWith(SLASH)) {\n      isRegexpPattern = false; // restore dot removed while splitting\n      // e.g. testProp./.{1,5}/\n\n      patternBuffer += `.${chunk}`;\n      chainPatterns.push(patternBuffer);\n      patternBuffer = '';\n    } else {\n      // if there are few dots in regexp pattern\n      // so chunk might be in the middle of it\n      if (isRegexpPattern) {\n        patternBuffer += chunk;\n      } else {\n        // otherwise it is string pattern\n        chainPatterns.push(chunk);\n      }\n    }\n\n    i += 1;\n  }\n\n  if (patternBuffer.length > 0) {\n    throw new Error(`Invalid regexp property pattern '${input}'`);\n  }\n\n  const chainMatchPatterns = chainPatterns.map(pattern => {\n    if (pattern.length === 0) {\n      // e.g. '.prop.id' or 'nested..test'\n      throw new Error(`Empty pattern '${pattern}' is invalid in chain '${input}'`);\n    }\n\n    let validPattern;\n\n    try {\n      validPattern = getValidMatcherArg(pattern, true);\n    } catch (e) {\n      logger.error(getErrorMessage(e));\n      throw new Error(`Invalid property pattern '${pattern}' in property chain '${input}'`);\n    }\n\n    return validPattern;\n  });\n  return chainMatchPatterns;\n};\n\n/**\n * Checks if the property exists in the base object (recursively).\n *\n * @param base Element to check.\n * @param chain Array of objects - parsed string property chain.\n * @param [output=[]] Result acc.\n *\n * @returns Array of parsed data  representation of `base`-related `chain`.\n */\nconst filterRootsByRegexpChain = function (base, chain) {\n  let output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const tempProp = getFirst(chain);\n\n  if (chain.length === 1) {\n    let key;\n\n    for (key in base) {\n      if (tempProp instanceof RegExp) {\n        if (tempProp.test(key)) {\n          output.push({\n            base,\n            prop: key,\n            value: base[key]\n          });\n        }\n      } else if (tempProp === key) {\n        output.push({\n          base,\n          prop: tempProp,\n          value: base[key]\n        });\n      }\n    }\n\n    return output;\n  } // if there is a regexp prop in input chain\n  // e.g. 'unit./^ad.+/.src' for 'unit.ad-1gf2.src unit.ad-fgd34.src'),\n  // every base keys should be tested by regexp and it can be more that one results\n\n\n  if (tempProp instanceof RegExp) {\n    const nextProp = chain.slice(1);\n    const baseKeys = [];\n\n    for (const key in base) {\n      if (tempProp.test(key)) {\n        baseKeys.push(key);\n      }\n    }\n\n    baseKeys.forEach(key => {\n      var _Object$getOwnPropert;\n\n      const item = (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(base, key)) === null || _Object$getOwnPropert === void 0 ? void 0 : _Object$getOwnPropert.value;\n      filterRootsByRegexpChain(item, nextProp, output);\n    });\n  }\n\n  if (base && typeof tempProp === 'string') {\n    var _Object$getOwnPropert2;\n\n    const nextBase = (_Object$getOwnPropert2 = Object.getOwnPropertyDescriptor(base, tempProp)) === null || _Object$getOwnPropert2 === void 0 ? void 0 : _Object$getOwnPropert2.value;\n    chain = chain.slice(1);\n\n    if (nextBase !== undefined) {\n      filterRootsByRegexpChain(nextBase, chain, output);\n    }\n  }\n\n  return output;\n};\n/**\n * Checks whether the domElement is matched by :matches-property() arg.\n *\n * @param argsData Pseudo-class name, arg, and dom element to check.\n *\n @returns True if DOM element is matched.\n * @throws An error on invalid prop in chain.\n */\n\n\nconst isPropertyMatched = argsData => {\n  const {\n    pseudoName,\n    pseudoArg,\n    domElement\n  } = argsData;\n  const {\n    rawName: rawPropertyName,\n    rawValue: rawPropertyValue\n  } = getRawMatchingData(pseudoName, pseudoArg); // chained property name cannot include '/' or '.'\n  // so regex prop names with such escaped characters are invalid\n\n  if (rawPropertyName.includes('\\\\/') || rawPropertyName.includes('\\\\.')) {\n    throw new Error(`Invalid :${pseudoName} name pattern: ${rawPropertyName}`);\n  }\n\n  let propChainMatches;\n\n  try {\n    propChainMatches = parseRawPropChain(rawPropertyName);\n  } catch (e) {\n    const errorMessage = getErrorMessage(e);\n    logger.error(errorMessage);\n    throw new SyntaxError(errorMessage);\n  }\n\n  const ownerObjArr = filterRootsByRegexpChain(domElement, propChainMatches);\n\n  if (ownerObjArr.length === 0) {\n    return false;\n  }\n\n  let isMatched = true;\n\n  if (rawPropertyValue) {\n    let propValueMatch;\n\n    try {\n      propValueMatch = getValidMatcherArg(rawPropertyValue);\n    } catch (e) {\n      const errorMessage = getErrorMessage(e);\n      logger.error(errorMessage);\n      throw new SyntaxError(errorMessage);\n    }\n\n    if (propValueMatch) {\n      for (let i = 0; i < ownerObjArr.length; i += 1) {\n        var _ownerObjArr$i;\n\n        const realValue = (_ownerObjArr$i = ownerObjArr[i]) === null || _ownerObjArr$i === void 0 ? void 0 : _ownerObjArr$i.value;\n\n        if (propValueMatch instanceof RegExp) {\n          isMatched = propValueMatch.test(convertTypeIntoString(realValue));\n        } else {\n          // handle 'null' and 'undefined' property values set as string\n          if (realValue === 'null' || realValue === 'undefined') {\n            isMatched = propValueMatch === realValue;\n            break;\n          }\n\n          isMatched = convertTypeFromString(propValueMatch) === realValue;\n        }\n\n        if (isMatched) {\n          break;\n        }\n      }\n    }\n  }\n\n  return isMatched;\n};\n/**\n * Checks whether the textContent is matched by :contains arg.\n *\n * @param argsData Pseudo-class name, arg, and dom element to check.\n *\n @returns True if DOM element is matched.\n * @throws An error on invalid arg of pseudo-class.\n */\n\nconst isTextMatched = argsData => {\n  const {\n    pseudoName,\n    pseudoArg,\n    domElement\n  } = argsData;\n  const textContent = getNodeTextContent(domElement);\n  let isTextContentMatched;\n  let pseudoArgToMatch = pseudoArg;\n\n  if (pseudoArgToMatch.startsWith(SLASH) && REGEXP_WITH_FLAGS_REGEXP.test(pseudoArgToMatch)) {\n    // regexp arg\n    const flagsIndex = pseudoArgToMatch.lastIndexOf('/');\n    const flagsStr = pseudoArgToMatch.substring(flagsIndex + 1);\n    pseudoArgToMatch = pseudoArgToMatch.substring(0, flagsIndex + 1).slice(1, -1).replace(/\\\\([\\\\\"])/g, '$1');\n    let regex;\n\n    try {\n      regex = new RegExp(pseudoArgToMatch, flagsStr);\n    } catch (e) {\n      throw new Error(`Invalid argument of :${pseudoName}() pseudo-class: ${pseudoArg}`);\n    }\n\n    isTextContentMatched = regex.test(textContent);\n  } else {\n    // none-regexp arg\n    pseudoArgToMatch = pseudoArgToMatch.replace(/\\\\([\\\\()[\\]\"])/g, '$1');\n    isTextContentMatched = textContent.includes(pseudoArgToMatch);\n  }\n\n  return isTextContentMatched;\n};\n\n/**\n * Validates number arg for :nth-ancestor() and :upward() pseudo-classes.\n *\n * @param rawArg Raw arg of pseudo-class.\n * @param pseudoName Pseudo-class name.\n *\n * @returns Valid number arg for :nth-ancestor() and :upward().\n * @throws An error on invalid `rawArg`.\n */\nconst getValidNumberAncestorArg = (rawArg, pseudoName) => {\n  const deep = Number(rawArg);\n\n  if (Number.isNaN(deep) || deep < 1 || deep >= 256) {\n    throw new Error(`Invalid argument of :${pseudoName} pseudo-class: '${rawArg}'`);\n  }\n\n  return deep;\n};\n/**\n * Returns nth ancestor by 'deep' number arg OR undefined if ancestor range limit exceeded.\n *\n * @param domElement DOM element to find ancestor for.\n * @param nth Depth up to needed ancestor.\n * @param pseudoName Pseudo-class name.\n *\n * @returns Ancestor element found in DOM, or null if not found.\n * @throws An error on invalid `nth` arg.\n */\n\nconst getNthAncestor = (domElement, nth, pseudoName) => {\n  let ancestor = null;\n  let i = 0;\n\n  while (i < nth) {\n    ancestor = domElement.parentElement;\n\n    if (!ancestor) {\n      throw new Error(`Out of DOM: Argument of :${pseudoName}() pseudo-class is too big  '${nth}'.`);\n    }\n\n    domElement = ancestor;\n    i += 1;\n  }\n\n  return ancestor;\n};\n/**\n * Validates standard CSS selector.\n *\n * @param selector Standard selector.\n *\n * @returns True if standard CSS selector is valid.\n */\n\nconst validateStandardSelector = selector => {\n  let isValid;\n\n  try {\n    document.querySelectorAll(selector);\n    isValid = true;\n  } catch (e) {\n    isValid = false;\n  }\n\n  return isValid;\n};\n\n/**\n * Wrapper to run matcher `callback` with `args`\n * and throw error with `errorMessage` if `callback` run fails.\n *\n * @param callback Matcher callback.\n * @param argsData Args needed for matcher callback.\n * @param errorMessage Error message.\n *\n * @returns True if `callback` returns true.\n * @throws An error if `callback` fails.\n */\nconst matcherWrapper = (callback, argsData, errorMessage) => {\n  let isMatched;\n\n  try {\n    isMatched = callback(argsData);\n  } catch (e) {\n    logger.error(getErrorMessage(e));\n    throw new Error(errorMessage);\n  }\n\n  return isMatched;\n};\n/**\n * Generates common error message to throw while matching element `propDesc`.\n *\n * @param propDesc Text to describe what element 'prop' pseudo-class is trying to match.\n * @param pseudoName Pseudo-class name.\n * @param pseudoArg Pseudo-class arg.\n *\n * @returns Generated error message string.\n */\n\n\nconst getAbsolutePseudoError = (propDesc, pseudoName, pseudoArg) => {\n  // eslint-disable-next-line max-len\n  return `${MATCHING_ELEMENT_ERROR_PREFIX} ${propDesc}, may be invalid :${pseudoName}() pseudo-class arg: '${pseudoArg}'`;\n};\n/**\n * Checks whether the domElement is matched by absolute extended pseudo-class argument.\n *\n * @param domElement Page element.\n * @param pseudoName Pseudo-class name.\n * @param pseudoArg Pseudo-class arg.\n *\n * @returns True if `domElement` is matched by absolute pseudo-class.\n * @throws An error on unknown absolute pseudo-class.\n */\n\n\nconst isMatchedByAbsolutePseudo = (domElement, pseudoName, pseudoArg) => {\n  let argsData;\n  let errorMessage;\n  let callback;\n\n  switch (pseudoName) {\n    case CONTAINS_PSEUDO:\n    case HAS_TEXT_PSEUDO:\n    case ABP_CONTAINS_PSEUDO:\n      callback = isTextMatched;\n      argsData = {\n        pseudoName,\n        pseudoArg,\n        domElement\n      };\n      errorMessage = getAbsolutePseudoError('text content', pseudoName, pseudoArg);\n      break;\n\n    case MATCHES_CSS_PSEUDO:\n    case MATCHES_CSS_AFTER_PSEUDO:\n    case MATCHES_CSS_BEFORE_PSEUDO:\n      callback = isStyleMatched;\n      argsData = {\n        pseudoName,\n        pseudoArg,\n        domElement\n      };\n      errorMessage = getAbsolutePseudoError('style', pseudoName, pseudoArg);\n      break;\n\n    case MATCHES_ATTR_PSEUDO_CLASS_MARKER:\n      callback = isAttributeMatched;\n      argsData = {\n        domElement,\n        pseudoName,\n        pseudoArg\n      };\n      errorMessage = getAbsolutePseudoError('attributes', pseudoName, pseudoArg);\n      break;\n\n    case MATCHES_PROPERTY_PSEUDO_CLASS_MARKER:\n      callback = isPropertyMatched;\n      argsData = {\n        domElement,\n        pseudoName,\n        pseudoArg\n      };\n      errorMessage = getAbsolutePseudoError('properties', pseudoName, pseudoArg);\n      break;\n\n    default:\n      throw new Error(`Unknown absolute pseudo-class :${pseudoName}()`);\n  }\n\n  return matcherWrapper(callback, argsData, errorMessage);\n};\nconst findByAbsolutePseudoPseudo = {\n  /**\n   * Returns list of nth ancestors relative to every dom node from domElements list.\n   *\n   * @param domElements DOM elements.\n   * @param rawPseudoArg Number arg of :nth-ancestor() or :upward() pseudo-class.\n   * @param pseudoName Pseudo-class name.\n   *\n   * @returns Array of ancestor DOM elements.\n   */\n  nthAncestor: (domElements, rawPseudoArg, pseudoName) => {\n    const deep = getValidNumberAncestorArg(rawPseudoArg, pseudoName);\n    const ancestors = domElements.map(domElement => {\n      let ancestor = null;\n\n      try {\n        ancestor = getNthAncestor(domElement, deep, pseudoName);\n      } catch (e) {\n        logger.error(getErrorMessage(e));\n      }\n\n      return ancestor;\n    }).filter(isHtmlElement);\n    return ancestors;\n  },\n\n  /**\n   * Returns list of elements by xpath expression, evaluated on every dom node from domElements list.\n   *\n   * @param domElements DOM elements.\n   * @param rawPseudoArg Arg of :xpath() pseudo-class.\n   *\n   * @returns Array of DOM elements matched by xpath expression.\n   */\n  xpath: (domElements, rawPseudoArg) => {\n    const foundElements = domElements.map(domElement => {\n      const result = [];\n      let xpathResult;\n\n      try {\n        xpathResult = document.evaluate(rawPseudoArg, domElement, null, window.XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null);\n      } catch (e) {\n        logger.error(getErrorMessage(e));\n        throw new Error(`Invalid argument of :xpath() pseudo-class: '${rawPseudoArg}'`);\n      }\n\n      let node = xpathResult.iterateNext();\n\n      while (node) {\n        if (isHtmlElement(node)) {\n          result.push(node);\n        }\n\n        node = xpathResult.iterateNext();\n      }\n\n      return result;\n    });\n    return flatten(foundElements);\n  },\n\n  /**\n   * Returns list of closest ancestors relative to every dom node from domElements list.\n   *\n   * @param domElements DOM elements.\n   * @param rawPseudoArg Standard selector arg of :upward() pseudo-class.\n   *\n   * @returns Array of closest ancestor DOM elements.\n   * @throws An error if `rawPseudoArg` is not a valid standard selector.\n   */\n  upward: (domElements, rawPseudoArg) => {\n    if (!validateStandardSelector(rawPseudoArg)) {\n      throw new Error(`Invalid argument of :upward pseudo-class: '${rawPseudoArg}'`);\n    }\n\n    const closestAncestors = domElements.map(domElement => {\n      // closest to parent element should be found\n      // otherwise `.base:upward(.base)` will return itself too, not only ancestor\n      const parent = domElement.parentElement;\n\n      if (!parent) {\n        return null;\n      }\n\n      return parent.closest(rawPseudoArg);\n    }).filter(isHtmlElement);\n    return closestAncestors;\n  }\n};\n\n/**\n * Calculated selector text which is needed to :has(), :is() and :not() pseudo-classes.\n * Contains calculated part (depends on the processed element)\n * and value of RegularSelector which is next to selector by.\n *\n * Native Document.querySelectorAll() does not select exact descendant elements\n * but match all page elements satisfying the selector,\n * so extra specification is needed for proper descendants selection\n * e.g. 'div:has(> img)'.\n *\n * Its calculation depends on extended selector.\n */\n\n/**\n * Combined `:scope` pseudo-class and **child** combinator  `:scope>`.\n */\nconst scopeDirectChildren = `${SCOPE_CSS_PSEUDO_CLASS}${CHILD_COMBINATOR}`;\n/**\n * Combined `:scope` pseudo-class and **descendant** combinator  `:scope `.\n */\n\nconst scopeAnyChildren = `${SCOPE_CSS_PSEUDO_CLASS}${DESCENDANT_COMBINATOR}`;\n/**\n * Type for relative pseudo-class helpers args.\n */\n\n/**\n * Returns the first of RegularSelector child node for `selectorNode`.\n *\n * @param selectorNode Ast Selector node.\n * @param pseudoName Name of relative pseudo-class.\n *\n * @returns Ast RegularSelector node.\n */\nconst getFirstInnerRegularChild = (selectorNode, pseudoName) => {\n  return getFirstRegularChild(selectorNode.children, `RegularSelector is missing for :${pseudoName}() pseudo-class`);\n}; // TODO: fix for <forgiving-relative-selector-list>\n// https://github.com/AdguardTeam/ExtendedCss/issues/154\n\n/**\n * Checks whether the element has all relative elements specified by pseudo-class arg.\n * Used for :has() pseudo-class.\n *\n * @param argsData Relative pseudo-class helpers args data.\n *\n * @returns True if **all selectors** from argsData.relativeSelectorList is **matched** for argsData.element.\n */\n\n\nconst hasRelativesBySelectorList = argsData => {\n  const {\n    element,\n    relativeSelectorList,\n    pseudoName\n  } = argsData;\n  return relativeSelectorList.children // Array.every() is used here as each Selector node from SelectorList should exist on page\n  .every(selectorNode => {\n    // selectorList.children always starts with regular selector as any selector generally\n    const relativeRegularSelector = getFirstInnerRegularChild(selectorNode, pseudoName);\n    let specifiedSelector = '';\n    let rootElement = null;\n    const regularSelector = getNodeValue(relativeRegularSelector);\n\n    if (regularSelector.startsWith(NEXT_SIBLING_COMBINATOR) || regularSelector.startsWith(SUBSEQUENT_SIBLING_COMBINATOR)) {\n      /**\n       * For matching the element by \"element:has(+ next-sibling)\" and \"element:has(~ sibling)\"\n       * we check whether the element's parentElement has specific direct child combination,\n       * e.g. 'h1:has(+ .share)' -> `h1Node.parentElement.querySelectorAll(':scope > h1 + .share')`.\n       *\n       * @see {@link https://www.w3.org/TR/selectors-4/#relational}\n       */\n      rootElement = element.parentElement;\n      const elementSelectorText = getElementSelectorDesc(element);\n      specifiedSelector = `${scopeDirectChildren}${elementSelectorText}${regularSelector}`;\n    } else if (regularSelector === ASTERISK) {\n      /**\n       * :scope specification is needed for proper descendants selection\n       * as native element.querySelectorAll() does not select exact element descendants\n       * e.g. 'a:has(> img)' -> `aNode.querySelectorAll(':scope > img')`.\n       *\n       * For 'any selector' as arg of relative simplicity should be set for all inner elements\n       * e.g. 'div:has(*)' -> `divNode.querySelectorAll(':scope *')`\n       * which means empty div with no child element.\n       */\n      rootElement = element;\n      specifiedSelector = `${scopeAnyChildren}${ASTERISK}`;\n    } else {\n      /**\n       * As it described above, inner elements should be found using `:scope` pseudo-class\n       * e.g. 'a:has(> img)' -> `aNode.querySelectorAll(':scope > img')`\n       * OR '.block(div > span)' -> `blockClassNode.querySelectorAll(':scope div > span')`.\n       */\n      specifiedSelector = `${scopeAnyChildren}${regularSelector}`;\n      rootElement = element;\n    }\n\n    if (!rootElement) {\n      throw new Error(`Selection by :${pseudoName}() pseudo-class is not possible`);\n    }\n\n    let relativeElements;\n\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      relativeElements = getElementsForSelectorNode(selectorNode, rootElement, specifiedSelector);\n    } catch (e) {\n      logger.error(getErrorMessage(e)); // fail for invalid selector\n\n      throw new Error(`Invalid selector for :${pseudoName}() pseudo-class: '${regularSelector}'`);\n    }\n\n    return relativeElements.length > 0;\n  });\n};\n/**\n * Checks whether the element is an any element specified by pseudo-class arg.\n * Used for :is() pseudo-class.\n *\n * @param argsData Relative pseudo-class helpers args data.\n *\n * @returns True if **any selector** from argsData.relativeSelectorList is **matched** for argsData.element.\n */\n\n\nconst isAnyElementBySelectorList = argsData => {\n  const {\n    element,\n    relativeSelectorList,\n    pseudoName\n  } = argsData;\n  return relativeSelectorList.children // Array.some() is used here as any selector from selector list should exist on page\n  .some(selectorNode => {\n    // selectorList.children always starts with regular selector\n    const relativeRegularSelector = getFirstInnerRegularChild(selectorNode, pseudoName);\n    /**\n     * For checking the element by 'div:is(.banner)'\n     * we check whether the element's parentElement has any specific direct child.\n     */\n\n    const rootElement = getParent(element, `Selection by :${pseudoName}() pseudo-class is not possible`);\n    /**\n     * So we calculate the element \"description\" by it's tagname and attributes for targeting\n     * and use it to specify the selection\n     * e.g. `div:is(.banner)` --> `divNode.parentElement.querySelectorAll(':scope > .banner')`.\n     */\n\n    const specifiedSelector = `${scopeDirectChildren}${getNodeValue(relativeRegularSelector)}`;\n    let anyElements;\n\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      anyElements = getElementsForSelectorNode(selectorNode, rootElement, specifiedSelector);\n    } catch (e) {\n      // do not fail on invalid selectors for :is()\n      return false;\n    } // TODO: figure out how to handle complex selectors with extended pseudo-classes\n    // (check readme - extended-css-is-limitations)\n    // because `element` and `anyElements` may be from different DOM levels\n\n\n    return anyElements.includes(element);\n  });\n};\n/**\n * Checks whether the element is not an element specified by pseudo-class arg.\n * Used for :not() pseudo-class.\n *\n * @param argsData Relative pseudo-class helpers args data.\n *\n * @returns True if **any selector** from argsData.relativeSelectorList is **not matched** for argsData.element.\n */\n\n\nconst notElementBySelectorList = argsData => {\n  const {\n    element,\n    relativeSelectorList,\n    pseudoName\n  } = argsData;\n  return relativeSelectorList.children // Array.every() is used here as element should not be selected by any selector from selector list\n  .every(selectorNode => {\n    // selectorList.children always starts with regular selector\n    const relativeRegularSelector = getFirstInnerRegularChild(selectorNode, pseudoName);\n    /**\n     * For checking the element by 'div:not([data=\"content\"])\n     * we check whether the element's parentElement has any specific direct child.\n     */\n\n    const rootElement = getParent(element, `Selection by :${pseudoName}() pseudo-class is not possible`);\n    /**\n     * So we calculate the element \"description\" by it's tagname and attributes for targeting\n     * and use it to specify the selection\n     * e.g. `div:not(.banner)` --> `divNode.parentElement.querySelectorAll(':scope > .banner')`.\n     */\n\n    const specifiedSelector = `${scopeDirectChildren}${getNodeValue(relativeRegularSelector)}`;\n    let anyElements;\n\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      anyElements = getElementsForSelectorNode(selectorNode, rootElement, specifiedSelector);\n    } catch (e) {\n      // fail on invalid selectors for :not()\n      logger.error(getErrorMessage(e)); // eslint-disable-next-line max-len\n\n      throw new Error(`Invalid selector for :${pseudoName}() pseudo-class: '${getNodeValue(relativeRegularSelector)}'`);\n    } // TODO: figure out how to handle up-looking pseudo-classes inside :not()\n    // (check readme - extended-css-not-limitations)\n    // because `element` and `anyElements` may be from different DOM levels\n\n\n    return !anyElements.includes(element);\n  });\n};\n/**\n * Selects dom elements by value of RegularSelector.\n *\n * @param regularSelectorNode RegularSelector node.\n * @param root Root DOM element.\n * @param specifiedSelector @see {@link SpecifiedSelector}.\n *\n * @returns Array of DOM elements.\n * @throws An error if RegularSelector node value is an invalid selector.\n */\n\n\nconst getByRegularSelector = (regularSelectorNode, root, specifiedSelector) => {\n  const selectorText = specifiedSelector ? specifiedSelector : getNodeValue(regularSelectorNode);\n  let selectedElements = [];\n\n  try {\n    selectedElements = Array.from(root.querySelectorAll(selectorText));\n  } catch (e) {\n    throw new Error(`Error: unable to select by '${selectorText}'  ${getErrorMessage(e)}`);\n  }\n\n  return selectedElements;\n};\n/**\n * Returns list of dom elements filtered or selected by ExtendedSelector node.\n *\n * @param domElements Array of DOM elements.\n * @param extendedSelectorNode ExtendedSelector node.\n *\n * @returns Array of DOM elements.\n * @throws An error on unknown pseudo-class,\n * absent or invalid arg of extended pseudo-class, etc.\n */\n\nconst getByExtendedSelector = (domElements, extendedSelectorNode) => {\n  let foundElements = [];\n  const extendedPseudoClassNode = getPseudoClassNode(extendedSelectorNode);\n  const pseudoName = getNodeName(extendedPseudoClassNode);\n\n  if (isAbsolutePseudoClass(pseudoName)) {\n    // absolute extended pseudo-classes should have an argument\n    const absolutePseudoArg = getNodeValue(extendedPseudoClassNode, `Missing arg for :${pseudoName}() pseudo-class`);\n\n    if (pseudoName === NTH_ANCESTOR_PSEUDO_CLASS_MARKER) {\n      // :nth-ancestor()\n      foundElements = findByAbsolutePseudoPseudo.nthAncestor(domElements, absolutePseudoArg, pseudoName);\n    } else if (pseudoName === XPATH_PSEUDO_CLASS_MARKER) {\n      // :xpath()\n      try {\n        document.createExpression(absolutePseudoArg, null);\n      } catch (e) {\n        throw new Error(`Invalid argument of :${pseudoName}() pseudo-class: '${absolutePseudoArg}'`);\n      }\n\n      foundElements = findByAbsolutePseudoPseudo.xpath(domElements, absolutePseudoArg);\n    } else if (pseudoName === UPWARD_PSEUDO_CLASS_MARKER) {\n      // :upward()\n      if (Number.isNaN(Number(absolutePseudoArg))) {\n        // so arg is selector, not a number\n        foundElements = findByAbsolutePseudoPseudo.upward(domElements, absolutePseudoArg);\n      } else {\n        foundElements = findByAbsolutePseudoPseudo.nthAncestor(domElements, absolutePseudoArg, pseudoName);\n      }\n    } else {\n      // all other absolute extended pseudo-classes\n      // e.g. contains, matches-attr, etc.\n      foundElements = domElements.filter(element => {\n        return isMatchedByAbsolutePseudo(element, pseudoName, absolutePseudoArg);\n      });\n    }\n  } else if (isRelativePseudoClass(pseudoName)) {\n    const relativeSelectorList = getRelativeSelectorListNode(extendedPseudoClassNode);\n    let relativePredicate;\n\n    switch (pseudoName) {\n      case HAS_PSEUDO_CLASS_MARKER:\n      case ABP_HAS_PSEUDO_CLASS_MARKER:\n        relativePredicate = element => hasRelativesBySelectorList({\n          element,\n          relativeSelectorList,\n          pseudoName\n        });\n\n        break;\n\n      case IS_PSEUDO_CLASS_MARKER:\n        relativePredicate = element => isAnyElementBySelectorList({\n          element,\n          relativeSelectorList,\n          pseudoName\n        });\n\n        break;\n\n      case NOT_PSEUDO_CLASS_MARKER:\n        relativePredicate = element => notElementBySelectorList({\n          element,\n          relativeSelectorList,\n          pseudoName\n        });\n\n        break;\n\n      default:\n        throw new Error(`Unknown relative pseudo-class: '${pseudoName}'`);\n    }\n\n    foundElements = domElements.filter(relativePredicate);\n  } else {\n    // extra check is parser missed something\n    throw new Error(`Unknown extended pseudo-class: '${pseudoName}'`);\n  }\n\n  return foundElements;\n};\n/**\n * Returns list of dom elements which is selected by RegularSelector value.\n *\n * @param domElements Array of DOM elements.\n * @param regularSelectorNode RegularSelector node.\n *\n * @returns Array of DOM elements.\n * @throws An error if RegularSelector has not value.\n */\n\nconst getByFollowingRegularSelector = (domElements, regularSelectorNode) => {\n  // array of arrays because of Array.map() later\n  let foundElements = [];\n  const value = getNodeValue(regularSelectorNode);\n\n  if (value.startsWith(CHILD_COMBINATOR)) {\n    // e.g. div:has(> img) > .banner\n    foundElements = domElements.map(root => {\n      const specifiedSelector = `${SCOPE_CSS_PSEUDO_CLASS}${value}`;\n      return getByRegularSelector(regularSelectorNode, root, specifiedSelector);\n    });\n  } else if (value.startsWith(NEXT_SIBLING_COMBINATOR) || value.startsWith(SUBSEQUENT_SIBLING_COMBINATOR)) {\n    // e.g. div:has(> img) + .banner\n    // or   div:has(> img) ~ .banner\n    foundElements = domElements.map(element => {\n      const rootElement = element.parentElement;\n\n      if (!rootElement) {\n        // do not throw error if there in no parent for element\n        // e.g. '*:contains(text)' selects `html` which has no parentElement\n        return [];\n      }\n\n      const elementSelectorText = getElementSelectorDesc(element);\n      const specifiedSelector = `${scopeDirectChildren}${elementSelectorText}${value}`;\n      const selected = getByRegularSelector(regularSelectorNode, rootElement, specifiedSelector);\n      return selected;\n    });\n  } else {\n    // space-separated regular selector after extended one\n    // e.g. div:has(> img) .banner\n    foundElements = domElements.map(root => {\n      const specifiedSelector = `${scopeAnyChildren}${getNodeValue(regularSelectorNode)}`;\n      return getByRegularSelector(regularSelectorNode, root, specifiedSelector);\n    });\n  } // foundElements should be flattened\n  // as getByRegularSelector() returns elements array, and Array.map() collects them to array\n\n\n  return flatten(foundElements);\n};\n/**\n * Returns elements nodes for Selector node.\n * As far as any selector always starts with regular part,\n * it selects by RegularSelector first and checks found elements later.\n *\n * Relative pseudo-classes has it's own subtree so getElementsForSelectorNode is called recursively.\n *\n * 'specifiedSelector' is needed for :has(), :is(), and :not() pseudo-classes\n * as native querySelectorAll() does not select exact element descendants even if it is called on 'div'\n * e.g. ':scope' specification is needed for proper descendants selection for 'div:has(> img)'.\n * So we check `divNode.querySelectorAll(':scope > img').length > 0`.\n *\n * @param selectorNode Selector node.\n * @param root Root DOM element.\n * @param specifiedSelector Needed element specification.\n *\n * @returns Array of DOM elements.\n * @throws An error if there is no selectorNodeChild.\n */\n\nconst getElementsForSelectorNode = (selectorNode, root, specifiedSelector) => {\n  let selectedElements = [];\n  let i = 0;\n\n  while (i < selectorNode.children.length) {\n    const selectorNodeChild = getItemByIndex(selectorNode.children, i, 'selectorNodeChild should be specified');\n\n    if (i === 0) {\n      // any selector always starts with regular selector\n      selectedElements = getByRegularSelector(selectorNodeChild, root, specifiedSelector);\n    } else if (isExtendedSelectorNode(selectorNodeChild)) {\n      // filter previously selected elements by next selector nodes\n      selectedElements = getByExtendedSelector(selectedElements, selectorNodeChild);\n    } else if (isRegularSelectorNode(selectorNodeChild)) {\n      selectedElements = getByFollowingRegularSelector(selectedElements, selectorNodeChild);\n    }\n\n    i += 1;\n  }\n\n  return selectedElements;\n};\n\n/**\n * Selects elements by ast.\n *\n * @param ast Ast of parsed selector.\n * @param doc Document.\n *\n * @returns Array of DOM elements.\n */\n\nconst selectElementsByAst = function (ast) {\n  let doc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n  const selectedElements = []; // ast root is SelectorList node;\n  // it has Selector nodes as children which should be processed separately\n\n  ast.children.forEach(selectorNode => {\n    selectedElements.push(...getElementsForSelectorNode(selectorNode, doc));\n  }); // selectedElements should be flattened as it is array of arrays with elements\n\n  const uniqueElements = [...new Set(flatten(selectedElements))];\n  return uniqueElements;\n};\n/**\n * Class of ExtCssDocument is needed for caching.\n * For making cache related to each new instance of class, not global.\n */\n\nclass ExtCssDocument {\n  /**\n   * Cache with selectors and their AST parsing results.\n   */\n\n  /**\n   * Creates new ExtCssDocument and inits new `astCache`.\n   */\n  constructor() {\n    this.astCache = new Map();\n  }\n  /**\n   * Saves selector and it's ast to cache.\n   *\n   * @param selector Standard or extended selector.\n   * @param ast Selector ast.\n   */\n\n\n  saveAstToCache(selector, ast) {\n    this.astCache.set(selector, ast);\n  }\n  /**\n   * Returns ast from cache for given selector.\n   *\n   * @param selector Standard or extended selector.\n   *\n   * @returns Previously parsed ast found in cache, or null if not found.\n   */\n\n\n  getAstFromCache(selector) {\n    const cachedAst = this.astCache.get(selector) || null;\n    return cachedAst;\n  }\n  /**\n   * Returns selector ast:\n   * - if cached ast exists  returns it;\n   * - if no cached ast  saves newly parsed ast to cache and returns it.\n   *\n   * @param selector Standard or extended selector.\n   *\n   * @returns Ast for `selector`.\n   */\n\n\n  getSelectorAst(selector) {\n    let ast = this.getAstFromCache(selector);\n\n    if (!ast) {\n      ast = parse(selector);\n    }\n\n    this.saveAstToCache(selector, ast);\n    return ast;\n  }\n  /**\n   * Selects elements by selector.\n   *\n   * @param selector Standard or extended selector.\n   *\n   * @returns Array of DOM elements.\n   */\n\n\n  querySelectorAll(selector) {\n    const ast = this.getSelectorAst(selector);\n    return selectElementsByAst(ast);\n  }\n\n}\nconst extCssDocument = new ExtCssDocument();\n\n/**\n * Converts array of `entries` to object.\n * Object.fromEntries() polyfill because it is not supported by old browsers, e.g. Chrome 55.\n * Only first two elements of `entries` array matter, other will be skipped silently.\n *\n * @see {@link https://caniuse.com/?search=Object.fromEntries}\n *\n * @param entries Array of pairs.\n *\n * @returns Object converted from `entries`.\n */\nconst getObjectFromEntries = entries => {\n  const object = {};\n  entries.forEach(el => {\n    const [key, value] = el;\n    object[key] = value;\n  });\n  return object;\n};\n\nconst DEBUG_PSEUDO_PROPERTY_KEY = 'debug';\n/**\n * Checks the presence of :remove() pseudo-class and validates it while parsing the selector part of css rule.\n *\n * @param rawSelector Selector which may contain :remove() pseudo-class.\n *\n * @returns Parsed selector data with selector and styles.\n * @throws An error on invalid :remove() position.\n */\n\nconst parseRemoveSelector = rawSelector => {\n  /**\n   * No error will be thrown on invalid selector as it will be validated later\n   * so it's better to explicitly specify 'any' selector for :remove() pseudo-class by '*',\n   * e.g. '.banner > *:remove()' instead of '.banner > :remove()'.\n   */\n  // ':remove()'\n  // eslint-disable-next-line max-len\n  const VALID_REMOVE_MARKER = `${COLON}${REMOVE_PSEUDO_MARKER}${BRACKET.PARENTHESES.LEFT}${BRACKET.PARENTHESES.RIGHT}`; // ':remove(' - needed for validation rules like 'div:remove(2)'\n\n  const INVALID_REMOVE_MARKER = `${COLON}${REMOVE_PSEUDO_MARKER}${BRACKET.PARENTHESES.LEFT}`;\n  let selector;\n  let shouldRemove = false;\n  const firstIndex = rawSelector.indexOf(VALID_REMOVE_MARKER);\n\n  if (firstIndex === 0) {\n    // e.g. ':remove()'\n    throw new Error(`${REMOVE_ERROR_PREFIX.NO_TARGET_SELECTOR}: '${rawSelector}'`);\n  } else if (firstIndex > 0) {\n    if (firstIndex !== rawSelector.lastIndexOf(VALID_REMOVE_MARKER)) {\n      // rule with more than one :remove() pseudo-class is invalid\n      // e.g. '.block:remove() > .banner:remove()'\n      throw new Error(`${REMOVE_ERROR_PREFIX.MULTIPLE_USAGE}: '${rawSelector}'`);\n    } else if (firstIndex + VALID_REMOVE_MARKER.length < rawSelector.length) {\n      // remove pseudo-class should be last in the rule\n      // e.g. '.block:remove():upward(2)'\n      throw new Error(`${REMOVE_ERROR_PREFIX.INVALID_POSITION}: '${rawSelector}'`);\n    } else {\n      // valid :remove() pseudo-class position\n      selector = rawSelector.substring(0, firstIndex);\n      shouldRemove = true;\n    }\n  } else if (rawSelector.includes(INVALID_REMOVE_MARKER)) {\n    // it is not valid if ':remove()' is absent in rule but just ':remove(' is present\n    // e.g. 'div:remove(0)'\n    throw new Error(`${REMOVE_ERROR_PREFIX.INVALID_REMOVE}: '${rawSelector}'`);\n  } else {\n    // there is no :remove() pseudo-class in rule\n    selector = rawSelector;\n  }\n\n  const stylesOfSelector = shouldRemove ? [{\n    property: REMOVE_PSEUDO_MARKER,\n    value: PSEUDO_PROPERTY_POSITIVE_VALUE\n  }] : [];\n  return {\n    selector,\n    stylesOfSelector\n  };\n};\n/**\n * Parses cropped selector part found before `{`.\n *\n * @param selectorBuffer Buffered selector to parse.\n * @param extCssDoc Needed for caching of selector ast.\n *\n * @returns Parsed validation data for cropped part of stylesheet which may be a selector.\n * @throws An error on unsupported CSS features, e.g. at-rules.\n */\n\nconst parseSelectorRulePart = (selectorBuffer, extCssDoc) => {\n  let selector = selectorBuffer.trim();\n\n  if (selector.startsWith(AT_RULE_MARKER)) {\n    throw new Error(`${NO_AT_RULE_ERROR_PREFIX}: '${selector}'.`);\n  }\n\n  let removeSelectorData;\n\n  try {\n    removeSelectorData = parseRemoveSelector(selector);\n  } catch (e) {\n    logger.error(getErrorMessage(e));\n    throw new Error(`${REMOVE_ERROR_PREFIX.INVALID_REMOVE}: '${selector}'`);\n  }\n\n  let stylesOfSelector = [];\n  let success = false;\n  let ast;\n\n  try {\n    selector = removeSelectorData.selector;\n    stylesOfSelector = removeSelectorData.stylesOfSelector; // validate found selector by parsing it to ast\n    // so if it is invalid error will be thrown\n\n    ast = extCssDoc.getSelectorAst(selector);\n    success = true;\n  } catch (e) {\n    success = false;\n  }\n\n  return {\n    success,\n    selector,\n    ast,\n    stylesOfSelector\n  };\n};\n/**\n * Creates a map for storing raw results of css rules parsing.\n * Used for merging styles for same selector.\n *\n * @returns Map where **key** is `selector`\n * and **value** is object with `ast` and `styles`.\n */\n\nconst createRawResultsMap = () => {\n  return new Map();\n};\n/**\n * Saves rules data for unique selectors.\n *\n * @param rawResults Previously collected results of parsing.\n * @param rawRuleData Parsed rule data.\n *\n * @throws An error if there is no rawRuleData.styles or rawRuleData.ast.\n */\n\nconst saveToRawResults = (rawResults, rawRuleData) => {\n  const {\n    selector,\n    ast,\n    rawStyles\n  } = rawRuleData;\n\n  if (!rawStyles) {\n    throw new Error(`No style declaration for selector: '${selector}'`);\n  }\n\n  if (!ast) {\n    throw new Error(`No ast parsed for selector: '${selector}'`);\n  }\n\n  const storedRuleData = rawResults.get(selector);\n\n  if (!storedRuleData) {\n    rawResults.set(selector, {\n      ast,\n      styles: rawStyles\n    });\n  } else {\n    storedRuleData.styles.push(...rawStyles);\n  }\n};\n/**\n * Checks whether the 'remove' property positively set in styles\n * with only one positive value - 'true'.\n *\n * @param styles Array of styles.\n *\n * @returns True if there is 'remove' property with 'true' value in `styles`.\n */\n\nconst isRemoveSetInStyles = styles => {\n  return styles.some(s => {\n    return s.property === REMOVE_PSEUDO_MARKER && s.value === PSEUDO_PROPERTY_POSITIVE_VALUE;\n  });\n};\n/**\n * Returns 'debug' property value which is set in styles.\n *\n * @param styles Array of styles.\n *\n * @returns Value of 'debug' property if it is set in `styles`,\n * or `undefined` if the property is not found.\n */\n\n\nconst getDebugStyleValue = styles => {\n  const debugStyle = styles.find(s => {\n    return s.property === DEBUG_PSEUDO_PROPERTY_KEY;\n  });\n  return debugStyle === null || debugStyle === void 0 ? void 0 : debugStyle.value;\n};\n/**\n * Prepares final RuleData.\n * Handles `debug` and `remove` in raw rule data styles.\n *\n * @param rawRuleData Raw data of selector css rule parsing.\n *\n * @returns Parsed ExtendedCss rule data.\n * @throws An error if rawRuleData.ast or rawRuleData.rawStyles not defined.\n */\n\n\nconst prepareRuleData = rawRuleData => {\n  const {\n    selector,\n    ast,\n    rawStyles\n  } = rawRuleData;\n\n  if (!ast) {\n    throw new Error(`AST should be parsed for selector: '${selector}'`);\n  }\n\n  if (!rawStyles) {\n    throw new Error(`Styles should be parsed for selector: '${selector}'`);\n  }\n\n  const ruleData = {\n    selector,\n    ast\n  };\n  const debugValue = getDebugStyleValue(rawStyles);\n  const shouldRemove = isRemoveSetInStyles(rawStyles);\n  let styles = rawStyles;\n\n  if (debugValue) {\n    // get rid of 'debug' from styles\n    styles = rawStyles.filter(s => s.property !== DEBUG_PSEUDO_PROPERTY_KEY); // and set it as separate property only if its value is valid\n    // which is 'true' or 'global'\n\n    if (debugValue === PSEUDO_PROPERTY_POSITIVE_VALUE || debugValue === DEBUG_PSEUDO_PROPERTY_GLOBAL_VALUE) {\n      ruleData.debug = debugValue;\n    }\n  }\n\n  if (shouldRemove) {\n    // no other styles are needed to apply if 'remove' is set\n    ruleData.style = {\n      [REMOVE_PSEUDO_MARKER]: PSEUDO_PROPERTY_POSITIVE_VALUE\n    };\n    /**\n     * 'content' property is needed for ExtCssConfiguration.beforeStyleApplied().\n     *\n     * @see {@link BeforeStyleAppliedCallback}\n     */\n\n    const contentStyle = styles.find(s => s.property === CONTENT_CSS_PROPERTY);\n\n    if (contentStyle) {\n      ruleData.style[CONTENT_CSS_PROPERTY] = contentStyle.value;\n    }\n  } else {\n    // otherwise all styles should be applied.\n    // every style property will be unique because of their converting into object\n    if (styles.length > 0) {\n      const stylesAsEntries = styles.map(style => {\n        const {\n          property,\n          value\n        } = style;\n        return [property, value];\n      });\n      const preparedStyleData = getObjectFromEntries(stylesAsEntries);\n      ruleData.style = preparedStyleData;\n    }\n  }\n\n  return ruleData;\n};\n/**\n * Combines previously parsed css rules data objects\n * into rules which are ready to apply.\n *\n * @param rawResults Previously parsed css rules data objects.\n *\n * @returns Parsed ExtendedCss rule data.\n */\n\nconst combineRulesData = rawResults => {\n  const results = [];\n  rawResults.forEach((value, key) => {\n    const selector = key;\n    const {\n      ast,\n      styles: rawStyles\n    } = value;\n    results.push(prepareRuleData({\n      selector,\n      ast,\n      rawStyles\n    }));\n  });\n  return results;\n};\n\n/**\n * Trims `rawStyle` and splits it into tokens.\n *\n * @param rawStyle Style declaration block content inside curly bracket  `{` and `}` \n * can be a single style declaration or a list of declarations.\n *\n * @returns Array of tokens supported for style declaration block.\n */\n\nconst tokenizeStyleBlock = rawStyle => {\n  const styleDeclaration = rawStyle.trim();\n  return tokenize(styleDeclaration, SUPPORTED_STYLE_DECLARATION_MARKS);\n};\n\n/**\n * Describes possible style declaration parts.\n *\n * IMPORTANT: it is used as 'const' instead of 'enum' to avoid side effects\n * during ExtendedCss import into other libraries.\n */\n\nconst DECLARATION_PART = {\n  PROPERTY: 'property',\n  VALUE: 'value'\n};\n\n/**\n * Checks whether the quotes has been opened for style value.\n *\n * @param context Style block parser context.\n *\n * @returns True if style value has already opened quotes.\n */\nconst isValueQuotesOpen = context => {\n  return context.bufferValue !== '' && context.valueQuoteMark !== null;\n};\n/**\n * Saves parsed property and value to collection of parsed styles.\n * Prunes context buffers for property and value.\n *\n * @param context Style block parser context.\n */\n\n\nconst collectStyle = context => {\n  context.styles.push({\n    property: context.bufferProperty.trim(),\n    value: context.bufferValue.trim()\n  }); // reset buffers\n\n  context.bufferProperty = '';\n  context.bufferValue = '';\n};\n/**\n * Handles token which is supposed to be a part of style **property**.\n *\n * @param context Style block parser context.\n * @param styleBlock Whole style block which is being parsed.\n * @param token Current token.\n *\n * @throws An error on invalid token.\n */\n\n\nconst processPropertyToken = (context, styleBlock, token) => {\n  const {\n    value: tokenValue\n  } = token;\n\n  switch (token.type) {\n    case TOKEN_TYPE.WORD:\n      if (context.bufferProperty.length > 0) {\n        // e.g. 'padding top: 0;' - current tokenValue is 'top' which is not valid\n        throw new Error(`Invalid style property in style block: '${styleBlock}'`);\n      }\n\n      context.bufferProperty += tokenValue;\n      break;\n\n    case TOKEN_TYPE.MARK:\n      // only colon and whitespaces are allowed while style property parsing\n      if (tokenValue === COLON) {\n        if (context.bufferProperty.trim().length === 0) {\n          // e.g. such style block: '{ : none; }'\n          throw new Error(`Missing style property before ':' in style block: '${styleBlock}'`);\n        } // the property successfully collected\n\n\n        context.bufferProperty = context.bufferProperty.trim(); // prepare for value collecting\n\n        context.processing = DECLARATION_PART.VALUE; // the property buffer shall be reset after the value is successfully collected\n      } else if (WHITE_SPACE_CHARACTERS.includes(tokenValue)) ; else {\n        // if after the property there is anything other than ':' except whitespace, this is a parse error\n        // https://www.w3.org/TR/css-syntax-3/#consume-declaration\n        throw new Error(`Invalid style declaration in style block: '${styleBlock}'`);\n      }\n\n      break;\n\n    default:\n      throw new Error(`Unsupported style property character: '${tokenValue}' in style block: '${styleBlock}'`);\n  }\n};\n/**\n * Handles token which is supposed to be a part of style **value**.\n *\n * @param context Style block parser context.\n * @param styleBlock Whole style block which is being parsed.\n * @param token Current token.\n *\n * @throws An error on invalid token.\n */\n\n\nconst processValueToken = (context, styleBlock, token) => {\n  const {\n    value: tokenValue\n  } = token;\n\n  if (token.type === TOKEN_TYPE.WORD) {\n    // simply collect to buffer\n    context.bufferValue += tokenValue;\n  } else {\n    // otherwise check the mark\n    switch (tokenValue) {\n      case COLON:\n        // the ':' character inside of the value should be inside of quotes\n        // otherwise the value is not valid\n        // e.g. 'content: display: none'\n        // parser is here        \n        if (!isValueQuotesOpen(context)) {\n          // eslint-disable-next-line max-len\n          throw new Error(`Invalid style value for property '${context.bufferProperty}' in style block: '${styleBlock}'`);\n        } // collect the colon inside quotes\n        // e.g. 'content: \"test:123\"'\n        // parser is here      \n\n\n        context.bufferValue += tokenValue;\n        break;\n\n      case SEMICOLON:\n        if (isValueQuotesOpen(context)) {\n          // ';' inside quotes is part of style value\n          // e.g. 'content: \"test;\"'\n          context.bufferValue += tokenValue;\n        } else {\n          // otherwise the value is successfully collected\n          // save parsed style\n          collectStyle(context); // prepare for value collecting\n\n          context.processing = DECLARATION_PART.PROPERTY;\n        }\n\n        break;\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE:\n        // if quotes are not open\n        if (context.valueQuoteMark === null) {\n          // save the opening quote mark for later comparison\n          context.valueQuoteMark = tokenValue;\n        } else if (!context.bufferValue.endsWith(BACKSLASH) // otherwise a quote appeared in the value earlier,\n        // and non-escaped quote should be checked whether it is a closing quote\n        && context.valueQuoteMark === tokenValue) {\n          context.valueQuoteMark = null;\n        } // always save the quote to the buffer\n        // but after the context.bufferValue is checked for BACKSLASH above\n        // e.g. 'content: \"test:123\"'\n        //      'content: \"\\\"\"'\n\n\n        context.bufferValue += tokenValue;\n        break;\n\n      case BACKSLASH:\n        if (!isValueQuotesOpen(context)) {\n          // eslint-disable-next-line max-len\n          throw new Error(`Invalid style value for property '${context.bufferProperty}' in style block: '${styleBlock}'`);\n        } // collect the backslash inside quotes\n        // e.g. ' content: \"\\\"\" '\n        // parser is here   \n\n\n        context.bufferValue += tokenValue;\n        break;\n\n      case SPACE:\n      case TAB:\n      case CARRIAGE_RETURN:\n      case LINE_FEED:\n      case FORM_FEED:\n        // whitespace should be collected only if the value collecting started\n        // which means inside of the value\n        // e.g. 'width: 100% !important'\n        // parser is here   \n        if (context.bufferValue.length > 0) {\n          context.bufferValue += tokenValue;\n        } // otherwise it can be omitted\n        // e.g. 'width:  100% !important'\n        // here        \n\n\n        break;\n\n      default:\n        throw new Error(`Unknown style declaration token: '${tokenValue}'`);\n    }\n  }\n};\n/**\n * Parses css rule style block.\n *\n * @param rawStyleBlock Style block to parse.\n *\n * @returns Array of style declarations.\n * @throws An error on invalid style block.\n */\n\n\nconst parseStyleBlock = rawStyleBlock => {\n  const styleBlock = rawStyleBlock.trim();\n  const tokens = tokenizeStyleBlock(styleBlock);\n  const context = {\n    // style declaration parsing always starts with 'property'\n    processing: DECLARATION_PART.PROPERTY,\n    styles: [],\n    bufferProperty: '',\n    bufferValue: '',\n    valueQuoteMark: null\n  };\n  let i = 0;\n\n  while (i < tokens.length) {\n    const token = tokens[i];\n\n    if (!token) {\n      break;\n    }\n\n    if (context.processing === DECLARATION_PART.PROPERTY) {\n      processPropertyToken(context, styleBlock, token);\n    } else if (context.processing === DECLARATION_PART.VALUE) {\n      processValueToken(context, styleBlock, token);\n    } else {\n      throw new Error('Style declaration parsing failed');\n    }\n\n    i += 1;\n  } // unbalanced value quotes\n  // e.g. 'content: \"test} '\n\n\n  if (isValueQuotesOpen(context)) {\n    throw new Error(`Unbalanced style declaration quotes in style block: '${styleBlock}'`);\n  } // collected property and value have not been saved to styles;\n  // it is possible for style block with no semicolon at the end\n  // e.g. such style block: '{ display: none }'\n\n\n  if (context.bufferProperty.length > 0) {\n    if (context.bufferValue.length === 0) {\n      // e.g. such style blocks:\n      //   '{ display:  }'\n      //   '{ remove }'\n      // eslint-disable-next-line max-len\n      throw new Error(`Missing style value for property '${context.bufferProperty}' in style block '${styleBlock}'`);\n    }\n\n    collectStyle(context);\n  } // rule with empty style block\n  // e.g. 'div { }'\n\n\n  if (context.styles.length === 0) {\n    throw new Error(STYLE_ERROR_PREFIX.NO_STYLE);\n  }\n\n  return context.styles;\n};\n\n/**\n * Returns array of positions of `{` in `cssRule`.\n *\n * @param cssRule CSS rule.\n *\n * @returns Array of left curly bracket indexes.\n */\n\nconst getLeftCurlyBracketIndexes = cssRule => {\n  const indexes = [];\n\n  for (let i = 0; i < cssRule.length; i += 1) {\n    if (cssRule[i] === BRACKET.CURLY.LEFT) {\n      indexes.push(i);\n    }\n  }\n\n  return indexes;\n}; // TODO: use `extCssDoc` for caching of style block parser results\n\n/**\n * Parses CSS rule into rules data object:\n * 1. Find the last `{` mark in the rule\n *    which supposed to be a divider between selector and style block.\n * 2. Validates found string part before the `{` via selector parser; and if:\n *  - parsing failed  get the previous `{` in the rule,\n *    and validates a new rule part again [2];\n *  - parsing successful  saves a found rule part as selector and parses the style block.\n *\n * @param rawCssRule Single CSS rule to parse.\n * @param extCssDoc ExtCssDocument which is used for selector ast caching.\n *\n * @returns Array of rules data which contains:\n *   - selector as string;\n *   - ast to query elements by;\n *   - map of styles to apply.\n * @throws An error on invalid css rule syntax:\n *   - unsupported CSS features  comments and at-rules\n *   - invalid selector or style block.\n */\n\n\nconst parseRule = (rawCssRule, extCssDoc) => {\n  var _rawRuleData$selector;\n\n  const cssRule = rawCssRule.trim();\n\n  if (cssRule.includes(`${SLASH}${ASTERISK}`) && cssRule.includes(`${ASTERISK}${SLASH}`)) {\n    throw new Error(STYLE_ERROR_PREFIX.NO_COMMENT);\n  }\n\n  const leftCurlyBracketIndexes = getLeftCurlyBracketIndexes(cssRule); // rule with style block but no selector\n  // e.g. '{ display: none; }'\n\n  if (getFirst(leftCurlyBracketIndexes) === 0) {\n    throw new Error(NO_SELECTOR_ERROR_PREFIX);\n  }\n\n  let selectorData; // if rule has `{` but there is no `}`\n\n  if (leftCurlyBracketIndexes.length > 0 && !cssRule.includes(BRACKET.CURLY.RIGHT)) {\n    throw new Error(`${STYLE_ERROR_PREFIX.NO_STYLE} OR ${STYLE_ERROR_PREFIX.UNCLOSED_STYLE}`);\n  }\n\n  if ( // if rule has no `{`\n  leftCurlyBracketIndexes.length === 0 // or `}`\n  || !cssRule.includes(BRACKET.CURLY.RIGHT)) {\n    try {\n      // the whole css rule considered as \"selector part\"\n      // which may contain :remove() pseudo-class\n      selectorData = parseSelectorRulePart(cssRule, extCssDoc);\n\n      if (selectorData.success) {\n        var _selectorData$stylesO;\n\n        // rule with no style block has valid :remove() pseudo-class\n        // which is parsed into \"styles\"\n        // e.g. 'div:remove()'\n        // but also it can be just selector with no styles\n        // e.g. 'div'\n        // which should not be considered as valid css rule\n        if (((_selectorData$stylesO = selectorData.stylesOfSelector) === null || _selectorData$stylesO === void 0 ? void 0 : _selectorData$stylesO.length) === 0) {\n          throw new Error(STYLE_ERROR_PREFIX.NO_STYLE_OR_REMOVE);\n        }\n\n        return {\n          selector: selectorData.selector.trim(),\n          ast: selectorData.ast,\n          rawStyles: selectorData.stylesOfSelector\n        };\n      } else {\n        // not valid selector\n        throw new Error('Invalid selector');\n      }\n    } catch (e) {\n      throw new Error(getErrorMessage(e));\n    }\n  }\n\n  let selectorBuffer;\n  let styleBlockBuffer;\n  const rawRuleData = {\n    selector: ''\n  }; // css rule should be parsed from its end\n\n  for (let i = leftCurlyBracketIndexes.length - 1; i > -1; i -= 1) {\n    const index = leftCurlyBracketIndexes[i];\n\n    if (!index) {\n      throw new Error(`Impossible to continue, no '{' to process for rule: '${cssRule}'`);\n    } // selector is before `{`, style block is after it\n\n\n    selectorBuffer = cssRule.slice(0, index); // skip curly brackets\n\n    styleBlockBuffer = cssRule.slice(index + 1, cssRule.length - 1);\n    selectorData = parseSelectorRulePart(selectorBuffer, extCssDoc);\n\n    if (selectorData.success) {\n      var _rawRuleData$rawStyle;\n\n      // selector successfully parsed\n      rawRuleData.selector = selectorData.selector.trim();\n      rawRuleData.ast = selectorData.ast;\n      rawRuleData.rawStyles = selectorData.stylesOfSelector; // style block should be parsed\n      // TODO: add cache for style block parsing\n\n      const parsedStyles = parseStyleBlock(styleBlockBuffer);\n      (_rawRuleData$rawStyle = rawRuleData.rawStyles) === null || _rawRuleData$rawStyle === void 0 ? void 0 : _rawRuleData$rawStyle.push(...parsedStyles); // stop rule parsing\n\n      break;\n    } else {\n      // if selector was not parsed successfully\n      // continue with next index of `{`\n      continue;\n    }\n  }\n\n  if (((_rawRuleData$selector = rawRuleData.selector) === null || _rawRuleData$selector === void 0 ? void 0 : _rawRuleData$selector.length) === 0) {\n    // skip the rule as selector\n    throw new Error('Selector in not valid');\n  }\n\n  return rawRuleData;\n};\n/**\n * Parses array of CSS rules into array of rules data objects.\n * Invalid rules are skipped and not applied,\n * and the errors are logged.\n *\n * @param rawCssRules Array of rules to parse.\n * @param extCssDoc Needed for selector ast caching.\n *\n * @returns Array of parsed valid rules data.\n */\n\nconst parseRules = (rawCssRules, extCssDoc) => {\n  const rawResults = createRawResultsMap();\n  const warnings = []; // trim all rules and find unique ones\n\n  const uniqueRules = [...new Set(rawCssRules.map(r => r.trim()))];\n  uniqueRules.forEach(rule => {\n    try {\n      saveToRawResults(rawResults, parseRule(rule, extCssDoc));\n    } catch (e) {\n      // skip the invalid rule\n      const errorMessage = getErrorMessage(e);\n      warnings.push(`'${rule}' - error: '${errorMessage}'`);\n    }\n  }); // log info about skipped invalid rules\n\n  if (warnings.length > 0) {\n    logger.info(`Invalid rules:\\n  ${warnings.join('\\n  ')}`);\n  }\n\n  return combineRulesData(rawResults);\n};\n\nconst REGEXP_DECLARATION_END = /[;}]/g;\nconst REGEXP_DECLARATION_DIVIDER = /[;:}]/g;\nconst REGEXP_NON_WHITESPACE = /\\S/g;\n/**\n * Interface for stylesheet parser context.\n */\n\n/**\n * Resets rule data buffer to init value after rule successfully collected.\n *\n * @param context Stylesheet parser context.\n */\nconst restoreRuleAcc = context => {\n  context.rawRuleData = {\n    selector: ''\n  };\n};\n/**\n * Parses cropped selector part found before `{` previously.\n *\n * @param context Stylesheet parser context.\n * @param extCssDoc Needed for caching of selector ast.\n *\n * @returns Parsed validation data for cropped part of stylesheet which may be a selector.\n * @throws An error on unsupported CSS features, e.g. at-rules.\n */\n\n\nconst parseSelectorPart = (context, extCssDoc) => {\n  let selector = context.selectorBuffer.trim();\n\n  if (selector.startsWith(AT_RULE_MARKER)) {\n    throw new Error(`${NO_AT_RULE_ERROR_PREFIX}: '${selector}'.`);\n  }\n\n  let removeSelectorData;\n\n  try {\n    removeSelectorData = parseRemoveSelector(selector);\n  } catch (e) {\n    logger.error(getErrorMessage(e));\n    throw new Error(`${REMOVE_ERROR_PREFIX.INVALID_REMOVE}: '${selector}'`);\n  }\n\n  if (context.nextIndex === -1) {\n    if (selector === removeSelectorData.selector) {\n      // rule should have style or pseudo-class :remove()\n      throw new Error(`${STYLE_ERROR_PREFIX.NO_STYLE_OR_REMOVE}: '${context.cssToParse}'`);\n    } // stop parsing as there is no style declaration and selector parsed fine\n\n\n    context.cssToParse = '';\n  }\n\n  let stylesOfSelector = [];\n  let success = false;\n  let ast;\n\n  try {\n    selector = removeSelectorData.selector;\n    stylesOfSelector = removeSelectorData.stylesOfSelector; // validate found selector by parsing it to ast\n    // so if it is invalid error will be thrown\n\n    ast = extCssDoc.getSelectorAst(selector);\n    success = true;\n  } catch (e) {\n    success = false;\n  }\n\n  if (context.nextIndex > 0) {\n    // slice found valid selector part off\n    // and parse rest of stylesheet later\n    context.cssToParse = context.cssToParse.slice(context.nextIndex);\n  }\n\n  return {\n    success,\n    selector,\n    ast,\n    stylesOfSelector\n  };\n};\n/**\n * Recursively parses style declaration string into `Style`s.\n *\n * @param context Stylesheet parser context.\n * @param styles Array of styles.\n *\n * @throws An error on invalid style declaration.\n * @returns A number index of the next `}` in `this.cssToParse`.\n */\n\n\nconst parseUntilClosingBracket = (context, styles) => {\n  // Expects \":\", \";\", and \"}\".\n  REGEXP_DECLARATION_DIVIDER.lastIndex = context.nextIndex;\n  let match = REGEXP_DECLARATION_DIVIDER.exec(context.cssToParse);\n\n  if (match === null) {\n    throw new Error(`${STYLE_ERROR_PREFIX.INVALID_STYLE}: '${context.cssToParse}'`);\n  }\n\n  let matchPos = match.index;\n  let matched = match[0];\n\n  if (matched === BRACKET.CURLY.RIGHT) {\n    const declarationChunk = context.cssToParse.slice(context.nextIndex, matchPos);\n\n    if (declarationChunk.trim().length === 0) {\n      // empty style declaration\n      // e.g. 'div { }'\n      if (styles.length === 0) {\n        throw new Error(`${STYLE_ERROR_PREFIX.NO_STYLE}: '${context.cssToParse}'`);\n      } // else valid style parsed before it\n      // e.g. '{ display: none; }' -- position is after ';'\n\n    } else {\n      // closing curly bracket '}' is matched before colon ':'\n      // trimmed declarationChunk is not a space, between ';' and '}',\n      // e.g. 'visible }' in style '{ display: none; visible }' after part before ';' is parsed\n      throw new Error(`${STYLE_ERROR_PREFIX.INVALID_STYLE}: '${context.cssToParse}'`);\n    }\n\n    return matchPos;\n  }\n\n  if (matched === COLON) {\n    const colonIndex = matchPos; // Expects \";\" and \"}\".\n\n    REGEXP_DECLARATION_END.lastIndex = colonIndex;\n    match = REGEXP_DECLARATION_END.exec(context.cssToParse);\n\n    if (match === null) {\n      throw new Error(`${STYLE_ERROR_PREFIX.UNCLOSED_STYLE}: '${context.cssToParse}'`);\n    }\n\n    matchPos = match.index;\n    matched = match[0]; // Populates the `styleMap` key-value map.\n\n    const property = context.cssToParse.slice(context.nextIndex, colonIndex).trim();\n\n    if (property.length === 0) {\n      throw new Error(`${STYLE_ERROR_PREFIX.NO_PROPERTY}: '${context.cssToParse}'`);\n    }\n\n    const value = context.cssToParse.slice(colonIndex + 1, matchPos).trim();\n\n    if (value.length === 0) {\n      throw new Error(`${STYLE_ERROR_PREFIX.NO_VALUE}: '${context.cssToParse}'`);\n    }\n\n    styles.push({\n      property,\n      value\n    }); // finish style parsing if '}' is found\n    // e.g. '{ display: none }' -- no ';' at the end of declaration\n\n    if (matched === BRACKET.CURLY.RIGHT) {\n      return matchPos;\n    }\n  } // matchPos is the position of the next ';'\n  // crop 'cssToParse' and re-run the loop\n\n\n  context.cssToParse = context.cssToParse.slice(matchPos + 1);\n  context.nextIndex = 0;\n  return parseUntilClosingBracket(context, styles); // Should be a subject of tail-call optimization.\n};\n/**\n * Parses next style declaration part in stylesheet.\n *\n * @param context Stylesheet parser context.\n *\n * @returns Array of style data objects.\n */\n\n\nconst parseNextStyle = context => {\n  const styles = [];\n  const styleEndPos = parseUntilClosingBracket(context, styles); // find next rule after the style declaration\n\n  REGEXP_NON_WHITESPACE.lastIndex = styleEndPos + 1;\n  const match = REGEXP_NON_WHITESPACE.exec(context.cssToParse);\n\n  if (match === null) {\n    context.cssToParse = '';\n    return styles;\n  }\n\n  const matchPos = match.index; // cut out matched style declaration for previous selector\n\n  context.cssToParse = context.cssToParse.slice(matchPos);\n  return styles;\n};\n/**\n * Parses stylesheet of rules into rules data objects (non-recursively):\n * 1. Iterates through stylesheet string.\n * 2. Finds first `{` which can be style declaration start or part of selector.\n * 3. Validates found string part via selector parser; and if:\n *  - it throws error  saves string part to buffer as part of selector,\n *    slice next stylesheet part to `{` [2] and validates again [3];\n *  - no error  saves found string part as selector and starts to parse styles (recursively).\n *\n * @param rawStylesheet Raw stylesheet as string.\n * @param extCssDoc ExtCssDocument which uses cache while selectors parsing.\n * @throws An error on unsupported CSS features, e.g. comments or invalid stylesheet syntax.\n * @returns Array of rules data which contains:\n * - selector as string;\n * - ast to query elements by;\n * - map of styles to apply.\n */\n\n\nconst parseStylesheet = (rawStylesheet, extCssDoc) => {\n  const stylesheet = rawStylesheet.trim();\n\n  if (stylesheet.includes(`${SLASH}${ASTERISK}`) && stylesheet.includes(`${ASTERISK}${SLASH}`)) {\n    throw new Error(`${STYLE_ERROR_PREFIX.NO_COMMENT} in stylesheet: '${stylesheet}'`);\n  }\n\n  const context = {\n    // any stylesheet should start with selector\n    isSelector: true,\n    // init value of parser position\n    nextIndex: 0,\n    // init value of cssToParse\n    cssToParse: stylesheet,\n    // buffer for collecting selector part\n    selectorBuffer: '',\n    // accumulator for rules\n    rawRuleData: {\n      selector: ''\n    }\n  };\n  const rawResults = createRawResultsMap();\n  let selectorData; // context.cssToParse is going to be cropped while its parsing\n\n  while (context.cssToParse) {\n    if (context.isSelector) {\n      // find index of first opening curly bracket\n      // which may mean start of style part and end of selector one\n      context.nextIndex = context.cssToParse.indexOf(BRACKET.CURLY.LEFT); // rule should not start with style, selector is required\n      // e.g. '{ display: none; }'\n\n      if (context.selectorBuffer.length === 0 && context.nextIndex === 0) {\n        throw new Error(`${STYLE_ERROR_PREFIX.NO_SELECTOR}: '${context.cssToParse}'`);\n      }\n\n      if (context.nextIndex === -1) {\n        // no style declaration in rule\n        // but rule still may contain :remove() pseudo-class\n        context.selectorBuffer = context.cssToParse;\n      } else {\n        // collect string parts before opening curly bracket\n        // until valid selector collected\n        context.selectorBuffer += context.cssToParse.slice(0, context.nextIndex);\n      }\n\n      selectorData = parseSelectorPart(context, extCssDoc);\n\n      if (selectorData.success) {\n        // selector successfully parsed\n        context.rawRuleData.selector = selectorData.selector.trim();\n        context.rawRuleData.ast = selectorData.ast;\n        context.rawRuleData.rawStyles = selectorData.stylesOfSelector;\n        context.isSelector = false; // save rule data if there is no style declaration\n\n        if (context.nextIndex === -1) {\n          saveToRawResults(rawResults, context.rawRuleData); // clean up ruleContext\n\n          restoreRuleAcc(context);\n        } else {\n          // skip the opening curly bracket at the start of style declaration part\n          context.nextIndex = 1;\n          context.selectorBuffer = '';\n        }\n      } else {\n        // if selector was not successfully parsed parseSelectorPart(), continue stylesheet parsing:\n        // save the found bracket to buffer and proceed to next loop iteration\n        context.selectorBuffer += BRACKET.CURLY.LEFT; // delete `{` from cssToParse\n\n        context.cssToParse = context.cssToParse.slice(1);\n      }\n    } else {\n      var _context$rawRuleData$;\n\n      // style declaration should be parsed\n      const parsedStyles = parseNextStyle(context); // styles can be parsed from selector part if it has :remove() pseudo-class\n      // e.g. '.banner:remove() { debug: true; }'\n\n      (_context$rawRuleData$ = context.rawRuleData.rawStyles) === null || _context$rawRuleData$ === void 0 ? void 0 : _context$rawRuleData$.push(...parsedStyles); // save rule data to results\n\n      saveToRawResults(rawResults, context.rawRuleData);\n      context.nextIndex = 0; // clean up ruleContext\n\n      restoreRuleAcc(context); // parse next rule selector after style successfully parsed\n\n      context.isSelector = true;\n    }\n  }\n\n  return combineRulesData(rawResults);\n};\n\n/**\n * Checks whether passed `arg` is number type.\n *\n * @param arg Value to check.\n *\n * @returns True if `arg` is number and not NaN.\n */\nconst isNumber = arg => {\n  return typeof arg === 'number' && !Number.isNaN(arg);\n};\n\n/**\n * The purpose of ThrottleWrapper is to throttle calls of the function\n * that applies ExtendedCss rules. The reasoning here is that the function calls\n * are triggered by MutationObserver and there may be many mutations in a short period of time.\n * We do not want to apply rules on every mutation so we use this helper to make sure\n * that there is only one call in the given amount of time.\n */\n\nclass ThrottleWrapper {\n  /**\n   * Creates new ThrottleWrapper.\n   * The {@link callback} should be executed not more often than {@link ThrottleWrapper.THROTTLE_DELAY_MS}.\n   *\n   * @param callback The callback.\n   */\n  constructor(callback) {\n    this.callback = callback;\n    this.executeCallback = this.executeCallback.bind(this);\n  }\n  /**\n   * Calls the {@link callback} function and update bounded throttle wrapper properties.\n   */\n\n\n  executeCallback() {\n    this.lastRunTime = performance.now();\n\n    if (isNumber(this.timerId)) {\n      clearTimeout(this.timerId);\n      delete this.timerId;\n    }\n\n    this.callback();\n  }\n  /**\n   * Schedules the {@link executeCallback} function execution via setTimeout.\n   * It may triggered by MutationObserver job which may occur too ofter, so we limit the function execution:\n   *\n   * 1. If {@link timerId} is set, ignore the call, because the function is already scheduled to be executed;\n   *\n   * 2. If {@link lastRunTime} is set, we need to check the time elapsed time since the last call. If it is\n   * less than {@link ThrottleWrapper.THROTTLE_DELAY_MS}, we schedule the function execution after the remaining time.\n   * \n   * Otherwise, we execute the function asynchronously to ensure that it is executed \n   * in the correct order with respect to DOM events, by deferring its execution until after \n   * those tasks have completed.\n   */\n\n\n  run() {\n    if (isNumber(this.timerId)) {\n      // there is a pending execution scheduled\n      return;\n    }\n\n    if (isNumber(this.lastRunTime)) {\n      const elapsedTime = performance.now() - this.lastRunTime;\n\n      if (elapsedTime < ThrottleWrapper.THROTTLE_DELAY_MS) {\n        this.timerId = window.setTimeout(this.executeCallback, ThrottleWrapper.THROTTLE_DELAY_MS - elapsedTime);\n        return;\n      }\n    }\n    /**\n     * We use `setTimeout` instead `requestAnimationFrame`\n     * here because requestAnimationFrame can be delayed for a long time\n     * when the browser saves battery or the engine is heavily loaded.\n     */\n\n\n    this.timerId = window.setTimeout(this.executeCallback);\n  }\n\n}\n\n_defineProperty(ThrottleWrapper, \"THROTTLE_DELAY_MS\", 150);\n\nconst LAST_EVENT_TIMEOUT_MS = 10;\nconst IGNORED_EVENTS = ['mouseover', 'mouseleave', 'mouseenter', 'mouseout'];\nconst SUPPORTED_EVENTS = [// keyboard events\n'keydown', 'keypress', 'keyup', // mouse events\n'auxclick', 'click', 'contextmenu', 'dblclick', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseover', 'mouseout', 'mouseup', 'pointerlockchange', 'pointerlockerror', 'select', 'wheel']; // 'wheel' event makes scrolling in Safari twitchy\n// https://github.com/AdguardTeam/ExtendedCss/issues/120\n\nconst SAFARI_PROBLEMATIC_EVENTS = ['wheel'];\n/**\n * We use EventTracker to track the event that is likely to cause the mutation.\n * The problem is that we cannot use `window.event` directly from the mutation observer call\n * as we're not in the event handler context anymore.\n */\n\nclass EventTracker {\n  /**\n   * Creates new EventTracker.\n   */\n  constructor() {\n    _defineProperty(this, \"getLastEventType\", () => this.lastEventType);\n\n    _defineProperty(this, \"getTimeSinceLastEvent\", () => {\n      if (!this.lastEventTime) {\n        return null;\n      }\n\n      return Date.now() - this.lastEventTime;\n    });\n\n    this.trackedEvents = isSafariBrowser ? SUPPORTED_EVENTS.filter(event => !SAFARI_PROBLEMATIC_EVENTS.includes(event)) : SUPPORTED_EVENTS;\n    this.trackedEvents.forEach(eventName => {\n      document.documentElement.addEventListener(eventName, this.trackEvent, true);\n    });\n  }\n  /**\n   * Callback for event listener for events tracking.\n   *\n   * @param event Any event.\n   */\n\n\n  trackEvent(event) {\n    this.lastEventType = event.type;\n    this.lastEventTime = Date.now();\n  }\n\n  /**\n   * Checks whether the last caught event should be ignored.\n   *\n   * @returns True if event should be ignored.\n   */\n  isIgnoredEventType() {\n    const lastEventType = this.getLastEventType();\n    const sinceLastEventTime = this.getTimeSinceLastEvent();\n    return !!lastEventType && IGNORED_EVENTS.includes(lastEventType) && !!sinceLastEventTime && sinceLastEventTime < LAST_EVENT_TIMEOUT_MS;\n  }\n  /**\n   * Stops event tracking by removing event listener.\n   */\n\n\n  stopTracking() {\n    this.trackedEvents.forEach(eventName => {\n      document.documentElement.removeEventListener(eventName, this.trackEvent, true);\n    });\n  }\n\n}\n\n/**\n * We are trying to limit the number of callback calls by not calling it on all kind of \"hover\" events.\n * The rationale behind this is that \"hover\" events often cause attributes modification,\n * but re-applying extCSS rules will be useless as these attribute changes are usually transient.\n *\n * @param mutations DOM elements mutation records.\n * @returns True if all mutations are about attributes changes, otherwise false.\n */\n\nfunction shouldIgnoreMutations(mutations) {\n  // ignore if all mutations are about attributes changes\n  return !mutations.some(m => m.type !== 'attributes');\n}\n/**\n * Adds new {@link context.domMutationObserver} instance and connect it to document.\n * \n * @param context ExtendedCss context.\n */\n\n\nfunction observeDocument(context) {\n  if (context.isDomObserved) {\n    return;\n  } // enable dynamically added elements handling\n\n\n  context.isDomObserved = true;\n  context.domMutationObserver = new natives.MutationObserver(mutations => {\n    if (!mutations || mutations.length === 0) {\n      return;\n    }\n\n    const eventTracker = new EventTracker();\n\n    if (eventTracker.isIgnoredEventType() && shouldIgnoreMutations(mutations)) {\n      return;\n    } // save instance of EventTracker to context\n    // for removing its event listeners on disconnectDocument() while mainDisconnect()\n\n\n    context.eventTracker = eventTracker;\n    context.scheduler.run();\n  });\n  context.domMutationObserver.observe(document, {\n    childList: true,\n    subtree: true,\n    attributes: true,\n    attributeFilter: ['id', 'class']\n  });\n}\n/**\n * Disconnect from {@link context.domMutationObserver}.\n * \n * @param context ExtendedCss context.\n */\n\nfunction disconnectDocument(context) {\n  if (!context.isDomObserved) {\n    return;\n  } // disable dynamically added elements handling\n\n\n  context.isDomObserved = false;\n\n  if (context.domMutationObserver) {\n    context.domMutationObserver.disconnect();\n  } // clean up event listeners\n\n\n  if (context.eventTracker) {\n    context.eventTracker.stopTracking();\n  }\n}\n\nconst CONTENT_ATTR_PREFIX_REGEXP = /^(\"|')adguard.+?/;\n/**\n * Removes affectedElement.node from DOM.\n *\n * @param context ExtendedCss context.\n * @param affectedElement Affected element.\n */\n\nconst removeElement = (context, affectedElement) => {\n  const {\n    node\n  } = affectedElement;\n  affectedElement.removed = true;\n  const elementSelector = getElementSelectorPath(node); // check if the element has been already removed earlier\n\n  const elementRemovalsCounter = context.removalsStatistic[elementSelector] || 0; // if removals attempts happened more than specified we do not try to remove node again\n\n  if (elementRemovalsCounter > MAX_STYLE_PROTECTION_COUNT) {\n    logger.error(`ExtendedCss: infinite loop protection for selector: '${elementSelector}'`);\n    return;\n  }\n\n  if (node.parentElement) {\n    node.parentElement.removeChild(node);\n    context.removalsStatistic[elementSelector] = elementRemovalsCounter + 1;\n  }\n};\n/**\n * Sets style to the specified DOM node.\n *\n * @param node DOM element.\n * @param style Style to set.\n */\n\n\nconst setStyleToElement = (node, style) => {\n  if (!(node instanceof HTMLElement)) {\n    return;\n  }\n\n  Object.keys(style).forEach(prop => {\n    // Apply this style only to existing properties\n    // We cannot use hasOwnProperty here (does not work in FF)\n    if (typeof node.style.getPropertyValue(prop.toString()) !== 'undefined') {\n      let value = style[prop];\n\n      if (!value) {\n        return;\n      } // do not apply 'content' style given by tsurlfilter\n      // which is needed only for BeforeStyleAppliedCallback\n\n\n      if (prop === CONTENT_CSS_PROPERTY && value.match(CONTENT_ATTR_PREFIX_REGEXP)) {\n        return;\n      } // First we should remove !important attribute (or it won't be applied')\n\n\n      value = removeSuffix(value.trim(), '!important').trim();\n      node.style.setProperty(prop, value, 'important');\n    }\n  });\n};\n/**\n * Checks the required properties of `affectedElement`\n * **before** `beforeStyleApplied()` execution.\n *\n * @param affectedElement Affected element.\n *\n * @returns False if there is no `node` or `rules`\n * or `rules` is not an array.\n */\n\nconst isIAffectedElement = affectedElement => {\n  return 'node' in affectedElement && 'rules' in affectedElement && affectedElement.rules instanceof Array;\n};\n/**\n * Checks the required properties of `affectedElement`\n * **after** `beforeStyleApplied()` execution.\n * These properties are needed for proper internal usage.\n *\n * @param affectedElement Affected element.\n *\n * @returns False if there is no `node` or `rules`\n * or `rules` is not an array.\n */\n\n\nconst isAffectedElement = affectedElement => {\n  return 'node' in affectedElement && 'originalStyle' in affectedElement && 'rules' in affectedElement && affectedElement.rules instanceof Array;\n};\n/**\n * Applies style to the specified DOM node.\n *\n * @param context ExtendedCss context.\n * @param rawAffectedElement Object containing DOM node and rule to be applied.\n *\n * @throws An error if affectedElement has no style to apply.\n */\n\n\nconst applyStyle = (context, rawAffectedElement) => {\n  if (rawAffectedElement.protectionObserver) {\n    // style is already applied and protected by the observer\n    return;\n  }\n\n  let affectedElement;\n\n  if (context.beforeStyleApplied) {\n    if (!isIAffectedElement(rawAffectedElement)) {\n      throw new Error(\"Returned IAffectedElement should have 'node' and 'rules' properties\");\n    }\n\n    affectedElement = context.beforeStyleApplied(rawAffectedElement);\n\n    if (!affectedElement) {\n      throw new Error(\"Callback 'beforeStyleApplied' should return IAffectedElement\");\n    }\n  } else {\n    affectedElement = rawAffectedElement;\n  }\n\n  if (!isAffectedElement(affectedElement)) {\n    throw new Error(\"Returned IAffectedElement should have 'node' and 'rules' properties\");\n  }\n\n  const {\n    node,\n    rules\n  } = affectedElement;\n\n  for (let i = 0; i < rules.length; i += 1) {\n    const rule = rules[i];\n    const selector = rule === null || rule === void 0 ? void 0 : rule.selector;\n    const style = rule === null || rule === void 0 ? void 0 : rule.style;\n    const debug = rule === null || rule === void 0 ? void 0 : rule.debug; // rule may not have style to apply\n    // e.g. 'div:has(> a) { debug: true }' -> means no style to apply, and enable debug mode\n\n    if (style) {\n      if (style[REMOVE_PSEUDO_MARKER] === PSEUDO_PROPERTY_POSITIVE_VALUE) {\n        removeElement(context, affectedElement);\n        return;\n      }\n\n      setStyleToElement(node, style);\n    } else if (!debug) {\n      // but rule should not have both style and debug properties\n      throw new Error(`No style declaration in rule for selector: '${selector}'`);\n    }\n  }\n};\n/**\n * Reverts style for the affected object.\n *\n * @param affectedElement Affected element.\n */\n\nconst revertStyle = affectedElement => {\n  if (affectedElement.protectionObserver) {\n    affectedElement.protectionObserver.disconnect();\n  }\n\n  affectedElement.node.style.cssText = affectedElement.originalStyle;\n};\n\n/**\n * ExtMutationObserver is a wrapper over regular MutationObserver with one additional function:\n * it keeps track of the number of times we called the \"ProtectionCallback\".\n *\n * We use an instance of this to monitor styles added by ExtendedCss\n * and to make sure these styles are recovered if the page script attempts to modify them.\n *\n * However, we want to avoid endless loops of modification if the page script repeatedly modifies the styles.\n * So we keep track of the number of calls and observe() makes a decision\n * whether to continue recovering the styles or not.\n */\n\nclass ExtMutationObserver {\n  /**\n   * Extra property for keeping 'style fix counts'.\n   */\n\n  /**\n   * Creates new ExtMutationObserver.\n   *\n   * @param protectionCallback Callback which execution should be counted.\n   */\n  constructor(protectionCallback) {\n    this.styleProtectionCount = 0;\n    this.observer = new natives.MutationObserver(mutations => {\n      if (!mutations.length) {\n        return;\n      }\n\n      this.styleProtectionCount += 1;\n      protectionCallback(mutations, this);\n    });\n  }\n  /**\n   * Starts to observe target element,\n   * prevents infinite loop of observing due to the limited number of times of callback runs.\n   *\n   * @param target Target to observe.\n   * @param options Mutation observer options.\n   */\n\n\n  observe(target, options) {\n    if (this.styleProtectionCount < MAX_STYLE_PROTECTION_COUNT) {\n      this.observer.observe(target, options);\n    } else {\n      logger.error('ExtendedCss: infinite loop protection for style');\n    }\n  }\n  /**\n   * Stops ExtMutationObserver from observing any mutations.\n   * Until the `observe()` is used again, `protectionCallback` will not be invoked.\n   */\n\n\n  disconnect() {\n    this.observer.disconnect();\n  }\n\n}\n\nconst PROTECTION_OBSERVER_OPTIONS = {\n  attributes: true,\n  attributeOldValue: true,\n  attributeFilter: ['style']\n};\n/**\n * Creates MutationObserver protection callback.\n *\n * @param styles Styles data object.\n *\n * @returns Callback for styles protection.\n */\n\nconst createProtectionCallback = styles => {\n  const protectionCallback = (mutations, extObserver) => {\n    if (!mutations[0]) {\n      return;\n    }\n\n    const {\n      target\n    } = mutations[0];\n    extObserver.disconnect();\n    styles.forEach(style => {\n      setStyleToElement(target, style);\n    });\n    extObserver.observe(target, PROTECTION_OBSERVER_OPTIONS);\n  };\n\n  return protectionCallback;\n};\n/**\n * Sets up a MutationObserver which protects style attributes from changes.\n *\n * @param node DOM node.\n * @param rules Rule data objects.\n * @returns Mutation observer used to protect attribute or null if there's nothing to protect.\n */\n\n\nconst protectStyleAttribute = (node, rules) => {\n  if (!natives.MutationObserver) {\n    return null;\n  }\n\n  const styles = [];\n  rules.forEach(ruleData => {\n    const {\n      style\n    } = ruleData; // some rules might have only debug property in style declaration\n    // e.g. 'div:has(> a) { debug: true }' -> parsed to boolean `ruleData.debug`\n    // so no style is fine, and here we should collect only valid styles to protect\n\n    if (style) {\n      styles.push(style);\n    }\n  });\n  const protectionObserver = new ExtMutationObserver(createProtectionCallback(styles));\n  protectionObserver.observe(node, PROTECTION_OBSERVER_OPTIONS);\n  return protectionObserver;\n};\n\nconst STATS_DECIMAL_DIGITS_COUNT = 4;\n\n/**\n * A helper class for applied rule stats.\n */\nclass TimingStats {\n  /**\n   * Creates new TimingStats.\n   */\n  constructor() {\n    this.appliesTimings = [];\n    this.appliesCount = 0;\n    this.timingsSum = 0;\n    this.meanTiming = 0;\n    this.squaredSum = 0;\n    this.standardDeviation = 0;\n  }\n  /**\n   * Observe target element and mark observer as active.\n   *\n   * @param elapsedTimeMs Time in ms.\n   */\n\n\n  push(elapsedTimeMs) {\n    this.appliesTimings.push(elapsedTimeMs);\n    this.appliesCount += 1;\n    this.timingsSum += elapsedTimeMs;\n    this.meanTiming = this.timingsSum / this.appliesCount;\n    this.squaredSum += elapsedTimeMs * elapsedTimeMs;\n    this.standardDeviation = Math.sqrt(this.squaredSum / this.appliesCount - Math.pow(this.meanTiming, 2));\n  }\n\n}\n\n/**\n * Makes the timestamps more readable.\n *\n * @param timestamp Raw timestamp.\n *\n * @returns Fine-looking timestamps.\n */\nconst beautifyTimingNumber = timestamp => {\n  return Number(timestamp.toFixed(STATS_DECIMAL_DIGITS_COUNT));\n};\n/**\n * Improves timing stats readability.\n *\n * @param rawTimings Collected timings with raw timestamp.\n *\n * @returns Fine-looking timing stats.\n */\n\n\nconst beautifyTimings = rawTimings => {\n  return {\n    appliesTimings: rawTimings.appliesTimings.map(t => beautifyTimingNumber(t)),\n    appliesCount: beautifyTimingNumber(rawTimings.appliesCount),\n    timingsSum: beautifyTimingNumber(rawTimings.timingsSum),\n    meanTiming: beautifyTimingNumber(rawTimings.meanTiming),\n    standardDeviation: beautifyTimingNumber(rawTimings.standardDeviation)\n  };\n};\n/**\n * Prints timing information if debugging mode is enabled.\n *\n * @param context ExtendedCss context.\n */\n\n\nconst printTimingInfo = context => {\n  if (context.areTimingsPrinted) {\n    return;\n  }\n\n  context.areTimingsPrinted = true;\n  const timingsLogData = {};\n  context.parsedRules.forEach(ruleData => {\n    if (ruleData.timingStats) {\n      const {\n        selector,\n        style,\n        debug,\n        matchedElements\n      } = ruleData; // style declaration for some rules is parsed to debug property and no style to apply\n      // e.g. 'div:has(> a) { debug: true }'\n\n      if (!style && !debug) {\n        throw new Error(`Rule should have style declaration for selector: '${selector}'`);\n      }\n\n      const selectorData = {\n        selectorParsed: selector,\n        timings: beautifyTimings(ruleData.timingStats)\n      }; // `ruleData.style` may contain `remove` pseudo-property\n      // and make logs look better\n\n      if (style && style[REMOVE_PSEUDO_MARKER] === PSEUDO_PROPERTY_POSITIVE_VALUE) {\n        selectorData.removed = true; // no matchedElements for such case as they are removed after ExtendedCss applied\n      } else {\n        selectorData.styleApplied = style || null;\n        selectorData.matchedElements = matchedElements;\n      }\n\n      timingsLogData[selector] = selectorData;\n    }\n  });\n\n  if (Object.keys(timingsLogData).length === 0) {\n    return;\n  } // add location.href to the message to distinguish frames\n\n\n  logger.info('[ExtendedCss] Timings in milliseconds for %o:\\n%o', window.location.href, timingsLogData);\n};\n\n/**\n * Finds affectedElement object for the specified DOM node.\n *\n * @param affElements Array of affected elements  context.affectedElements.\n * @param domNode DOM node.\n * @returns Found affectedElement or undefined.\n */\n\nconst findAffectedElement = (affElements, domNode) => {\n  return affElements.find(affEl => affEl.node === domNode);\n};\n/**\n * Applies specified rule and returns list of elements affected.\n *\n * @param context ExtendedCss context.\n * @param ruleData Rule to apply.\n * @returns List of elements affected by the rule.\n */\n\n\nconst applyRule = (context, ruleData) => {\n  // debugging mode can be enabled in two ways:\n  // 1. for separate rules - by `{ debug: true; }`\n  // 2. for all rules simultaneously by:\n  //   - `{ debug: global; }` in any rule\n  //   - positive `debug` property in ExtCssConfiguration\n  const isDebuggingMode = !!ruleData.debug || context.debug;\n  let startTime;\n\n  if (isDebuggingMode) {\n    startTime = performance.now();\n  }\n\n  const {\n    ast\n  } = ruleData;\n  const nodes = []; // selector can be successfully parser into ast with no error\n  // but its applying by native Document.querySelectorAll() still may throw an error\n  // e.g. 'div[..banner]'\n\n  try {\n    nodes.push(...selectElementsByAst(ast));\n  } catch (e) {\n    // log the error only in debug mode\n    if (context.debug) {\n      logger.error(getErrorMessage(e));\n    }\n  }\n\n  nodes.forEach(node => {\n    let affectedElement = findAffectedElement(context.affectedElements, node);\n\n    if (affectedElement) {\n      affectedElement.rules.push(ruleData);\n      applyStyle(context, affectedElement);\n    } else {\n      // Applying style first time\n      const originalStyle = node.style.cssText;\n      affectedElement = {\n        node,\n        // affected DOM node\n        rules: [ruleData],\n        // rule to be applied\n        originalStyle,\n        // original node style\n        protectionObserver: null // style attribute observer\n\n      };\n      applyStyle(context, affectedElement);\n      context.affectedElements.push(affectedElement);\n    }\n  });\n\n  if (isDebuggingMode && startTime) {\n    const elapsedTimeMs = performance.now() - startTime;\n\n    if (!ruleData.timingStats) {\n      ruleData.timingStats = new TimingStats();\n    }\n\n    ruleData.timingStats.push(elapsedTimeMs);\n  }\n\n  return nodes;\n};\n/**\n * Applies filtering rules.\n *\n * @param context ExtendedCss context.\n */\n\n\nconst applyRules = context => {\n  const newSelectedElements = []; // some rules could make call - selector.querySelectorAll() temporarily to change node id attribute\n  // this caused MutationObserver to call recursively\n  // https://github.com/AdguardTeam/ExtendedCss/issues/81\n\n  disconnectDocument(context);\n  context.parsedRules.forEach(ruleData => {\n    const nodes = applyRule(context, ruleData);\n    Array.prototype.push.apply(newSelectedElements, nodes); // save matched elements to ruleData as linked to applied rule\n    // only for debugging purposes\n\n    if (ruleData.debug) {\n      ruleData.matchedElements = nodes;\n    }\n  }); // Now revert styles for elements which are no more affected\n\n  let affLength = context.affectedElements.length; // do nothing if there is no elements to process\n\n  while (affLength) {\n    const affectedElement = context.affectedElements[affLength - 1];\n\n    if (!affectedElement) {\n      break;\n    }\n\n    if (!newSelectedElements.includes(affectedElement.node)) {\n      // Time to revert style\n      revertStyle(affectedElement);\n      context.affectedElements.splice(affLength - 1, 1);\n    } else if (!affectedElement.removed) {\n      // Add style protection observer\n      // Protect \"style\" attribute from changes\n      if (!affectedElement.protectionObserver) {\n        affectedElement.protectionObserver = protectStyleAttribute(affectedElement.node, affectedElement.rules);\n      }\n    }\n\n    affLength -= 1;\n  } // After styles are applied we can start observe again\n\n\n  observeDocument(context);\n  printTimingInfo(context);\n};\n\n/**\n * Result of selector validation.\n */\n\n/**\n * Main class of ExtendedCss lib.\n *\n * Parses css stylesheet with any selectors (passed to its argument as styleSheet),\n * and guarantee its applying as mutation observer is used to prevent the restyling of needed elements by other scripts.\n * This style protection is limited to 50 times to avoid infinite loop (MAX_STYLE_PROTECTION_COUNT).\n * Our own ThrottleWrapper is used for styles applying to avoid too often lib reactions on page mutations.\n *\n * Constructor creates the instance of class which should be run be `apply()` method to apply the rules,\n * and the applying can be stopped by `dispose()`.\n *\n * Can be used to select page elements by selector with `query()` method (similar to `Document.querySelectorAll()`),\n * which does not require instance creating.\n */\nclass ExtendedCss {\n  /**\n   * Creates new ExtendedCss.\n   *\n   * @param configuration ExtendedCss configuration.\n   */\n  constructor(configuration) {\n    if (!configuration) {\n      throw new Error('ExtendedCss configuration should be provided.');\n    }\n\n    this.applyRulesCallbackListener = this.applyRulesCallbackListener.bind(this);\n    this.context = {\n      beforeStyleApplied: configuration.beforeStyleApplied,\n      debug: false,\n      affectedElements: [],\n      isDomObserved: false,\n      removalsStatistic: {},\n      parsedRules: [],\n      scheduler: new ThrottleWrapper(this.applyRulesCallbackListener)\n    }; // TODO: throw an error instead of logging and handle it in related products.\n\n    if (!isBrowserSupported()) {\n      logger.error('Browser is not supported by ExtendedCss');\n      return;\n    } // at least 'styleSheet' or 'cssRules' should be provided\n\n\n    if (!configuration.styleSheet && !configuration.cssRules) {\n      throw new Error(\"ExtendedCss configuration should have 'styleSheet' or 'cssRules' defined.\");\n    } // 'styleSheet' and 'cssRules' are optional\n    // and both can be provided at the same time\n    // so both should be parsed and applied in such case\n\n\n    if (configuration.styleSheet) {\n      // stylesheet parsing can fail on some invalid selectors\n      try {\n        this.context.parsedRules.push(...parseStylesheet(configuration.styleSheet, extCssDocument));\n      } catch (e) {\n        // eslint-disable-next-line max-len\n        throw new Error(`Pass the rules as configuration.cssRules since configuration.styleSheet cannot be parsed because of: '${getErrorMessage(e)}'`);\n      }\n    }\n\n    if (configuration.cssRules) {\n      this.context.parsedRules.push(...parseRules(configuration.cssRules, extCssDocument));\n    } // true if set in configuration\n    // or any rule in styleSheet has `debug: global`\n\n\n    this.context.debug = configuration.debug || this.context.parsedRules.some(ruleData => {\n      return ruleData.debug === DEBUG_PSEUDO_PROPERTY_GLOBAL_VALUE;\n    });\n\n    if (this.context.beforeStyleApplied && typeof this.context.beforeStyleApplied !== 'function') {\n      // eslint-disable-next-line max-len\n      throw new Error(`Invalid configuration. Type of 'beforeStyleApplied' should be a function, received: '${typeof this.context.beforeStyleApplied}'`);\n    }\n  }\n  /**\n   * Invokes {@link applyRules} function with current app context.\n   * \n   * This method is bound to the class instance in the constructor because it is called\n   * in {@link ThrottleWrapper} and on the DOMContentLoaded event.\n   */\n\n\n  applyRulesCallbackListener() {\n    applyRules(this.context);\n  }\n  /**\n   * Initializes ExtendedCss.\n   *\n   * Should be executed on page ASAP,\n   * otherwise the :contains() pseudo-class may work incorrectly.\n   */\n\n\n  init() {\n    /**\n     * Native Node textContent getter must be intercepted as soon as possible,\n     * and stored as it is needed for proper work of :contains() pseudo-class\n     * because DOM Node prototype 'textContent' property may be mocked.\n     *\n     * @see {@link https://github.com/AdguardTeam/ExtendedCss/issues/127}\n     */\n    nativeTextContent.setGetter();\n  }\n  /**\n   * Applies stylesheet rules on page.\n   */\n\n\n  apply() {\n    applyRules(this.context);\n\n    if (document.readyState !== 'complete') {\n      document.addEventListener('DOMContentLoaded', this.applyRulesCallbackListener, false);\n    }\n  }\n  /**\n   * Disposes ExtendedCss and removes our styles from matched elements.\n   */\n\n\n  dispose() {\n    disconnectDocument(this.context);\n    this.context.affectedElements.forEach(el => {\n      revertStyle(el);\n    });\n    document.removeEventListener('DOMContentLoaded', this.applyRulesCallbackListener, false);\n  }\n  /**\n   * Exposed for testing purposes only.\n   *\n   * @returns Array of AffectedElement data objects.\n   */\n\n\n  getAffectedElements() {\n    return this.context.affectedElements;\n  }\n  /**\n   * Returns a list of the document's elements that match the specified selector.\n   * Uses ExtCssDocument.querySelectorAll().\n   *\n   * @param selector Selector text.\n   * @param [noTiming=true] If true  do not print the timings to the console.\n   *\n   * @throws An error if selector is not valid.\n   * @returns A list of elements that match the selector.\n   */\n\n\n  static query(selector) {\n    let noTiming = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (typeof selector !== 'string') {\n      throw new Error('Selector should be defined as a string.');\n    }\n\n    const start = performance.now();\n\n    try {\n      return extCssDocument.querySelectorAll(selector);\n    } finally {\n      const end = performance.now();\n\n      if (!noTiming) {\n        logger.info(`[ExtendedCss] Elapsed: ${Math.round((end - start) * 1000)} s.`);\n      }\n    }\n  }\n  /**\n   * Validates selector.\n   *\n   * @param inputSelector Selector text to validate.\n   *\n   * @returns Result of selector validation.\n   */\n\n\n  static validate(inputSelector) {\n    try {\n      // ExtendedCss in general supports :remove() in selector\n      // but ExtendedCss.query() does not support it as it should be parsed by stylesheet parser.\n      // so for validation we have to handle selectors with `:remove()` in it\n      const {\n        selector\n      } = parseRemoveSelector(inputSelector);\n      ExtendedCss.query(selector);\n      return {\n        ok: true,\n        error: null\n      };\n    } catch (e) {\n      // not valid input `selector` should be logged eventually\n      const error = `Error: Invalid selector: '${inputSelector}' -- ${getErrorMessage(e)}`;\n      return {\n        ok: false,\n        error\n      };\n    }\n  }\n\n}\n\nexport { ExtendedCss };\n","import browser from 'webextension-polyfill';\nimport { ExtendedCss } from '@adguard/extended-css';\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\n\n/**\n * @file\n * This file contains constants for communication between background and content scripts.\n * This constants are separated from message.ts to reduce bundle size,\n * because rollup cannot tree-shake tswebextension library code.\n */\n/**\n * Name of the message handler.\n * It is needed for determining specific tswebextension message from other messages.\n */\nconst MESSAGE_HANDLER_NAME = 'tsWebExtension';\n/**\n * Message types for communication between background and content scripts.\n */\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"ProcessShouldCollapse\"] = \"processShouldCollapse\";\n    MessageType[\"GetCosmeticData\"] = \"getCosmeticData\";\n    MessageType[\"GetCss\"] = \"getCss\";\n    MessageType[\"GetCookieRules\"] = \"getCookieRules\";\n    MessageType[\"SaveCookieLogEvent\"] = \"saveCookieLogEvent\";\n    MessageType[\"InitAssistant\"] = \"initAssistant\";\n    MessageType[\"CloseAssistant\"] = \"closeAssistant\";\n    MessageType[\"AssistantCreateRule\"] = \"assistantCreateRule\";\n    MessageType[\"SaveCssHitsStats\"] = \"saveCssHitsStats\";\n})(MessageType || (MessageType = {}));\n\n// TODO check if we can return typed message here\n/**\n * Sends message to the background page.\n *\n * @param message Message to send.\n * @param message.payload Payload of the message.\n * @param message.type Message type.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst sendAppMessage = (message) => __awaiter(void 0, void 0, void 0, function* () {\n    return browser.runtime.sendMessage(Object.assign({ handlerName: MESSAGE_HANDLER_NAME }, message));\n});\n\n/**\n * This class applies cookie rules in page context.\n *\n * - Removes cookies matching rules\n * - Listens to new cookies, then tries to apply rules to them.\n */\nclass CookieController {\n    /**\n     * Constructor.\n     *\n     * @param callback On rule applied callback.\n     */\n    constructor(callback) {\n        /**\n         * Default cookie polling interval.\n         */\n        this.DEFAULT_COOKIE_POLLING_INTERVAL_MS = 1000;\n        /**\n         * Is current context third-party.\n         */\n        this.isThirdPartyContext = false;\n        this.onRuleAppliedCallback = callback;\n        this.isThirdPartyContext = this.isThirdPartyFrame();\n    }\n    /**\n     * Applies rules.\n     *\n     * @param rules Rules to apply.\n     */\n    apply(rules) {\n        this.applyRules(rules);\n        let lastCookie = document.cookie;\n        this.listenCookieChange((oldValue, newValue) => {\n            if (newValue === lastCookie) {\n                // Skip changes made by this class\n                return;\n            }\n            this.applyRules(rules);\n            lastCookie = document.cookie;\n        });\n        window.addEventListener('beforeunload', () => {\n            this.applyRules(rules);\n        });\n    }\n    /**\n     * Polling document cookie.\n     *\n     * @param callback Callback to be called periodically.\n     * @param interval Polling interval.\n     */\n    listenCookieChange(callback, interval = this.DEFAULT_COOKIE_POLLING_INTERVAL_MS) {\n        let lastCookie = document.cookie;\n        setInterval(() => {\n            const { cookie } = document;\n            if (cookie !== lastCookie) {\n                try {\n                    callback(lastCookie, cookie);\n                }\n                finally {\n                    lastCookie = cookie;\n                }\n            }\n        }, interval);\n    }\n    /**\n     * Checks if current context is third-party.\n     *\n     * @returns True if current context is third-party.\n     */\n    // eslint-disable-next-line class-methods-use-this\n    isThirdPartyFrame() {\n        try {\n            return window.self !== window.top && document.location.hostname !== window.parent.location.hostname;\n        }\n        catch (e) {\n            return true;\n        }\n    }\n    /**\n     * Applies rules to document cookies.\n     *\n     * @param rules Rules to apply.\n     *\n     * Inspired by remove-cookie scriptlet.\n     * @see {@link https://github.com/AdguardTeam/Scriptlets/blob/master/src/scriptlets/remove-cookie.js}\n     */\n    applyRules(rules) {\n        document.cookie.split(';').forEach((cookieStr) => {\n            const pos = cookieStr.indexOf('=');\n            if (pos === -1) {\n                return;\n            }\n            const cookieName = cookieStr.slice(0, pos).trim();\n            const cookieValue = cookieStr.slice(pos + 1).trim();\n            const matchingRules = rules.filter((r) => {\n                if (this.isThirdPartyContext !== r.isThirdParty) {\n                    return false;\n                }\n                const regex = r.match ? CookieController.toRegExp(r.match) : CookieController.toRegExp('/.?/');\n                return regex.test(cookieName);\n            });\n            const importantRules = matchingRules.filter((r) => r.ruleText.includes('important'));\n            if (importantRules.length > 0) {\n                importantRules.forEach((rule) => {\n                    this.applyRule(rule, cookieName, cookieValue);\n                });\n            }\n            else {\n                const allowlistRules = matchingRules.filter((r) => r.isAllowlist);\n                if (allowlistRules.length > 0) {\n                    allowlistRules.forEach((rule) => {\n                        this.applyRule(rule, cookieName, cookieValue);\n                    });\n                }\n                else {\n                    matchingRules.forEach((rule) => {\n                        this.applyRule(rule, cookieName, cookieValue);\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * Applies rule.\n     *\n     * @param rule Rule to apply.\n     * @param cookieName Cookie name.\n     * @param cookieValue Cookie value.\n     */\n    applyRule(rule, cookieName, cookieValue) {\n        if (!rule.isAllowlist) {\n            const hostParts = document.location.hostname.split('.');\n            for (let i = 0; i <= hostParts.length - 1; i += 1) {\n                const hostName = hostParts.slice(i).join('.');\n                if (hostName) {\n                    CookieController.removeCookieFromHost(cookieName, hostName);\n                }\n            }\n        }\n        this.onRuleAppliedCallback({\n            cookieName,\n            cookieValue,\n            cookieDomain: document.location.hostname,\n            cookieRuleText: rule.ruleText,\n            thirdParty: rule.isThirdParty,\n            filterId: rule.filterId,\n        });\n    }\n    /**\n     * Removes cookie for host.\n     *\n     * @param cookieName Cookie name.\n     * @param hostName Host name.\n     */\n    static removeCookieFromHost(cookieName, hostName) {\n        const cookieSpec = `${cookieName}=`;\n        const domain1 = `; domain=${hostName}`;\n        const domain2 = `; domain=.${hostName}`;\n        const path = '; path=/';\n        const expiration = '; expires=Thu, 01 Jan 1970 00:00:00 GMT';\n        document.cookie = cookieSpec + expiration;\n        document.cookie = cookieSpec + domain1 + expiration;\n        document.cookie = cookieSpec + domain2 + expiration;\n        document.cookie = cookieSpec + path + expiration;\n        document.cookie = cookieSpec + domain1 + path + expiration;\n        document.cookie = cookieSpec + domain2 + path + expiration;\n    }\n    /**\n     * Converts cookie rule match to regular expression.\n     *\n     * @param str String to convert.\n     * @returns Regular expression.\n     */\n    static toRegExp(str) {\n        if (str[0] === '/' && str[str.length - 1] === '/') {\n            return new RegExp(str.slice(1, -1));\n        }\n        const escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        return new RegExp(`^${escaped}$`);\n    }\n}\n\n/**\n * Utils class.\n */\nclass ElementUtils {\n    /**\n     * Serialize HTML element.\n     *\n     * @param element Element to serialize.\n     *\n     * @returns String representation of the element.\n     */\n    static elementToString(element) {\n        const s = [];\n        s.push('<');\n        s.push(element.localName);\n        const { attributes } = element;\n        for (let i = 0; i < attributes.length; i += 1) {\n            const attr = attributes[i];\n            s.push(' ');\n            s.push(attr.name);\n            s.push('=\"');\n            const value = attr.value === null ? '' : attr.value.replace(/\"/g, '\\\\\"');\n            s.push(value);\n            s.push('\"');\n        }\n        s.push('>');\n        return s.join('');\n    }\n    /**\n     * Appends node children to the array.\n     *\n     * @param node Element whose children we would like to add.\n     * @param arrayWithNodes Array where we add children.\n     */\n    static appendChildren(node, arrayWithNodes) {\n        const children = node.querySelectorAll('*');\n        if (children && children.length > 0) {\n            for (let i = 0; i < children.length; i += 1) {\n                arrayWithNodes.push(children[i]);\n            }\n        }\n    }\n    /**\n     * Adds elements into array if they are not in the array yet.\n     *\n     * @param targetArray Array where we add elements.\n     * @param sourceArray Array with elements.\n     */\n    static addUnique(targetArray, sourceArray) {\n        if (sourceArray.length > 0) {\n            for (let i = 0; i < sourceArray.length; i += 1) {\n                const sourceElement = sourceArray[i];\n                if (targetArray.indexOf(sourceElement) === -1) {\n                    targetArray.push(sourceElement);\n                }\n            }\n        }\n    }\n    /**\n     * Removes all elements in array.\n     *\n     * @param elements Array with elements.\n     */\n    static removeElements(elements) {\n        for (let i = 0; i < elements.length; i += 1) {\n            const element = elements[i];\n            element.remove();\n        }\n    }\n    /**\n     * Parses hits info from style content.\n     *\n     * @param content Style.\n     * @param attributeMarker Attribute marker.\n     *\n     * @returns Info with filterId, ruleText or null.\n     */\n    static parseInfo(content, attributeMarker) {\n        if (!content || content.indexOf(attributeMarker) < 0) {\n            return null;\n        }\n        let filterIdAndRuleText = decodeURIComponent(content);\n        // 'content' value may include open and close quotes.\n        filterIdAndRuleText = ElementUtils.removeQuotes(filterIdAndRuleText);\n        // Remove prefix\n        filterIdAndRuleText = filterIdAndRuleText.substring(attributeMarker.length);\n        // Attribute 'content' in css looks like: {content: 'adguard{filterId};{ruleText}'}\n        const index = filterIdAndRuleText.indexOf(';');\n        if (index < 0) {\n            return null;\n        }\n        const filterId = parseInt(filterIdAndRuleText.substring(0, index), 10);\n        if (Number.isNaN(filterId)) {\n            return null;\n        }\n        const ruleText = filterIdAndRuleText.substring(index + 1);\n        return { filterId, ruleText };\n    }\n    /**\n     * Parses hits info from style content.\n     *\n     * @param content Style.\n     * @param attributeMarker Attribute marker.\n     *\n     * @returns Info with filterId, ruleText or null.\n     */\n    static parseExtendedStyleInfo(content, attributeMarker) {\n        const important = '!important';\n        const indexOfImportant = content.lastIndexOf(important);\n        if (indexOfImportant === -1) {\n            return ElementUtils.parseInfo(content, attributeMarker);\n        }\n        const contentWithoutImportant = content.substring(0, indexOfImportant).trim();\n        return ElementUtils.parseInfo(contentWithoutImportant, attributeMarker);\n    }\n    /**\n     * Unquotes specified value.\n     *\n     * @param value Value to unquote.\n     *\n     * @returns Unquoted value.\n     */\n    static removeQuotes(value) {\n        if (value.length > 1\n            && ((value[0] === '\"' && value[value.length - 1] === '\"')\n                || (value[0] === '\\'' && value[value.length - 1] === '\\''))) {\n            // Remove double-quotes or single-quotes\n            return value.substring(1, value.length - 1);\n        }\n        return value;\n    }\n}\n\n// TODO remove the comment turning off the rule\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * This storage is used to keep track of counted rules received from node elements.\n */\nclass HitsStorage {\n    constructor() {\n        /**\n         * Start count number.\n         */\n        this.counter = 0;\n        /**\n         * Storage random identificator.\n         */\n        this.randomKey = HitsStorage.generateRandomKey();\n        /**\n         * Map storage.\n         */\n        this.map = new Map();\n    }\n    /**\n     * Checks if element is counted.\n     *\n     * @param element Html element.\n     * @param rule Rule text.\n     *\n     * @returns True if element is counted.\n     */\n    isCounted(element, rule) {\n        const hitAddress = element[this.randomKey];\n        if (hitAddress) {\n            const countedHit = this.map.get(hitAddress);\n            if (countedHit) {\n                return countedHit.element === element && countedHit.rule === rule;\n            }\n        }\n        return false;\n    }\n    /**\n     * Stores rule-element info in storage.\n     *\n     * @param element Html element.\n     * @param rule Rule text.\n     */\n    setCounted(element, rule) {\n        const counter = this.getCounter();\n        // eslint-disable-next-line no-param-reassign\n        element[this.randomKey] = counter;\n        this.map.set(counter, { element, rule });\n    }\n    /**\n     * Returns current counter value and increments it.\n     *\n     * @returns Count number.\n     */\n    getCounter() {\n        this.counter += 1;\n        return this.counter;\n    }\n    // TODO replace with nanoid\n    /**\n     * Random id generator.\n     *\n     * @returns Random key with 10 characters length.\n     */\n    static generateRandomKey() {\n        const keyLength = 10;\n        const possibleValues = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        let result = '';\n        for (let i = 0; i < keyLength; i += 1) {\n            result += possibleValues.charAt(Math.floor(Math.random() * possibleValues.length));\n        }\n        return result;\n    }\n}\n\n/**\n * Class represents collecting css style hits process.\n *\n * During applying css styles to element we add special 'content:' attribute\n *  e.g.: \".selector -> .selector { content: 'adguard{filterId};{ruleText} !important;}\".\n * After the style is applied we parse this \"content\" attribute and call provided via constructor callback function.\n */\nclass CssHitsCounter {\n    /**\n     * This function prepares calculation of css hits.\n     * We are waiting for 'load' event and start calculation.\n     *\n     * @param callback Which receives {@link ICountedElement} and handles counted css hits.\n     */\n    constructor(callback) {\n        /**\n         * Hits storage.\n         */\n        this.hitsStorage = new HitsStorage();\n        /**\n         * Mutation observer.\n         */\n        this.observer = null;\n        /**\n         * Counting on process flag.\n         */\n        this.countIsWorking = false;\n        this.onCssHitsFoundCallback = callback;\n        if (document.readyState === 'complete'\n            || document.readyState === 'interactive') {\n            this.countCssHits();\n        }\n        else {\n            document.addEventListener('readystatechange', this.startCounter.bind(this));\n        }\n    }\n    /**\n     * Stops css hits counting process.\n     */\n    stop() {\n        this.onCssHitsFoundCallback = () => { };\n        if (this.observer) {\n            this.observer.disconnect();\n        }\n    }\n    /**\n     * Callback used to collect statistics of elements affected by extended css rules.\n     *\n     * @param affectedEl Affected element.\n     * @returns Affected element.\n     */\n    countAffectedByExtendedCss(affectedEl) {\n        if (affectedEl && affectedEl.rules && affectedEl.rules.length > 0) {\n            const result = [];\n            for (const rule of affectedEl.rules) {\n                if (rule.style && rule.style.content) {\n                    const styleInfo = ElementUtils.parseExtendedStyleInfo(rule.style.content, CssHitsCounter.CONTENT_ATTR_PREFIX);\n                    if (styleInfo === null) {\n                        continue;\n                    }\n                    const { filterId, ruleText } = styleInfo;\n                    if (filterId !== undefined && ruleText !== undefined) {\n                        result.push({\n                            filterId,\n                            ruleText,\n                            element: ElementUtils.elementToString(affectedEl.node),\n                        });\n                        // clear style content to avoid duplicate counting\n                        rule.style.content = '';\n                    }\n                }\n            }\n            this.onCssHitsFoundCallback(result);\n        }\n        return affectedEl;\n    }\n    /**\n     * Starts counting process.\n     */\n    startCounter() {\n        if (document.readyState === 'interactive'\n            || document.readyState === 'complete') {\n            this.countCssHits();\n            document.removeEventListener('readystatechange', this.startCounter);\n        }\n    }\n    /**\n     * Counts css hits.\n     */\n    countCssHits() {\n        this.countAllCssHits();\n        this.countCssHitsForMutations();\n    }\n    /**\n     * Counts css hits for already affected elements.\n     */\n    countAllCssHits() {\n        // we don't start counting again all css hits till previous count process wasn't finished\n        if (this.countIsWorking) {\n            return;\n        }\n        this.countIsWorking = true;\n        const elements = document.querySelectorAll('*');\n        this.countCssHitsBatch(elements, 0, CssHitsCounter.CSS_HITS_BATCH_SIZE, CssHitsCounter.CSS_HITS_BATCH_SIZE, [], (result) => {\n            if (result.length > 0) {\n                this.onCssHitsFoundCallback(result);\n            }\n            this.countIsWorking = false;\n        });\n    }\n    /**\n     * Main calculation function.\n     * 1. Selects sub collection from elements.\n     * 2. For each element from sub collection: retrieves calculated css 'content'\n     * attribute and if it contains 'adguard'\n     * marker then retrieves rule text and filter identifier.\n     * 3. Starts next task with some delay.\n     *\n     * @param elements Collection of all elements.\n     * @param start Start of batch.\n     * @param end End of batch.\n     * @param step Size of batch.\n     * @param result Collection for save result.\n     * @param callback Finish callback.\n     */\n    // eslint-disable-next-line max-len\n    countCssHitsBatch(elements, start, end, step, result, callback) {\n        const length = Math.min(end, elements.length);\n        result = result.concat(this.countCssHitsForElements(elements, start, length));\n        if (length === elements.length) {\n            callback(result);\n            return;\n        }\n        start = end;\n        end += step;\n        // Start next task with some delay\n        window.setTimeout(() => {\n            this.countCssHitsBatch(elements, start, end, step, result, callback);\n        }, CssHitsCounter.COUNT_CSS_HITS_BATCH_DELAY);\n    }\n    /**\n     * Counts css hits for array of elements.\n     *\n     * @param elements Array of elements.\n     * @param start Start of batch.\n     * @param length Length of batch.\n     *\n     * @returns Data with information about filter id, rule text and element.\n     */\n    countCssHitsForElements(elements, start, length) {\n        const RULE_FILTER_SEPARATOR = ';';\n        start = start || 0;\n        length = length || elements.length;\n        const result = [];\n        for (let i = start; i < length; i += 1) {\n            const element = elements[i];\n            const cssHitData = CssHitsCounter.getCssHitData(element);\n            if (!cssHitData) {\n                continue;\n            }\n            const { filterId, ruleText } = cssHitData;\n            const ruleAndFilterString = filterId + RULE_FILTER_SEPARATOR + ruleText;\n            if (this.hitsStorage.isCounted(element, ruleAndFilterString)) {\n                continue;\n            }\n            this.hitsStorage.setCounted(element, ruleAndFilterString);\n            result.push({\n                filterId,\n                ruleText,\n                element: ElementUtils.elementToString(element),\n            });\n        }\n        return result;\n    }\n    /**\n     * Counts css hits for mutations.\n     */\n    countCssHitsForMutations() {\n        // eslint-disable-next-line prefer-destructuring\n        const MutationObserver = window.MutationObserver;\n        if (!MutationObserver) {\n            return;\n        }\n        if (this.observer) {\n            this.observer.disconnect();\n        }\n        /**\n         * To avoid cases where two css hits counters try to append and remove the\n         * same elements one after the other, we do not append already met nodes.\n         */\n        const probesWeakSet = new WeakSet();\n        let timeoutId = null;\n        this.observer = new MutationObserver(((mutationRecords) => {\n            // Collect probe elements, count them, then remove from their targets\n            const probeElements = [];\n            const childrenOfProbeElements = [];\n            const potentialProbeElements = [];\n            mutationRecords.forEach((mutationRecord) => {\n                if (mutationRecord.addedNodes.length === 0) {\n                    return;\n                }\n                for (let i = 0; i < mutationRecord.addedNodes.length; i += 1) {\n                    const node = mutationRecord.addedNodes[i];\n                    if (!(node instanceof Element) || CssHitsCounter.isIgnoredNodeTag(node.tagName)) {\n                        continue;\n                    }\n                    const { target } = mutationRecord;\n                    if (!node.parentNode && target) {\n                        // If this node has been appended to the DOM and counted once, do not add\n                        // it again.\n                        if (probesWeakSet.has(node)) {\n                            return;\n                        }\n                        // Most likely this is a \"probe\" element that was added and then\n                        // immediately removed from DOM.\n                        // We re-add it and check if any rule matched it\n                        probeElements.push(node);\n                        // To ensure that this \"probe\" node has only been added once to the DOM,\n                        // we add it to the weak set.\n                        probesWeakSet.add(node);\n                        // CSS rules could be applied to the nodes inside probe element\n                        // that's why we get all child elements of added node\n                        ElementUtils.appendChildren(node, childrenOfProbeElements);\n                        if (this.observer) {\n                            this.observer.disconnect();\n                        }\n                        mutationRecord.target.appendChild(node);\n                    }\n                    else if (node.parentNode && target) {\n                        // Sometimes probe elements are appended to the DOM\n                        potentialProbeElements.push(node);\n                        ElementUtils.appendChildren(node, potentialProbeElements);\n                    }\n                }\n            });\n            // If the list of potential probe elements is relatively small,\n            // we can count CSS hits immediately\n            if (potentialProbeElements.length > 0\n                && potentialProbeElements.length <= CssHitsCounter.CSS_HITS_BATCH_SIZE) {\n                const result = this.countCssHitsForElements(potentialProbeElements, 0, null);\n                if (result.length > 0) {\n                    this.onCssHitsFoundCallback(result);\n                }\n            }\n            const allProbeElements = [];\n            ElementUtils.addUnique(allProbeElements, childrenOfProbeElements);\n            ElementUtils.addUnique(allProbeElements, probeElements);\n            if (allProbeElements.length > 0) {\n                const result = this.countCssHitsForElements(allProbeElements, 0, null);\n                if (result.length > 0) {\n                    this.onCssHitsFoundCallback(result);\n                }\n                /**\n                 * Don't remove child elements of probe elements\n                 * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1096.\n                 */\n                ElementUtils.removeElements(probeElements);\n                this.startObserver();\n            }\n            // debounce counting all css hits when mutation record fires\n            if (timeoutId) {\n                window.clearTimeout(timeoutId);\n            }\n            timeoutId = window.setTimeout(() => {\n                this.countAllCssHits();\n                window.clearTimeout(timeoutId);\n            }, CssHitsCounter.COUNT_ALL_CSS_HITS_TIMEOUT_MS);\n        }));\n        this.startObserver();\n    }\n    /**\n     * Starts mutation observer.\n     */\n    startObserver() {\n        if (this.observer) {\n            // TODO: Check, maybe we should observer for 'characterData' and\n            // 'characterDataOldValue' like it was in the old extension code\n            this.observer.observe(document.documentElement, {\n                childList: true,\n                subtree: true,\n                attributes: true,\n            });\n        }\n    }\n    /**\n     * Function retrieves css hits data from element style content attribute contains data injected with AdGuard.\n     *\n     * @param element Element to check.\n     * @returns Filter id and rule text or null.\n     */\n    static getCssHitData(element) {\n        const style = getComputedStyle(element);\n        return ElementUtils.parseInfo(style.content, CssHitsCounter.CONTENT_ATTR_PREFIX);\n    }\n    /**\n     * Checks if tag is ignored.\n     *\n     * @param nodeTag Tag name to check.\n     * @returns True if tag is ignored.\n     */\n    static isIgnoredNodeTag(nodeTag) {\n        const ignoredTags = ['script'];\n        return ignoredTags.includes(nodeTag.toLowerCase());\n    }\n}\n/**\n * We split CSS hits counting into smaller batches of elements and schedule them one by one using setTimeout.\n */\nCssHitsCounter.COUNT_CSS_HITS_BATCH_DELAY = 5;\n/**\n * Size of small batches of elements we count.\n */\nCssHitsCounter.CSS_HITS_BATCH_SIZE = 25;\n/**\n * In order to find elements hidden by AdGuard we look for a `:content` pseudo-class\n * with values starting with this prefix. Filter information will be\n * encoded in this value as well.\n */\nCssHitsCounter.CONTENT_ATTR_PREFIX = 'adguard';\n/**\n * We delay countAllCssHits function if it was called too frequently from mutationObserver.\n */\nCssHitsCounter.COUNT_ALL_CSS_HITS_TIMEOUT_MS = 500;\n\nvar RequestType = {\n    NotSet: 0,\n    Document: 1,\n    SubDocument: 2,\n    Script: 4,\n    Stylesheet: 8,\n    Object: 16,\n    Image: 32,\n    XmlHttpRequest: 64,\n    Media: 128,\n    Font: 256,\n    WebSocket: 512,\n    Ping: 1024,\n    Other: 2048,\n};\n\n/**\n * Css, injected to broken element for hiding.\n */\n// eslint-disable-next-line max-len\nconst HIDING_STYLE = '{ display: none!important; visibility: hidden!important; height: 0px!important; min-height: 0px!important; }';\n/**\n * Creates hiding css rule for specified tag with src attribute.\n *\n * @param tag Element tag for css selector.\n * @param src `src` attribute value for css selector. If value is the empty string\n * then the selector does not represent anything.\n * @param matching Attribute matching type. Currently support strict (=) and suffix ($=) matching.\n * Default to strict.\n *\n * @returns Css rule text.\n */\nfunction createHidingCssRule(tag, src, matching = \"=\" /* AttributeMatching.Strict */) {\n    return `${tag}[src${matching}\"${src}\"] ${HIDING_STYLE}\\n`;\n}\n\n/**\n * Hides broken items after blocking a network request.\n */\nclass ElementCollapser {\n    /**\n     * Creates new element collapser.\n     */\n    constructor() {\n        this.shouldCollapseElement = this.shouldCollapseElement.bind(this);\n    }\n    /**\n     * Starts listening for error events.\n     */\n    start() {\n        document.addEventListener('error', this.shouldCollapseElement, true);\n        // We need to listen for load events to hide blocked iframes (they don't raise error event)\n        document.addEventListener('load', this.shouldCollapseElement, true);\n    }\n    /**\n     * Stops listening for error events.\n     */\n    stop() {\n        document.removeEventListener('error', this.shouldCollapseElement, true);\n        // We need to listen for load events to hide blocked iframes (they don't raise error event)\n        document.removeEventListener('load', this.shouldCollapseElement, true);\n    }\n    /**\n     * Appends Css rule to {@link #styleNode} sheet.\n     *\n     * @param rule - Css rule text.\n     */\n    appendCssRule(rule) {\n        if (!this.styleNode) {\n            this.styleNode = document.createElement('style');\n            this.styleNode.setAttribute('type', 'text/css');\n            (document.head || document.documentElement).appendChild(this.styleNode);\n        }\n        if (this.styleNode.sheet) {\n            this.styleNode.sheet.insertRule(rule, this.styleNode.sheet.cssRules.length);\n        }\n    }\n    /**\n     * Checks if element should be collapsed by requirements.\n     *\n     * @param event Error or load event.\n     */\n    shouldCollapseElement(event) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const eventType = event.type;\n            const element = event.target;\n            const tagName = element.tagName.toLowerCase();\n            const expectedEventType = (tagName === 'iframe'\n                || tagName === 'frame'\n                || tagName === 'embed') ? 'load' : 'error';\n            if (eventType !== expectedEventType) {\n                return;\n            }\n            const requestType = ElementCollapser.getRequestTypeByInitiatorTagName(element.localName);\n            if (!requestType) {\n                return;\n            }\n            const elementUrl = ElementCollapser.getElementUrl(element);\n            if (!elementUrl) {\n                return;\n            }\n            if (ElementCollapser.isElementCollapsed(element)) {\n                return;\n            }\n            const payload = {\n                elementUrl,\n                documentUrl: document.URL,\n                requestType,\n            };\n            const shouldCollapse = yield sendAppMessage({\n                type: MessageType.ProcessShouldCollapse,\n                payload,\n            });\n            if (!shouldCollapse) {\n                return;\n            }\n            const srcAttribute = element.getAttribute('src');\n            if (srcAttribute) {\n                const rule = createHidingCssRule(tagName, CSS.escape(srcAttribute));\n                this.appendCssRule(rule);\n            }\n            else {\n                element.setAttribute('style', HIDING_STYLE);\n            }\n        });\n    }\n    /**\n     * Returns request type by tag name.\n     *\n     * @param tagName Tag name.\n     * @returns Request type or null.\n     */\n    static getRequestTypeByInitiatorTagName(tagName) {\n        switch (tagName) {\n            case 'img':\n            case 'input': {\n                return RequestType.Image;\n            }\n            case 'audio':\n            case 'video': {\n                return RequestType.Media;\n            }\n            case 'object':\n            case 'embed': {\n                return RequestType.Object;\n            }\n            case 'frame':\n            case 'iframe':\n                return RequestType.SubDocument;\n            default:\n                return null;\n        }\n    }\n    /**\n     * Extracts element URL from the dom node.\n     *\n     * @param element Dom node.\n     * @returns Element URL or null.\n     */\n    static getElementUrl(element) {\n        let elementUrl = element.src || element.data;\n        if (!elementUrl\n            || elementUrl.indexOf('http') !== 0\n            // Some sources could not be set yet, lazy loaded images or smth.\n            // In some cases like on gog.com, collapsing these elements could break\n            // the page script loading their sources\n            || elementUrl === element.baseURI) {\n            return null;\n        }\n        // truncate too long urls\n        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1493\n        const MAX_URL_LENGTH = 16 * 1024;\n        if (elementUrl.length > MAX_URL_LENGTH) {\n            elementUrl = elementUrl.slice(0, MAX_URL_LENGTH);\n        }\n        return elementUrl;\n    }\n    /**\n     * Checks if element is already collapsed.\n     *\n     * @param element DOM element.\n     * @returns True if element is collapsed.\n     */\n    static isElementCollapsed(element) {\n        const computedStyle = window.getComputedStyle(element);\n        return (computedStyle && computedStyle.display === 'none');\n    }\n}\n\n/**\n * This class applies cosmetic rules in page context.\n */\nclass CosmeticController {\n    /**\n     * Creates new {@link CosmeticController} instance.\n     */\n    constructor() {\n        /**\n         * Number of {@link MessageType.GetCosmeticData} requests.\n         */\n        this.tries = 0;\n        this.process = this.process.bind(this);\n        this.beforeStyleApplied = this.beforeStyleApplied.bind(this);\n    }\n    /**\n     * Init cosmetic processing.\n     */\n    init() {\n        const elementCollapser = new ElementCollapser();\n        elementCollapser.start();\n        this.process();\n    }\n    /**\n     * Sends {@link MessageType.GetCosmeticData} message to background and process response.\n     */\n    process() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const res = yield sendAppMessage({\n                type: MessageType.GetCosmeticData,\n                payload: {\n                    documentUrl: window.location.href,\n                },\n            });\n            if (res) {\n                this.applyCosmetic(res);\n            }\n        });\n    }\n    /**\n     * Process {@link MessageType.GetCosmeticData} response from background.\n     *\n     * If {@link cosmeticData.isAppStarted} is false, retry\n     * request after {@link GET_COSMETIC_DATA_RETRY_TIMEOUT_MS} milliseconds.\n     * Else apply extended css rules from {@link cosmeticData.extCssText}\n     * and enable {@link CssHitsCounter} if {@link cosmeticData.areHitsStatsCollected} is true.\n     *\n     * @param cosmeticData Response cosmetic data from background.\n     */\n    applyCosmetic(cosmeticData) {\n        const { isAppStarted, extCssRules, areHitsStatsCollected, } = cosmeticData;\n        if (!isAppStarted\n            && this.tries <= CosmeticController.MAX_GET_COSMETIC_DATA_TRIES) {\n            this.tries += 1;\n            setTimeout(this.process, CosmeticController.GET_COSMETIC_DATA_RETRY_TIMEOUT_MS);\n            return;\n        }\n        if (areHitsStatsCollected) {\n            this.cssHitsCounter = CosmeticController.createCssHitsCounter();\n        }\n        if (!extCssRules || extCssRules.length === 0) {\n            return;\n        }\n        const extendedCssConfig = {\n            cssRules: extCssRules,\n        };\n        if (areHitsStatsCollected) {\n            extendedCssConfig.beforeStyleApplied = this.beforeStyleApplied;\n        }\n        const extendedCss = new ExtendedCss(extendedCssConfig);\n        extendedCss.apply();\n    }\n    /**\n     * Preprocess {@link IAffectedElement} for {@link ExtendedCss} instance.\n     *\n     * @param el Record with required 'content' style property in rules.\n     * @returns Affected element record.\n     */\n    beforeStyleApplied(el) {\n        if (!this.cssHitsCounter) {\n            return el;\n        }\n        return this.cssHitsCounter.countAffectedByExtendedCss(el);\n    }\n    /**\n     * Create new {@link CssHitsCounter} instance.\n     *\n     * @returns CssHitsCounter instance.\n     */\n    static createCssHitsCounter() {\n        return new CssHitsCounter((stats) => {\n            sendAppMessage({\n                type: MessageType.SaveCssHitsStats,\n                payload: stats,\n            });\n        });\n    }\n}\n/**\n * Retry timeout for {@link MessageType.GetCosmeticData} request to background in milliseconds.\n */\nCosmeticController.GET_COSMETIC_DATA_RETRY_TIMEOUT_MS = 100;\n/**\n * Max {@link MessageType.GetCosmeticData} request limit.\n */\nCosmeticController.MAX_GET_COSMETIC_DATA_TRIES = 200;\n\n/**\n * Initializes assistant object and create messages listener for assistant.\n */\nconst initAssistant = () => {\n    if (window.top !== window || !(document.documentElement instanceof HTMLElement)) {\n        return;\n    }\n    browser.runtime.onMessage.addListener((message) => __awaiter(void 0, void 0, void 0, function* () {\n        switch (message.type) {\n            case MessageType.InitAssistant: {\n                // If there is no assistant on the window after execute\n                // loading script - throw error.\n                if (window.adguardAssistant === undefined) {\n                    throw new Error('adguardAssistant not found in the window object.');\n                }\n                else {\n                    window.adguardAssistant.close();\n                }\n                window.adguardAssistant.start(null, (rules) => {\n                    sendAppMessage({\n                        type: MessageType.AssistantCreateRule,\n                        payload: { ruleText: rules },\n                    });\n                });\n                break;\n            }\n            case MessageType.CloseAssistant: {\n                if (window.adguardAssistant) {\n                    window.adguardAssistant.close();\n                }\n                break;\n            }\n        }\n    }));\n};\n\n// Disable jest coverage for this file, because it will insert\n// line comments, and code to count lines covered by tests, for example:\n// /* istanbul ignore next */\n// cov_uqm40oh03().f[0]++;\n// cov_uqm40oh03().s[2]++;\n// And we cannot test these strings correctly, because the names of these\n// functions with counters are generated at runtime\n/* istanbul ignore file */\n/**\n * This module applies stealth actions in page context.\n */\nclass StealthHelper {\n    /**\n     * Sends a Global Privacy Control DOM signal.\n     */\n    static setDomSignal() {\n        try {\n            if ('globalPrivacyControl' in Navigator.prototype) {\n                return;\n            }\n            Object.defineProperty(Navigator.prototype, 'globalPrivacyControl', {\n                get: () => true,\n                configurable: true,\n                enumerable: true,\n            });\n        }\n        catch (ex) {\n            // Ignore\n        }\n    }\n}\n\nconst cosmeticController = new CosmeticController();\ncosmeticController.init();\ninitAssistant();\n/**\n * TODO: wait for engine starts (like in {@link CosmeticController}).\n *\n * Runs CookieController.\n *\n * Steps:\n * - content script requests matching cookie rules for the frame(in which this script is executed)\n * - service returns matching set of rules data to content script\n * - the rules are applied with TSUrlFilterContentScript.CookieController\n * - filtering log receives callback with applied rules data.\n *\n * The important point is:\n * - there is no way to run cookie controller script via chrome.tabs.executeScript cause one only could be executed\n * for all frames or main frame only. But it's not correct cause there should be different rules\n * for each frame.\n */\n(() => __awaiter(void 0, void 0, void 0, function* () {\n    const response = yield sendAppMessage({\n        type: MessageType.GetCookieRules,\n        payload: {\n            documentUrl: window.location.href,\n        },\n    });\n    if (!response) {\n        return;\n    }\n    if (response.rulesData) {\n        try {\n            const cookieController = new CookieController(({ cookieName, cookieValue, cookieDomain, cookieRuleText, thirdParty, filterId, }) => {\n                sendAppMessage({\n                    type: MessageType.SaveCookieLogEvent,\n                    payload: {\n                        cookieName,\n                        cookieValue,\n                        cookieDomain,\n                        cookieRuleText,\n                        thirdParty,\n                        filterId,\n                    },\n                });\n            });\n            cookieController.apply(response.rulesData);\n        }\n        catch (e) {\n            // Ignore exceptions\n        }\n    }\n}))();\n\nexport { CookieController, CssHitsCounter, StealthHelper };\n","/**\n * @file\n * This file is part of Adguard API library (https://github.com/AdguardTeam/tsurlfilter/packages/adguard-api).\n *\n * Adguard API is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Adguard API is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Adguard API. If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport \"@adguard/tswebextension/content-script\";\n"],"names":[],"sourceRoot":""}