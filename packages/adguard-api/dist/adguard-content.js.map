{"version":3,"file":"adguard-content.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;ACVA;AACA,MAAM,IAA0C;AAChD,IAAI,iCAAgC,CAAC,MAAQ,CAAC,oCAAE,OAAO;AAAA;AAAA;AAAA,kGAAC;AACxD,IAAI,KAAK,YAQN;AACH,CAAC;AACD;;AAEA,sCAAsC;;AAEtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wHAAwH;AACxH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG;AACpB,mBAAmB,SAAS;AAC5B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA,iBAAiB,UAAU;AAC3B;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;;AAGA;AACA;AACA;AACA,iDAAiD,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AAC5I;;AAEA;AACA,gDAAgD,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AAC3I;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB,gCAAgC,MAAM;AACtC,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,iBAAiB,QAAQ,cAAc;AACvC;AACA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA,iBAAiB,QAAQ,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mBAAmB;AACnB;;AAEA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA,eAAe;AACf;AACA;;AAEA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oCAAoC;AACrD;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;;AAGA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,aAAa;AAChC;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA,0EAA0E;AAC1E;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA,YAAY;;;AAGZ;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AAC1I;;AAEA;AACA,8CAA8C,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AACzI;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;;;;;;;UCpvCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,+BAA+B;AAC7E;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC,SAAS;;AAElD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;;;AAGA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uCAAuC;AACvC;;AAEA,wCAAwC,KAAK;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;;;AAGA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;;;AAGN;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,YAAY;AACZ;;;AAGA;AACA,8CAA8C;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;;;AAGA;AACA;AACA,2BAA2B,0CAA0C;AACrE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;;AAGA;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,QAAQ;;AAEvB;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;;AAEvB;AACA,eAAe,QAAQ;;AAEvB;AACA;AACA;AACA,WAAW,QAAQ;AACnB;;;AAGA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;;AAEvB;AACA,eAAe,QAAQ;AACvB;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2CAA2C,aAAa;AACxD;AACA;;;AAGA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,yBAAyB,IAAI;AAC7B;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;;AAGZ;AACA,UAAU;;;AAGV;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO,GAAG;;;AAGV;AACA,wFAAwF;AACxF;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,uBAAuB;;AAEvB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA,UAAU;;;AAGV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,oBAAoB;;AAEpB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB,gBAAgB;AAChB;AACA,gCAAgC;AAChC,gBAAgB;AAChB;AACA;AACA;AACA,cAAc;;;AAGd;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;;;AAGlB;AACA;;AAEA;AACA;AACA;;AAEA,gDAAgD;;AAEhD;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;;AAGV;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;;;AAGA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;;;AAGZ;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,iBAAiB,UAAU;AAC3B;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B,mBAAmB,QAAQ;AAC3B;;;AAGA;AACA;AACA,iGAAiG;;AAEjG;AACA;AACA,UAAU;;;AAGV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,6BAA6B;AACvD;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,gBAAgB;AAChB;;;AAGA;;AAEA;AACA;AACA;;AAEA,+CAA+C;AAC/C;AACA;AACA,YAAY;AACZ;AACA,YAAY;;;AAGZ;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC,mBAAmB,wBAAwB;AAC3C;;;AAGA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC,mBAAmB,QAAQ;AAC3B;;;AAGA;AACA;AACA;AACA,oEAAoE;;AAEpE;AACA;AACA,UAAU;;;AAGV;AACA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA,wEAAwE;AACxE,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,GAAG;;AAEZ,wFAAwF;AACxF;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,GAAG;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;;;AAGlB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;;AAGV;AACA;AACA,sDAAsD;AACtD,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,uDAAuD;;AAEvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yMAAyM;AACzM;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA,cAAc;;;AAGd;AACA;AACA,cAAc;AACd;AACA;;;AAGA;AACA;AACA,cAAc;AACd;AACA;;;AAGA;AACA;AACA;AACA,WAAW;AACX;AACA,0IAA0I;AAC1I;;AAEA;AACA;AACA,6DAA6D;AAC7D;;AAEA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA,cAAc;AACd;;;AAGA;;AAEA;AACA;AACA,cAAc;;;AAGd;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;;AAEA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA,oEAAoE;AACpE;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;;;AAGZ;;AAEA;AACA;AACA,YAAY;;;AAGZ;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;;;AAGd;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA,kJAAkJ;AAClJ,YAAY;AACZ;AACA,YAAY;;;AAGZ;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;;;AAGZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;;;AAGA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;;AAGA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;;;AAGV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+DAA+D;;AAE/D;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;AAGA;AACA,uEAAuE;AACvE,cAAc;AACd;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA,cAAc;;;AAGd;AACA,qDAAqD;AACrD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;;;AAGd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;;;AAGtB;AACA;;AAEA;AACA;;AAEA,0EAA0E;;AAE1E;AACA;AACA;AACA;AACA,mEAAmE,GAAG;AACtE;;AAEA,4FAA4F;AAC5F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,qEAAqE,GAAG;AACxE;;AAEA,8FAA8F;AAC9F;AACA;AACA;AACA,oBAAoB;AACpB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,GAAG;AAC9E;;AAEA,oGAAoG;AACpG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;;AAGlB;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,qIAAqI;AACrI;AACA;;AAEA;AACA;AACA,cAAc;;;AAGd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,kDAAkD;;AAElD;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA,2EAA2E,UAAU;AACrF,gDAAgD,2BAA2B;AAC3E;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA;AACA;;AAEA;AACA,YAAY;;AAEZ;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,aAAa;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,OAAO;AAC5B;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B,mBAAmB;AAC7C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,OAAO;AAC5B;;;AAGA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,WAAW;;;AAGX;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,iBAAiB,GAAG;AACpB;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sCAAsC;AAC1D,oBAAoB,QAAQ;AAC5B,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG,0BAA0B,sBAAsB;AACpE,mBAAmB,sBAAsB;AACzC;;;AAGA;AACA;AACA;AACA;AACA,yDAAyD;;AAEzD;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;;AAEd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,YAAY;;;AAGZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,iEAAiE,GAAG;AACpE;;AAEA,0FAA0F;;AAE1F;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA,+CAA+C,6BAA6B;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA,YAAY;;;AAGZ;AACA;AACA,gDAAgD;;AAEhD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;;;AAGhB;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd,YAAY;AACZ;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,+LAA+L;;AAE/L;AACA;AACA,SAAS;;AAET,eAAe,SAAS;AACxB;AACA;AACA,YAAY;AACZ,kFAAkF;;AAElF;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA,yDAAyD;;;AAGzD,iBAAiB,wCAAwC;AACzD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;;;AAGd;AACA;AACA;AACA;AACA,gBAAgB;;;AAGhB;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;;AAGhB;AACA,cAAc;;;AAGd,6CAA6C;;AAE7C;AACA;AACA;AACA,YAAY;;;AAGZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;;;AAGZ,oGAAoG;;AAEpG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA,iBAAiB,SAAS;AAC1B,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B;AAC9B,cAAc;AACd;AACA;;AAEA;AACA,YAAY;;;AAGZ;;AAEA;AACA,+BAA+B;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;;AAGA;AACA;AACA,SAAS;AACT;;;AAGA,mFAAmF;AACnF;;AAEA,iDAAiD;;AAEjD,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;;;AAGA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;;;AAGA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;;;AAGA,qBAAqB;AACrB,KAAK,UAAU;;AAEf;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA,sDAAsD;;AAEtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA,4BAA4B,EAAE,OAAO,EAAE;AACvC,yCAAyC;AACzC;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;;;AAGL;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;;AAGA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,IAAI;;;AAGJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;;;AAGA;AACA,uEAAuE,cAAc;AACrF;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA,QAAQ;;AAER,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,SAAS;AACvB,cAAc,eAAe;AAC7B,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;;;AAGL;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,WAAW;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ;;;AAGR,6CAA6C;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,GAAG;;AAEV;AACA,MAAM;AACN;AACA;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;;AAE5B;;AAEA;;AAEA;AACA;AACA;AACA,OAAO,GAAG;;AAEV;AACA;;AAEA;AACA;AACA,MAAM;AACN;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA;AACA,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,eAAe;AAC7B,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB,wBAAwB;AAC9C;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD;AAChD;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;;;AAGL;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,GAAG;;AAEV;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB;;AAExB,iCAAiC;;AAEjC,+CAA+C;;AAE/C,4CAA4C;;AAE5C,iDAAiD;;AAEjD,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gEAAgE;;AAEhE;AACA,4EAA4E;;AAE5E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,4DAA4D;AAC5D;;AAEA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mDAAmD;;AAEnD;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,qBAAqB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;;;AAGR,aAAa,OAAO;AACpB;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA,yCAAyC,OAAO;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;;AAEA,oDAAoD,kBAAkB;AACtE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,kJAAkJ;AAClJ;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;;AAEA,oDAAoD,kBAAkB;AACtE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;;AAEA,oDAAoD,kBAAkB;AACtE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;;;AAGA;AACA;AACA,wEAAwE;AACxE;;AAEA;AACA,0FAA0F;;AAE1F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB,yBAAyB,EAAE;AAC3B;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,kBAAkB,QAAQ,6BAA6B,wBAAwB;AAC/E,kBAAkB,QAAQ;AAC1B;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA,0BAA0B;;AAE1B;AACA,2BAA2B;AAC3B;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;;;AAGA,iDAAiD,OAAO;AACxD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,gEAAgE;;AAEhE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,gBAAgB,QAAQ,uBAAuB;AAC/C;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB;AACxB;AACA;;AAEA;AACA,mCAAmC,aAAa,QAAQ;;AAExD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B;;AAE5B;AACA;AACA,oCAAoC,cAAc;;AAElD,0BAA0B;AAC1B;AACA;AACA,QAAQ,0CAA0C;AAClD;;;AAGA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,2MAA2M;AAC3M;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,gEAAgE;;AAEhE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD;;AAEvD,0EAA0E;;AAE1E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,kCAAkC;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,GAAG;;AAER,qCAAqC;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,MAAM;;;AAGN;AACA,IAAI;;;AAGJ,kDAAkD;;AAElD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,sBAAsB;AACnC;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uDAAe,WAAW,EAAC;;;;;;ACpqKY;AACK;;AAE5C;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,kBAAkB,WAAW,SAAS;AACzF,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB,WAAW,UAAU,YAAY;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uBAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sCAAsC;AACtE;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8CAA2B,iBAAiB,mCAAmC;AAC1F,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oEAAoE,8BAA8B,uBAAuB,0BAA0B;AACnJ,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,2BAA2B,SAAS,SAAS;AAC7C,2BAA2B,UAAU,SAAS;AAC9C,wBAAwB;AACxB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wDAAqC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA,4BAA4B,gBAAW;AACvC;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6DAA6D,8EAA8E;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAE0C;;;ACpgC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@adguard/api/webpack/universalModuleDefinition","webpack://@adguard/api/../../node_modules/webextension-polyfill/dist/browser-polyfill.js","webpack://@adguard/api/webpack/bootstrap","webpack://@adguard/api/webpack/runtime/compat get default export","webpack://@adguard/api/webpack/runtime/define property getters","webpack://@adguard/api/webpack/runtime/hasOwnProperty shorthand","webpack://@adguard/api/webpack/runtime/make namespace object","webpack://@adguard/api/../../node_modules/extended-css/dist/extended-css.esm.js","webpack://@adguard/api/../tswebextension/dist/content-script.js","webpack://@adguard/api/./src/content-script/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(\"webextension-polyfill\", [\"module\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(module);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod);\n    global.browser = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (module) {\n  /* webextension-polyfill - v0.10.0 - Fri Aug 12 2022 19:42:44 */\n\n  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */\n\n  /* vim: set sts=2 sw=2 et tw=80: */\n\n  /* This Source Code Form is subject to the terms of the Mozilla Public\n   * License, v. 2.0. If a copy of the MPL was not distributed with this\n   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n  \"use strict\";\n\n  if (!globalThis.chrome?.runtime?.id) {\n    throw new Error(\"This script should only be loaded in a browser extension.\");\n  }\n\n  if (typeof globalThis.browser === \"undefined\" || Object.getPrototypeOf(globalThis.browser) !== Object.prototype) {\n    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = \"The message port closed before a response was received.\"; // Wrapping the bulk of this polyfill in a one-time-use function is a minor\n    // optimization for Firefox. Since Spidermonkey does not fully parse the\n    // contents of a function until the first time it's called, and since it will\n    // never actually need to be called, this allows the polyfill to be included\n    // in Firefox nearly for free.\n\n    const wrapAPIs = extensionAPIs => {\n      // NOTE: apiMetadata is associated to the content of the api-metadata.json file\n      // at build time by replacing the following \"include\" with the content of the\n      // JSON file.\n      const apiMetadata = {\n        \"alarms\": {\n          \"clear\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"clearAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"bookmarks\": {\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getChildren\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getRecent\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getSubTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTree\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"browserAction\": {\n          \"disable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"enable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"getBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"openPopup\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"browsingData\": {\n          \"remove\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"removeCache\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCookies\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeDownloads\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFormData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeHistory\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeLocalStorage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePasswords\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePluginData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"settings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"commands\": {\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"contextMenus\": {\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"cookies\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAllCookieStores\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"set\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"devtools\": {\n          \"inspectedWindow\": {\n            \"eval\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 2,\n              \"singleCallbackArg\": false\n            }\n          },\n          \"panels\": {\n            \"create\": {\n              \"minArgs\": 3,\n              \"maxArgs\": 3,\n              \"singleCallbackArg\": true\n            },\n            \"elements\": {\n              \"createSidebarPane\": {\n                \"minArgs\": 1,\n                \"maxArgs\": 1\n              }\n            }\n          }\n        },\n        \"downloads\": {\n          \"cancel\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"download\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"erase\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFileIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"open\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"pause\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFile\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"resume\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"extension\": {\n          \"isAllowedFileSchemeAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"isAllowedIncognitoAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"history\": {\n          \"addUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"deleteRange\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getVisits\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"i18n\": {\n          \"detectLanguage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAcceptLanguages\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"identity\": {\n          \"launchWebAuthFlow\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"idle\": {\n          \"queryState\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"management\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setEnabled\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"uninstallSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"notifications\": {\n          \"clear\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPermissionLevel\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"pageAction\": {\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"hide\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"permissions\": {\n          \"contains\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"request\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"runtime\": {\n          \"getBackgroundPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPlatformInfo\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"openOptionsPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"requestUpdateCheck\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"sendMessage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 3\n          },\n          \"sendNativeMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"setUninstallURL\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"sessions\": {\n          \"getDevices\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getRecentlyClosed\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"restore\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"storage\": {\n          \"local\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          },\n          \"managed\": {\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            }\n          },\n          \"sync\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          }\n        },\n        \"tabs\": {\n          \"captureVisibleTab\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"detectLanguage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"discard\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"duplicate\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"executeScript\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getZoom\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getZoomSettings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goBack\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goForward\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"highlight\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"insertCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"query\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"reload\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"sendMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 3\n          },\n          \"setZoom\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"setZoomSettings\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"update\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          }\n        },\n        \"topSites\": {\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"webNavigation\": {\n          \"getAllFrames\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFrame\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"webRequest\": {\n          \"handlerBehaviorChanged\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"windows\": {\n          \"create\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getLastFocused\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        }\n      };\n\n      if (Object.keys(apiMetadata).length === 0) {\n        throw new Error(\"api-metadata.json has not been included in browser-polyfill\");\n      }\n      /**\n       * A WeakMap subclass which creates and stores a value for any key which does\n       * not exist when accessed, but behaves exactly as an ordinary WeakMap\n       * otherwise.\n       *\n       * @param {function} createItem\n       *        A function which will be called in order to create the value for any\n       *        key which does not exist, the first time it is accessed. The\n       *        function receives, as its only argument, the key being created.\n       */\n\n\n      class DefaultWeakMap extends WeakMap {\n        constructor(createItem, items = undefined) {\n          super(items);\n          this.createItem = createItem;\n        }\n\n        get(key) {\n          if (!this.has(key)) {\n            this.set(key, this.createItem(key));\n          }\n\n          return super.get(key);\n        }\n\n      }\n      /**\n       * Returns true if the given object is an object with a `then` method, and can\n       * therefore be assumed to behave as a Promise.\n       *\n       * @param {*} value The value to test.\n       * @returns {boolean} True if the value is thenable.\n       */\n\n\n      const isThenable = value => {\n        return value && typeof value === \"object\" && typeof value.then === \"function\";\n      };\n      /**\n       * Creates and returns a function which, when called, will resolve or reject\n       * the given promise based on how it is called:\n       *\n       * - If, when called, `chrome.runtime.lastError` contains a non-null object,\n       *   the promise is rejected with that value.\n       * - If the function is called with exactly one argument, the promise is\n       *   resolved to that value.\n       * - Otherwise, the promise is resolved to an array containing all of the\n       *   function's arguments.\n       *\n       * @param {object} promise\n       *        An object containing the resolution and rejection functions of a\n       *        promise.\n       * @param {function} promise.resolve\n       *        The promise's resolution function.\n       * @param {function} promise.reject\n       *        The promise's rejection function.\n       * @param {object} metadata\n       *        Metadata about the wrapped method which has created the callback.\n       * @param {boolean} metadata.singleCallbackArg\n       *        Whether or not the promise is resolved with only the first\n       *        argument of the callback, alternatively an array of all the\n       *        callback arguments is resolved. By default, if the callback\n       *        function is invoked with only a single argument, that will be\n       *        resolved to the promise, while all arguments will be resolved as\n       *        an array if multiple are given.\n       *\n       * @returns {function}\n       *        The generated callback function.\n       */\n\n\n      const makeCallback = (promise, metadata) => {\n        return (...callbackArgs) => {\n          if (extensionAPIs.runtime.lastError) {\n            promise.reject(new Error(extensionAPIs.runtime.lastError.message));\n          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {\n            promise.resolve(callbackArgs[0]);\n          } else {\n            promise.resolve(callbackArgs);\n          }\n        };\n      };\n\n      const pluralizeArguments = numArgs => numArgs == 1 ? \"argument\" : \"arguments\";\n      /**\n       * Creates a wrapper function for a method with the given name and metadata.\n       *\n       * @param {string} name\n       *        The name of the method which is being wrapped.\n       * @param {object} metadata\n       *        Metadata about the method being wrapped.\n       * @param {integer} metadata.minArgs\n       *        The minimum number of arguments which must be passed to the\n       *        function. If called with fewer than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {integer} metadata.maxArgs\n       *        The maximum number of arguments which may be passed to the\n       *        function. If called with more than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {boolean} metadata.singleCallbackArg\n       *        Whether or not the promise is resolved with only the first\n       *        argument of the callback, alternatively an array of all the\n       *        callback arguments is resolved. By default, if the callback\n       *        function is invoked with only a single argument, that will be\n       *        resolved to the promise, while all arguments will be resolved as\n       *        an array if multiple are given.\n       *\n       * @returns {function(object, ...*)}\n       *       The generated wrapper function.\n       */\n\n\n      const wrapAsyncFunction = (name, metadata) => {\n        return function asyncFunctionWrapper(target, ...args) {\n          if (args.length < metadata.minArgs) {\n            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n          }\n\n          if (args.length > metadata.maxArgs) {\n            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n          }\n\n          return new Promise((resolve, reject) => {\n            if (metadata.fallbackToNoCallback) {\n              // This API method has currently no callback on Chrome, but it return a promise on Firefox,\n              // and so the polyfill will try to call it with a callback first, and it will fallback\n              // to not passing the callback if the first call fails.\n              try {\n                target[name](...args, makeCallback({\n                  resolve,\n                  reject\n                }, metadata));\n              } catch (cbError) {\n                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + \"falling back to call it without a callback: \", cbError);\n                target[name](...args); // Update the API method metadata, so that the next API calls will not try to\n                // use the unsupported callback anymore.\n\n                metadata.fallbackToNoCallback = false;\n                metadata.noCallback = true;\n                resolve();\n              }\n            } else if (metadata.noCallback) {\n              target[name](...args);\n              resolve();\n            } else {\n              target[name](...args, makeCallback({\n                resolve,\n                reject\n              }, metadata));\n            }\n          });\n        };\n      };\n      /**\n       * Wraps an existing method of the target object, so that calls to it are\n       * intercepted by the given wrapper function. The wrapper function receives,\n       * as its first argument, the original `target` object, followed by each of\n       * the arguments passed to the original method.\n       *\n       * @param {object} target\n       *        The original target object that the wrapped method belongs to.\n       * @param {function} method\n       *        The method being wrapped. This is used as the target of the Proxy\n       *        object which is created to wrap the method.\n       * @param {function} wrapper\n       *        The wrapper function which is called in place of a direct invocation\n       *        of the wrapped method.\n       *\n       * @returns {Proxy<function>}\n       *        A Proxy object for the given method, which invokes the given wrapper\n       *        method in its place.\n       */\n\n\n      const wrapMethod = (target, method, wrapper) => {\n        return new Proxy(method, {\n          apply(targetMethod, thisObj, args) {\n            return wrapper.call(thisObj, target, ...args);\n          }\n\n        });\n      };\n\n      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\n      /**\n       * Wraps an object in a Proxy which intercepts and wraps certain methods\n       * based on the given `wrappers` and `metadata` objects.\n       *\n       * @param {object} target\n       *        The target object to wrap.\n       *\n       * @param {object} [wrappers = {}]\n       *        An object tree containing wrapper functions for special cases. Any\n       *        function present in this object tree is called in place of the\n       *        method in the same location in the `target` object tree. These\n       *        wrapper methods are invoked as described in {@see wrapMethod}.\n       *\n       * @param {object} [metadata = {}]\n       *        An object tree containing metadata used to automatically generate\n       *        Promise-based wrapper functions for asynchronous. Any function in\n       *        the `target` object tree which has a corresponding metadata object\n       *        in the same location in the `metadata` tree is replaced with an\n       *        automatically-generated wrapper function, as described in\n       *        {@see wrapAsyncFunction}\n       *\n       * @returns {Proxy<object>}\n       */\n\n      const wrapObject = (target, wrappers = {}, metadata = {}) => {\n        let cache = Object.create(null);\n        let handlers = {\n          has(proxyTarget, prop) {\n            return prop in target || prop in cache;\n          },\n\n          get(proxyTarget, prop, receiver) {\n            if (prop in cache) {\n              return cache[prop];\n            }\n\n            if (!(prop in target)) {\n              return undefined;\n            }\n\n            let value = target[prop];\n\n            if (typeof value === \"function\") {\n              // This is a method on the underlying object. Check if we need to do\n              // any wrapping.\n              if (typeof wrappers[prop] === \"function\") {\n                // We have a special-case wrapper for this method.\n                value = wrapMethod(target, target[prop], wrappers[prop]);\n              } else if (hasOwnProperty(metadata, prop)) {\n                // This is an async method that we have metadata for. Create a\n                // Promise wrapper for it.\n                let wrapper = wrapAsyncFunction(prop, metadata[prop]);\n                value = wrapMethod(target, target[prop], wrapper);\n              } else {\n                // This is a method that we don't know or care about. Return the\n                // original method, bound to the underlying object.\n                value = value.bind(target);\n              }\n            } else if (typeof value === \"object\" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {\n              // This is an object that we need to do some wrapping for the children\n              // of. Create a sub-object wrapper for it with the appropriate child\n              // metadata.\n              value = wrapObject(value, wrappers[prop], metadata[prop]);\n            } else if (hasOwnProperty(metadata, \"*\")) {\n              // Wrap all properties in * namespace.\n              value = wrapObject(value, wrappers[prop], metadata[\"*\"]);\n            } else {\n              // We don't need to do any wrapping for this property,\n              // so just forward all access to the underlying object.\n              Object.defineProperty(cache, prop, {\n                configurable: true,\n                enumerable: true,\n\n                get() {\n                  return target[prop];\n                },\n\n                set(value) {\n                  target[prop] = value;\n                }\n\n              });\n              return value;\n            }\n\n            cache[prop] = value;\n            return value;\n          },\n\n          set(proxyTarget, prop, value, receiver) {\n            if (prop in cache) {\n              cache[prop] = value;\n            } else {\n              target[prop] = value;\n            }\n\n            return true;\n          },\n\n          defineProperty(proxyTarget, prop, desc) {\n            return Reflect.defineProperty(cache, prop, desc);\n          },\n\n          deleteProperty(proxyTarget, prop) {\n            return Reflect.deleteProperty(cache, prop);\n          }\n\n        }; // Per contract of the Proxy API, the \"get\" proxy handler must return the\n        // original value of the target if that value is declared read-only and\n        // non-configurable. For this reason, we create an object with the\n        // prototype set to `target` instead of using `target` directly.\n        // Otherwise we cannot return a custom object for APIs that\n        // are declared read-only and non-configurable, such as `chrome.devtools`.\n        //\n        // The proxy handlers themselves will still use the original `target`\n        // instead of the `proxyTarget`, so that the methods and properties are\n        // dereferenced via the original targets.\n\n        let proxyTarget = Object.create(target);\n        return new Proxy(proxyTarget, handlers);\n      };\n      /**\n       * Creates a set of wrapper functions for an event object, which handles\n       * wrapping of listener functions that those messages are passed.\n       *\n       * A single wrapper is created for each listener function, and stored in a\n       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`\n       * retrieve the original wrapper, so that  attempts to remove a\n       * previously-added listener work as expected.\n       *\n       * @param {DefaultWeakMap<function, function>} wrapperMap\n       *        A DefaultWeakMap object which will create the appropriate wrapper\n       *        for a given listener function when one does not exist, and retrieve\n       *        an existing one when it does.\n       *\n       * @returns {object}\n       */\n\n\n      const wrapEvent = wrapperMap => ({\n        addListener(target, listener, ...args) {\n          target.addListener(wrapperMap.get(listener), ...args);\n        },\n\n        hasListener(target, listener) {\n          return target.hasListener(wrapperMap.get(listener));\n        },\n\n        removeListener(target, listener) {\n          target.removeListener(wrapperMap.get(listener));\n        }\n\n      });\n\n      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {\n        if (typeof listener !== \"function\") {\n          return listener;\n        }\n        /**\n         * Wraps an onRequestFinished listener function so that it will return a\n         * `getContent()` property which returns a `Promise` rather than using a\n         * callback API.\n         *\n         * @param {object} req\n         *        The HAR entry object representing the network request.\n         */\n\n\n        return function onRequestFinished(req) {\n          const wrappedReq = wrapObject(req, {}\n          /* wrappers */\n          , {\n            getContent: {\n              minArgs: 0,\n              maxArgs: 0\n            }\n          });\n          listener(wrappedReq);\n        };\n      });\n      const onMessageWrappers = new DefaultWeakMap(listener => {\n        if (typeof listener !== \"function\") {\n          return listener;\n        }\n        /**\n         * Wraps a message listener function so that it may send responses based on\n         * its return value, rather than by returning a sentinel value and calling a\n         * callback. If the listener function returns a Promise, the response is\n         * sent when the promise either resolves or rejects.\n         *\n         * @param {*} message\n         *        The message sent by the other end of the channel.\n         * @param {object} sender\n         *        Details about the sender of the message.\n         * @param {function(*)} sendResponse\n         *        A callback which, when called with an arbitrary argument, sends\n         *        that value as a response.\n         * @returns {boolean}\n         *        True if the wrapped listener returned a Promise, which will later\n         *        yield a response. False otherwise.\n         */\n\n\n        return function onMessage(message, sender, sendResponse) {\n          let didCallSendResponse = false;\n          let wrappedSendResponse;\n          let sendResponsePromise = new Promise(resolve => {\n            wrappedSendResponse = function (response) {\n              didCallSendResponse = true;\n              resolve(response);\n            };\n          });\n          let result;\n\n          try {\n            result = listener(message, sender, wrappedSendResponse);\n          } catch (err) {\n            result = Promise.reject(err);\n          }\n\n          const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called\n          // wrappedSendResponse synchronously, we can exit earlier\n          // because there will be no response sent from this listener.\n\n          if (result !== true && !isResultThenable && !didCallSendResponse) {\n            return false;\n          } // A small helper to send the message if the promise resolves\n          // and an error if the promise rejects (a wrapped sendMessage has\n          // to translate the message into a resolved promise or a rejected\n          // promise).\n\n\n          const sendPromisedResult = promise => {\n            promise.then(msg => {\n              // send the message value.\n              sendResponse(msg);\n            }, error => {\n              // Send a JSON representation of the error if the rejected value\n              // is an instance of error, or the object itself otherwise.\n              let message;\n\n              if (error && (error instanceof Error || typeof error.message === \"string\")) {\n                message = error.message;\n              } else {\n                message = \"An unexpected error occurred\";\n              }\n\n              sendResponse({\n                __mozWebExtensionPolyfillReject__: true,\n                message\n              });\n            }).catch(err => {\n              // Print an error on the console if unable to send the response.\n              console.error(\"Failed to send onMessage rejected reply\", err);\n            });\n          }; // If the listener returned a Promise, send the resolved value as a\n          // result, otherwise wait the promise related to the wrappedSendResponse\n          // callback to resolve and send it as a response.\n\n\n          if (isResultThenable) {\n            sendPromisedResult(result);\n          } else {\n            sendPromisedResult(sendResponsePromise);\n          } // Let Chrome know that the listener is replying.\n\n\n          return true;\n        };\n      });\n\n      const wrappedSendMessageCallback = ({\n        reject,\n        resolve\n      }, reply) => {\n        if (extensionAPIs.runtime.lastError) {\n          // Detect when none of the listeners replied to the sendMessage call and resolve\n          // the promise to undefined as in Firefox.\n          // See https://github.com/mozilla/webextension-polyfill/issues/130\n          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {\n            resolve();\n          } else {\n            reject(new Error(extensionAPIs.runtime.lastError.message));\n          }\n        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {\n          // Convert back the JSON representation of the error into\n          // an Error instance.\n          reject(new Error(reply.message));\n        } else {\n          resolve(reply);\n        }\n      };\n\n      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {\n        if (args.length < metadata.minArgs) {\n          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        if (args.length > metadata.maxArgs) {\n          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        return new Promise((resolve, reject) => {\n          const wrappedCb = wrappedSendMessageCallback.bind(null, {\n            resolve,\n            reject\n          });\n          args.push(wrappedCb);\n          apiNamespaceObj.sendMessage(...args);\n        });\n      };\n\n      const staticWrappers = {\n        devtools: {\n          network: {\n            onRequestFinished: wrapEvent(onRequestFinishedWrappers)\n          }\n        },\n        runtime: {\n          onMessage: wrapEvent(onMessageWrappers),\n          onMessageExternal: wrapEvent(onMessageWrappers),\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 1,\n            maxArgs: 3\n          })\n        },\n        tabs: {\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 2,\n            maxArgs: 3\n          })\n        }\n      };\n      const settingMetadata = {\n        clear: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        get: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        set: {\n          minArgs: 1,\n          maxArgs: 1\n        }\n      };\n      apiMetadata.privacy = {\n        network: {\n          \"*\": settingMetadata\n        },\n        services: {\n          \"*\": settingMetadata\n        },\n        websites: {\n          \"*\": settingMetadata\n        }\n      };\n      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);\n    }; // The build process adds a UMD wrapper around this file, which makes the\n    // `module` variable available.\n\n\n    module.exports = wrapAPIs(chrome);\n  } else {\n    module.exports = globalThis.browser;\n  }\n});\n//# sourceMappingURL=browser-polyfill.js.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*! extended-css - v1.3.14 - Fri Mar 18 2022\n* https://github.com/AdguardTeam/ExtendedCss\n* Copyright (c) 2022 AdGuard. Licensed GPL-3.0\n*/\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n/**\n * Copyright 2016 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable no-console */\nvar utils = {};\nutils.MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n/**\n * Stores native Node textContent getter to be used for contains pseudo-class\n * because elements' 'textContent' and 'innerText' properties might be mocked\n * https://github.com/AdguardTeam/ExtendedCss/issues/127\n */\n\nutils.nodeTextContentGetter = function () {\n  var nativeNode = window.Node || Node;\n  return Object.getOwnPropertyDescriptor(nativeNode.prototype, 'textContent').get;\n}();\n\nutils.isSafariBrowser = function () {\n  return navigator.vendor === 'Apple Computer, Inc.';\n}();\n/**\n * Converts regular expressions passed as pseudo class arguments into RegExp instances.\n * Have to unescape doublequote \" as well, because we escape them while enclosing such\n * arguments with doublequotes, and sizzle does not automatically unescapes them.\n */\n\n\nutils.pseudoArgToRegex = function (regexSrc, flag) {\n  flag = flag || 'i';\n  regexSrc = regexSrc.trim().replace(/\\\\([\"\\\\])/g, '$1');\n  return new RegExp(regexSrc, flag);\n};\n/**\n * Converts string to the regexp\n * @param {string} str\n * @returns {RegExp}\n */\n\n\nutils.toRegExp = function (str) {\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n};\n\nutils.startsWith = function (str, prefix) {\n  // if str === '', (str && false) will return ''\n  // that's why it has to be !!str\n  return !!str && str.indexOf(prefix) === 0;\n};\n\nutils.endsWith = function (str, postfix) {\n  if (!str || !postfix) {\n    return false;\n  }\n\n  if (str.endsWith) {\n    return str.endsWith(postfix);\n  }\n\n  var t = String(postfix);\n  var index = str.lastIndexOf(t);\n  return index >= 0 && index === str.length - t.length;\n};\n/**\n * Helper function for creating regular expression from a url filter rule syntax.\n */\n\n\nutils.createURLRegex = function () {\n  // Constants\n  var regexConfiguration = {\n    maskStartUrl: '||',\n    maskPipe: '|',\n    maskSeparator: '^',\n    maskAnySymbol: '*',\n    regexAnySymbol: '.*',\n    regexSeparator: '([^ a-zA-Z0-9.%_-]|$)',\n    regexStartUrl: '^(http|https|ws|wss)://([a-z0-9-_.]+\\\\.)?',\n    regexStartString: '^',\n    regexEndString: '$'\n  }; // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp\n  // should be escaped . * + ? ^ $ { } ( ) | [ ] / \\\n  // except of * | ^\n\n  var specials = ['.', '+', '?', '$', '{', '}', '(', ')', '[', ']', '\\\\', '/'];\n  var specialsRegex = new RegExp(\"[\".concat(specials.join('\\\\'), \"]\"), 'g');\n  /**\n   * Escapes regular expression string\n   */\n\n  var escapeRegExp = function escapeRegExp(str) {\n    return str.replace(specialsRegex, '\\\\$&');\n  };\n\n  var replaceAll = function replaceAll(str, find, replace) {\n    if (!str) {\n      return str;\n    }\n\n    return str.split(find).join(replace);\n  };\n  /**\n   * Main function that converts a url filter rule string to a regex.\n   * @param {string} str\n   * @return {RegExp}\n   */\n\n\n  var createRegexText = function createRegexText(str) {\n    var regex = escapeRegExp(str);\n\n    if (utils.startsWith(regex, regexConfiguration.maskStartUrl)) {\n      regex = regex.substring(0, regexConfiguration.maskStartUrl.length) + replaceAll(regex.substring(regexConfiguration.maskStartUrl.length, regex.length - 1), '\\|', '\\\\|') + regex.substring(regex.length - 1);\n    } else if (utils.startsWith(regex, regexConfiguration.maskPipe)) {\n      regex = regex.substring(0, regexConfiguration.maskPipe.length) + replaceAll(regex.substring(regexConfiguration.maskPipe.length, regex.length - 1), '\\|', '\\\\|') + regex.substring(regex.length - 1);\n    } else {\n      regex = replaceAll(regex.substring(0, regex.length - 1), '\\|', '\\\\|') + regex.substring(regex.length - 1);\n    } // Replacing special url masks\n\n\n    regex = replaceAll(regex, regexConfiguration.maskAnySymbol, regexConfiguration.regexAnySymbol);\n    regex = replaceAll(regex, regexConfiguration.maskSeparator, regexConfiguration.regexSeparator);\n\n    if (utils.startsWith(regex, regexConfiguration.maskStartUrl)) {\n      regex = regexConfiguration.regexStartUrl + regex.substring(regexConfiguration.maskStartUrl.length);\n    } else if (utils.startsWith(regex, regexConfiguration.maskPipe)) {\n      regex = regexConfiguration.regexStartString + regex.substring(regexConfiguration.maskPipe.length);\n    }\n\n    if (utils.endsWith(regex, regexConfiguration.maskPipe)) {\n      regex = regex.substring(0, regex.length - 1) + regexConfiguration.regexEndString;\n    }\n\n    return new RegExp(regex, 'i');\n  };\n\n  return createRegexText;\n}();\n/**\n * Creates an object implementing Location interface from a url.\n * An alternative to URL.\n * https://github.com/AdguardTeam/FingerprintingBlocker/blob/master/src/shared/url.ts#L64\n */\n\n\nutils.createLocation = function (href) {\n  var anchor = document.createElement('a');\n  anchor.href = href;\n\n  if (anchor.host === '') {\n    anchor.href = anchor.href; // eslint-disable-line no-self-assign\n  }\n\n  return anchor;\n};\n/**\n * Checks whether A has the same origin as B.\n * @param {string} urlA location.href of A.\n * @param {Location} locationB location of B.\n * @param {string} domainB document.domain of B.\n * @return {boolean}\n */\n\n\nutils.isSameOrigin = function (urlA, locationB, domainB) {\n  var locationA = utils.createLocation(urlA); // eslint-disable-next-line no-script-url\n\n  if (locationA.protocol === 'javascript:' || locationA.href === 'about:blank') {\n    return true;\n  }\n\n  if (locationA.protocol === 'data:' || locationA.protocol === 'file:') {\n    return false;\n  }\n\n  return locationA.hostname === domainB && locationA.port === locationB.port && locationA.protocol === locationB.protocol;\n};\n/**\n * A helper class to throttle function calls with setTimeout and requestAnimationFrame.\n */\n\n\nutils.AsyncWrapper = function () {\n  var supported = typeof window.requestAnimationFrame !== 'undefined';\n  var rAF = supported ? requestAnimationFrame : setTimeout;\n  var cAF = supported ? cancelAnimationFrame : clearTimeout;\n  var perf = supported ? performance : Date;\n  /**\n   * @param {Function} callback\n   * @param {number} throttle number, the provided callback should be executed twice\n   * in this time frame.\n   * @constructor\n   */\n\n  function AsyncWrapper(callback, throttle) {\n    this.callback = callback;\n    this.throttle = throttle;\n    this.wrappedCallback = this.wrappedCallback.bind(this);\n\n    if (this.wrappedAsapCallback) {\n      this.wrappedAsapCallback = this.wrappedAsapCallback.bind(this);\n    }\n  }\n  /** @private */\n\n\n  AsyncWrapper.prototype.wrappedCallback = function (ts) {\n    this.lastRun = isNumber(ts) ? ts : perf.now();\n    delete this.rAFid;\n    delete this.timerId;\n    delete this.asapScheduled;\n    this.callback();\n  };\n  /** @private Indicates whether there is a scheduled callback. */\n\n\n  AsyncWrapper.prototype.hasPendingCallback = function () {\n    return isNumber(this.rAFid) || isNumber(this.timerId);\n  };\n  /**\n   * Schedules a function call before the next animation frame.\n   */\n\n\n  AsyncWrapper.prototype.run = function () {\n    if (this.hasPendingCallback()) {\n      // There is a pending execution scheduled.\n      return;\n    }\n\n    if (typeof this.lastRun !== 'undefined') {\n      var elapsed = perf.now() - this.lastRun;\n\n      if (elapsed < this.throttle) {\n        this.timerId = setTimeout(this.wrappedCallback, this.throttle - elapsed);\n        return;\n      }\n    }\n\n    this.rAFid = rAF(this.wrappedCallback);\n  };\n  /**\n   * Schedules a function call in the most immenent microtask.\n   * This cannot be canceled.\n   */\n\n\n  AsyncWrapper.prototype.runAsap = function () {\n    if (this.asapScheduled) {\n      return;\n    }\n\n    this.asapScheduled = true;\n    cAF(this.rAFid);\n    clearTimeout(this.timerId);\n\n    if (utils.MutationObserver) {\n      /**\n       * Using MutationObservers to access microtask queue is a standard technique,\n       * used in ASAP library\n       * {@link https://github.com/kriskowal/asap/blob/master/browser-raw.js#L140}\n       */\n      if (!this.mo) {\n        this.mo = new utils.MutationObserver(this.wrappedCallback);\n        this.node = document.createTextNode(1);\n        this.mo.observe(this.node, {\n          characterData: true\n        });\n      }\n\n      this.node.nodeValue = -this.node.nodeValue;\n    } else {\n      setTimeout(this.wrappedCallback);\n    }\n  };\n  /**\n   * Runs scheduled execution immediately, if there were any.\n   */\n\n\n  AsyncWrapper.prototype.runImmediately = function () {\n    if (this.hasPendingCallback()) {\n      cAF(this.rAFid);\n      clearTimeout(this.timerId);\n      delete this.rAFid;\n      delete this.timerId;\n      this.wrappedCallback();\n    }\n  };\n\n  AsyncWrapper.now = function () {\n    return perf.now();\n  };\n\n  return AsyncWrapper;\n}();\n/**\n * Stores native OdP to be used in WeakMap and Set polyfills.\n */\n\n\nutils.defineProperty = Object.defineProperty;\nutils.WeakMap = typeof WeakMap !== 'undefined' ? WeakMap : function () {\n  /** Originally based on {@link https://github.com/Polymer/WeakMap} */\n  var counter = Date.now() % 1e9;\n\n  var WeakMap = function WeakMap() {\n    this.name = \"__st\".concat(Math.random() * 1e9 >>> 0).concat(counter++, \"__\");\n  };\n\n  WeakMap.prototype = {\n    set: function set(key, value) {\n      var entry = key[this.name];\n\n      if (entry && entry[0] === key) {\n        entry[1] = value;\n      } else {\n        utils.defineProperty(key, this.name, {\n          value: [key, value],\n          writable: true\n        });\n      }\n\n      return this;\n    },\n    get: function get(key) {\n      var entry = key[this.name];\n      return entry && entry[0] === key ? entry[1] : undefined;\n    },\n    delete: function _delete(key) {\n      var entry = key[this.name];\n\n      if (!entry) {\n        return false;\n      }\n\n      var hasValue = entry[0] === key;\n      delete entry[0];\n      delete entry[1];\n      return hasValue;\n    },\n    has: function has(key) {\n      var entry = key[this.name];\n\n      if (!entry) {\n        return false;\n      }\n\n      return entry[0] === key;\n    }\n  };\n  return WeakMap;\n}();\nutils.Set = typeof Set !== 'undefined' ? Set : function () {\n  var counter = Date.now() % 1e9;\n  /**\n   * A polyfill which covers only the basic usage.\n   * Only supports methods that are supported in IE11.\n   * {@link https://docs.microsoft.com/en-us/scripting/javascript/reference/set-object-javascript}\n   * Assumes that 'key's are all objects, not primitives such as a number.\n   *\n   * @param {Array} items Initial items in this set\n   */\n\n  var Set = function Set(items) {\n    this.name = \"__st\".concat(Math.random() * 1e9 >>> 0).concat(counter++, \"__\");\n    this.keys = [];\n\n    if (items && items.length) {\n      var iItems = items.length;\n\n      while (iItems--) {\n        this.add(items[iItems]);\n      }\n    }\n  };\n\n  Set.prototype = {\n    add: function add(key) {\n      if (!isNumber(key[this.name])) {\n        var index = this.keys.push(key) - 1;\n        utils.defineProperty(key, this.name, {\n          value: index,\n          writable: true\n        });\n      }\n    },\n    delete: function _delete(key) {\n      if (isNumber(key[this.name])) {\n        var index = key[this.name];\n        delete this.keys[index];\n        key[this.name] = undefined;\n      }\n    },\n    has: function has(key) {\n      return isNumber(key[this.name]);\n    },\n    clear: function clear() {\n      this.keys.forEach(function (key) {\n        key[this.name] = undefined;\n      });\n      this.keys.length = 0;\n    },\n    forEach: function forEach(cb) {\n      var that = this;\n      this.keys.forEach(function (value) {\n        cb(value, value, that);\n      });\n    }\n  };\n  utils.defineProperty(Set.prototype, 'size', {\n    get: function get() {\n      // Skips holes.\n      return this.keys.reduce(function (acc) {\n        return acc + 1;\n      }, 0);\n    }\n  });\n  return Set;\n}();\n/**\n * Vendor-specific Element.prototype.matches\n */\n\nutils.matchesPropertyName = function () {\n  var props = ['matches', 'matchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector', 'webkitMatchesSelector'];\n\n  for (var i = 0; i < 6; i++) {\n    if (Element.prototype.hasOwnProperty(props[i])) {\n      return props[i];\n    }\n  }\n}();\n/**\n * Provides stats information\n */\n\n\nutils.Stats = function () {\n  /** @member {Array<number>} */\n  this.array = [];\n  /** @member {number} */\n\n  this.length = 0;\n  var zeroDescriptor = {\n    value: 0,\n    writable: true\n  };\n  /** @member {number} @private */\n\n  Object.defineProperty(this, 'sum', zeroDescriptor);\n  /** @member {number} @private */\n\n  Object.defineProperty(this, 'squaredSum', zeroDescriptor);\n};\n/**\n * @param {number} dataPoint data point\n */\n\n\nutils.Stats.prototype.push = function (dataPoint) {\n  this.array.push(dataPoint);\n  this.length++;\n  this.sum += dataPoint;\n  this.squaredSum += dataPoint * dataPoint;\n  /** @member {number} */\n\n  this.mean = this.sum / this.length;\n  /** @member {number} */\n  // eslint-disable-next-line no-restricted-properties\n\n  this.stddev = Math.sqrt(this.squaredSum / this.length - Math.pow(this.mean, 2));\n};\n/** Safe console.error version */\n\n\nutils.logError = typeof console !== 'undefined' && console.error && Function.prototype.bind && console.error.bind ? console.error.bind(window.console) : console.error;\n/** Safe console.info version */\n\nutils.logInfo = typeof console !== 'undefined' && console.info && Function.prototype.bind && console.info.bind ? console.info.bind(window.console) : console.info;\n\nfunction isNumber(obj) {\n  return typeof obj === 'number';\n}\n/**\n * Returns path to element we will use as element identifier\n * @param {Element} inputEl\n * @returns {string} - path to the element\n */\n\n\nutils.getNodeSelector = function (inputEl) {\n  if (!(inputEl instanceof Element)) {\n    throw new Error('Function received argument with wrong type');\n  }\n\n  var el = inputEl;\n  var path = []; // we need to check '!!el' first because it is possible\n  // that some ancestor of the inputEl was removed before it\n\n  while (!!el && el.nodeType === Node.ELEMENT_NODE) {\n    var selector = el.nodeName.toLowerCase();\n\n    if (el.id && typeof el.id === 'string') {\n      selector += \"#\".concat(el.id);\n      path.unshift(selector);\n      break;\n    } else {\n      var sibling = el;\n      var nth = 1;\n\n      while (sibling.previousSibling) {\n        sibling = sibling.previousSibling;\n\n        if (sibling.nodeType === Node.ELEMENT_NODE && sibling.nodeName.toLowerCase() === selector) {\n          nth++;\n        }\n      }\n\n      if (nth !== 1) {\n        selector += \":nth-of-type(\".concat(nth, \")\");\n      }\n    }\n\n    path.unshift(selector);\n    el = el.parentNode;\n  }\n\n  return path.join(' > ');\n};\n\n/**\n * Copyright 2016 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Helper class css utils\n *\n * @type {{normalize}}\n */\nvar cssUtils = function () {\n  /**\n   * Regex that matches AdGuard's backward compatible syntaxes.\n   */\n  var reAttrFallback = /\\[-(?:ext|abp)-([a-z-_]+)=([\"'])((?:(?=(\\\\?))\\4.)*?)\\2\\]/g;\n  /**\n   * Complex replacement function.\n   * Unescapes quote characters inside of an extended selector.\n   *\n   * @param match     Whole matched string\n   * @param name      Group 1\n   * @param quoteChar Group 2\n   * @param value     Group 3\n   */\n\n  var evaluateMatch = function evaluateMatch(match, name, quoteChar, value) {\n    // Unescape quotes\n    var re = new RegExp(\"([^\\\\\\\\]|^)\\\\\\\\\".concat(quoteChar), 'g');\n    value = value.replace(re, \"$1\".concat(quoteChar));\n    return \":\".concat(name, \"(\").concat(value, \")\");\n  }; // Sizzle's parsing of pseudo class arguments is buggy on certain circumstances\n  // We support following form of arguments:\n  // 1. for :matches-css, those of a form {propertyName}: /.*/\n  // 2. for :contains, those of a form /.*/\n  // We transform such cases in a way that Sizzle has no ambiguity in parsing arguments.\n\n\n  var reMatchesCss = /\\:(matches-css(?:-after|-before)?)\\(([a-z-\\s]*\\:\\s*\\/(?:\\\\.|[^\\/])*?\\/\\s*)\\)/g;\n  var reContains = /:(?:-abp-)?(contains|has-text)\\((\\s*\\/(?:\\\\.|[^\\/])*?\\/\\s*)\\)/g;\n  var reScope = /\\(\\:scope >/g; // Note that we require `/` character in regular expressions to be escaped.\n\n  /**\n   * Used for pre-processing pseudo-classes values with above two regexes.\n   */\n\n  var addQuotes = function addQuotes(_, c1, c2) {\n    return \":\".concat(c1, \"(\\\"\").concat(c2.replace(/[\"\\\\]/g, '\\\\$&'), \"\\\")\");\n  };\n\n  var SCOPE_REPLACER = '(>';\n  /**\n   * Normalizes specified css text in a form that can be parsed by the\n   * Sizzle engine.\n   * Normalization means\n   *  1. transforming [-ext-*=\"\"] attributes to pseudo classes\n   *  2. enclosing possibly ambiguous arguments of `:contains`,\n   *     `:matches-css` pseudo classes with quotes.\n   * @param {string} cssText\n   * @return {string}\n   */\n\n  var normalize = function normalize(cssText) {\n    var normalizedCssText = cssText.replace(reAttrFallback, evaluateMatch).replace(reMatchesCss, addQuotes).replace(reContains, addQuotes).replace(reScope, SCOPE_REPLACER);\n    return normalizedCssText;\n  };\n\n  var isSimpleSelectorValid = function isSimpleSelectorValid(selector) {\n    try {\n      document.querySelectorAll(selector);\n    } catch (e) {\n      return false;\n    }\n\n    return true;\n  };\n\n  return {\n    normalize: normalize,\n    isSimpleSelectorValid: isSimpleSelectorValid\n  };\n}();\n\n/*!\n * Sizzle CSS Selector Engine v2.3.4-pre-adguard\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://js.foundation/\n *\n * Date: 2020-08-04\n */\n\n/**\n * Version of Sizzle patched by AdGuard in order to be used in the ExtendedCss module.\n * https://github.com/AdguardTeam/sizzle-extcss\n *\n * Look for [AdGuard Patch] and ADGUARD_EXTCSS markers to find out what exactly was changed by us.\n *\n * Global changes:\n * 1. Added additional parameters to the \"Sizzle.tokenize\" method so that it can be used for stylesheets parsing and validation.\n * 2. Added tokens re-sorting mechanism forcing slow pseudos to be matched last  (see sortTokenGroups).\n * 3. Fix the nonnativeSelectorCache caching -- there was no value corresponding to a key.\n * 4. Added Sizzle.compile call to the `:has` pseudo definition.\n *\n * Changes that are applied to the ADGUARD_EXTCSS build only:\n * 1. Do not expose Sizzle to the global scope. Initialize it lazily via initializeSizzle().\n * 2. Removed :contains pseudo declaration -- its syntax is changed and declared outside of Sizzle.\n * 3. Removed declarations for the following non-standard pseudo classes:\n * :parent, :header, :input, :button, :text, :first, :last, :eq,\n * :even, :odd, :lt, :gt, :nth, :radio, :checkbox, :file,\n * :password, :image, :submit, :reset\n * 4. Added es6 module export\n */\nvar Sizzle;\n/**\n * Initializes Sizzle object.\n * In the case of AdGuard ExtendedCss we want to avoid initializing Sizzle right away\n * and exposing it to the global scope.\n */\n\nvar initializeSizzle = function initializeSizzle() {\n  // jshint ignore:line\n  if (!Sizzle) {\n    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n    Sizzle = function (window) {\n      var support,\n          Expr,\n          getText,\n          isXML,\n          tokenize,\n          compile,\n          select,\n          outermostContext,\n          sortInput,\n          hasDuplicate,\n          // Local document vars\n      setDocument,\n          document,\n          docElem,\n          documentIsHTML,\n          rbuggyQSA,\n          rbuggyMatches,\n          matches,\n          contains,\n          // Instance-specific data\n      expando = \"sizzle\" + 1 * new Date(),\n          preferredDoc = window.document,\n          dirruns = 0,\n          done = 0,\n          classCache = createCache(),\n          tokenCache = createCache(),\n          compilerCache = createCache(),\n          nonnativeSelectorCache = createCache(),\n          sortOrder = function sortOrder(a, b) {\n        if (a === b) {\n          hasDuplicate = true;\n        }\n\n        return 0;\n      },\n          // Instance methods\n      hasOwn = {}.hasOwnProperty,\n          arr = [],\n          pop = arr.pop,\n          push_native = arr.push,\n          push = arr.push,\n          slice = arr.slice,\n          // Use a stripped-down indexOf as it's faster than native\n      // https://jsperf.com/thor-indexof-vs-for/5\n      indexOf = function indexOf(list, elem) {\n        var i = 0,\n            len = list.length;\n\n        for (; i < len; i++) {\n          if (list[i] === elem) {\n            return i;\n          }\n        }\n\n        return -1;\n      },\n          booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n          // Regular expressions\n      // http://www.w3.org/TR/css3-selectors/#whitespace\n      whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n          // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n      identifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n          // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n      attributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace + // Operator (capture 2)\n      \"*([*^$|!~]?=)\" + whitespace + // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n      \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n          pseudos = \":(\" + identifier + \")(?:\\\\((\" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n      // 1. quoted (capture 3; capture 4 or capture 5)\n      \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" + // 2. simple (capture 6)\n      \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" + // 3. anything else (capture 2)\n      \".*\" + \")\\\\)|)\",\n          // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n      rwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n          rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n          rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n          rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n          rpseudo = new RegExp(pseudos),\n          ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n          matchExpr = {\n        \"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n        \"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n        \"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n        \"ATTR\": new RegExp(\"^\" + attributes),\n        \"PSEUDO\": new RegExp(\"^\" + pseudos),\n        \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n        \"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n        // For use in libraries implementing .is()\n        // We use this for POS matching in `select`\n        \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n      },\n          rnative = /^[^{]+\\{\\s*\\[native \\w/,\n          // Easily-parseable/retrievable ID or TAG or CLASS selectors\n      rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n          rsibling = /[+~]/,\n          // CSS escapes\n      // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n      runescape = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\"),\n          funescape = function funescape(_, escaped, escapedWhitespace) {\n        var high = \"0x\" + escaped - 0x10000; // NaN means non-codepoint\n        // Support: Firefox<24\n        // Workaround erroneous numeric interpretation of +\"0x\"\n\n        return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint\n        String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n        String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n      },\n          // CSS string/identifier serialization\n      // https://drafts.csswg.org/cssom/#common-serializing-idioms\n      rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n          fcssescape = function fcssescape(ch, asCodePoint) {\n        if (asCodePoint) {\n          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n          if (ch === \"\\0\") {\n            return \"\\uFFFD\";\n          } // Control characters and (dependent upon position) numbers get escaped as code points\n\n\n          return ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n        } // Other potentially-special ASCII characters get backslash-escaped\n\n\n        return \"\\\\\" + ch;\n      },\n          // Used for iframes\n      // See setDocument()\n      // Removing the function wrapper causes a \"Permission Denied\"\n      // error in IE\n      unloadHandler = function unloadHandler() {\n        setDocument();\n      },\n          inDisabledFieldset = addCombinator(function (elem) {\n        return elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n      }, {\n        dir: \"parentNode\",\n        next: \"legend\"\n      }); // Optimize for push.apply( _, NodeList )\n\n\n      try {\n        push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0\n        // Detect silently failing push.apply\n\n        arr[preferredDoc.childNodes.length].nodeType;\n      } catch (e) {\n        push = {\n          apply: arr.length ? // Leverage slice if possible\n          function (target, els) {\n            push_native.apply(target, slice.call(els));\n          } : // Support: IE<9\n          // Otherwise append directly\n          function (target, els) {\n            var j = target.length,\n                i = 0; // Can't trust NodeList.length\n\n            while (target[j++] = els[i++]) {}\n\n            target.length = j - 1;\n          }\n        };\n      }\n\n      function Sizzle(selector, context, results, seed) {\n        var m,\n            i,\n            elem,\n            nid,\n            match,\n            groups,\n            newSelector,\n            newContext = context && context.ownerDocument,\n            // nodeType defaults to 9, since context defaults to document\n        nodeType = context ? context.nodeType : 9;\n        results = results || []; // Return early from calls with invalid selector or context\n\n        if (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n          return results;\n        } // Try to shortcut find operations (as opposed to filters) in HTML documents\n\n\n        if (!seed) {\n          if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n            setDocument(context);\n          }\n\n          context = context || document;\n\n          if (documentIsHTML) {\n            // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n            // (excepting DocumentFragment context, where the methods don't exist)\n            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n              // ID selector\n              if (m = match[1]) {\n                // Document context\n                if (nodeType === 9) {\n                  if (elem = context.getElementById(m)) {\n                    // Support: IE, Opera, Webkit\n                    // TODO: identify versions\n                    // getElementById can match elements by name instead of ID\n                    if (elem.id === m) {\n                      results.push(elem);\n                      return results;\n                    }\n                  } else {\n                    return results;\n                  } // Element context\n\n                } else {\n                  // Support: IE, Opera, Webkit\n                  // TODO: identify versions\n                  // getElementById can match elements by name instead of ID\n                  if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n                    results.push(elem);\n                    return results;\n                  }\n                } // Type selector\n\n              } else if (match[2]) {\n                push.apply(results, context.getElementsByTagName(selector));\n                return results; // Class selector\n              } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n                push.apply(results, context.getElementsByClassName(m));\n                return results;\n              }\n            } // Take advantage of querySelectorAll\n\n\n            if (support.qsa && !nonnativeSelectorCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n              if (nodeType !== 1) {\n                newContext = context;\n                newSelector = selector; // qSA looks outside Element context, which is not what we want\n                // Thanks to Andrew Dupont for this workaround technique\n                // Support: IE <=8\n                // Exclude object elements\n              } else if (context.nodeName.toLowerCase() !== \"object\") {\n                // Capture the context ID, setting it first if necessary\n                if (nid = context.getAttribute(\"id\")) {\n                  nid = nid.replace(rcssescape, fcssescape);\n                } else {\n                  context.setAttribute(\"id\", nid = expando);\n                } // Prefix every selector in the list\n\n\n                groups = tokenize(selector);\n                i = groups.length;\n\n                while (i--) {\n                  groups[i] = \"#\" + nid + \" \" + toSelector(groups[i]);\n                }\n\n                newSelector = groups.join(\",\"); // Expand context for sibling selectors\n\n                newContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n              }\n\n              if (newSelector) {\n                try {\n                  push.apply(results, newContext.querySelectorAll(newSelector));\n                  return results;\n                } catch (qsaError) {\n                  // [AdGuard Path]: Fix the cache value\n                  nonnativeSelectorCache(selector, true);\n                } finally {\n                  if (nid === expando) {\n                    context.removeAttribute(\"id\");\n                  }\n                }\n              }\n            }\n          }\n        } // All others\n\n\n        return select(selector.replace(rtrim, \"$1\"), context, results, seed);\n      }\n      /**\n       * Create key-value caches of limited size\n       * @returns {function(string, object)} Returns the Object data after storing it on itself with\n       *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n       *\tdeleting the oldest entry\n       */\n\n\n      function createCache() {\n        var keys = [];\n\n        function cache(key, value) {\n          // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n          if (keys.push(key + \" \") > Expr.cacheLength) {\n            // Only keep the most recent entries\n            delete cache[keys.shift()];\n          }\n\n          return cache[key + \" \"] = value;\n        }\n\n        return cache;\n      }\n      /**\n       * Mark a function for special use by Sizzle\n       * @param {Function} fn The function to mark\n       */\n\n\n      function markFunction(fn) {\n        fn[expando] = true;\n        return fn;\n      }\n      /**\n       * Support testing using an element\n       * @param {Function} fn Passed the created element and returns a boolean result\n       */\n\n\n      function assert(fn) {\n        var el = document.createElement(\"fieldset\");\n\n        try {\n          return !!fn(el);\n        } catch (e) {\n          return false;\n        } finally {\n          // Remove from its parent by default\n          if (el.parentNode) {\n            el.parentNode.removeChild(el);\n          } // release memory in IE\n\n\n          el = null;\n        }\n      }\n      /**\n       * Adds the same handler for all of the specified attrs\n       * @param {String} attrs Pipe-separated list of attributes\n       * @param {Function} handler The method that will be applied\n       */\n\n\n      function addHandle(attrs, handler) {\n        var arr = attrs.split(\"|\"),\n            i = arr.length;\n\n        while (i--) {\n          Expr.attrHandle[arr[i]] = handler;\n        }\n      }\n      /**\n       * Checks document order of two siblings\n       * @param {Element} a\n       * @param {Element} b\n       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n       */\n\n\n      function siblingCheck(a, b) {\n        var cur = b && a,\n            diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes\n\n        if (diff) {\n          return diff;\n        } // Check if b follows a\n\n\n        if (cur) {\n          while (cur = cur.nextSibling) {\n            if (cur === b) {\n              return -1;\n            }\n          }\n        }\n\n        return a ? 1 : -1;\n      }\n      /**\n       * Returns a function to use in pseudos for :enabled/:disabled\n       * @param {Boolean} disabled true for :disabled; false for :enabled\n       */\n\n\n      function createDisabledPseudo(disabled) {\n        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n        return function (elem) {\n          // Only certain elements can match :enabled or :disabled\n          // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n          // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n          if (\"form\" in elem) {\n            // Check for inherited disabledness on relevant non-disabled elements:\n            // * listed form-associated elements in a disabled fieldset\n            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n            // * option elements in a disabled optgroup\n            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n            // All such elements have a \"form\" property.\n            if (elem.parentNode && elem.disabled === false) {\n              // Option elements defer to a parent optgroup if present\n              if (\"label\" in elem) {\n                if (\"label\" in elem.parentNode) {\n                  return elem.parentNode.disabled === disabled;\n                } else {\n                  return elem.disabled === disabled;\n                }\n              } // Support: IE 6 - 11\n              // Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\n\n              return elem.isDisabled === disabled || // Where there is no isDisabled, check manually\n\n              /* jshint -W018 */\n              elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;\n            }\n\n            return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.\n            // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n            // even exist on them, let alone have a boolean value.\n          } else if (\"label\" in elem) {\n            return elem.disabled === disabled;\n          } // Remaining elements are neither :enabled nor :disabled\n\n\n          return false;\n        };\n      }\n      /**\n       * Checks a node for validity as a Sizzle context\n       * @param {Element|Object=} context\n       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n       */\n\n\n      function testContext(context) {\n        return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n      } // Expose support vars for convenience\n\n\n      support = Sizzle.support = {};\n      /**\n       * Detects XML nodes\n       * @param {Element|Object} elem An element or a document\n       * @returns {Boolean} True iff elem is a non-HTML XML node\n       */\n\n      isXML = Sizzle.isXML = function (elem) {\n        // documentElement is verified for cases where it doesn't yet exist\n        // (such as loading iframes in IE - #4833)\n        var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n        return documentElement ? documentElement.nodeName !== \"HTML\" : false;\n      };\n      /**\n       * Sets document-related variables once based on the current document\n       * @param {Element|Object} [doc] An element or document object to use to set the document\n       * @returns {Object} Returns the current document\n       */\n\n\n      setDocument = Sizzle.setDocument = function (node) {\n        var hasCompare,\n            subWindow,\n            doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected\n\n        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n          return document;\n        } // Update global variables\n\n\n        document = doc;\n        docElem = document.documentElement;\n        documentIsHTML = !isXML(document); // Support: IE 9-11, Edge\n        // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\n        if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n          // Support: IE 11, Edge\n          if (subWindow.addEventListener) {\n            subWindow.addEventListener(\"unload\", unloadHandler, false); // Support: IE 9 - 10 only\n          } else if (subWindow.attachEvent) {\n            subWindow.attachEvent(\"onunload\", unloadHandler);\n          }\n        }\n        /* Attributes\n        ---------------------------------------------------------------------- */\n        // Support: IE<8\n        // Verify that getAttribute really returns attributes and not properties\n        // (excepting IE8 booleans)\n\n\n        support.attributes = assert(function (el) {\n          el.className = \"i\";\n          return !el.getAttribute(\"className\");\n        });\n        /* getElement(s)By*\n        ---------------------------------------------------------------------- */\n        // Check if getElementsByTagName(\"*\") returns only elements\n\n        support.getElementsByTagName = assert(function (el) {\n          el.appendChild(document.createComment(\"\"));\n          return !el.getElementsByTagName(\"*\").length;\n        }); // Support: IE<9\n\n        support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10\n        // Check if getElementById returns elements by name\n        // The broken getElementById methods don't pick up programmatically-set names,\n        // so use a roundabout getElementsByName test\n\n        support.getById = assert(function (el) {\n          docElem.appendChild(el).id = expando;\n          return !document.getElementsByName || !document.getElementsByName(expando).length;\n        }); // ID filter and find\n\n        if (support.getById) {\n          Expr.filter[\"ID\"] = function (id) {\n            var attrId = id.replace(runescape, funescape);\n            return function (elem) {\n              return elem.getAttribute(\"id\") === attrId;\n            };\n          };\n\n          Expr.find[\"ID\"] = function (id, context) {\n            if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n              var elem = context.getElementById(id);\n              return elem ? [elem] : [];\n            }\n          };\n        } else {\n          Expr.filter[\"ID\"] = function (id) {\n            var attrId = id.replace(runescape, funescape);\n            return function (elem) {\n              var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n              return node && node.value === attrId;\n            };\n          }; // Support: IE 6 - 7 only\n          // getElementById is not reliable as a find shortcut\n\n\n          Expr.find[\"ID\"] = function (id, context) {\n            if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n              var node,\n                  i,\n                  elems,\n                  elem = context.getElementById(id);\n\n              if (elem) {\n                // Verify the id attribute\n                node = elem.getAttributeNode(\"id\");\n\n                if (node && node.value === id) {\n                  return [elem];\n                } // Fall back on getElementsByName\n\n\n                elems = context.getElementsByName(id);\n                i = 0;\n\n                while (elem = elems[i++]) {\n                  node = elem.getAttributeNode(\"id\");\n\n                  if (node && node.value === id) {\n                    return [elem];\n                  }\n                }\n              }\n\n              return [];\n            }\n          };\n        } // Tag\n\n\n        Expr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n          if (typeof context.getElementsByTagName !== \"undefined\") {\n            return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN\n          } else if (support.qsa) {\n            return context.querySelectorAll(tag);\n          }\n        } : function (tag, context) {\n          var elem,\n              tmp = [],\n              i = 0,\n              // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n          results = context.getElementsByTagName(tag); // Filter out possible comments\n\n          if (tag === \"*\") {\n            while (elem = results[i++]) {\n              if (elem.nodeType === 1) {\n                tmp.push(elem);\n              }\n            }\n\n            return tmp;\n          }\n\n          return results;\n        }; // Class\n\n        Expr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n          if (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n            return context.getElementsByClassName(className);\n          }\n        };\n        /* QSA/matchesSelector\n        ---------------------------------------------------------------------- */\n        // QSA and matchesSelector support\n        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\n\n        rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)\n        // We allow this because of a bug in IE8/9 that throws an error\n        // whenever `document.activeElement` is accessed on an iframe\n        // So, we allow :focus to pass through QSA all the time to avoid the IE error\n        // See https://bugs.jquery.com/ticket/13378\n\n        rbuggyQSA = [];\n\n        if (support.qsa = rnative.test(document.querySelectorAll)) {\n          // Build QSA regex\n          // Regex strategy adopted from Diego Perini\n          assert(function (el) {\n            // Select is set to empty string on purpose\n            // This is to test IE's treatment of not explicitly\n            // setting a boolean content attribute,\n            // since its presence should be enough\n            // https://bugs.jquery.com/ticket/12359\n            docElem.appendChild(el).innerHTML = AGPolicy.createHTML(\"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\"); // Support: IE8, Opera 11-12.16\n            // Nothing should be selected when empty strings follow ^= or $= or *=\n            // The test attribute must be unknown in Opera but \"safe\" for WinRT\n            // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\n            if (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n              rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n            } // Support: IE8\n            // Boolean attributes and \"value\" are not treated correctly\n\n\n            if (!el.querySelectorAll(\"[selected]\").length) {\n              rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n            } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\n\n            if (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n              rbuggyQSA.push(\"~=\");\n            } // Webkit/Opera - :checked should return selected option elements\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n            // IE8 throws error here and will not see later tests\n\n\n            if (!el.querySelectorAll(\":checked\").length) {\n              rbuggyQSA.push(\":checked\");\n            } // Support: Safari 8+, iOS 8+\n            // https://bugs.webkit.org/show_bug.cgi?id=136851\n            // In-page `selector#id sibling-combinator selector` fails\n\n\n            if (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n              rbuggyQSA.push(\".#.+[+~]\");\n            }\n          });\n          assert(function (el) {\n            el.innerHTML = AGPolicy.createHTML(\"<a href='' disabled='disabled'></a>\" + \"<select disabled='disabled'><option/></select>\"); // Support: Windows 8 Native Apps\n            // The type and name attributes are restricted during .innerHTML assignment\n\n            var input = document.createElement(\"input\");\n            input.setAttribute(\"type\", \"hidden\");\n            el.appendChild(input).setAttribute(\"name\", \"D\"); // Support: IE8\n            // Enforce case-sensitivity of name attribute\n\n            if (el.querySelectorAll(\"[name=d]\").length) {\n              rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n            } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n            // IE8 throws error here and will not see later tests\n\n\n            if (el.querySelectorAll(\":enabled\").length !== 2) {\n              rbuggyQSA.push(\":enabled\", \":disabled\");\n            } // Support: IE9-11+\n            // IE's :disabled selector does not pick up the children of disabled fieldsets\n\n\n            docElem.appendChild(el).disabled = true;\n\n            if (el.querySelectorAll(\":disabled\").length !== 2) {\n              rbuggyQSA.push(\":enabled\", \":disabled\");\n            } // Opera 10-11 does not throw on post-comma invalid pseudos\n\n\n            el.querySelectorAll(\"*,:x\");\n            rbuggyQSA.push(\",.*:\");\n          });\n        }\n\n        if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n          assert(function (el) {\n            // Check to see if it's possible to do matchesSelector\n            // on a disconnected node (IE 9)\n            support.disconnectedMatch = matches.call(el, \"*\"); // This should fail with an exception\n            // Gecko does not error, returns false instead\n\n            matches.call(el, \"[s!='']:x\");\n            rbuggyMatches.push(\"!=\", pseudos);\n          });\n        }\n\n        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n        /* Contains\n        ---------------------------------------------------------------------- */\n\n        hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another\n        // Purposefully self-exclusive\n        // As in, an element does not contain itself\n\n        contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n          var adown = a.nodeType === 9 ? a.documentElement : a,\n              bup = b && b.parentNode;\n          return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n        } : function (a, b) {\n          if (b) {\n            while (b = b.parentNode) {\n              if (b === a) {\n                return true;\n              }\n            }\n          }\n\n          return false;\n        };\n        /* Sorting\n        ---------------------------------------------------------------------- */\n        // Document order sorting\n\n        sortOrder = hasCompare ? function (a, b) {\n          // Flag for duplicate removal\n          if (a === b) {\n            hasDuplicate = true;\n            return 0;\n          } // Sort on method existence if only one input has compareDocumentPosition\n\n\n          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\n          if (compare) {\n            return compare;\n          } // Calculate position if both inputs belong to the same document\n\n\n          compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected\n          1; // Disconnected nodes\n\n          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n            // Choose the first element that is related to our preferred document\n            if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\n              return -1;\n            }\n\n            if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\n              return 1;\n            } // Maintain original order\n\n\n            return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n          }\n\n          return compare & 4 ? -1 : 1;\n        } : function (a, b) {\n          // Exit early if the nodes are identical\n          if (a === b) {\n            hasDuplicate = true;\n            return 0;\n          }\n\n          var cur,\n              i = 0,\n              aup = a.parentNode,\n              bup = b.parentNode,\n              ap = [a],\n              bp = [b]; // Parentless nodes are either documents or disconnected\n\n          if (!aup || !bup) {\n            return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check\n          } else if (aup === bup) {\n            return siblingCheck(a, b);\n          } // Otherwise we need full lists of their ancestors for comparison\n\n\n          cur = a;\n\n          while (cur = cur.parentNode) {\n            ap.unshift(cur);\n          }\n\n          cur = b;\n\n          while (cur = cur.parentNode) {\n            bp.unshift(cur);\n          } // Walk down the tree looking for a discrepancy\n\n\n          while (ap[i] === bp[i]) {\n            i++;\n          }\n\n          return i ? // Do a sibling check if the nodes have a common ancestor\n          siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first\n          ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n        };\n        return document;\n      };\n\n      Sizzle.matches = function (expr, elements) {\n        return Sizzle(expr, null, null, elements);\n      };\n\n      Sizzle.matchesSelector = function (elem, expr) {\n        // Set document vars if needed\n        if ((elem.ownerDocument || elem) !== document) {\n          setDocument(elem);\n        }\n\n        if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + \" \"] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n          try {\n            var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n            if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n            // fragment in IE 9\n            elem.document && elem.document.nodeType !== 11) {\n              return ret;\n            }\n          } catch (e) {\n            // [AdGuard Path]: Fix the cache value\n            nonnativeSelectorCache(expr, true);\n          }\n        }\n\n        return Sizzle(expr, document, null, [elem]).length > 0;\n      };\n\n      Sizzle.contains = function (context, elem) {\n        // Set document vars if needed\n        if ((context.ownerDocument || context) !== document) {\n          setDocument(context);\n        }\n\n        return contains(context, elem);\n      };\n\n      Sizzle.attr = function (elem, name) {\n        // Set document vars if needed\n        if ((elem.ownerDocument || elem) !== document) {\n          setDocument(elem);\n        }\n\n        var fn = Expr.attrHandle[name.toLowerCase()],\n            // Don't get fooled by Object.prototype properties (jQuery #13807)\n        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n        return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n      };\n\n      Sizzle.escape = function (sel) {\n        return (sel + \"\").replace(rcssescape, fcssescape);\n      };\n\n      Sizzle.error = function (msg) {\n        throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n      };\n      /**\n       * Document sorting and removing duplicates\n       * @param {ArrayLike} results\n       */\n\n\n      Sizzle.uniqueSort = function (results) {\n        var elem,\n            duplicates = [],\n            j = 0,\n            i = 0; // Unless we *know* we can detect duplicates, assume their presence\n\n        hasDuplicate = !support.detectDuplicates;\n        sortInput = !support.sortStable && results.slice(0);\n        results.sort(sortOrder);\n\n        if (hasDuplicate) {\n          while (elem = results[i++]) {\n            if (elem === results[i]) {\n              j = duplicates.push(i);\n            }\n          }\n\n          while (j--) {\n            results.splice(duplicates[j], 1);\n          }\n        } // Clear input after sorting to release objects\n        // See https://github.com/jquery/sizzle/pull/225\n\n\n        sortInput = null;\n        return results;\n      };\n      /**\n       * Utility function for retrieving the text value of an array of DOM nodes\n       * @param {Array|Element} elem\n       */\n\n\n      getText = Sizzle.getText = function (elem) {\n        var node,\n            ret = \"\",\n            i = 0,\n            nodeType = elem.nodeType;\n\n        if (!nodeType) {\n          // If no nodeType, this is expected to be an array\n          while (node = elem[i++]) {\n            // Do not traverse comment nodes\n            ret += getText(node);\n          }\n        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n          // Use textContent for elements\n          // innerText usage removed for consistency of new lines (jQuery #11153)\n          if (typeof elem.textContent === \"string\") {\n            return elem.textContent;\n          } else {\n            // Traverse its children\n            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n              ret += getText(elem);\n            }\n          }\n        } else if (nodeType === 3 || nodeType === 4) {\n          return elem.nodeValue;\n        } // Do not include comment or processing instruction nodes\n\n\n        return ret;\n      };\n\n      Expr = Sizzle.selectors = {\n        // Can be adjusted by the user\n        cacheLength: 50,\n        createPseudo: markFunction,\n        match: matchExpr,\n        attrHandle: {},\n        find: {},\n        relative: {\n          \">\": {\n            dir: \"parentNode\",\n            first: true\n          },\n          \" \": {\n            dir: \"parentNode\"\n          },\n          \"+\": {\n            dir: \"previousSibling\",\n            first: true\n          },\n          \"~\": {\n            dir: \"previousSibling\"\n          }\n        },\n        preFilter: {\n          \"ATTR\": function ATTR(match) {\n            match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted\n\n            match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n            if (match[2] === \"~=\") {\n              match[3] = \" \" + match[3] + \" \";\n            }\n\n            return match.slice(0, 4);\n          },\n          \"CHILD\": function CHILD(match) {\n            /* matches from matchExpr[\"CHILD\"]\n            \t1 type (only|nth|...)\n            \t2 what (child|of-type)\n            \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n            \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n            \t5 sign of xn-component\n            \t6 x of xn-component\n            \t7 sign of y-component\n            \t8 y of y-component\n            */\n            match[1] = match[1].toLowerCase();\n\n            if (match[1].slice(0, 3) === \"nth\") {\n              // nth-* requires argument\n              if (!match[3]) {\n                Sizzle.error(match[0]);\n              } // numeric x and y parameters for Expr.filter.CHILD\n              // remember that false/true cast respectively to 0/1\n\n\n              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n              match[5] = +(match[7] + match[8] || match[3] === \"odd\"); // other types prohibit arguments\n            } else if (match[3]) {\n              Sizzle.error(match[0]);\n            }\n\n            return match;\n          },\n          \"PSEUDO\": function PSEUDO(match) {\n            var excess,\n                unquoted = !match[6] && match[2];\n\n            if (matchExpr[\"CHILD\"].test(match[0])) {\n              return null;\n            } // Accept quoted arguments as-is\n\n\n            if (match[3]) {\n              match[2] = match[4] || match[5] || \"\"; // Strip excess characters from unquoted arguments\n            } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)\n            excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis\n            excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n              // excess is a negative index\n              match[0] = match[0].slice(0, excess);\n              match[2] = unquoted.slice(0, excess);\n            } // Return only captures needed by the pseudo filter method (type and argument)\n\n\n            return match.slice(0, 3);\n          }\n        },\n        filter: {\n          \"TAG\": function TAG(nodeNameSelector) {\n            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n            return nodeNameSelector === \"*\" ? function () {\n              return true;\n            } : function (elem) {\n              return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n            };\n          },\n          \"CLASS\": function CLASS(className) {\n            var pattern = classCache[className + \" \"];\n            return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n              return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n            });\n          },\n          \"ATTR\": function ATTR(name, operator, check) {\n            return function (elem) {\n              var result = Sizzle.attr(elem, name);\n\n              if (result == null) {\n                return operator === \"!=\";\n              }\n\n              if (!operator) {\n                return true;\n              }\n\n              result += \"\";\n              return operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n            };\n          },\n          \"CHILD\": function CHILD(type, what, argument, first, last) {\n            var simple = type.slice(0, 3) !== \"nth\",\n                forward = type.slice(-4) !== \"last\",\n                ofType = what === \"of-type\";\n            return first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n            function (elem) {\n              return !!elem.parentNode;\n            } : function (elem, context, xml) {\n              var cache,\n                  uniqueCache,\n                  outerCache,\n                  node,\n                  nodeIndex,\n                  start,\n                  dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n                  parent = elem.parentNode,\n                  name = ofType && elem.nodeName.toLowerCase(),\n                  useCache = !xml && !ofType,\n                  diff = false;\n\n              if (parent) {\n                // :(first|last|only)-(child|of-type)\n                if (simple) {\n                  while (dir) {\n                    node = elem;\n\n                    while (node = node[dir]) {\n                      if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n                        return false;\n                      }\n                    } // Reverse direction for :only-* (if we haven't yet done so)\n\n\n                    start = dir = type === \"only\" && !start && \"nextSibling\";\n                  }\n\n                  return true;\n                }\n\n                start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`\n\n                if (forward && useCache) {\n                  // Seek `elem` from a previously-cached index\n                  // ...in a gzip-friendly way\n                  node = parent;\n                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                  // Defend against cloned attroperties (jQuery gh-1709)\n\n                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                  cache = uniqueCache[type] || [];\n                  nodeIndex = cache[0] === dirruns && cache[1];\n                  diff = nodeIndex && cache[2];\n                  node = nodeIndex && parent.childNodes[nodeIndex];\n\n                  while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start\n                  diff = nodeIndex = 0) || start.pop()) {\n                    // When found, cache indexes on `parent` and break\n                    if (node.nodeType === 1 && ++diff && node === elem) {\n                      uniqueCache[type] = [dirruns, nodeIndex, diff];\n                      break;\n                    }\n                  }\n                } else {\n                  // Use previously-cached element index if available\n                  if (useCache) {\n                    // ...in a gzip-friendly way\n                    node = elem;\n                    outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                    // Defend against cloned attroperties (jQuery gh-1709)\n\n                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                    cache = uniqueCache[type] || [];\n                    nodeIndex = cache[0] === dirruns && cache[1];\n                    diff = nodeIndex;\n                  } // xml :nth-child(...)\n                  // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\n\n                  if (diff === false) {\n                    // Use the same loop as above to seek `elem` from the start\n                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n                      if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n                        // Cache the index of each encountered element\n                        if (useCache) {\n                          outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                          // Defend against cloned attroperties (jQuery gh-1709)\n\n                          uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                          uniqueCache[type] = [dirruns, diff];\n                        }\n\n                        if (node === elem) {\n                          break;\n                        }\n                      }\n                    }\n                  }\n                } // Incorporate the offset, then check against cycle size\n\n\n                diff -= last;\n                return diff === first || diff % first === 0 && diff / first >= 0;\n              }\n            };\n          },\n          \"PSEUDO\": function PSEUDO(pseudo, argument) {\n            // pseudo-class names are case-insensitive\n            // http://www.w3.org/TR/selectors/#pseudo-classes\n            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n            // Remember that setFilters inherits from pseudos\n            var args,\n                fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo); // The user may use createPseudo to indicate that\n            // arguments are needed to create the filter function\n            // just as Sizzle does\n\n            if (fn[expando]) {\n              return fn(argument);\n            } // But maintain support for old signatures\n\n\n            if (fn.length > 1) {\n              args = [pseudo, pseudo, \"\", argument];\n              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n                var idx,\n                    matched = fn(seed, argument),\n                    i = matched.length;\n\n                while (i--) {\n                  idx = indexOf(seed, matched[i]);\n                  seed[idx] = !(matches[idx] = matched[i]);\n                }\n              }) : function (elem) {\n                return fn(elem, 0, args);\n              };\n            }\n\n            return fn;\n          }\n        },\n        pseudos: {\n          // Potentially complex pseudos\n          \"not\": markFunction(function (selector) {\n            // Trim the selector passed to compile\n            // to avoid treating leading and trailing\n            // spaces as combinators\n            var input = [],\n                results = [],\n                matcher = compile(selector.replace(rtrim, \"$1\"));\n            return matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n              var elem,\n                  unmatched = matcher(seed, null, xml, []),\n                  i = seed.length; // Match elements unmatched by `matcher`\n\n              while (i--) {\n                if (elem = unmatched[i]) {\n                  seed[i] = !(matches[i] = elem);\n                }\n              }\n            }) : function (elem, context, xml) {\n              input[0] = elem;\n              matcher(input, null, xml, results); // Don't keep the element (issue #299)\n\n              input[0] = null;\n              return !results.pop();\n            };\n          }),\n          \"has\": markFunction(function (selector) {\n            if (typeof selector === \"string\") {\n              Sizzle.compile(selector);\n            }\n\n            return function (elem) {\n              return Sizzle(selector, elem).length > 0;\n            };\n          }),\n          // Removed :contains pseudo-class declaration\n          // \"Whether an element is represented by a :lang() selector\n          // is based solely on the element's language value\n          // being equal to the identifier C,\n          // or beginning with the identifier C immediately followed by \"-\".\n          // The matching of C against the element's language value is performed case-insensitively.\n          // The identifier C does not have to be a valid language name.\"\n          // http://www.w3.org/TR/selectors/#lang-pseudo\n          \"lang\": markFunction(function (lang) {\n            // lang value must be a valid identifier\n            if (!ridentifier.test(lang || \"\")) {\n              Sizzle.error(\"unsupported lang: \" + lang);\n            }\n\n            lang = lang.replace(runescape, funescape).toLowerCase();\n            return function (elem) {\n              var elemLang;\n\n              do {\n                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n                  elemLang = elemLang.toLowerCase();\n                  return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n                }\n              } while ((elem = elem.parentNode) && elem.nodeType === 1);\n\n              return false;\n            };\n          }),\n          // Miscellaneous\n          \"target\": function target(elem) {\n            var hash = window.location && window.location.hash;\n            return hash && hash.slice(1) === elem.id;\n          },\n          \"root\": function root(elem) {\n            return elem === docElem;\n          },\n          \"focus\": function focus(elem) {\n            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n          },\n          // Boolean properties\n          \"enabled\": createDisabledPseudo(false),\n          \"disabled\": createDisabledPseudo(true),\n          \"checked\": function checked(elem) {\n            // In CSS3, :checked should return both checked and selected elements\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n            var nodeName = elem.nodeName.toLowerCase();\n            return nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n          },\n          \"selected\": function selected(elem) {\n            // Accessing this property makes selected-by-default\n            // options in Safari work properly\n            if (elem.parentNode) {\n              elem.parentNode.selectedIndex;\n            }\n\n            return elem.selected === true;\n          },\n          // Contents\n          \"empty\": function empty(elem) {\n            // http://www.w3.org/TR/selectors/#empty-pseudo\n            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n            //   but not by others (comment: 8; processing instruction: 7; etc.)\n            // nodeType < 6 works because attributes (2) do not appear as children\n            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n              if (elem.nodeType < 6) {\n                return false;\n              }\n            }\n\n            return true;\n          } // Removed custom pseudo-classes\n\n        }\n      }; // Removed custom pseudo-classes\n      // Easy API for creating new setFilters\n\n      function setFilters() {}\n\n      setFilters.prototype = Expr.filters = Expr.pseudos;\n      Expr.setFilters = new setFilters();\n      /**\n       * [AdGuard Patch]:\n       * Sorts the tokens in order to mitigate the performance issues caused by matching slow pseudos first:\n       * https://github.com/AdguardTeam/ExtendedCss/issues/55#issuecomment-364058745\n       */\n\n      var sortTokenGroups = function () {\n        /**\n         * Splits compound selector into a list of simple selectors\n         *\n         * @param {*} tokens Tokens to split into groups\n         * @returns an array consisting of token groups (arrays) and relation tokens.\n         */\n        var splitCompoundSelector = function splitCompoundSelector(tokens) {\n          var groups = [];\n          var currentTokensGroup = [];\n          var maxIdx = tokens.length - 1;\n\n          for (var i = 0; i <= maxIdx; i++) {\n            var token = tokens[i];\n            var relative = Sizzle.selectors.relative[token.type];\n\n            if (relative) {\n              groups.push(currentTokensGroup);\n              groups.push(token);\n              currentTokensGroup = [];\n            } else {\n              currentTokensGroup.push(token);\n            }\n\n            if (i === maxIdx) {\n              groups.push(currentTokensGroup);\n            }\n          }\n\n          return groups;\n        };\n\n        var TOKEN_TYPES_VALUES = {\n          // nth-child, etc, always go last\n          \"CHILD\": 100,\n          \"ID\": 90,\n          \"CLASS\": 80,\n          \"TAG\": 70,\n          \"ATTR\": 70,\n          \"PSEUDO\": 60\n        };\n        var POSITIONAL_PSEUDOS = [\"nth\", \"first\", \"last\", \"eq\", \"even\", \"odd\", \"lt\", \"gt\", \"not\"];\n        /**\n         * A function that defines the sort order.\n         * Returns a value lesser than 0 if \"left\" is less than \"right\".\n         */\n\n        var compareFunction = function compareFunction(left, right) {\n          var leftValue = TOKEN_TYPES_VALUES[left.type];\n          var rightValue = TOKEN_TYPES_VALUES[right.type];\n          return leftValue - rightValue;\n        };\n        /**\n         * Checks if the specified tokens group is sortable.\n         * We do not re-sort tokens in case of any positional or child pseudos in the group\n         */\n\n\n        var isSortable = function isSortable(tokens) {\n          var iTokens = tokens.length;\n\n          while (iTokens--) {\n            var token = tokens[iTokens];\n\n            if (token.type === \"PSEUDO\" && POSITIONAL_PSEUDOS.indexOf(token.matches[0]) !== -1) {\n              return false;\n            }\n\n            if (token.type === \"CHILD\") {\n              return false;\n            }\n          }\n\n          return true;\n        };\n        /**\n         * Sorts the tokens in order to mitigate the issues caused by the left-to-right matching.\n         * The idea is change the tokens order so that Sizzle was matching fast selectors first (id, class),\n         * and slow selectors after that (and here I mean our slow custom pseudo classes).\n         *\n         * @param {Array} tokens An array of tokens to sort\n         * @returns {Array} A new re-sorted array\n         */\n\n\n        var sortTokens = function sortTokens(tokens) {\n          if (!tokens || tokens.length === 1) {\n            return tokens;\n          }\n\n          var sortedTokens = [];\n          var groups = splitCompoundSelector(tokens);\n\n          for (var i = 0; i < groups.length; i++) {\n            var group = groups[i];\n\n            if (group instanceof Array) {\n              if (isSortable(group)) {\n                group.sort(compareFunction);\n              }\n\n              sortedTokens = sortedTokens.concat(group);\n            } else {\n              sortedTokens.push(group);\n            }\n          }\n\n          return sortedTokens;\n        };\n        /**\n         * Sorts every tokens array inside of the specified \"groups\" array.\n         * See \"sortTokens\" methods for more information on how tokens are sorted.\n         *\n         * @param {Array} groups An array of tokens arrays.\n         * @returns {Array} A new array that consists of the same tokens arrays after sorting\n         */\n\n\n        var sortTokenGroups = function sortTokenGroups(groups) {\n          var sortedGroups = [];\n          var len = groups.length;\n          var i = 0;\n\n          for (; i < len; i++) {\n            sortedGroups.push(sortTokens(groups[i]));\n          }\n\n          return sortedGroups;\n        }; // Expose\n\n\n        return sortTokenGroups;\n      }();\n      /**\n       * Creates custom policy to use TrustedTypes CSP policy\n       * https://w3c.github.io/webappsec-trusted-types/dist/spec/\n       */\n\n\n      var AGPolicy = function createPolicy() {\n        var defaultPolicy = {\n          createHTML: function createHTML(input) {\n            return input;\n          },\n          createScript: function createScript(input) {\n            return input;\n          },\n          createScriptURL: function createScriptURL(input) {\n            return input;\n          }\n        };\n\n        if (window.trustedTypes && window.trustedTypes.createPolicy) {\n          return window.trustedTypes.createPolicy(\"AGPolicy\", defaultPolicy);\n        }\n\n        return defaultPolicy;\n      }();\n      /**\n       * [AdGuard Patch]:\n       * Removes trailing spaces from the tokens list\n       *\n       * @param {*} tokens An array of Sizzle tokens to post-process\n       */\n\n\n      function removeTrailingSpaces(tokens) {\n        var iTokens = tokens.length;\n\n        while (iTokens--) {\n          var token = tokens[iTokens];\n\n          if (token.type === \" \") {\n            tokens.length = iTokens;\n          } else {\n            break;\n          }\n        }\n      }\n      /**\n       * [AdGuard Patch]:\n       * An object with the information about selectors and their token representation\n       * @typedef {{selectorText: string, groups: Array}} SelectorData\n       * @property {string} selectorText A CSS selector text\n       * @property {Array} groups An array of token groups corresponding to that selector\n       */\n\n      /**\n       * [AdGuard Patch]:\n       * This method processes parsed token groups, divides them into a number of selectors\n       * and makes sure that each selector's tokens are cached properly in Sizzle.\n       *\n       * @param {*} groups Token groups (see {@link Sizzle.tokenize})\n       * @returns {Array.<SelectorData>} An array of selectors data we got from the groups\n       */\n\n\n      function tokenGroupsToSelectors(groups) {\n        // Remove trailing spaces which we can encounter in tolerant mode\n        // We're doing it in tolerant mode only as this is the only case when\n        // encountering trailing spaces is expected\n        removeTrailingSpaces(groups[groups.length - 1]); // We need sorted tokens to make cache work properly\n\n        var sortedGroups = sortTokenGroups(groups);\n        var selectors = [];\n\n        for (var i = 0; i < groups.length; i++) {\n          var tokenGroups = groups[i];\n          var selectorText = toSelector(tokenGroups);\n          selectors.push({\n            // Sizzle expects an array of token groups when compiling a selector\n            groups: [tokenGroups],\n            selectorText: selectorText\n          }); // Now make sure that selector tokens are cached\n\n          var tokensCacheItem = {\n            groups: tokenGroups,\n            sortedGroups: [sortedGroups[i]]\n          };\n          tokenCache(selectorText, tokensCacheItem);\n        }\n\n        return selectors;\n      }\n      /**\n       * [AdGuard Patch]:\n       * Add an additional argument for Sizzle.tokenize which indicates that it\n       * should not throw on invalid tokens, and instead should return tokens\n       * that it has produced so far.\n       *\n       * One more additional argument that allow to choose if you want to receive sorted or unsorted tokens\n       * The problem is that the re-sorted selectors are valid for Sizzle, but not for the browser.\n       * options.returnUnsorted -- return unsorted tokens if true.\n       * options.cacheOnly -- return cached result only. Required for unit-tests.\n       *\n       * @param {*} options Optional configuration object with two additional flags\n       * (options.tolerant, options.returnUnsorted, options.cacheOnly) -- see patches #5 and #6 notes\n       */\n\n\n      tokenize = Sizzle.tokenize = function (selector, parseOnly, options) {\n        var matched,\n            match,\n            tokens,\n            type,\n            soFar,\n            groups,\n            preFilters,\n            cached = tokenCache[selector + \" \"];\n        var tolerant = options && options.tolerant;\n        var returnUnsorted = options && options.returnUnsorted;\n        var cacheOnly = options && options.cacheOnly;\n\n        if (cached) {\n          if (parseOnly) {\n            return 0;\n          } else {\n            return (returnUnsorted ? cached.groups : cached.sortedGroups).slice(0);\n          }\n        }\n\n        if (cacheOnly) {\n          return null;\n        }\n\n        soFar = selector;\n        groups = [];\n        preFilters = Expr.preFilter;\n\n        while (soFar) {\n          // Comma and first run\n          if (!matched || (match = rcomma.exec(soFar))) {\n            if (match) {\n              // Don't consume trailing commas as valid\n              soFar = soFar.slice(match[0].length) || soFar;\n            }\n\n            groups.push(tokens = []);\n          }\n\n          matched = false; // Combinators\n\n          if (match = rcombinators.exec(soFar)) {\n            matched = match.shift();\n            tokens.push({\n              value: matched,\n              // Cast descendant combinators to space\n              type: match[0].replace(rtrim, \" \")\n            });\n            soFar = soFar.slice(matched.length);\n          } // Filters\n\n\n          for (type in Expr.filter) {\n            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n              matched = match.shift();\n              tokens.push({\n                value: matched,\n                type: type,\n                matches: match\n              });\n              soFar = soFar.slice(matched.length);\n            }\n          }\n\n          if (!matched) {\n            break;\n          }\n        } // Return the length of the invalid excess\n        // if we're just parsing\n        // Otherwise, throw an error or return tokens\n\n\n        var invalidLen = soFar.length;\n\n        if (parseOnly) {\n          return invalidLen;\n        }\n\n        if (invalidLen !== 0 && !tolerant) {\n          Sizzle.error(selector); // Throws an error.\n        }\n\n        if (tolerant) {\n          /**\n           * [AdGuard Patch]:\n           * In tolerant mode we return a special object that constists of\n           * an array of parsed selectors (and their tokens) and a \"nextIndex\" field\n           * that points to an index after which we're not able to parse selectors farther.\n           */\n          var nextIndex = selector.length - invalidLen;\n          var selectors = tokenGroupsToSelectors(groups);\n          return {\n            selectors: selectors,\n            nextIndex: nextIndex\n          };\n        }\n        /** [AdGuard Patch]: Sorting tokens */\n\n\n        var sortedGroups = sortTokenGroups(groups);\n        /** [AdGuard Patch]: Change the way tokens are cached */\n\n        var tokensCacheItem = {\n          groups: groups,\n          sortedGroups: sortedGroups\n        };\n        tokensCacheItem = tokenCache(selector, tokensCacheItem);\n        return (returnUnsorted ? tokensCacheItem.groups : tokensCacheItem.sortedGroups).slice(0);\n      };\n\n      function toSelector(tokens) {\n        var i = 0,\n            len = tokens.length,\n            selector = \"\";\n\n        for (; i < len; i++) {\n          selector += tokens[i].value;\n        }\n\n        return selector;\n      }\n\n      function addCombinator(matcher, combinator, base) {\n        var dir = combinator.dir,\n            skip = combinator.next,\n            key = skip || dir,\n            checkNonElements = base && key === \"parentNode\",\n            doneName = done++;\n        return combinator.first ? // Check against closest ancestor/preceding element\n        function (elem, context, xml) {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              return matcher(elem, context, xml);\n            }\n          }\n\n          return false;\n        } : // Check against all ancestor/preceding elements\n        function (elem, context, xml) {\n          var oldCache,\n              uniqueCache,\n              outerCache,\n              newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\n          if (xml) {\n            while (elem = elem[dir]) {\n              if (elem.nodeType === 1 || checkNonElements) {\n                if (matcher(elem, context, xml)) {\n                  return true;\n                }\n              }\n            }\n          } else {\n            while (elem = elem[dir]) {\n              if (elem.nodeType === 1 || checkNonElements) {\n                outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only\n                // Defend against cloned attroperties (jQuery gh-1709)\n\n                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n                if (skip && skip === elem.nodeName.toLowerCase()) {\n                  elem = elem[dir] || elem;\n                } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n                  // Assign to newCache so results back-propagate to previous elements\n                  return newCache[2] = oldCache[2];\n                } else {\n                  // Reuse newcache so results back-propagate to previous elements\n                  uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking\n\n                  if (newCache[2] = matcher(elem, context, xml)) {\n                    return true;\n                  }\n                }\n              }\n            }\n          }\n\n          return false;\n        };\n      }\n\n      function elementMatcher(matchers) {\n        return matchers.length > 1 ? function (elem, context, xml) {\n          var i = matchers.length;\n\n          while (i--) {\n            if (!matchers[i](elem, context, xml)) {\n              return false;\n            }\n          }\n\n          return true;\n        } : matchers[0];\n      }\n\n      function multipleContexts(selector, contexts, results) {\n        var i = 0,\n            len = contexts.length;\n\n        for (; i < len; i++) {\n          Sizzle(selector, contexts[i], results);\n        }\n\n        return results;\n      }\n\n      function condense(unmatched, map, filter, context, xml) {\n        var elem,\n            newUnmatched = [],\n            i = 0,\n            len = unmatched.length,\n            mapped = map != null;\n\n        for (; i < len; i++) {\n          if (elem = unmatched[i]) {\n            if (!filter || filter(elem, context, xml)) {\n              newUnmatched.push(elem);\n\n              if (mapped) {\n                map.push(i);\n              }\n            }\n          }\n        }\n\n        return newUnmatched;\n      }\n\n      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n        if (postFilter && !postFilter[expando]) {\n          postFilter = setMatcher(postFilter);\n        }\n\n        if (postFinder && !postFinder[expando]) {\n          postFinder = setMatcher(postFinder, postSelector);\n        }\n\n        return markFunction(function (seed, results, context, xml) {\n          var temp,\n              i,\n              elem,\n              preMap = [],\n              postMap = [],\n              preexisting = results.length,\n              // Get initial elements from seed or context\n          elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n              // Prefilter to get matcher input, preserving a map for seed-results synchronization\n          matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n              matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n          postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n          [] : // ...otherwise use results directly\n          results : matcherIn; // Find primary matches\n\n          if (matcher) {\n            matcher(matcherIn, matcherOut, context, xml);\n          } // Apply postFilter\n\n\n          if (postFilter) {\n            temp = condense(matcherOut, postMap);\n            postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn\n\n            i = temp.length;\n\n            while (i--) {\n              if (elem = temp[i]) {\n                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n              }\n            }\n          }\n\n          if (seed) {\n            if (postFinder || preFilter) {\n              if (postFinder) {\n                // Get the final matcherOut by condensing this intermediate into postFinder contexts\n                temp = [];\n                i = matcherOut.length;\n\n                while (i--) {\n                  if (elem = matcherOut[i]) {\n                    // Restore matcherIn since elem is not yet a final match\n                    temp.push(matcherIn[i] = elem);\n                  }\n                }\n\n                postFinder(null, matcherOut = [], temp, xml);\n              } // Move matched elements from seed to results to keep them synchronized\n\n\n              i = matcherOut.length;\n\n              while (i--) {\n                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n                  seed[temp] = !(results[temp] = elem);\n                }\n              }\n            } // Add elements to results, through postFinder if defined\n\n          } else {\n            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\n            if (postFinder) {\n              postFinder(null, results, matcherOut, xml);\n            } else {\n              push.apply(results, matcherOut);\n            }\n          }\n        });\n      }\n\n      function matcherFromTokens(tokens) {\n        var checkContext,\n            matcher,\n            j,\n            len = tokens.length,\n            leadingRelative = Expr.relative[tokens[0].type],\n            implicitRelative = leadingRelative || Expr.relative[\" \"],\n            i = leadingRelative ? 1 : 0,\n            // The foundational matcher ensures that elements are reachable from top-level context(s)\n        matchContext = addCombinator(function (elem) {\n          return elem === checkContext;\n        }, implicitRelative, true),\n            matchAnyContext = addCombinator(function (elem) {\n          return indexOf(checkContext, elem) > -1;\n        }, implicitRelative, true),\n            matchers = [function (elem, context, xml) {\n          var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)\n\n          checkContext = null;\n          return ret;\n        }];\n\n        for (; i < len; i++) {\n          if (matcher = Expr.relative[tokens[i].type]) {\n            matchers = [addCombinator(elementMatcher(matchers), matcher)];\n          } else {\n            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher\n\n            if (matcher[expando]) {\n              // Find the next relative operator (if any) for proper handling\n              j = ++i;\n\n              for (; j < len; j++) {\n                if (Expr.relative[tokens[j].type]) {\n                  break;\n                }\n              }\n\n              return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n              tokens.slice(0, i - 1).concat({\n                value: tokens[i - 2].type === \" \" ? \"*\" : \"\"\n              })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n            }\n\n            matchers.push(matcher);\n          }\n        }\n\n        return elementMatcher(matchers);\n      }\n\n      function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n        var bySet = setMatchers.length > 0,\n            byElement = elementMatchers.length > 0,\n            superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n          var elem,\n              j,\n              matcher,\n              matchedCount = 0,\n              i = \"0\",\n              unmatched = seed && [],\n              setMatched = [],\n              contextBackup = outermostContext,\n              // We must always have either seed elements or outermost context\n          elems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n              // Use integer dirruns iff this is the outermost matcher\n          dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n              len = elems.length;\n\n          if (outermost) {\n            outermostContext = context === document || context || outermost;\n          } // Add elements passing elementMatchers directly to results\n          // Support: IE<9, Safari\n          // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\n\n          for (; i !== len && (elem = elems[i]) != null; i++) {\n            if (byElement && elem) {\n              j = 0;\n\n              if (!context && elem.ownerDocument !== document) {\n                setDocument(elem);\n                xml = !documentIsHTML;\n              }\n\n              while (matcher = elementMatchers[j++]) {\n                if (matcher(elem, context || document, xml)) {\n                  results.push(elem);\n                  break;\n                }\n              }\n\n              if (outermost) {\n                dirruns = dirrunsUnique;\n              }\n            } // Track unmatched elements for set filters\n\n\n            if (bySet) {\n              // They will have gone through all possible matchers\n              if (elem = !matcher && elem) {\n                matchedCount--;\n              } // Lengthen the array for every element, matched or not\n\n\n              if (seed) {\n                unmatched.push(elem);\n              }\n            }\n          } // `i` is now the count of elements visited above, and adding it to `matchedCount`\n          // makes the latter nonnegative.\n\n\n          matchedCount += i; // Apply set filters to unmatched elements\n          // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n          // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n          // no element matchers and no seed.\n          // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n          // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n          // numerically zero.\n\n          if (bySet && i !== matchedCount) {\n            j = 0;\n\n            while (matcher = setMatchers[j++]) {\n              matcher(unmatched, setMatched, context, xml);\n            }\n\n            if (seed) {\n              // Reintegrate element matches to eliminate the need for sorting\n              if (matchedCount > 0) {\n                while (i--) {\n                  if (!(unmatched[i] || setMatched[i])) {\n                    setMatched[i] = pop.call(results);\n                  }\n                }\n              } // Discard index placeholder values to get only actual matches\n\n\n              setMatched = condense(setMatched);\n            } // Add matches to results\n\n\n            push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting\n\n            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n              Sizzle.uniqueSort(results);\n            }\n          } // Override manipulation of globals by nested matchers\n\n\n          if (outermost) {\n            dirruns = dirrunsUnique;\n            outermostContext = contextBackup;\n          }\n\n          return unmatched;\n        };\n\n        return bySet ? markFunction(superMatcher) : superMatcher;\n      }\n\n      compile = Sizzle.compile = function (selector, match\n      /* Internal Use Only */\n      ) {\n        var i,\n            setMatchers = [],\n            elementMatchers = [],\n            cached = compilerCache[selector + \" \"];\n\n        if (!cached) {\n          // Generate a function of recursive functions that can be used to check each element\n          if (!match) {\n            match = tokenize(selector);\n          }\n\n          i = match.length;\n\n          while (i--) {\n            cached = matcherFromTokens(match[i]);\n\n            if (cached[expando]) {\n              setMatchers.push(cached);\n            } else {\n              elementMatchers.push(cached);\n            }\n          } // Cache the compiled function\n\n\n          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization\n\n          cached.selector = selector;\n        }\n\n        return cached;\n      };\n      /**\n       * A low-level selection function that works with Sizzle's compiled\n       *  selector functions\n       * @param {String|Function} selector A selector or a pre-compiled\n       *  selector function built with Sizzle.compile\n       * @param {Element} context\n       * @param {Array} [results]\n       * @param {Array} [seed] A set of elements to match against\n       */\n\n\n      select = Sizzle.select = function (selector, context, results, seed) {\n        var i,\n            tokens,\n            token,\n            type,\n            find,\n            compiled = typeof selector === \"function\" && selector,\n            match = !seed && tokenize(selector = compiled.selector || selector);\n        results = results || []; // Try to minimize operations if there is only one selector in the list and no seed\n        // (the latter of which guarantees us context)\n\n        if (match.length === 1) {\n          // Reduce context if the leading compound selector is an ID\n          tokens = match[0] = match[0].slice(0);\n\n          if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n            context = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\n            if (!context) {\n              return results; // Precompiled matchers will still verify ancestry, so step up a level\n            } else if (compiled) {\n              context = context.parentNode;\n            }\n\n            selector = selector.slice(tokens.shift().value.length);\n          } // Fetch a seed set for right-to-left matching\n\n\n          i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\n          while (i--) {\n            token = tokens[i]; // Abort if we hit a combinator\n\n            if (Expr.relative[type = token.type]) {\n              break;\n            }\n\n            if (find = Expr.find[type]) {\n              // Search, expanding context for leading sibling combinators\n              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n                // If seed is empty or no tokens remain, we can return early\n                tokens.splice(i, 1);\n                selector = seed.length && toSelector(tokens);\n\n                if (!selector) {\n                  push.apply(results, seed);\n                  return results;\n                }\n\n                break;\n              }\n            }\n          }\n        } // Compile and execute a filtering function if one is not provided\n        // Provide `match` to avoid retokenization if we modified the selector above\n\n\n        (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n        return results;\n      }; // One-time assignments\n      // Sort stability\n\n\n      support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando; // Support: Chrome 14-35+\n      // Always assume duplicates if they aren't passed to the comparison function\n\n      support.detectDuplicates = !!hasDuplicate; // Initialize against the default document\n\n      setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n      // Detached nodes confoundingly follow *each other*\n\n      support.sortDetached = assert(function (el) {\n        // Should return 1, but returns 4 (following)\n        return el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n      }); // Support: IE<8\n      // Prevent attribute/property \"interpolation\"\n      // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\n      if (!assert(function (el) {\n        el.innerHTML = AGPolicy.createHTML(\"<a href='#'></a>\");\n        return el.firstChild.getAttribute(\"href\") === \"#\";\n      })) {\n        addHandle(\"type|href|height|width\", function (elem, name, isXML) {\n          if (!isXML) {\n            return elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n          }\n        });\n      } // Support: IE<9\n      // Use defaultValue in place of getAttribute(\"value\")\n\n\n      if (!support.attributes || !assert(function (el) {\n        el.innerHTML = AGPolicy.createHTML(\"<input/>\");\n        el.firstChild.setAttribute(\"value\", \"\");\n        return el.firstChild.getAttribute(\"value\") === \"\";\n      })) {\n        addHandle(\"value\", function (elem, name, isXML) {\n          if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n            return elem.defaultValue;\n          }\n        });\n      } // Support: IE<9\n      // Use getAttributeNode to fetch booleans when getAttribute lies\n\n\n      if (!assert(function (el) {\n        return el.getAttribute(\"disabled\") == null;\n      })) {\n        addHandle(booleans, function (elem, name, isXML) {\n          var val;\n\n          if (!isXML) {\n            return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n          }\n        });\n      } // EXPOSE\n      // Do not expose Sizzle to the global scope in the case of AdGuard ExtendedCss build\n\n\n      return Sizzle; // EXPOSE\n    }(window); //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n  }\n\n  return Sizzle;\n};\n\n/* jshint ignore:end */\n\n/**\n * Copyright 2016 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Class that extends Sizzle and adds support for \"matches-css\" pseudo element.\n */\n\nvar StylePropertyMatcher = function (window) {\n  var isPhantom = !!window._phantom;\n  var useFallback = isPhantom && !!window.getMatchedCSSRules;\n  /**\n   * Unquotes specified value\n   * Webkit-based browsers singlequotes <string> content property values\n   * Other browsers doublequotes content property values.\n   */\n\n  var removeContentQuotes = function removeContentQuotes(value) {\n    if (typeof value === 'string') {\n      return value.replace(/^([\"'])([\\s\\S]*)\\1$/, '$2');\n    }\n\n    return value;\n  };\n\n  var getComputedStyle = window.getComputedStyle.bind(window);\n  var getMatchedCSSRules = useFallback ? window.getMatchedCSSRules.bind(window) : null;\n  /**\n   * There is an issue in browsers based on old webkit:\n   * getComputedStyle(el, \":before\") is empty if element is not visible.\n   *\n   * To circumvent this issue we use getMatchedCSSRules instead.\n   *\n   * It appears that getMatchedCSSRules sorts the CSS rules\n   * in increasing order of specifities of corresponding selectors.\n   * We pick the css rule that is being applied to an element based on this assumption.\n   *\n   * @param element       DOM node\n   * @param pseudoElement Optional pseudoElement name\n   * @param propertyName  CSS property name\n   */\n\n  var getComputedStylePropertyValue = function getComputedStylePropertyValue(element, pseudoElement, propertyName) {\n    var value = '';\n\n    if (useFallback && pseudoElement) {\n      var cssRules = getMatchedCSSRules(element, pseudoElement) || [];\n      var i = cssRules.length;\n\n      while (i-- > 0 && !value) {\n        value = cssRules[i].style.getPropertyValue(propertyName);\n      }\n    } else {\n      var style = getComputedStyle(element, pseudoElement);\n\n      if (style) {\n        value = style.getPropertyValue(propertyName); // https://bugs.webkit.org/show_bug.cgi?id=93445\n\n        if (propertyName === 'opacity' && utils.isSafariBrowser) {\n          value = (Math.round(parseFloat(value) * 100) / 100).toString();\n        }\n      }\n    }\n\n    if (propertyName === 'content') {\n      value = removeContentQuotes(value);\n    }\n\n    return value;\n  };\n  /**\n   * Adds url parameter quotes for non-regex pattern\n   * @param {string} pattern\n   */\n\n\n  var addUrlQuotes = function addUrlQuotes(pattern) {\n    // for regex patterns\n    if (pattern[0] === '/' && pattern[pattern.length - 1] === '/' && pattern.indexOf('\\\\\"') < 10) {\n      // e.g. /^url\\\\([a-z]{4}:[a-z]{5}/\n      // or /^url\\\\(data\\\\:\\\\image\\\\/gif;base64.+/\n      var re = /(\\^)?url(\\\\)?\\\\\\((\\w|\\[\\w)/g;\n      return pattern.replace(re, '$1url$2\\\\\\(\\\\\"?$3');\n    } // for non-regex patterns\n\n\n    if (pattern.indexOf('url(\"') === -1) {\n      var _re = /url\\((.*?)\\)/g;\n      return pattern.replace(_re, 'url(\"$1\")');\n    }\n\n    return pattern;\n  };\n  /**\n   * Class that matches element style against the specified expression\n   * @member {string} propertyName\n   * @member {string} pseudoElement\n   * @member {RegExp} regex\n   */\n\n\n  var Matcher = function Matcher(propertyFilter, pseudoElement) {\n    this.pseudoElement = pseudoElement;\n\n    try {\n      var index = propertyFilter.indexOf(':');\n      this.propertyName = propertyFilter.substring(0, index).trim();\n      var pattern = propertyFilter.substring(index + 1).trim();\n      pattern = addUrlQuotes(pattern); // Unescaping pattern\n      // For non-regex patterns, (,),[,] should be unescaped, because we require escaping them in filter rules.\n      // For regex patterns, \",\\ should be escaped, because we manually escape those in extended-css-selector.js.\n\n      if (/^\\/.*\\/$/.test(pattern)) {\n        pattern = pattern.slice(1, -1);\n        this.regex = utils.pseudoArgToRegex(pattern);\n      } else {\n        pattern = pattern.replace(/\\\\([\\\\()[\\]\"])/g, '$1');\n        this.regex = utils.createURLRegex(pattern);\n      }\n    } catch (ex) {\n      utils.logError(\"StylePropertyMatcher: invalid match string \".concat(propertyFilter));\n    }\n  };\n  /**\n   * Function to check if element CSS property matches filter pattern\n   * @param {Element} element to check\n   */\n\n\n  Matcher.prototype.matches = function (element) {\n    if (!this.regex || !this.propertyName) {\n      return false;\n    }\n\n    var value = getComputedStylePropertyValue(element, this.pseudoElement, this.propertyName);\n    return value && this.regex.test(value);\n  };\n  /**\n   * Creates a new pseudo-class and registers it in Sizzle\n   */\n\n\n  var extendSizzle = function extendSizzle(sizzle) {\n    // First of all we should prepare Sizzle engine\n    sizzle.selectors.pseudos['matches-css'] = sizzle.selectors.createPseudo(function (propertyFilter) {\n      var matcher = new Matcher(propertyFilter);\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n    sizzle.selectors.pseudos['matches-css-before'] = sizzle.selectors.createPseudo(function (propertyFilter) {\n      var matcher = new Matcher(propertyFilter, ':before');\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n    sizzle.selectors.pseudos['matches-css-after'] = sizzle.selectors.createPseudo(function (propertyFilter) {\n      var matcher = new Matcher(propertyFilter, ':after');\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n  }; // EXPOSE\n\n\n  return {\n    extendSizzle: extendSizzle\n  };\n}(window);\n\n/**\n * Copyright 2016 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar matcherUtils = {};\nmatcherUtils.MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n/**\n * Parses argument of matcher pseudo (for matches-attr and matches-property)\n * @param {string} matcherFilter argument of pseudo class\n * @returns {Array}\n */\n\nmatcherUtils.parseMatcherFilter = function (matcherFilter) {\n  var FULL_MATCH_MARKER = '\"=\"';\n  var rawArgs = [];\n\n  if (matcherFilter.indexOf(FULL_MATCH_MARKER) === -1) {\n    // if there is only one pseudo arg\n    // e.g. :matches-attr(\"data-name\") or :matches-property(\"inner.prop\")\n    // Sizzle will parse it and get rid of quotes\n    // so it might be valid arg already without them\n    rawArgs.push(matcherFilter);\n  } else {\n    matcherFilter.split('=').forEach(function (arg) {\n      if (arg[0] === '\"' && arg[arg.length - 1] === '\"') {\n        rawArgs.push(arg.slice(1, -1));\n      }\n    });\n  }\n\n  return rawArgs;\n};\n/**\n * @typedef {Object} ArgData\n * @property {string} arg\n * @property {boolean} isRegexp\n */\n\n/**\n * Parses raw matcher arg\n * @param {string} rawArg\n * @returns {ArgData}\n */\n\n\nmatcherUtils.parseRawMatcherArg = function (rawArg) {\n  var arg = rawArg;\n  var isRegexp = !!rawArg && rawArg[0] === '/' && rawArg[rawArg.length - 1] === '/';\n\n  if (isRegexp) {\n    // to avoid at least such case — :matches-property(\"//\")\n    if (rawArg.length > 2) {\n      arg = utils.toRegExp(rawArg);\n    } else {\n      throw new Error(\"Invalid regexp: \".concat(rawArg));\n    }\n  }\n\n  return {\n    arg: arg,\n    isRegexp: isRegexp\n  };\n};\n/**\n * @typedef Chain\n * @property {Object} base\n * @property {string} prop\n * @property {string} value\n */\n\n/**\n * Checks if the property exists in the base object (recursively).\n * @param {Object} base\n * @param {ArgData[]} chain array of objects - parsed string property chain\n * @param {Array} [output=[]] result acc\n * @returns {Chain[]} array of objects\n */\n\n\nmatcherUtils.filterRootsByRegexpChain = function (base, chain) {\n  var output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var tempProp = chain[0];\n\n  if (chain.length === 1) {\n    // eslint-disable-next-line no-restricted-syntax\n    for (var key in base) {\n      if (tempProp.isRegexp) {\n        if (tempProp.arg.test(key)) {\n          output.push({\n            base: base,\n            prop: key,\n            value: base[key]\n          });\n        }\n      } else if (tempProp.arg === key) {\n        output.push({\n          base: base,\n          prop: tempProp.arg,\n          value: base[key]\n        });\n      }\n    }\n\n    return output;\n  } // if there is a regexp prop in input chain\n  // e.g. 'unit./^ad.+/.src' for 'unit.ad-1gf2.src unit.ad-fgd34.src'),\n  // every base keys should be tested by regexp and it can be more that one results\n\n\n  if (tempProp.isRegexp) {\n    var nextProp = chain.slice(1);\n    var baseKeys = []; // eslint-disable-next-line no-restricted-syntax\n\n    for (var _key in base) {\n      if (tempProp.arg.test(_key)) {\n        baseKeys.push(_key);\n      }\n    }\n\n    baseKeys.forEach(function (key) {\n      var item = base[key];\n      matcherUtils.filterRootsByRegexpChain(item, nextProp, output);\n    });\n  } // avoid TypeError while accessing to null-prop's child\n\n\n  if (base === null) {\n    return;\n  }\n\n  var nextBase = base[tempProp.arg];\n  chain = chain.slice(1);\n\n  if (nextBase !== undefined) {\n    matcherUtils.filterRootsByRegexpChain(nextBase, chain, output);\n  }\n\n  return output;\n};\n/**\n * Validates parsed args of matches-property pseudo\n * @param {...ArgData} args\n */\n\n\nmatcherUtils.validatePropMatcherArgs = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  for (var i = 0; i < args.length; i += 1) {\n    if (args[i].isRegexp) {\n      if (!utils.startsWith(args[i].arg.toString(), '/') || !utils.endsWith(args[i].arg.toString(), '/')) {\n        return false;\n      } // simple arg check if it is not a regexp\n\n    } else if (!/^[\\w-]+$/.test(args[i].arg)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Class that extends Sizzle and adds support for \"matches-attr\" pseudo element.\n */\n\nvar AttributesMatcher = function () {\n  /**\n   * Class that matches element attributes against the specified expressions\n   * @param {ArgData} nameArg - parsed name argument\n   * @param {ArgData} valueArg - parsed value argument\n   * @param {string} pseudoElement\n   * @constructor\n   *\n   * @member {string|RegExp} attrName\n   * @member {boolean} isRegexpName\n   * @member {string|RegExp} attrValue\n   * @member {boolean} isRegexpValue\n   */\n  var AttrMatcher = function AttrMatcher(nameArg, valueArg, pseudoElement) {\n    this.pseudoElement = pseudoElement;\n    this.attrName = nameArg.arg;\n    this.isRegexpName = nameArg.isRegexp;\n    this.attrValue = valueArg.arg;\n    this.isRegexpValue = valueArg.isRegexp;\n  };\n  /**\n   * Function to check if element attributes matches filter pattern\n   * @param {Element} element to check\n   */\n\n\n  AttrMatcher.prototype.matches = function (element) {\n    var elAttrs = element.attributes;\n\n    if (elAttrs.length === 0 || !this.attrName) {\n      return false;\n    }\n\n    var i = 0;\n\n    while (i < elAttrs.length) {\n      var attr = elAttrs[i];\n      var matched = false;\n      var attrNameMatched = this.isRegexpName ? this.attrName.test(attr.name) : this.attrName === attr.name;\n\n      if (!this.attrValue) {\n        // for :matches-attr(\"/regex/\") or :matches-attr(\"attr-name\")\n        matched = attrNameMatched;\n      } else {\n        var attrValueMatched = this.isRegexpValue ? this.attrValue.test(attr.value) : this.attrValue === attr.value;\n        matched = attrNameMatched && attrValueMatched;\n      }\n\n      if (matched) {\n        return true;\n      }\n\n      i += 1;\n    }\n  };\n  /**\n   * Creates a new pseudo-class and registers it in Sizzle\n   */\n\n\n  var extendSizzle = function extendSizzle(sizzle) {\n    // First of all we should prepare Sizzle engine\n    sizzle.selectors.pseudos['matches-attr'] = sizzle.selectors.createPseudo(function (attrFilter) {\n      var _matcherUtils$parseMa = matcherUtils.parseMatcherFilter(attrFilter),\n          _matcherUtils$parseMa2 = _slicedToArray(_matcherUtils$parseMa, 2),\n          rawName = _matcherUtils$parseMa2[0],\n          rawValue = _matcherUtils$parseMa2[1];\n\n      var nameArg = matcherUtils.parseRawMatcherArg(rawName);\n      var valueArg = matcherUtils.parseRawMatcherArg(rawValue);\n\n      if (!attrFilter || !matcherUtils.validatePropMatcherArgs(nameArg, valueArg)) {\n        throw new Error(\"Invalid argument of :matches-attr pseudo class: \".concat(attrFilter));\n      }\n\n      var matcher = new AttrMatcher(nameArg, valueArg);\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n  }; // EXPOSE\n\n\n  return {\n    extendSizzle: extendSizzle\n  };\n}();\n\n/**\n * Parses raw property arg\n * @param {string} input\n * @returns {ArgData[]} array of objects\n */\n\nvar parseRawPropChain = function parseRawPropChain(input) {\n  var PROPS_DIVIDER = '.';\n  var REGEXP_MARKER = '/';\n  var propsArr = [];\n  var str = input;\n\n  while (str.length > 0) {\n    if (utils.startsWith(str, PROPS_DIVIDER)) {\n      // for cases like '.prop.id' and 'nested..test'\n      throw new Error(\"Invalid chain property: \".concat(input));\n    }\n\n    if (!utils.startsWith(str, REGEXP_MARKER)) {\n      var isRegexp = false;\n      var dividerIndex = str.indexOf(PROPS_DIVIDER);\n\n      if (str.indexOf(PROPS_DIVIDER) === -1) {\n        // if there is no '.' left in str\n        // take the rest of str as prop\n        propsArr.push({\n          arg: str,\n          isRegexp: isRegexp\n        });\n        return propsArr;\n      } // else take prop from str\n\n\n      var prop = str.slice(0, dividerIndex); // for cases like 'asadf.?+/.test'\n\n      if (prop.indexOf(REGEXP_MARKER) > -1) {\n        // prop is '?+/'\n        throw new Error(\"Invalid chain property: \".concat(prop));\n      }\n\n      propsArr.push({\n        arg: prop,\n        isRegexp: isRegexp\n      }); // delete prop from str\n\n      str = str.slice(dividerIndex);\n    } else {\n      // deal with regexp\n      var propChunks = [];\n      propChunks.push(str.slice(0, 1)); // if str starts with '/', delete it from str and find closing regexp slash.\n      // note that chained property name can not include '/' or '.'\n      // so there is no checking for escaped characters\n\n      str = str.slice(1);\n      var regexEndIndex = str.indexOf(REGEXP_MARKER);\n\n      if (regexEndIndex < 1) {\n        // regexp should be at least === '/./'\n        // so we should avoid args like '/id' and 'test.//.id'\n        throw new Error(\"Invalid regexp: \".concat(REGEXP_MARKER).concat(str));\n      }\n\n      var _isRegexp = true; // take the rest regexp part\n\n      propChunks.push(str.slice(0, regexEndIndex + 1));\n\n      var _prop = utils.toRegExp(propChunks.join(''));\n\n      propsArr.push({\n        arg: _prop,\n        isRegexp: _isRegexp\n      }); // delete prop from str\n\n      str = str.slice(regexEndIndex + 1);\n    }\n\n    if (!str) {\n      return propsArr;\n    } // str should be like '.nextProp' now\n    // so 'zx.prop' or '.' is invalid\n\n\n    if (!utils.startsWith(str, PROPS_DIVIDER) || utils.startsWith(str, PROPS_DIVIDER) && str.length === 1) {\n      throw new Error(\"Invalid chain property: \".concat(input));\n    }\n\n    str = str.slice(1);\n  }\n};\n\nvar convertTypeFromStr = function convertTypeFromStr(value) {\n  var numValue = Number(value);\n  var output;\n\n  if (!Number.isNaN(numValue)) {\n    output = numValue;\n  } else {\n    switch (value) {\n      case 'undefined':\n        output = undefined;\n        break;\n\n      case 'null':\n        output = null;\n        break;\n\n      case 'true':\n        output = true;\n        break;\n\n      case 'false':\n        output = false;\n        break;\n\n      default:\n        output = value;\n    }\n  }\n\n  return output;\n};\n\nvar convertTypeIntoStr = function convertTypeIntoStr(value) {\n  var output;\n\n  switch (value) {\n    case undefined:\n      output = 'undefined';\n      break;\n\n    case null:\n      output = 'null';\n      break;\n\n    default:\n      output = value.toString();\n  }\n\n  return output;\n};\n/**\n * Class that extends Sizzle and adds support for \"matches-property\" pseudo element.\n */\n\n\nvar ElementPropertyMatcher = function () {\n  /**\n   * Class that matches element properties against the specified expressions\n   * @param {ArgData[]} propsChainArg - array of parsed props chain objects\n   * @param {ArgData} valueArg - parsed value argument\n   * @param {string} pseudoElement\n   * @constructor\n   *\n   * @member {Array} chainedProps\n   * @member {boolean} isRegexpName\n   * @member {string|RegExp} propValue\n   * @member {boolean} isRegexpValue\n   */\n  var PropMatcher = function PropMatcher(propsChainArg, valueArg, pseudoElement) {\n    this.pseudoElement = pseudoElement;\n    this.chainedProps = propsChainArg;\n    this.propValue = valueArg.arg;\n    this.isRegexpValue = valueArg.isRegexp;\n  };\n  /**\n   * Function to check if element properties matches filter pattern\n   * @param {Element} element to check\n   */\n\n\n  PropMatcher.prototype.matches = function (element) {\n    var ownerObjArr = matcherUtils.filterRootsByRegexpChain(element, this.chainedProps);\n\n    if (ownerObjArr.length === 0) {\n      return false;\n    }\n\n    var matched = true;\n\n    if (this.propValue) {\n      for (var i = 0; i < ownerObjArr.length; i += 1) {\n        var realValue = ownerObjArr[i].value;\n\n        if (this.isRegexpValue) {\n          matched = this.propValue.test(convertTypeIntoStr(realValue));\n        } else {\n          // handle 'null' and 'undefined' property values set as string\n          if (realValue === 'null' || realValue === 'undefined') {\n            matched = this.propValue === realValue;\n            break;\n          }\n\n          matched = convertTypeFromStr(this.propValue) === realValue;\n        }\n\n        if (matched) {\n          break;\n        }\n      }\n    }\n\n    return matched;\n  };\n  /**\n   * Creates a new pseudo-class and registers it in Sizzle\n   */\n\n\n  var extendSizzle = function extendSizzle(sizzle) {\n    // First of all we should prepare Sizzle engine\n    sizzle.selectors.pseudos['matches-property'] = sizzle.selectors.createPseudo(function (propertyFilter) {\n      if (!propertyFilter) {\n        throw new Error('No argument is given for :matches-property pseudo class');\n      }\n\n      var _matcherUtils$parseMa = matcherUtils.parseMatcherFilter(propertyFilter),\n          _matcherUtils$parseMa2 = _slicedToArray(_matcherUtils$parseMa, 2),\n          rawProp = _matcherUtils$parseMa2[0],\n          rawValue = _matcherUtils$parseMa2[1]; // chained property name can not include '/' or '.'\n      // so regex prop names with such escaped characters are invalid\n\n\n      if (rawProp.indexOf('\\\\/') > -1 || rawProp.indexOf('\\\\.') > -1) {\n        throw new Error(\"Invalid property name: \".concat(rawProp));\n      }\n\n      var propsChainArg = parseRawPropChain(rawProp);\n      var valueArg = matcherUtils.parseRawMatcherArg(rawValue);\n      var propsToValidate = [].concat(_toConsumableArray(propsChainArg), [valueArg]);\n\n      if (!matcherUtils.validatePropMatcherArgs(propsToValidate)) {\n        throw new Error(\"Invalid argument of :matches-property pseudo class: \".concat(propertyFilter));\n      }\n\n      var matcher = new PropMatcher(propsChainArg, valueArg);\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n  }; // EXPOSE\n\n\n  return {\n    extendSizzle: extendSizzle\n  };\n}();\n\n/**\n * Copyright 2020 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Class that extends Sizzle and adds support for :is() pseudo element.\n */\n\nvar IsAnyMatcher = function () {\n  /**\n   * Class that matches element by one of the selectors\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/:is\n   * @param {Array} selectors\n   * @param {string} pseudoElement\n   * @constructor\n   */\n  var IsMatcher = function IsMatcher(selectors, pseudoElement) {\n    this.selectors = selectors;\n    this.pseudoElement = pseudoElement;\n  };\n  /**\n   * Function to check if element can be matched by any passed selector\n   * @param {Element} element to check\n   */\n\n\n  IsMatcher.prototype.matches = function (element) {\n    var isMatched = !!this.selectors.find(function (selector) {\n      var nodes = document.querySelectorAll(selector);\n      return Array.from(nodes).find(function (node) {\n        return node === element;\n      });\n    });\n    return isMatched;\n  };\n  /**\n   * Creates a new pseudo-class and registers it in Sizzle\n   */\n\n\n  var extendSizzle = function extendSizzle(sizzle) {\n    // First of all we should prepare Sizzle engine\n    sizzle.selectors.pseudos['is'] = sizzle.selectors.createPseudo(function (input) {\n      if (input === '') {\n        throw new Error(\"Invalid argument of :is pseudo-class: \".concat(input));\n      }\n\n      var selectors = input.split(',').map(function (s) {\n        return s.trim();\n      }); // collect valid selectors and log about invalid ones\n\n      var validSelectors = selectors.reduce(function (acc, selector) {\n        if (cssUtils.isSimpleSelectorValid(selector)) {\n          acc.push(selector);\n        } else {\n          utils.logInfo(\"Invalid selector passed to :is() pseudo-class: '\".concat(selector, \"'\"));\n        }\n\n        return acc;\n      }, []);\n      var matcher = new IsMatcher(validSelectors);\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n  };\n\n  return {\n    extendSizzle: extendSizzle\n  };\n}();\n\n/**\n * Copyright 2021 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Extended selector factory module, for creating extended selector classes.\n *\n * Extended selection capabilities description:\n * https://github.com/AdguardTeam/ExtendedCss/blob/master/README.md\n */\n\nvar ExtendedSelectorFactory = function () {\n  // while adding new markers, constants in other AdGuard repos should be corrected\n  // AdGuard browser extension : CssFilterRule.SUPPORTED_PSEUDO_CLASSES and CssFilterRule.EXTENDED_CSS_MARKERS\n  // tsurlfilter, SafariConverterLib : EXT_CSS_PSEUDO_INDICATORS\n  var PSEUDO_EXTENSIONS_MARKERS = [':has', ':contains', ':has-text', ':matches-css', ':-abp-has', ':-abp-has-text', ':if', ':if-not', ':xpath', ':nth-ancestor', ':upward', ':remove', ':matches-attr', ':matches-property', ':-abp-contains', ':is'];\n  var initialized = false;\n  var Sizzle;\n  /**\n   * Lazy initialization of the ExtendedSelectorFactory and objects that might be necessary for creating and applying styles.\n   * This method extends Sizzle engine that we use under the hood with our custom pseudo-classes.\n   */\n\n  function initialize() {\n    if (initialized) {\n      return;\n    }\n\n    initialized = true; // Our version of Sizzle is initialized lazily as well\n\n    Sizzle = initializeSizzle(); // Add :matches-css-*() support\n\n    StylePropertyMatcher.extendSizzle(Sizzle); // Add :matches-attr() support\n\n    AttributesMatcher.extendSizzle(Sizzle); // Add :matches-property() support\n\n    ElementPropertyMatcher.extendSizzle(Sizzle); // Add :is() support\n\n    IsAnyMatcher.extendSizzle(Sizzle); // Add :contains, :has-text, :-abp-contains support\n\n    var containsPseudo = Sizzle.selectors.createPseudo(function (text) {\n      if (/^\\s*\\/.*\\/[gmisuy]*\\s*$/.test(text)) {\n        text = text.trim();\n        var flagsIndex = text.lastIndexOf('/');\n        var flags = text.substring(flagsIndex + 1);\n        text = text.substr(0, flagsIndex + 1).slice(1, -1).replace(/\\\\([\\\\\"])/g, '$1');\n        var regex;\n\n        try {\n          regex = new RegExp(text, flags);\n        } catch (e) {\n          throw new Error(\"Invalid argument of :contains pseudo class: \".concat(text));\n        }\n\n        return function (elem) {\n          var elemTextContent = utils.nodeTextContentGetter.apply(elem);\n          return regex.test(elemTextContent);\n        };\n      }\n\n      text = text.replace(/\\\\([\\\\()[\\]\"])/g, '$1');\n      return function (elem) {\n        var elemTextContent = utils.nodeTextContentGetter.apply(elem);\n        return elemTextContent.indexOf(text) > -1;\n      };\n    });\n    Sizzle.selectors.pseudos['contains'] = containsPseudo;\n    Sizzle.selectors.pseudos['has-text'] = containsPseudo;\n    Sizzle.selectors.pseudos['-abp-contains'] = containsPseudo; // Add :if, :-abp-has support\n\n    Sizzle.selectors.pseudos['if'] = Sizzle.selectors.pseudos['has'];\n    Sizzle.selectors.pseudos['-abp-has'] = Sizzle.selectors.pseudos['has']; // Add :if-not support\n\n    Sizzle.selectors.pseudos['if-not'] = Sizzle.selectors.createPseudo(function (selector) {\n      if (typeof selector === 'string') {\n        Sizzle.compile(selector);\n      }\n\n      return function (elem) {\n        return Sizzle(selector, elem).length === 0;\n      };\n    });\n    registerParserOnlyTokens();\n  }\n  /**\n   * Registrate custom tokens for parser.\n   * Needed for proper work of pseudos:\n   * for checking if the token is last and pseudo-class arguments validation\n   */\n\n\n  function registerParserOnlyTokens() {\n    Sizzle.selectors.pseudos['xpath'] = Sizzle.selectors.createPseudo(function (selector) {\n      try {\n        document.createExpression(selector, null);\n      } catch (e) {\n        throw new Error(\"Invalid argument of :xpath pseudo class: \".concat(selector));\n      }\n\n      return function () {\n        return true;\n      };\n    });\n    Sizzle.selectors.pseudos['nth-ancestor'] = Sizzle.selectors.createPseudo(function (selector) {\n      var deep = Number(selector);\n\n      if (Number.isNaN(deep) || deep < 1 || deep >= 256) {\n        throw new Error(\"Invalid argument of :nth-ancestor pseudo class: \".concat(selector));\n      }\n\n      return function () {\n        return true;\n      };\n    });\n    Sizzle.selectors.pseudos['upward'] = Sizzle.selectors.createPseudo(function (input) {\n      if (input === '') {\n        throw new Error(\"Invalid argument of :upward pseudo class: \".concat(input));\n      } else if (Number.isInteger(+input) && (+input < 1 || +input >= 256)) {\n        throw new Error(\"Invalid argument of :upward pseudo class: \".concat(input));\n      }\n\n      return function () {\n        return true;\n      };\n    });\n    Sizzle.selectors.pseudos['remove'] = Sizzle.selectors.createPseudo(function (input) {\n      if (input !== '') {\n        throw new Error(\"Invalid argument of :remove pseudo class: \".concat(input));\n      }\n\n      return function () {\n        return true;\n      };\n    });\n  }\n  /**\n   * Checks if specified token can be used by document.querySelectorAll.\n   */\n\n\n  function isSimpleToken(token) {\n    var type = token.type;\n\n    if (type === 'ID' || type === 'CLASS' || type === 'ATTR' || type === 'TAG' || type === 'CHILD') {\n      // known simple tokens\n      return true;\n    }\n\n    if (type === 'PSEUDO') {\n      // check if value contains any of extended pseudo classes\n      var i = PSEUDO_EXTENSIONS_MARKERS.length;\n\n      while (i--) {\n        if (token.value.indexOf(PSEUDO_EXTENSIONS_MARKERS[i]) >= 0) {\n          return false;\n        }\n      }\n\n      return true;\n    } // all others aren't simple\n\n\n    return false;\n  }\n  /**\n   * Checks if specified token is a combinator\n   */\n\n\n  function isRelationToken(token) {\n    var type = token.type;\n    return type === ' ' || type === '>' || type === '+' || type === '~';\n  }\n  /**\n   * ExtendedSelectorParser is a helper class for creating various selector instances which\n   * all shares a method `querySelectorAll()` and `matches()` implementing different search strategies\n   * depending on a type of selector.\n   *\n   * Currently, there are 3 types:\n   *  A trait-less extended selector\n   *    - we directly feed selector strings to Sizzle.\n   *  A splitted extended selector\n   *    - such as #container #feedItem:has(.ads), where it is splitted to `#container` and `#feedItem:has(.ads)`.\n   */\n\n\n  function ExtendedSelectorParser(selectorText, tokens, debug) {\n    initialize();\n\n    if (typeof tokens === 'undefined') {\n      this.selectorText = cssUtils.normalize(selectorText); // Passing `returnUnsorted` in order to receive tokens in the order that's valid for the browser\n      // In Sizzle internally, the tokens are re-sorted: https://github.com/AdguardTeam/ExtendedCss/issues/55\n\n      this.tokens = Sizzle.tokenize(this.selectorText, false, {\n        returnUnsorted: true\n      });\n    } else {\n      this.selectorText = selectorText;\n      this.tokens = tokens;\n    }\n\n    if (debug === true) {\n      this.debug = true;\n    }\n  }\n\n  ExtendedSelectorParser.prototype = {\n    /**\n     * The main method, creates a selector instance depending on the type of a selector.\n     * @public\n     */\n    createSelector: function createSelector() {\n      var debug = this.debug;\n      var tokens = this.tokens;\n      var selectorText = this.selectorText;\n\n      if (tokens.length !== 1) {\n        // Comma-separate selector - can't optimize further\n        return new TraitLessSelector(selectorText, debug);\n      }\n\n      var xpathPart = this.getXpathPart();\n\n      if (typeof xpathPart !== 'undefined') {\n        return new XpathSelector(selectorText, xpathPart, debug);\n      }\n\n      var upwardPart = this.getUpwardPart();\n\n      if (typeof upwardPart !== 'undefined') {\n        var output;\n        var upwardDeep = parseInt(upwardPart, 10); // if upward parameter is not a number, we consider it as a selector\n\n        if (Number.isNaN(upwardDeep)) {\n          output = new UpwardSelector(selectorText, upwardPart, debug);\n        } else {\n          // upward works like nth-ancestor\n          var xpath = this.convertNthAncestorToken(upwardDeep);\n          output = new XpathSelector(selectorText, xpath, debug);\n        }\n\n        return output;\n      } // argument of pseudo-class remove;\n      // it's defined only if remove is parsed as last token\n      // and it's valid only if remove arg is empty string\n\n\n      var removePart = this.getRemovePart();\n\n      if (typeof removePart !== 'undefined') {\n        var hasValidRemovePart = removePart === '';\n        return new RemoveSelector(selectorText, hasValidRemovePart, debug);\n      }\n\n      tokens = tokens[0];\n      var l = tokens.length;\n      var lastRelTokenInd = this.getSplitPoint();\n\n      if (typeof lastRelTokenInd === 'undefined') {\n        try {\n          document.querySelector(selectorText);\n        } catch (e) {\n          return new TraitLessSelector(selectorText, debug);\n        }\n\n        return new NotAnExtendedSelector(selectorText, debug);\n      }\n\n      var simple = '';\n      var relation = null;\n      var complex = '';\n      var i = 0;\n\n      for (; i < lastRelTokenInd; i++) {\n        // build simple part\n        simple += tokens[i].value;\n      }\n\n      if (i > 0) {\n        // build relation part\n        relation = tokens[i++].type;\n      } // i is pointing to the start of a complex part.\n\n\n      for (; i < l; i++) {\n        complex += tokens[i].value;\n      }\n\n      return lastRelTokenInd === -1 ? new TraitLessSelector(selectorText, debug) : new SplittedSelector(selectorText, simple, relation, complex, debug);\n    },\n\n    /**\n     * @private\n     * @return {number|undefined} An index of a token that is split point.\n     * returns undefined if the selector does not contain any complex tokens\n     * or it is not eligible for splitting.\n     * Otherwise returns an integer indicating the index of the last relation token.\n     */\n    getSplitPoint: function getSplitPoint() {\n      var tokens = this.tokens[0]; // We split selector only when the last compound selector\n      // is the only extended selector.\n\n      var latestRelationTokenIndex = -1;\n      var haveMetComplexToken = false;\n\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        var token = tokens[i];\n\n        if (isRelationToken(token)) {\n          if (haveMetComplexToken) {\n            return;\n          }\n\n          latestRelationTokenIndex = i;\n        } else if (!isSimpleToken(token)) {\n          haveMetComplexToken = true;\n        }\n      }\n\n      if (!haveMetComplexToken) {\n        return;\n      }\n\n      return latestRelationTokenIndex;\n    },\n\n    /**\n     * @private\n     * @return {string|undefined} xpath selector part if exists\n     * returns undefined if the selector does not contain xpath tokens\n     */\n    getXpathPart: function getXpathPart() {\n      var tokens = this.tokens[0];\n\n      for (var i = 0, tokensLength = tokens.length; i < tokensLength; i++) {\n        var token = tokens[i];\n\n        if (token.type === 'PSEUDO') {\n          var matches = token.matches;\n\n          if (matches && matches.length > 1) {\n            if (matches[0] === 'xpath') {\n              if (this.isLastToken(tokens, i)) {\n                throw new Error('Invalid pseudo: \\':xpath\\' should be at the end of the selector');\n              }\n\n              return matches[1];\n            }\n\n            if (matches[0] === 'nth-ancestor') {\n              if (this.isLastToken(tokens, i)) {\n                throw new Error('Invalid pseudo: \\':nth-ancestor\\' should be at the end of the selector');\n              }\n\n              var deep = matches[1];\n\n              if (deep > 0 && deep < 256) {\n                return this.convertNthAncestorToken(deep);\n              }\n            }\n          }\n        }\n      }\n    },\n\n    /**\n     * converts nth-ancestor/upward deep value to xpath equivalent\n     * @param {number} deep\n     * @return {string}\n     */\n    convertNthAncestorToken: function convertNthAncestorToken(deep) {\n      var result = '..';\n\n      while (deep > 1) {\n        result += '/..';\n        deep--;\n      }\n\n      return result;\n    },\n\n    /**\n     * Checks if the token is last,\n     * except of remove pseudo-class\n     * @param {Array} tokens\n     * @param {number} i index of token\n     * @returns {boolean}\n     */\n    isLastToken: function isLastToken(tokens, i) {\n      // check id the next parsed token is remove pseudo\n      var isNextRemoveToken = tokens[i + 1] && tokens[i + 1].type === 'PSEUDO' && tokens[i + 1].matches && tokens[i + 1].matches[0] === 'remove'; // check if the token is last\n      // and if it is not check if it is remove one\n      // which should be skipped\n\n      return i + 1 !== tokens.length && !isNextRemoveToken;\n    },\n\n    /**\n     * @private\n     * @return {string|undefined} upward parameter\n     * or undefined if the input does not contain upward tokens\n     */\n    getUpwardPart: function getUpwardPart() {\n      var tokens = this.tokens[0];\n\n      for (var i = 0, tokensLength = tokens.length; i < tokensLength; i++) {\n        var token = tokens[i];\n\n        if (token.type === 'PSEUDO') {\n          var matches = token.matches;\n\n          if (matches && matches.length > 1) {\n            if (matches[0] === 'upward') {\n              if (this.isLastToken(tokens, i)) {\n                throw new Error('Invalid pseudo: \\':upward\\' should be at the end of the selector');\n              }\n\n              return matches[1];\n            }\n          }\n        }\n      }\n    },\n\n    /**\n     * @private\n     * @return {string|undefined} remove parameter\n     * or undefined if the input does not contain remove tokens\n     */\n    getRemovePart: function getRemovePart() {\n      var tokens = this.tokens[0];\n\n      for (var i = 0, tokensLength = tokens.length; i < tokensLength; i++) {\n        var token = tokens[i];\n\n        if (token.type === 'PSEUDO') {\n          var matches = token.matches;\n\n          if (matches && matches.length > 1) {\n            if (matches[0] === 'remove') {\n              if (i + 1 !== tokensLength) {\n                throw new Error('Invalid pseudo: \\':remove\\' should be at the end of the selector');\n              }\n\n              return matches[1];\n            }\n          }\n        }\n      }\n    }\n  };\n  var globalDebuggingFlag = false;\n\n  function isDebugging() {\n    return globalDebuggingFlag || this.debug;\n  }\n  /**\n   * This class represents a selector which is not an extended selector.\n   * @param {string} selectorText\n   * @param {boolean=} debug\n   * @final\n   */\n\n\n  function NotAnExtendedSelector(selectorText, debug) {\n    this.selectorText = selectorText;\n    this.debug = debug;\n  }\n\n  NotAnExtendedSelector.prototype = {\n    querySelectorAll: function querySelectorAll() {\n      return document.querySelectorAll(this.selectorText);\n    },\n    matches: function matches(element) {\n      return element[utils.matchesPropertyName](this.selectorText);\n    },\n    isDebugging: isDebugging\n  };\n  /**\n   * A trait-less extended selector class.\n   * @param {string} selectorText\n   * @param {boolean=} debug\n   * @constructor\n   */\n\n  function TraitLessSelector(selectorText, debug) {\n    this.selectorText = selectorText;\n    this.debug = debug;\n    Sizzle.compile(selectorText);\n  }\n\n  TraitLessSelector.prototype = {\n    querySelectorAll: function querySelectorAll() {\n      return Sizzle(this.selectorText);\n    },\n\n    /** @final */\n    matches: function matches(element) {\n      return Sizzle.matchesSelector(element, this.selectorText);\n    },\n\n    /** @final */\n    isDebugging: isDebugging\n  };\n  /**\n   * Parental class for such pseudo-classes as xpath, upward, remove\n   * which are limited to be the last one token in selector\n   *\n   * @param {string} selectorText\n   * @param {string} pseudoClassArg pseudo-class arg\n   * @param {boolean=} debug\n   * @constructor\n   */\n\n  function BaseLastArgumentSelector(selectorText, pseudoClassArg, debug) {\n    this.selectorText = selectorText;\n    this.pseudoClassArg = pseudoClassArg;\n    this.debug = debug;\n    Sizzle.compile(this.selectorText);\n  }\n\n  BaseLastArgumentSelector.prototype = {\n    querySelectorAll: function querySelectorAll() {\n      var _this = this;\n\n      var resultNodes = [];\n      var simpleNodes;\n\n      if (this.selectorText) {\n        simpleNodes = Sizzle(this.selectorText);\n\n        if (!simpleNodes || !simpleNodes.length) {\n          return resultNodes;\n        }\n      } else {\n        simpleNodes = [document];\n      }\n\n      simpleNodes.forEach(function (node) {\n        _this.searchResultNodes(node, _this.pseudoClassArg, resultNodes);\n      });\n      return Sizzle.uniqueSort(resultNodes);\n    },\n\n    /** @final */\n    matches: function matches(element) {\n      var results = this.querySelectorAll();\n      return results.indexOf(element) > -1;\n    },\n\n    /** @final */\n    isDebugging: isDebugging,\n\n    /**\n     * Primitive method that returns all nodes if pseudo-class arg is defined.\n     * That logic works for remove pseudo-class,\n     * but for others it should be overridden.\n     * @param {Object} node context element\n     * @param {string} pseudoClassArg pseudo-class argument\n     * @param {Array} result\n     */\n    searchResultNodes: function searchResultNodes(node, pseudoClassArg, result) {\n      if (pseudoClassArg) {\n        result.push(node);\n      }\n    }\n  };\n  /**\n   * Xpath selector class\n   * Limited to support 'xpath' to be only the last one token in selector\n   * @param {string} selectorText\n   * @param {string} xpath value\n   * @param {boolean=} debug\n   * @constructor\n   * @augments BaseLastArgumentSelector\n   */\n\n  function XpathSelector(selectorText, xpath, debug) {\n    var NO_SELECTOR_MARKER = ':xpath(//';\n    var BODY_SELECTOR_REPLACER = 'body:xpath(//';\n    var modifiedSelectorText = selectorText; // Normally, a pseudo-class is applied to nodes selected by a selector -- selector:xpath(...).\n    // However, :xpath is special as the selector can be ommited.\n    // For any other pseudo-class that would mean \"apply to ALL DOM nodes\",\n    // but in case of :xpath it just means \"apply me to the document\".\n\n    if (utils.startsWith(selectorText, NO_SELECTOR_MARKER)) {\n      modifiedSelectorText = selectorText.replace(NO_SELECTOR_MARKER, BODY_SELECTOR_REPLACER);\n    }\n\n    BaseLastArgumentSelector.call(this, modifiedSelectorText, xpath, debug);\n  }\n\n  XpathSelector.prototype = Object.create(BaseLastArgumentSelector.prototype);\n  XpathSelector.prototype.constructor = XpathSelector;\n  /**\n   * Applies xpath pseudo-class to provided context node\n   * @param {Object} node context element\n   * @param {string} pseudoClassArg xpath\n   * @param {Array} result\n   * @override\n   */\n\n  XpathSelector.prototype.searchResultNodes = function (node, pseudoClassArg, result) {\n    var xpathResult = document.evaluate(pseudoClassArg, node, null, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null);\n    var iNode; // eslint-disable-next-line no-cond-assign\n\n    while (iNode = xpathResult.iterateNext()) {\n      result.push(iNode);\n    }\n  };\n  /**\n   * Upward selector class\n   * Limited to support 'upward' to be only the last one token in selector\n   * @param {string} selectorText\n   * @param {string} upwardSelector value\n   * @param {boolean=} debug\n   * @constructor\n   * @augments BaseLastArgumentSelector\n   */\n\n\n  function UpwardSelector(selectorText, upwardSelector, debug) {\n    BaseLastArgumentSelector.call(this, selectorText, upwardSelector, debug);\n  }\n\n  UpwardSelector.prototype = Object.create(BaseLastArgumentSelector.prototype);\n  UpwardSelector.prototype.constructor = UpwardSelector;\n  /**\n   * Applies upward pseudo-class to provided context node\n   * @param {Object} node context element\n   * @param {string} upwardSelector upward selector\n   * @param {Array} result\n   * @override\n   */\n\n  UpwardSelector.prototype.searchResultNodes = function (node, upwardSelector, result) {\n    if (upwardSelector !== '') {\n      var parent = node.parentElement;\n\n      if (parent === null) {\n        return;\n      }\n\n      node = parent.closest(upwardSelector);\n\n      if (node === null) {\n        return;\n      }\n    }\n\n    result.push(node);\n  };\n  /**\n   * Remove selector class\n   * Limited to support 'remove' to be only the last one token in selector\n   * @param {string} selectorText\n   * @param {boolean} hasValidRemovePart\n   * @param {boolean=} debug\n   * @constructor\n   * @augments BaseLastArgumentSelector\n   */\n\n\n  function RemoveSelector(selectorText, hasValidRemovePart, debug) {\n    var REMOVE_PSEUDO_MARKER = ':remove()';\n    var removeMarkerIndex = selectorText.indexOf(REMOVE_PSEUDO_MARKER); // deleting remove part of rule instead of which\n    // pseudo-property property 'remove' will be added by ExtendedCssParser\n\n    var modifiedSelectorText = selectorText.slice(0, removeMarkerIndex);\n    BaseLastArgumentSelector.call(this, modifiedSelectorText, hasValidRemovePart, debug); // mark extendedSelector as Remove one for ExtendedCssParser\n\n    this.isRemoveSelector = true;\n  }\n\n  RemoveSelector.prototype = Object.create(BaseLastArgumentSelector.prototype);\n  RemoveSelector.prototype.constructor = RemoveSelector;\n  /**\n   * A splitted extended selector class.\n   *\n   * #container #feedItem:has(.ads)\n   * +--------+                     simple\n   *           +                    relation\n   *            +-----------------+ complex\n   * We split selector only when the last selector is complex\n   * @param {string} selectorText\n   * @param {string} simple\n   * @param {string} relation\n   * @param {string} complex\n   * @param {boolean=} debug\n   * @constructor\n   * @extends TraitLessSelector\n   */\n\n  function SplittedSelector(selectorText, simple, relation, complex, debug) {\n    TraitLessSelector.call(this, selectorText, debug);\n    this.simple = simple;\n    this.relation = relation;\n    this.complex = complex;\n    Sizzle.compile(complex);\n  }\n\n  SplittedSelector.prototype = Object.create(TraitLessSelector.prototype);\n  SplittedSelector.prototype.constructor = SplittedSelector;\n  /** @override */\n\n  SplittedSelector.prototype.querySelectorAll = function () {\n    var _this2 = this;\n\n    var resultNodes = [];\n    var simpleNodes;\n    var simple = this.simple;\n    var relation;\n\n    if (simple) {\n      // First we use simple selector to narrow our search\n      simpleNodes = document.querySelectorAll(simple);\n\n      if (!simpleNodes || !simpleNodes.length) {\n        return resultNodes;\n      }\n\n      relation = this.relation;\n    } else {\n      simpleNodes = [document];\n      relation = ' ';\n    }\n\n    switch (relation) {\n      case ' ':\n        simpleNodes.forEach(function (node) {\n          _this2.relativeSearch(node, resultNodes);\n        });\n        break;\n\n      case '>':\n        {\n          simpleNodes.forEach(function (node) {\n            Object.values(node.children).forEach(function (childNode) {\n              if (_this2.matches(childNode)) {\n                resultNodes.push(childNode);\n              }\n            });\n          });\n          break;\n        }\n\n      case '+':\n        {\n          simpleNodes.forEach(function (node) {\n            var parentNode = node.parentNode;\n            Object.values(parentNode.children).forEach(function (childNode) {\n              if (_this2.matches(childNode) && childNode.previousElementSibling === node) {\n                resultNodes.push(childNode);\n              }\n            });\n          });\n          break;\n        }\n\n      case '~':\n        {\n          simpleNodes.forEach(function (node) {\n            var parentNode = node.parentNode;\n            Object.values(parentNode.children).forEach(function (childNode) {\n              if (_this2.matches(childNode) && node.compareDocumentPosition(childNode) === 4) {\n                resultNodes.push(childNode);\n              }\n            });\n          });\n          break;\n        }\n    }\n\n    return Sizzle.uniqueSort(resultNodes);\n  };\n  /**\n   * Performs a search of \"complex\" part relative to results for the \"simple\" part.\n   * @param {Node} node a node matching the \"simple\" part.\n   * @param {Node[]} result an array to append search result.\n   */\n\n\n  SplittedSelector.prototype.relativeSearch = function (node, results) {\n    Sizzle(this.complex, node, results);\n  };\n\n  return {\n    /**\n     * Wraps the inner class so that the instance is not exposed.\n     */\n    createSelector: function createSelector(selector, tokens, debug) {\n      return new ExtendedSelectorParser(selector, tokens, debug).createSelector();\n    },\n\n    /**\n     * Mark every selector as a selector being debugged, so that timing information\n     * for the selector is printed to the console.\n     */\n    enableGlobalDebugging: function enableGlobalDebugging() {\n      globalDebuggingFlag = true;\n    }\n  };\n}();\n\n/**\n * Copyright 2016 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A helper class that parses stylesheets containing extended selectors\n * into ExtendedSelector instances and key-value maps of style declarations.\n * Please note, that it does not support any complex things like media queries and such.\n */\n\nvar ExtendedCssParser = function () {\n  var reDeclEnd = /[;}]/g;\n  var reDeclDivider = /[;:}]/g;\n  var reNonWhitespace = /\\S/g;\n  var Sizzle;\n  /**\n   * @param {string} cssText\n   * @constructor\n   */\n\n  function Parser(cssText) {\n    this.cssText = cssText;\n  }\n\n  Parser.prototype = {\n    error: function error(position) {\n      throw new Error(\"CssParser: parse error at position \".concat(this.posOffset + position));\n    },\n\n    /**\n     * Validates that the tokens correspond to a valid selector.\n     * Sizzle is different from browsers and some selectors that it tolerates aren't actually valid.\n     * For instance, \"div >\" won't work in a browser, but it will in Sizzle (it'd be the same as \"div > *\").\n     *\n     * @param {*} selectors An array of SelectorData (selector, groups)\n     * @returns {boolean} false if any of the groups are invalid\n     */\n    validateSelectors: function validateSelectors(selectors) {\n      var iSelectors = selectors.length;\n\n      while (iSelectors--) {\n        var groups = selectors[iSelectors].groups;\n        var iGroups = groups.length;\n\n        while (iGroups--) {\n          var tokens = groups[iGroups];\n          var lastToken = tokens[tokens.length - 1];\n\n          if (Sizzle.selectors.relative[lastToken.type]) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    },\n\n    /**\n     * Parses a stylesheet and returns a list of pairs of an ExtendedSelector and a styles map.\n     * This method will throw an error in case of an obviously invalid input.\n     * If any of the selectors used in the stylesheet cannot be compiled into an ExtendedSelector,\n     * it will be ignored.\n     *\n     * @typedef {Object} ExtendedStyle\n     * @property {Object} selector An instance of the {@link ExtendedSelector} class\n     * @property {Object} styleMap A map of styles parsed\n     *\n     * @returns {Array.<ExtendedStyle>} An array of the styles parsed\n     */\n    parseCss: function parseCss() {\n      this.posOffset = 0;\n\n      if (!this.cssText) {\n        this.error(0);\n      }\n\n      var results = [];\n\n      while (this.cssText) {\n        // Apply tolerant tokenization.\n        var parseResult = Sizzle.tokenize(this.cssText, false, {\n          tolerant: true,\n          returnUnsorted: true\n        });\n        var selectorData = parseResult.selectors;\n        this.nextIndex = parseResult.nextIndex;\n\n        if (this.cssText.charCodeAt(this.nextIndex) !== 123 ||\n        /* charCode of '{' */\n        !this.validateSelectors(selectorData)) {\n          this.error(this.nextIndex);\n        }\n\n        this.nextIndex++; // Move the pointer to the start of style declaration.\n\n        var styleMap = this.parseNextStyle();\n        var debug = false; // If there is a style property 'debug', mark the selector\n        // as a debuggable selector, and delete the style declaration.\n\n        var debugPropertyValue = styleMap['debug'];\n\n        if (typeof debugPropertyValue !== 'undefined') {\n          if (debugPropertyValue === 'global') {\n            ExtendedSelectorFactory.enableGlobalDebugging();\n          }\n\n          debug = true;\n          delete styleMap['debug'];\n        } // Creating an ExtendedSelector instance for every selector we got from Sizzle.tokenize.\n        // This is quite important as Sizzle does a poor job at executing selectors like \"selector1, selector2\".\n\n\n        for (var i = 0, l = selectorData.length; i < l; i++) {\n          var data = selectorData[i];\n\n          try {\n            var extendedSelector = ExtendedSelectorFactory.createSelector(data.selectorText, data.groups, debug);\n\n            if (extendedSelector.pseudoClassArg && extendedSelector.isRemoveSelector) {\n              // if there is remove pseudo-class in rule,\n              // the element will be removed and no other styles will be applied\n              styleMap['remove'] = 'true';\n            }\n\n            results.push({\n              selector: extendedSelector,\n              style: styleMap\n            });\n          } catch (ex) {\n            utils.logError(\"ExtendedCssParser: ignoring invalid selector \".concat(data.selectorText));\n          }\n        }\n      }\n\n      return results;\n    },\n    parseNextStyle: function parseNextStyle() {\n      var styleMap = Object.create(null);\n      var bracketPos = this.parseUntilClosingBracket(styleMap); // Cut out matched portion from cssText.\n\n      reNonWhitespace.lastIndex = bracketPos + 1;\n      var match = reNonWhitespace.exec(this.cssText);\n\n      if (match === null) {\n        this.cssText = '';\n        return styleMap;\n      }\n\n      var matchPos = match.index;\n      this.cssText = this.cssText.slice(matchPos);\n      this.posOffset += matchPos;\n      return styleMap;\n    },\n\n    /**\n     * @return {number} an index of the next '}' in `this.cssText`.\n     */\n    parseUntilClosingBracket: function parseUntilClosingBracket(styleMap) {\n      // Expects \":\", \";\", and \"}\".\n      reDeclDivider.lastIndex = this.nextIndex;\n      var match = reDeclDivider.exec(this.cssText);\n\n      if (match === null) {\n        this.error(this.nextIndex);\n      }\n\n      var matchPos = match.index;\n      var matched = match[0];\n\n      if (matched === '}') {\n        return matchPos;\n      }\n\n      if (matched === ':') {\n        var colonIndex = matchPos; // Expects \";\" and \"}\".\n\n        reDeclEnd.lastIndex = colonIndex;\n        match = reDeclEnd.exec(this.cssText);\n\n        if (match === null) {\n          this.error(colonIndex);\n        }\n\n        matchPos = match.index;\n        matched = match[0]; // Populates the `styleMap` key-value map.\n\n        var property = this.cssText.slice(this.nextIndex, colonIndex).trim();\n        var value = this.cssText.slice(colonIndex + 1, matchPos).trim();\n        styleMap[property] = value; // If found \"}\", re-run the outer loop.\n\n        if (matched === '}') {\n          return matchPos;\n        }\n      } // matchPos is the position of the next ';'.\n      // Increase 'nextIndex' and re-run the loop.\n\n\n      this.nextIndex = matchPos + 1;\n      return this.parseUntilClosingBracket(styleMap); // Should be a subject of tail-call optimization.\n    }\n  };\n  return {\n    parseCss: function parseCss(cssText) {\n      Sizzle = initializeSizzle();\n      return new Parser(cssUtils.normalize(cssText)).parseCss();\n    }\n  };\n}();\n\n/**\n * This callback is used to get affected node elements and handle style properties\n * before they are applied to them if it is necessary\n * @callback beforeStyleApplied\n * @param {object} affectedElement - Object containing DOM node and rule to be applied\n * @return {object} affectedElement - Same or modified object containing DOM node and rule to be applied\n */\n\n/**\n * Extended css class\n *\n * @param {Object} configuration\n * @param {string} configuration.styleSheet - the CSS stylesheet text\n * @param {beforeStyleApplied} [configuration.beforeStyleApplied] - the callback that handles affected elements\n * @constructor\n */\n\nfunction ExtendedCss(configuration) {\n  if (!configuration) {\n    throw new Error('Configuration is not provided.');\n  }\n\n  var styleSheet = configuration.styleSheet;\n  var beforeStyleApplied = configuration.beforeStyleApplied;\n\n  if (beforeStyleApplied && typeof beforeStyleApplied !== 'function') {\n    // eslint-disable-next-line max-len\n    throw new Error(\"Wrong configuration. Type of 'beforeStyleApplied' field should be a function, received: \".concat(_typeof(beforeStyleApplied)));\n  } // We use EventTracker to track the event that is likely to cause the mutation.\n  // The problem is that we cannot use `window.event` directly from the mutation observer call\n  // as we're not in the event handler context anymore.\n\n\n  var EventTracker = function () {\n    var ignoredEventTypes = ['mouseover', 'mouseleave', 'mouseenter', 'mouseout'];\n    var LAST_EVENT_TIMEOUT_MS = 10;\n    var EVENTS = [// keyboard events\n    'keydown', 'keypress', 'keyup', // mouse events\n    'auxclick', 'click', 'contextmenu', 'dblclick', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseover', 'mouseout', 'mouseup', 'pointerlockchange', 'pointerlockerror', 'select', 'wheel']; // 'wheel' event makes scrolling in Safari twitchy\n    // https://github.com/AdguardTeam/ExtendedCss/issues/120\n\n    var safariProblematicEvents = ['wheel'];\n    var trackedEvents = utils.isSafariBrowser ? EVENTS.filter(function (el) {\n      return !(safariProblematicEvents.indexOf(el) > -1);\n    }) : EVENTS;\n    var lastEventType;\n    var lastEventTime;\n\n    var trackEvent = function trackEvent(e) {\n      lastEventType = e.type;\n      lastEventTime = Date.now();\n    };\n\n    trackedEvents.forEach(function (evName) {\n      document.documentElement.addEventListener(evName, trackEvent, true);\n    });\n\n    var getLastEventType = function getLastEventType() {\n      return lastEventType;\n    };\n\n    var getTimeSinceLastEvent = function getTimeSinceLastEvent() {\n      return Date.now() - lastEventTime;\n    };\n\n    return {\n      isIgnoredEventType: function isIgnoredEventType() {\n        return ignoredEventTypes.indexOf(getLastEventType()) > -1 && getTimeSinceLastEvent() < LAST_EVENT_TIMEOUT_MS;\n      }\n    };\n  }();\n\n  var rules = [];\n  var affectedElements = [];\n  var removalsStatistic = {};\n  var domObserved;\n  var eventListenerSupported = window.addEventListener;\n  var domMutationObserver;\n\n  function observeDocument(callback) {\n    // We are trying to limit the number of callback calls by not calling it on all kind of \"hover\" events.\n    // The rationale behind this is that \"hover\" events often cause attributes modification,\n    // but re-applying extCSS rules will be useless as these attribute changes are usually transient.\n    var isIgnoredMutation = function isIgnoredMutation(mutations) {\n      for (var i = 0; i < mutations.length; i += 1) {\n        if (mutations.type !== 'attributes') {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    if (utils.MutationObserver) {\n      domMutationObserver = new utils.MutationObserver(function (mutations) {\n        if (!mutations || mutations.length === 0) {\n          return;\n        }\n\n        if (EventTracker.isIgnoredEventType() && isIgnoredMutation(mutations)) {\n          return;\n        }\n\n        callback();\n      });\n      domMutationObserver.observe(document, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: ['id', 'class']\n      });\n    } else if (eventListenerSupported) {\n      document.addEventListener('DOMNodeInserted', callback, false);\n      document.addEventListener('DOMNodeRemoved', callback, false);\n      document.addEventListener('DOMAttrModified', callback, false);\n    }\n  }\n\n  function disconnectDocument(callback) {\n    if (domMutationObserver) {\n      domMutationObserver.disconnect();\n    } else if (eventListenerSupported) {\n      document.removeEventListener('DOMNodeInserted', callback, false);\n      document.removeEventListener('DOMNodeRemoved', callback, false);\n      document.removeEventListener('DOMAttrModified', callback, false);\n    }\n  }\n\n  var MAX_STYLE_PROTECTION_COUNT = 50;\n  var protectionObserverOption = {\n    attributes: true,\n    attributeOldValue: true,\n    attributeFilter: ['style']\n  };\n  /**\n   * Creates MutationObserver protection function\n   *\n   * @param styles\n   * @return {protectionFunction}\n   */\n\n  function createProtectionFunction(styles) {\n    function protectionFunction(mutations, observer) {\n      if (!mutations.length) {\n        return;\n      }\n\n      var mutation = mutations[0];\n      var target = mutation.target;\n      observer.disconnect();\n      styles.forEach(function (style) {\n        setStyleToElement(target, style);\n      });\n\n      if (++observer.styleProtectionCount < MAX_STYLE_PROTECTION_COUNT) {\n        observer.observe(target, protectionObserverOption);\n      } else {\n        utils.logError('ExtendedCss: infinite loop protection for style');\n      }\n    }\n\n    return protectionFunction;\n  }\n  /**\n   * Sets up a MutationObserver which protects style attributes from changes\n   * @param node DOM node\n   * @param rules rules\n   * @returns Mutation observer used to protect attribute or null if there's nothing to protect\n   */\n\n\n  function protectStyleAttribute(node, rules) {\n    if (!utils.MutationObserver) {\n      return null;\n    }\n\n    var styles = rules.map(function (r) {\n      return r.style;\n    });\n    var protectionObserver = new utils.MutationObserver(createProtectionFunction(styles));\n    protectionObserver.observe(node, protectionObserverOption); // Adds an expando to the observer to keep 'style fix counts'.\n\n    protectionObserver.styleProtectionCount = 0;\n    return protectionObserver;\n  }\n\n  function removeSuffix(str, suffix) {\n    var index = str.indexOf(suffix, str.length - suffix.length);\n\n    if (index >= 0) {\n      return str.substring(0, index);\n    }\n\n    return str;\n  }\n  /**\n   * Finds affectedElement object for the specified DOM node\n   * @param node  DOM node\n   * @returns     affectedElement found or null\n   */\n\n\n  function findAffectedElement(node) {\n    for (var i = 0; i < affectedElements.length; i += 1) {\n      if (affectedElements[i].node === node) {\n        return affectedElements[i];\n      }\n    }\n\n    return null;\n  }\n\n  function removeElement(affectedElement) {\n    var node = affectedElement.node;\n    affectedElement.removed = true;\n    var elementSelector = utils.getNodeSelector(node); // check if the element has been already removed earlier\n\n    var elementRemovalsCounter = removalsStatistic[elementSelector] || 0; // if removals attempts happened more than specified we do not try to remove node again\n\n    if (elementRemovalsCounter > MAX_STYLE_PROTECTION_COUNT) {\n      utils.logError('ExtendedCss: infinite loop protection for SELECTOR', elementSelector);\n      return;\n    }\n\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n      removalsStatistic[elementSelector] = elementRemovalsCounter + 1;\n    }\n  }\n  /**\n   * Applies style to the specified DOM node\n   * @param affectedElement Object containing DOM node and rule to be applied\n   */\n\n\n  function applyStyle(affectedElement) {\n    if (affectedElement.protectionObserver) {\n      // Style is already applied and protected by the observer\n      return;\n    }\n\n    if (beforeStyleApplied) {\n      affectedElement = beforeStyleApplied(affectedElement);\n\n      if (!affectedElement) {\n        return;\n      }\n    }\n\n    var _affectedElement = affectedElement,\n        node = _affectedElement.node;\n\n    for (var i = 0; i < affectedElement.rules.length; i++) {\n      var style = affectedElement.rules[i].style;\n\n      if (style['remove'] === 'true') {\n        removeElement(affectedElement);\n        return;\n      }\n\n      setStyleToElement(node, style);\n    }\n  }\n  /**\n   * Sets style to the specified DOM node\n   * @param node element\n   * @param style style\n   */\n\n\n  function setStyleToElement(node, style) {\n    Object.keys(style).forEach(function (prop) {\n      // Apply this style only to existing properties\n      // We can't use hasOwnProperty here (does not work in FF)\n      if (typeof node.style.getPropertyValue(prop) !== 'undefined') {\n        var value = style[prop]; // First we should remove !important attribute (or it won't be applied')\n\n        value = removeSuffix(value.trim(), '!important').trim();\n        node.style.setProperty(prop, value, 'important');\n      }\n    });\n  }\n  /**\n   * Reverts style for the affected object\n   */\n\n\n  function revertStyle(affectedElement) {\n    if (affectedElement.protectionObserver) {\n      affectedElement.protectionObserver.disconnect();\n    }\n\n    affectedElement.node.style.cssText = affectedElement.originalStyle;\n  }\n  /**\n   * Applies specified rule and returns list of elements affected\n   * @param rule Rule to apply\n   * @returns List of elements affected by this rule\n   */\n\n\n  function applyRule(rule) {\n    var debug = rule.selector.isDebugging();\n    var start;\n\n    if (debug) {\n      start = utils.AsyncWrapper.now();\n    }\n\n    var selector = rule.selector;\n    var nodes = selector.querySelectorAll();\n    nodes.forEach(function (node) {\n      var affectedElement = findAffectedElement(node);\n\n      if (affectedElement) {\n        affectedElement.rules.push(rule);\n        applyStyle(affectedElement);\n      } else {\n        // Applying style first time\n        var originalStyle = node.style.cssText;\n        affectedElement = {\n          node: node,\n          // affected DOM node\n          rules: [rule],\n          // rules to be applied\n          originalStyle: originalStyle,\n          // original node style\n          protectionObserver: null // style attribute observer\n\n        };\n        applyStyle(affectedElement);\n        affectedElements.push(affectedElement);\n      }\n    });\n\n    if (debug) {\n      var elapsed = utils.AsyncWrapper.now() - start;\n\n      if (!('timingStats' in rule)) {\n        rule.timingStats = new utils.Stats();\n      }\n\n      rule.timingStats.push(elapsed);\n    }\n\n    return nodes;\n  }\n  /**\n   * Applies filtering rules\n   */\n\n\n  function applyRules() {\n    var elementsIndex = []; // some rules could make call - selector.querySelectorAll() temporarily to change node id attribute\n    // this caused MutationObserver to call recursively\n    // https://github.com/AdguardTeam/ExtendedCss/issues/81\n\n    stopObserve();\n    rules.forEach(function (rule) {\n      var nodes = applyRule(rule);\n      Array.prototype.push.apply(elementsIndex, nodes);\n    }); // Now revert styles for elements which are no more affected\n\n    var l = affectedElements.length; // do nothing if there is no elements to process\n\n    if (elementsIndex.length > 0) {\n      while (l--) {\n        var obj = affectedElements[l];\n\n        if (elementsIndex.indexOf(obj.node) === -1) {\n          // Time to revert style\n          revertStyle(obj);\n          affectedElements.splice(l, 1);\n        } else if (!obj.removed) {\n          // Add style protection observer\n          // Protect \"style\" attribute from changes\n          if (!obj.protectionObserver) {\n            obj.protectionObserver = protectStyleAttribute(obj.node, obj.rules);\n          }\n        }\n      }\n    } // After styles are applied we can start observe again\n\n\n    observe();\n    printTimingInfo();\n  }\n\n  var APPLY_RULES_DELAY = 150;\n  var applyRulesScheduler = new utils.AsyncWrapper(applyRules, APPLY_RULES_DELAY);\n  var mainCallback = applyRulesScheduler.run.bind(applyRulesScheduler);\n\n  function observe() {\n    if (domObserved) {\n      return;\n    } // Handle dynamically added elements\n\n\n    domObserved = true;\n    observeDocument(mainCallback);\n  }\n\n  function stopObserve() {\n    if (!domObserved) {\n      return;\n    }\n\n    domObserved = false;\n    disconnectDocument(mainCallback);\n  }\n\n  function apply() {\n    applyRules();\n\n    if (document.readyState !== 'complete') {\n      document.addEventListener('DOMContentLoaded', applyRules);\n    }\n  }\n  /**\n   * Disposes ExtendedCss and removes our styles from matched elements\n   */\n\n\n  function dispose() {\n    stopObserve();\n    affectedElements.forEach(function (obj) {\n      revertStyle(obj);\n    });\n  }\n\n  var timingsPrinted = false;\n  /**\n   * Prints timing information for all selectors marked as \"debug\"\n   */\n\n  function printTimingInfo() {\n    if (timingsPrinted) {\n      return;\n    }\n\n    timingsPrinted = true;\n    var timings = rules.filter(function (rule) {\n      return rule.selector.isDebugging();\n    }).map(function (rule) {\n      return {\n        selectorText: rule.selector.selectorText,\n        timingStats: rule.timingStats\n      };\n    });\n\n    if (timings.length === 0) {\n      return;\n    } // Add location.href to the message to distinguish frames\n\n\n    utils.logInfo('[ExtendedCss] Timings for %o:\\n%o (in milliseconds)', window.location.href, timings);\n  } // First of all parse the stylesheet\n\n\n  rules = ExtendedCssParser.parseCss(styleSheet); // EXPOSE\n\n  this.dispose = dispose;\n  this.apply = apply;\n  /** Exposed for testing purposes only */\n\n  this._getAffectedElements = function () {\n    return affectedElements;\n  };\n}\n/**\n * Expose querySelectorAll for debugging and validating selectors\n *\n * @param {string} selectorText selector text\n * @param {boolean} noTiming if true -- do not print the timing to the console\n * @returns {Array<Node>|NodeList} a list of elements found\n * @throws Will throw an error if the argument is not a valid selector\n */\n\n\nExtendedCss.query = function (selectorText, noTiming) {\n  if (typeof selectorText !== 'string') {\n    throw new Error('Selector text is empty');\n  }\n\n  var now = utils.AsyncWrapper.now;\n  var start = now();\n\n  try {\n    return ExtendedSelectorFactory.createSelector(selectorText).querySelectorAll();\n  } finally {\n    var end = now();\n\n    if (!noTiming) {\n      utils.logInfo(\"[ExtendedCss] Elapsed: \".concat(Math.round((end - start) * 1000), \" \\u03BCs.\"));\n    }\n  }\n};\n\nexport default ExtendedCss;\n","import ExtendedCss from 'extended-css';\nimport browser from 'webextension-polyfill';\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\n\n/**\n * Utils class.\n */\nclass ElementUtils {\n    /**\n     * Serialize HTML element.\n     *\n     * @param element Element to serialize.\n     *\n     * @returns String representation of the element.\n     */\n    static elementToString(element) {\n        const s = [];\n        s.push('<');\n        s.push(element.localName);\n        const { attributes } = element;\n        for (let i = 0; i < attributes.length; i += 1) {\n            const attr = attributes[i];\n            s.push(' ');\n            s.push(attr.name);\n            s.push('=\"');\n            const value = attr.value === null ? '' : attr.value.replace(/\"/g, '\\\\\"');\n            s.push(value);\n            s.push('\"');\n        }\n        s.push('>');\n        return s.join('');\n    }\n    /**\n     * Appends node children to the array.\n     *\n     * @param node Element whose children we would like to add.\n     * @param arrayWithNodes Array where we add children.\n     */\n    static appendChildren(node, arrayWithNodes) {\n        const children = node.querySelectorAll('*');\n        if (children && children.length > 0) {\n            for (let i = 0; i < children.length; i += 1) {\n                arrayWithNodes.push(children[i]);\n            }\n        }\n    }\n    /**\n     * Adds elements into array if they are not in the array yet.\n     *\n     * @param targetArray Array where we add elements.\n     * @param sourceArray Array with elements.\n     */\n    static addUnique(targetArray, sourceArray) {\n        if (sourceArray.length > 0) {\n            for (let i = 0; i < sourceArray.length; i += 1) {\n                const sourceElement = sourceArray[i];\n                if (targetArray.indexOf(sourceElement) === -1) {\n                    targetArray.push(sourceElement);\n                }\n            }\n        }\n    }\n    /**\n     * Removes all elements in array.\n     *\n     * @param elements Array with elements.\n     */\n    static removeElements(elements) {\n        for (let i = 0; i < elements.length; i += 1) {\n            const element = elements[i];\n            element.remove();\n        }\n    }\n    /**\n     * Parses hits info from style content.\n     *\n     * @param content Style.\n     * @param attributeMarker Attribute marker.\n     *\n     * @returns Info with filterId, ruleText or null.\n     */\n    static parseInfo(content, attributeMarker) {\n        if (!content || content.indexOf(attributeMarker) < 0) {\n            return null;\n        }\n        let filterIdAndRuleText = decodeURIComponent(content);\n        // 'content' value may include open and close quotes.\n        filterIdAndRuleText = ElementUtils.removeQuotes(filterIdAndRuleText);\n        // Remove prefix\n        filterIdAndRuleText = filterIdAndRuleText.substring(attributeMarker.length);\n        // Attribute 'content' in css looks like: {content: 'adguard{filterId};{ruleText}'}\n        const index = filterIdAndRuleText.indexOf(';');\n        if (index < 0) {\n            return null;\n        }\n        const filterId = parseInt(filterIdAndRuleText.substring(0, index), 10);\n        if (Number.isNaN(filterId)) {\n            return null;\n        }\n        const ruleText = filterIdAndRuleText.substring(index + 1);\n        return { filterId, ruleText };\n    }\n    /**\n     * Parses hits info from style content.\n     *\n     * @param content Style.\n     * @param attributeMarker Attribute marker.\n     *\n     * @returns Info with filterId, ruleText or null.\n     */\n    static parseExtendedStyleInfo(content, attributeMarker) {\n        const important = '!important';\n        const indexOfImportant = content.lastIndexOf(important);\n        if (indexOfImportant === -1) {\n            return ElementUtils.parseInfo(content, attributeMarker);\n        }\n        const contentWithoutImportant = content.substring(0, indexOfImportant).trim();\n        return ElementUtils.parseInfo(contentWithoutImportant, attributeMarker);\n    }\n    /**\n     * Unquotes specified value.\n     *\n     * @param value Value to unquote.\n     *\n     * @returns Unquoted value.\n     */\n    static removeQuotes(value) {\n        if (value.length > 1\n            && ((value[0] === '\"' && value[value.length - 1] === '\"')\n                || (value[0] === '\\'' && value[value.length - 1] === '\\''))) {\n            // Remove double-quotes or single-quotes\n            return value.substring(1, value.length - 1);\n        }\n        return value;\n    }\n}\n\n// TODO remove the comment turning off the rule\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * This storage is used to keep track of counted rules received from node elements.\n */\nclass HitsStorage {\n    constructor() {\n        /**\n         * Start count number.\n         */\n        this.counter = 0;\n        /**\n         * Storage random identificator.\n         */\n        this.randomKey = HitsStorage.generateRandomKey();\n        /**\n         * Map storage.\n         */\n        this.map = new Map();\n    }\n    /**\n     * Checks if element is counted.\n     *\n     * @param element Html element.\n     * @param rule Rule text.\n     *\n     * @returns True if element is counted.\n     */\n    isCounted(element, rule) {\n        const hitAddress = element[this.randomKey];\n        if (hitAddress) {\n            const countedHit = this.map.get(hitAddress);\n            if (countedHit) {\n                return countedHit.element === element && countedHit.rule === rule;\n            }\n        }\n        return false;\n    }\n    /**\n     * Stores rule-element info in storage.\n     *\n     * @param element Html element.\n     * @param rule Rule text.\n     */\n    setCounted(element, rule) {\n        const counter = this.getCounter();\n        // eslint-disable-next-line no-param-reassign\n        element[this.randomKey] = counter;\n        this.map.set(counter, { element, rule });\n    }\n    /**\n     * Returns current counter value and increments it.\n     *\n     * @returns Count number.\n     */\n    getCounter() {\n        this.counter += 1;\n        return this.counter;\n    }\n    // TODO replace with nanoid\n    /**\n     * Random id generator.\n     *\n     * @returns Random key with 10 characters length.\n     */\n    static generateRandomKey() {\n        const keyLength = 10;\n        const possibleValues = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        let result = '';\n        for (let i = 0; i < keyLength; i += 1) {\n            result += possibleValues.charAt(Math.floor(Math.random() * possibleValues.length));\n        }\n        return result;\n    }\n}\n\n/**\n * Class represents collecting css style hits process.\n *\n * During applying css styles to element we add special 'content:' attribute\n *  e.g.: \".selector -> .selector { content: 'adguard{filterId};{ruleText} !important;}\".\n * After the style is applied we parse this \"content\" attribute and call provided via constructor callback function.\n */\nclass CssHitsCounter {\n    /**\n     * This function prepares calculation of css hits.\n     * We are waiting for 'load' event and start calculation.\n     *\n     * @param callback Which receives {@link ICountedElement} and handles counted css hits.\n     */\n    constructor(callback) {\n        /**\n         * Hits storage.\n         */\n        this.hitsStorage = new HitsStorage();\n        /**\n         * Mutation observer.\n         */\n        this.observer = null;\n        /**\n         * Counting on process flag.\n         */\n        this.countIsWorking = false;\n        this.onCssHitsFoundCallback = callback;\n        if (document.readyState === 'complete'\n            || document.readyState === 'interactive') {\n            this.countCssHits();\n        }\n        else {\n            document.addEventListener('readystatechange', this.startCounter.bind(this));\n        }\n    }\n    /**\n     * Stops css hits counting process.\n     */\n    stop() {\n        this.onCssHitsFoundCallback = () => { };\n        if (this.observer) {\n            this.observer.disconnect();\n        }\n    }\n    /**\n     * Callback used to collect statistics of elements affected by extended css rules.\n     *\n     * @param affectedEl Affected element.\n     * @returns Affected element.\n     */\n    countAffectedByExtendedCss(affectedEl) {\n        if (affectedEl && affectedEl.rules && affectedEl.rules.length > 0) {\n            const result = [];\n            for (const rule of affectedEl.rules) {\n                if (rule.style && rule.style.content) {\n                    const styleInfo = ElementUtils.parseExtendedStyleInfo(rule.style.content, CssHitsCounter.CONTENT_ATTR_PREFIX);\n                    if (styleInfo === null) {\n                        continue;\n                    }\n                    const { filterId, ruleText } = styleInfo;\n                    if (filterId !== undefined && ruleText !== undefined) {\n                        result.push({\n                            filterId,\n                            ruleText,\n                            element: ElementUtils.elementToString(affectedEl.node),\n                        });\n                        // clear style content to avoid duplicate counting\n                        rule.style.content = '';\n                    }\n                }\n            }\n            this.onCssHitsFoundCallback(result);\n        }\n        return affectedEl;\n    }\n    /**\n     * Starts counting process.\n     */\n    startCounter() {\n        if (document.readyState === 'interactive'\n            || document.readyState === 'complete') {\n            this.countCssHits();\n            document.removeEventListener('readystatechange', this.startCounter);\n        }\n    }\n    /**\n     * Counts css hits.\n     */\n    countCssHits() {\n        this.countAllCssHits();\n        this.countCssHitsForMutations();\n    }\n    /**\n     * Counts css hits for already affected elements.\n     */\n    countAllCssHits() {\n        // we don't start counting again all css hits till previous count process wasn't finished\n        if (this.countIsWorking) {\n            return;\n        }\n        this.countIsWorking = true;\n        const elements = document.querySelectorAll('*');\n        this.countCssHitsBatch(elements, 0, CssHitsCounter.CSS_HITS_BATCH_SIZE, CssHitsCounter.CSS_HITS_BATCH_SIZE, [], (result) => {\n            if (result.length > 0) {\n                this.onCssHitsFoundCallback(result);\n            }\n            this.countIsWorking = false;\n        });\n    }\n    /**\n     * Main calculation function.\n     * 1. Selects sub collection from elements.\n     * 2. For each element from sub collection: retrieves calculated css 'content'\n     * attribute and if it contains 'adguard'\n     * marker then retrieves rule text and filter identifier.\n     * 3. Starts next task with some delay.\n     *\n     * @param elements Collection of all elements.\n     * @param start Start of batch.\n     * @param end End of batch.\n     * @param step Size of batch.\n     * @param result Collection for save result.\n     * @param callback Finish callback.\n     */\n    // eslint-disable-next-line max-len\n    countCssHitsBatch(elements, start, end, step, result, callback) {\n        const length = Math.min(end, elements.length);\n        result = result.concat(this.countCssHitsForElements(elements, start, length));\n        if (length === elements.length) {\n            callback(result);\n            return;\n        }\n        start = end;\n        end += step;\n        // Start next task with some delay\n        window.setTimeout(() => {\n            this.countCssHitsBatch(elements, start, end, step, result, callback);\n        }, CssHitsCounter.COUNT_CSS_HITS_BATCH_DELAY);\n    }\n    /**\n     * Counts css hits for array of elements.\n     *\n     * @param elements Array of elements.\n     * @param start Start of batch.\n     * @param length Length of batch.\n     *\n     * @returns Data with information about filter id, rule text and element.\n     */\n    countCssHitsForElements(elements, start, length) {\n        const RULE_FILTER_SEPARATOR = ';';\n        start = start || 0;\n        length = length || elements.length;\n        const result = [];\n        for (let i = start; i < length; i += 1) {\n            const element = elements[i];\n            const cssHitData = CssHitsCounter.getCssHitData(element);\n            if (!cssHitData) {\n                continue;\n            }\n            const { filterId, ruleText } = cssHitData;\n            const ruleAndFilterString = filterId + RULE_FILTER_SEPARATOR + ruleText;\n            if (this.hitsStorage.isCounted(element, ruleAndFilterString)) {\n                continue;\n            }\n            this.hitsStorage.setCounted(element, ruleAndFilterString);\n            result.push({\n                filterId,\n                ruleText,\n                element: ElementUtils.elementToString(element),\n            });\n        }\n        return result;\n    }\n    /**\n     * Counts css hits for mutations.\n     */\n    countCssHitsForMutations() {\n        // eslint-disable-next-line prefer-destructuring\n        const MutationObserver = window.MutationObserver;\n        if (!MutationObserver) {\n            return;\n        }\n        if (this.observer) {\n            this.observer.disconnect();\n        }\n        let timeoutId = null;\n        this.observer = new MutationObserver(((mutationRecords) => {\n            // Collect probe elements, count them, then remove from their targets\n            const probeElements = [];\n            const childrenOfProbeElements = [];\n            const potentialProbeElements = [];\n            mutationRecords.forEach((mutationRecord) => {\n                if (mutationRecord.addedNodes.length === 0) {\n                    return;\n                }\n                for (let i = 0; i < mutationRecord.addedNodes.length; i += 1) {\n                    const node = mutationRecord.addedNodes[i];\n                    if (!(node instanceof Element) || CssHitsCounter.isIgnoredNodeTag(node.tagName)) {\n                        continue;\n                    }\n                    const { target } = mutationRecord;\n                    if (!node.parentNode && target) {\n                        // Most likely this is a \"probe\" element that was added and then\n                        // immediately removed from DOM.\n                        // We re-add it and check if any rule matched it\n                        probeElements.push(node);\n                        // CSS rules could be applied to the nodes inside probe element\n                        // that's why we get all child elements of added node\n                        ElementUtils.appendChildren(node, childrenOfProbeElements);\n                        if (this.observer) {\n                            this.observer.disconnect();\n                        }\n                        mutationRecord.target.appendChild(node);\n                    }\n                    else if (node.parentNode && target) {\n                        // Sometimes probe elements are appended to the DOM\n                        potentialProbeElements.push(node);\n                        ElementUtils.appendChildren(node, potentialProbeElements);\n                    }\n                }\n            });\n            // If the list of potential probe elements is relatively small,\n            // we can count CSS hits immediately\n            if (potentialProbeElements.length > 0\n                && potentialProbeElements.length <= CssHitsCounter.CSS_HITS_BATCH_SIZE) {\n                const result = this.countCssHitsForElements(potentialProbeElements, 0, null);\n                if (result.length > 0) {\n                    this.onCssHitsFoundCallback(result);\n                }\n            }\n            const allProbeElements = [];\n            ElementUtils.addUnique(allProbeElements, childrenOfProbeElements);\n            ElementUtils.addUnique(allProbeElements, probeElements);\n            if (allProbeElements.length > 0) {\n                const result = this.countCssHitsForElements(allProbeElements, 0, null);\n                if (result.length > 0) {\n                    this.onCssHitsFoundCallback(result);\n                }\n                /**\n                 * Don't remove child elements of probe elements\n                 * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1096.\n                 */\n                ElementUtils.removeElements(probeElements);\n                this.startObserver();\n            }\n            // debounce counting all css hits when mutation record fires\n            if (timeoutId) {\n                window.clearTimeout(timeoutId);\n            }\n            timeoutId = window.setTimeout(() => {\n                this.countAllCssHits();\n                window.clearTimeout(timeoutId);\n            }, CssHitsCounter.COUNT_ALL_CSS_HITS_TIMEOUT_MS);\n        }));\n        this.startObserver();\n    }\n    /**\n     * Starts mutation observer.\n     */\n    startObserver() {\n        if (this.observer) {\n            // TODO: Check, maybe we should observer for 'characterData' and\n            // 'characterDataOldValue' like it was in the old extension code\n            this.observer.observe(document.documentElement, {\n                childList: true,\n                subtree: true,\n                attributes: true,\n            });\n        }\n    }\n    /**\n     * Function retrieves css hits data from element style content attribute contains data injected with AdGuard.\n     *\n     * @param element Element to check.\n     * @returns Filter id and rule text or null.\n     */\n    static getCssHitData(element) {\n        const style = getComputedStyle(element);\n        return ElementUtils.parseInfo(style.content, CssHitsCounter.CONTENT_ATTR_PREFIX);\n    }\n    /**\n     * Checks if tag is ignored.\n     *\n     * @param nodeTag Tag name to check.\n     * @returns True if tag is ignored.\n     */\n    static isIgnoredNodeTag(nodeTag) {\n        const ignoredTags = ['script'];\n        return ignoredTags.includes(nodeTag.toLowerCase());\n    }\n}\n/**\n * We split CSS hits counting into smaller batches of elements and schedule them one by one using setTimeout.\n */\nCssHitsCounter.COUNT_CSS_HITS_BATCH_DELAY = 5;\n/**\n * Size of small batches of elements we count.\n */\nCssHitsCounter.CSS_HITS_BATCH_SIZE = 25;\n/**\n * In order to find elements hidden by AdGuard we look for a `:content` pseudo-class\n * with values starting with this prefix. Filter information will be\n * encoded in this value as well.\n */\nCssHitsCounter.CONTENT_ATTR_PREFIX = 'adguard';\n/**\n * We delay countAllCssHits function if it was called too frequently from mutationObserver.\n */\nCssHitsCounter.COUNT_ALL_CSS_HITS_TIMEOUT_MS = 500;\n\nvar RequestType = {\n    Document: 1,\n    SubDocument: 2,\n    Script: 4,\n    Stylesheet: 8,\n    Object: 16,\n    Image: 32,\n    XmlHttpRequest: 64,\n    Media: 128,\n    Font: 256,\n    WebSocket: 512,\n    Ping: 1024,\n    Other: 2048,\n};\n\n// Separate file for enum and const to reduce bundle size,\n// because rollup cannot do tree-shaking with TypeScript\nconst MESSAGE_HANDLER_NAME = 'tsWebExtension';\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"PROCESS_SHOULD_COLLAPSE\"] = \"PROCESS_SHOULD_COLLAPSE\";\n    MessageType[\"GET_EXTENDED_CSS\"] = \"GET_EXTENDED_CSS\";\n    MessageType[\"GET_CSS\"] = \"GET_CSS\";\n    MessageType[\"GET_COOKIE_RULES\"] = \"GET_COOKIE_RULES\";\n    MessageType[\"SAVE_COOKIE_LOG_EVENT\"] = \"SAVE_COOKIE_LOG_EVENT\";\n    MessageType[\"INIT_ASSISTANT\"] = \"INIT_ASSISTANT\";\n    MessageType[\"CLOSE_ASSISTANT\"] = \"CLOSE_ASSISTANT\";\n    MessageType[\"ASSISTANT_CREATE_RULE\"] = \"ASSISTANT_CREATE_RULE\";\n    MessageType[\"SAVE_CSS_HITS_STATS\"] = \"SAVE_CSS_HITS_STATS\";\n})(MessageType || (MessageType = {}));\n\n// TODO check if we can return typed message here\n/**\n * Sends message to the background page.\n *\n * @param message Message to send.\n * @param message.payload Payload of the message.\n * @param message.type Message type.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst sendAppMessage = (message) => __awaiter(void 0, void 0, void 0, function* () {\n    return browser.runtime.sendMessage(Object.assign({ handlerName: MESSAGE_HANDLER_NAME }, message));\n});\n\n/**\n * Hides broken items after blocking a network request.\n */\nclass ElementCollapser {\n    /**\n     * Start listening for error events.\n     */\n    static start() {\n        document.addEventListener('error', ElementCollapser.shouldCollapseElement, true);\n        // We need to listen for load events to hide blocked iframes (they don't raise error event)\n        document.addEventListener('load', ElementCollapser.shouldCollapseElement, true);\n    }\n    /**\n     * Stop listening for error events.\n     */\n    static stop() {\n        document.removeEventListener('error', ElementCollapser.shouldCollapseElement, true);\n        // We need to listen for load events to hide blocked iframes (they don't raise error event)\n        document.removeEventListener('load', ElementCollapser.shouldCollapseElement, true);\n    }\n    /**\n     * Returns request type by tag name.\n     *\n     * @param tagName Tag name.\n     * @returns Request type or null.\n     */\n    static getRequestTypeByInitiatorTagName(tagName) {\n        switch (tagName) {\n            case 'img':\n            case 'input': {\n                return RequestType.Image;\n            }\n            case 'audio':\n            case 'video': {\n                return RequestType.Media;\n            }\n            case 'object':\n            case 'embed': {\n                return RequestType.Object;\n            }\n            case 'frame':\n            case 'iframe':\n                return RequestType.SubDocument;\n            default:\n                return null;\n        }\n    }\n    /**\n     * Extracts element URL from the dom node.\n     *\n     * @param element Dom node.\n     * @returns Element URL or null.\n     */\n    static getElementUrl(element) {\n        let elementUrl = element.src || element.data;\n        if (!elementUrl\n            || elementUrl.indexOf('http') !== 0\n            // Some sources could not be set yet, lazy loaded images or smth.\n            // In some cases like on gog.com, collapsing these elements could break\n            // the page script loading their sources\n            || elementUrl === element.baseURI) {\n            return null;\n        }\n        // truncate too long urls\n        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1493\n        const MAX_URL_LENGTH = 16 * 1024;\n        if (elementUrl.length > MAX_URL_LENGTH) {\n            elementUrl = elementUrl.slice(0, MAX_URL_LENGTH);\n        }\n        return elementUrl;\n    }\n    /**\n     * Checks if element is already collapsed.\n     *\n     * @param element DOM element.\n     * @returns True if element is collapsed.\n     */\n    static isElementCollapsed(element) {\n        const computedStyle = window.getComputedStyle(element);\n        return (computedStyle && computedStyle.display === 'none');\n    }\n    /**\n     * Checks if element should be collapsed by requirements.\n     *\n     * @param event Error or load event.\n     */\n    static shouldCollapseElement(event) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const eventType = event.type;\n            const element = event.target;\n            const tagName = element.tagName.toLowerCase();\n            const expectedEventType = (tagName === 'iframe'\n                || tagName === 'frame'\n                || tagName === 'embed') ? 'load' : 'error';\n            if (eventType !== expectedEventType) {\n                return;\n            }\n            const requestType = ElementCollapser.getRequestTypeByInitiatorTagName(element.localName);\n            if (!requestType) {\n                return;\n            }\n            const elementUrl = ElementCollapser.getElementUrl(element);\n            if (!elementUrl) {\n                return;\n            }\n            if (ElementCollapser.isElementCollapsed(element)) {\n                return;\n            }\n            const payload = {\n                elementUrl,\n                documentUrl: document.URL,\n                requestType,\n            };\n            const shouldCollapse = yield sendAppMessage({\n                type: MessageType.PROCESS_SHOULD_COLLAPSE,\n                payload,\n            });\n            if (!shouldCollapse) {\n                return;\n            }\n            element.setAttribute('style', 'display: none!important; visibility: hidden!important; height: 0px!important; min-height: 0px!important;');\n        });\n    }\n}\n\n/**\n * This class applies cookie rules in page context.\n *\n * - Removes cookies matching rules\n * - Listens to new cookies, then tries to apply rules to them.\n */\nclass CookieController {\n    /**\n     * Constructor.\n     *\n     * @param callback On rule applied callback.\n     */\n    constructor(callback) {\n        /**\n         * Default cookie polling interval.\n         */\n        this.DEFAULT_COOKIE_POLLING_INTERVAL_MS = 1000;\n        /**\n         * Is current context third-party.\n         */\n        this.isThirdPartyContext = false;\n        this.onRuleAppliedCallback = callback;\n        this.isThirdPartyContext = this.isThirdPartyFrame();\n    }\n    /**\n     * Applies rules.\n     *\n     * @param rules Rules to apply.\n     */\n    apply(rules) {\n        this.applyRules(rules);\n        let lastCookie = document.cookie;\n        this.listenCookieChange((oldValue, newValue) => {\n            if (newValue === lastCookie) {\n                // Skip changes made by this class\n                return;\n            }\n            this.applyRules(rules);\n            lastCookie = document.cookie;\n        });\n        window.addEventListener('beforeunload', () => {\n            this.applyRules(rules);\n        });\n    }\n    /**\n     * Polling document cookie.\n     *\n     * @param callback Callback to be called periodically.\n     * @param interval Polling interval.\n     */\n    listenCookieChange(callback, interval = this.DEFAULT_COOKIE_POLLING_INTERVAL_MS) {\n        let lastCookie = document.cookie;\n        setInterval(() => {\n            const { cookie } = document;\n            if (cookie !== lastCookie) {\n                try {\n                    callback(lastCookie, cookie);\n                }\n                finally {\n                    lastCookie = cookie;\n                }\n            }\n        }, interval);\n    }\n    /**\n     * Checks if current context is third-party.\n     *\n     * @returns True if current context is third-party.\n     */\n    // eslint-disable-next-line class-methods-use-this\n    isThirdPartyFrame() {\n        try {\n            return window.self !== window.top && document.location.hostname !== window.parent.location.hostname;\n        }\n        catch (e) {\n            return true;\n        }\n    }\n    /**\n     * Applies rules to document cookies.\n     *\n     * @param rules Rules to apply.\n     *\n     * Inspired by remove-cookie scriptlet.\n     * @see {@link https://github.com/AdguardTeam/Scriptlets/blob/master/src/scriptlets/remove-cookie.js}\n     */\n    applyRules(rules) {\n        document.cookie.split(';').forEach((cookieStr) => {\n            const pos = cookieStr.indexOf('=');\n            if (pos === -1) {\n                return;\n            }\n            const cookieName = cookieStr.slice(0, pos).trim();\n            const cookieValue = cookieStr.slice(pos + 1).trim();\n            const matchingRules = rules.filter((r) => {\n                if (this.isThirdPartyContext !== r.isThirdParty) {\n                    return false;\n                }\n                const regex = r.match ? CookieController.toRegExp(r.match) : CookieController.toRegExp('/.?/');\n                return regex.test(cookieName);\n            });\n            const importantRules = matchingRules.filter((r) => r.ruleText.includes('important'));\n            if (importantRules.length > 0) {\n                importantRules.forEach((rule) => {\n                    this.applyRule(rule, cookieName, cookieValue);\n                });\n            }\n            else {\n                const allowlistRules = matchingRules.filter((r) => r.isAllowlist);\n                if (allowlistRules.length > 0) {\n                    allowlistRules.forEach((rule) => {\n                        this.applyRule(rule, cookieName, cookieValue);\n                    });\n                }\n                else {\n                    matchingRules.forEach((rule) => {\n                        this.applyRule(rule, cookieName, cookieValue);\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * Applies rule.\n     *\n     * @param rule Rule to apply.\n     * @param cookieName Cookie name.\n     * @param cookieValue Cookie value.\n     */\n    applyRule(rule, cookieName, cookieValue) {\n        if (!rule.isAllowlist) {\n            const hostParts = document.location.hostname.split('.');\n            for (let i = 0; i <= hostParts.length - 1; i += 1) {\n                const hostName = hostParts.slice(i).join('.');\n                if (hostName) {\n                    CookieController.removeCookieFromHost(cookieName, hostName);\n                }\n            }\n        }\n        this.onRuleAppliedCallback({\n            cookieName,\n            cookieValue,\n            cookieDomain: document.location.hostname,\n            cookieRuleText: rule.ruleText,\n            thirdParty: rule.isThirdParty,\n            filterId: rule.filterId,\n        });\n    }\n    /**\n     * Removes cookie for host.\n     *\n     * @param cookieName Cookie name.\n     * @param hostName Host name.\n     */\n    static removeCookieFromHost(cookieName, hostName) {\n        const cookieSpec = `${cookieName}=`;\n        const domain1 = `; domain=${hostName}`;\n        const domain2 = `; domain=.${hostName}`;\n        const path = '; path=/';\n        const expiration = '; expires=Thu, 01 Jan 1970 00:00:00 GMT';\n        document.cookie = cookieSpec + expiration;\n        document.cookie = cookieSpec + domain1 + expiration;\n        document.cookie = cookieSpec + domain2 + expiration;\n        document.cookie = cookieSpec + path + expiration;\n        document.cookie = cookieSpec + domain1 + path + expiration;\n        document.cookie = cookieSpec + domain2 + path + expiration;\n    }\n    /**\n     * Converts cookie rule match to regular expression.\n     *\n     * @param str String to convert.\n     * @returns Regular expression.\n     */\n    static toRegExp(str) {\n        if (str[0] === '/' && str[str.length - 1] === '/') {\n            return new RegExp(str.slice(1, -1));\n        }\n        const escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        return new RegExp(`^${escaped}$`);\n    }\n}\n\n/**\n * Initializes assistant object and create messages listener for assistant.\n */\nconst initAssistant = () => {\n    if (window.top !== window || !(document.documentElement instanceof HTMLElement)) {\n        return;\n    }\n    browser.runtime.onMessage.addListener((message) => __awaiter(void 0, void 0, void 0, function* () {\n        switch (message.type) {\n            case MessageType.INIT_ASSISTANT: {\n                // If there is no assistant on the window after execute\n                // loading script - throw error.\n                if (window.adguardAssistant === undefined) {\n                    throw new Error('adguardAssistant not found in the window object.');\n                }\n                else {\n                    window.adguardAssistant.close();\n                }\n                window.adguardAssistant.start(null, (rules) => {\n                    sendAppMessage({\n                        type: MessageType.ASSISTANT_CREATE_RULE,\n                        payload: { ruleText: rules },\n                    });\n                });\n                break;\n            }\n            case MessageType.CLOSE_ASSISTANT: {\n                if (window.adguardAssistant) {\n                    window.adguardAssistant.close();\n                }\n                break;\n            }\n        }\n    }));\n};\n\n// Disable jest coverage for this file, because it will insert\n// line comments, and code to count lines covered by tests, for example:\n// /* istanbul ignore next */\n// cov_uqm40oh03().f[0]++;\n// cov_uqm40oh03().s[2]++;\n// And we cannot test these strings correctly, because the names of these\n// functions with counters are generated at runtime\n/* istanbul ignore file */\n/**\n * This module applies stealth actions in page context.\n */\nclass StealthHelper {\n    /**\n     * Sends a Global Privacy Control DOM signal.\n     */\n    static setDomSignal() {\n        try {\n            if ('globalPrivacyControl' in Navigator.prototype) {\n                return;\n            }\n            Object.defineProperty(Navigator.prototype, 'globalPrivacyControl', {\n                get: () => true,\n                configurable: true,\n                enumerable: true,\n            });\n        }\n        catch (ex) {\n            // Ignore\n        }\n    }\n}\n\nElementCollapser.start();\ninitAssistant();\nconst cssHitsCounter = new CssHitsCounter((stats) => {\n    sendAppMessage({\n        type: MessageType.SAVE_CSS_HITS_STATS,\n        payload: stats,\n    });\n});\nconst applyExtendedCss = (cssText) => {\n    // Apply extended css stylesheets\n    const extendedCss = new ExtendedCss({\n        styleSheet: cssText,\n        beforeStyleApplied: (el) => {\n            return cssHitsCounter.countAffectedByExtendedCss(el);\n        },\n    });\n    extendedCss.apply();\n};\n(() => __awaiter(void 0, void 0, void 0, function* () {\n    const res = yield sendAppMessage({\n        type: MessageType.GET_EXTENDED_CSS,\n        payload: {\n            documentUrl: window.location.href,\n        },\n    });\n    if (res) {\n        applyExtendedCss(res);\n    }\n}))();\n/**\n * Runs CookieController.\n *\n * Steps:\n * - content script requests matching cookie rules for the frame(in which this script is executed)\n * - service returns matching set of rules data to content script\n * - the rules are applied with TSUrlFilterContentScript.CookieController\n * - filtering log receives callback with applied rules data.\n *\n * The important point is:\n * - there is no way to run cookie controller script via chrome.tabs.executeScript cause one only could be executed\n * for all frames or main frame only. But it's not correct cause there should be different rules\n * for each frame.\n */\n(() => __awaiter(void 0, void 0, void 0, function* () {\n    const response = yield sendAppMessage({\n        type: MessageType.GET_COOKIE_RULES,\n        payload: {\n            documentUrl: window.location.href,\n        },\n    });\n    if (!response) {\n        return;\n    }\n    if (response.rulesData) {\n        try {\n            const cookieController = new CookieController(({ cookieName, cookieValue, cookieDomain, cookieRuleText, thirdParty, filterId, }) => {\n                sendAppMessage({\n                    type: MessageType.SAVE_COOKIE_LOG_EVENT,\n                    payload: {\n                        cookieName,\n                        cookieValue,\n                        cookieDomain,\n                        cookieRuleText,\n                        thirdParty,\n                        filterId,\n                    },\n                });\n            });\n            cookieController.apply(response.rulesData);\n        }\n        catch (e) {\n            // Ignore exceptions\n        }\n    }\n}))();\n\nexport { CookieController, StealthHelper };\n","/**\n * @file\n * This file is part of Adguard API library (https://github.com/AdguardTeam/tsurlfilter/packages/adguard-api).\n *\n * Adguard API is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Adguard API is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Adguard API. If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport \"@adguard/tswebextension/content-script\";\n"],"names":[],"sourceRoot":""}