import { type RuleScanner } from './rule-scanner';
import { IndexedStorageRule } from '../../rules/rule';

/**
 * RuleStorageScanner scans multiple RuleScanner instances.
 * The storage index is built from the rule position in the list
 * + cumulative offset value of filter lists.
 */
export class RuleStorageScanner {
    /**
     * Scanners is the list of list scanners backing this combined scanner.
     */
    declare private readonly scanners: RuleScanner[];

    /**
     * Cursor for the {@link listOffsetKeys} and {@link listOffsetValues}.
     */
    declare private listOffsetEntriesCursor: number;

    /**
     * Mapping between list ID and the offset in the storage.
     */
    declare private listOffsetKeys: Int32Array;

    /**
     * Mapping between list ID and the offset in the storage.
     */
    declare private listOffsetValues: Uint32Array;

    /**
     * Current scanner.
     */
    private currentScanner: RuleScanner | null = null;

    /**
     * Index of the current scanner.
     */
    private currentScannerIdx = -1;

    /**
     * Rule position in the concatenated filter lists data.
     */
    private storageOffset = 0;

    /**
     * Constructor.
     *
     * @param scanners List of scanners.
     */
    constructor(scanners: RuleScanner[]) {
        this.scanners = scanners;
        this.listOffsetEntriesCursor = 0;
        this.listOffsetKeys = new Int32Array(scanners.length);
        this.listOffsetValues = new Uint32Array(scanners.length);
    }

    /**
     * Scan advances the RuleStorageScanner to the next rule, which will then be available
     * through the Rule method. It returns false when the scan stops, either by
     * reaching the end of the input or an error.
     *
     * @returns True if there is some result.
     */
    public scan(): boolean {
        const scannersLength = this.scanners.length;

        if (scannersLength === 0) {
            return false;
        }

        if (!this.currentScanner) {
            this.currentScannerIdx = 0;
            this.currentScanner = this.scanners[this.currentScannerIdx];
            this.setListOffset(this.currentScanner.getListId(), this.storageOffset);
        }

        while (this.currentScannerIdx < scannersLength) {
            if (this.currentScanner.scan()) {
                return true;
            }

            // Accumulate the length of the current scanner before moving to the next one
            this.storageOffset += this.currentScanner.getDataLength();

            // Move to the next scanner
            this.currentScannerIdx += 1;

            // Check if there's a next scanner
            if (this.currentScannerIdx < this.scanners.length) {
                this.currentScanner = this.scanners[this.currentScannerIdx];
                this.setListOffset(this.currentScanner.getListId(), this.storageOffset);
            }
        }

        return false;
    }

    /**
     * Rule returns the most recent rule generated by a call to Scan, and the index of this rule.
     * See ruleListIdxToStorageIdx for more information on what this index is.
     *
     * @returns The most recent rule and its index, or null if no rule is available.
     */
    public getRule(): IndexedStorageRule | null {
        if (!this.currentScanner) {
            return null;
        }

        const rule = this.currentScanner.getRule();
        if (!rule) {
            return null;
        }

        const offset = this.getListOffset(rule.rule.getFilterListId())!;
        const index = offset + rule.index;
        return new IndexedStorageRule(rule.rule, index);
    }

    /**
     * Match storage index with range of filter list offset
     * and return list id and local filter list position.
     *
     * @param storageIdx Rule position in concatenated filter lists data.
     *
     * @returns Tuple of list id and local filter list position.
     */
    public getIds(storageIdx: number): [number, number] {
        const listOffsetEntriesLength = this.listOffsetKeys.length;

        if (listOffsetEntriesLength === 1) {
            return [this.listOffsetKeys[0], storageIdx - this.listOffsetValues[0]];
        }

        for (let i = 0; i < listOffsetEntriesLength - 1; i += 1) {
            const offset = this.listOffsetValues[i];
            const nextOffset = this.listOffsetValues[i + 1];
            if (storageIdx >= offset && storageIdx < nextOffset) {
                return [this.listOffsetKeys[i], storageIdx - offset];
            }
        }

        return [
            this.listOffsetKeys[listOffsetEntriesLength - 1],
            storageIdx - this.listOffsetValues[listOffsetEntriesLength - 1],
        ];
    }

    /**
     * Push listID and offset to the {@link listOffsetEntries}.
     *
     * @param listId Filter list id.
     * @param offset Filter list offset position in the storage.
     */
    private setListOffset(listId: number, offset: number): void {
        this.listOffsetKeys[this.listOffsetEntriesCursor] = listId;
        this.listOffsetValues[this.listOffsetEntriesCursor] = offset;
        this.listOffsetEntriesCursor += 1;
    }

    /**
     * Gets filter list offset by list id.
     *
     * @param listId Filter list id.
     *
     * @returns Offset position in the storage.
     *
     * @throws Error if listId is not found.
     */
    private getListOffset(listId: number): number {
        const idx = this.listOffsetKeys.indexOf(listId);
        if (idx !== -1) {
            return this.listOffsetValues[idx];
        }

        throw new Error(`listId ${listId} not found in the storage`);
    }
}
