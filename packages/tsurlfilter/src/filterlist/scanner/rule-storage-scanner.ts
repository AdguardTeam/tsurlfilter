import { RuleScanner } from './rule-scanner';
import { IndexedStorageRule } from '../../rules/rule';

/**
 * RuleStorageScanner scans multiple RuleScanner instances.
 * The storage index is built from the rule position in the list
 * + cumulative offset value of filter lists.
*/
export class RuleStorageScanner {
    /**
     * Scanners is the list of list scanners backing this combined scanner
     */
    declare private readonly scanners: RuleScanner[];

    /**
     * Cursor for the {@link listOffsetEntries}
     */
    declare private listOffsetEntriesCursor: number;

    /**
     * Mapping between list ID and the offset in the storage
     */
    declare private listOffsetEntries: Uint32Array;

    /**
     * Current scanner
     */
    private currentScanner: RuleScanner | null = null;

    /**
     * Index of the current scanner
     */
    private currentScannerIdx = -1;

    /**
     * Rule position in the concatenated filter lists data
     */
    private storageOffset = 0;

    /**
     * Constructor
     *
     * @param scanners
     */
    constructor(scanners: RuleScanner[]) {
        this.scanners = scanners;
        this.listOffsetEntriesCursor = 0;
        this.listOffsetEntries = new Uint32Array(scanners.length * 2);
    }

    /**
     * Scan advances the RuleStorageScanner to the next rule, which will then be available
     * through the Rule method. It returns false when the scan stops, either by
     * reaching the end of the input or an error.
     *
     * @return true if there is some result
    */
    public scan(): boolean {
        if (this.scanners.length === 0) {
            return false;
        }

        if (!this.currentScanner) {
            this.currentScannerIdx = 0;
            this.currentScanner = this.scanners[this.currentScannerIdx];
            this.setListOffset(this.currentScanner.getListId(), this.storageOffset);
        }

        while (true) {
            if (this.currentScanner.scan()) {
                return true;
            }

            // Take the next scanner or just return false if there's nothing more
            if (this.currentScannerIdx === (this.scanners.length - 1)) {
                return false;
            }

            // Accumulate the length of the current scanner before moving to the next one
            this.storageOffset += this.currentScanner.getDataLength();

            // Take the next scanner
            this.currentScannerIdx += 1;
            this.currentScanner = this.scanners[this.currentScannerIdx];

            // Store the offset for the next scanner
            this.setListOffset(this.currentScanner.getListId(), this.storageOffset);
        }
    }

    /**
     * Rule returns the most recent rule generated by a call to Scan, and the index of this rule.
     * See ruleListIdxToStorageIdx for more information on what this index is.
     */
    public getRule(): IndexedStorageRule | null {
        if (!this.currentScanner) {
            return null;
        }

        const rule = this.currentScanner.getRule();
        if (!rule) {
            return null;
        }

        const offset = this.getListOffset(rule.rule.getFilterListId())!;
        const index = offset + rule.index;
        return new IndexedStorageRule(rule.rule, index);
    }

    /**
     * Match storage index with range of filter list offset
     * and return list id and local filter list position.
     *
     * @param storageIdx rule position in concatenated filter lists data
     * @returns tuple of list id and local filter list position
     */
    public getIds(storageIdx: number): [number, number] {
        const listOffsetEntriesLength = this.listOffsetEntries.length;

        if (listOffsetEntriesLength === 2) {
            return [this.listOffsetEntries[0], storageIdx - this.listOffsetEntries[1]];
        }

        for (let i = 1; i < listOffsetEntriesLength - 2; i += 2) {
            const offset = this.listOffsetEntries[i];
            const nextOffset = this.listOffsetEntries[i + 2];
            if (storageIdx >= offset && storageIdx < nextOffset) {
                return [this.listOffsetEntries[i - 1], storageIdx - offset];
            }
        }

        return [
            this.listOffsetEntries[listOffsetEntriesLength - 2],
            storageIdx - this.listOffsetEntries[listOffsetEntriesLength - 1],
        ];
    }

    /**
     * Push listID and offset to the {@link listOffsetEntries}.
     *
     * @param listId Filter list id.
     * @param offset Filter list offset position in the storage.
     */
    private setListOffset(listId: number, offset: number): void {
        this.listOffsetEntries[this.listOffsetEntriesCursor] = listId;
        this.listOffsetEntriesCursor += 1;
        this.listOffsetEntries[this.listOffsetEntriesCursor] = offset;
        this.listOffsetEntriesCursor += 1;
    }

    /**
     * Get filter list offset by list id.
     *
     * @param listId Filter list id.
     * @returns offset position in the storage.
     * @throws Error if listId is not found.
     */
    private getListOffset(listId: number): number {
        for (let i = 0; i < this.listOffsetEntries.length; i += 2) {
            if (this.listOffsetEntries[i] === listId) {
                return this.listOffsetEntries[i + 1];
            }
        }

        throw new Error(`listId ${listId} not found in the storage`);
    }
}
