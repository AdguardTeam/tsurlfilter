import { IndexedRule } from '../../rules/rule-new';
import { type ILineReader } from '../reader/line-reader';
import {
    CosmeticRuleType,
    getRuleParts,
    RuleCategory,
    type RuleParts,
} from '../rule-parts';

import { ScannerType } from './scanner-type';

/**
 * Represents the RuleScanner configuration.
 */
export interface RuleScannerConfiguration {
    /**
     * Scanner type.
     */
    scannerType: ScannerType;

    /**
     * If true, cosmetic rules will be ignored.
     */
    ignoreCosmetic?: boolean;

    /**
     * If true, javascript cosmetic rules will be ignored.
     */
    ignoreJS?: boolean;

    /**
     * If true, some `unsafe` rules will be ignored, $removeheader rules as an
     * example.
     *
     * TODO(ameshkov): Reconsider how "unsafe" works (does not include JS now).
     */
    ignoreUnsafe?: boolean;
}

/**
 * Rule scanner provides the functionality for reading rules from a filter list.
 */
export class RuleScanner {
    /**
     * Filter list ID.
     */
    private readonly listId: number;

    /**
     * True if we should ignore cosmetic rules.
     */
    private readonly ignoreCosmetic: boolean;

    /**
     * True if we should ignore javascript cosmetic rules.
     */
    private readonly ignoreJS: boolean;

    /**
     * True if we should ignore unsafe rules, like $removeheader.
     */
    private readonly ignoreUnsafe: boolean;

    /**
     * True if we should ignore network rules.
     */
    private ignoreNetwork: boolean;

    /**
     * True if we should ignore host filtering rules.
     */
    private ignoreHost: boolean;

    /**
     * Underlying reader object.
     */
    private readonly reader: ILineReader;

    /**
     * Current rule.
     */
    private currentRule: RuleParts | null = null;

    /**
     * Index of the beginning of the current rule (basically, a line number).
     */
    private currentRuleIndex = 0;

    /**
     * Constructor of a RuleScanner object.
     *
     * @param reader Source of the filtering rules.
     * @param listId Filter list ID.
     * @param configuration Scanner configuration object.
     */
    constructor(
        reader: ILineReader,
        listId: number,
        configuration: RuleScannerConfiguration,
    ) {
        this.reader = reader;
        this.listId = listId;

        this.ignoreCosmetic = !!configuration.ignoreCosmetic
            || ((configuration.scannerType & ScannerType.CosmeticRules) !== ScannerType.CosmeticRules);
        this.ignoreNetwork = (configuration.scannerType & ScannerType.NetworkRules) !== ScannerType.NetworkRules;
        this.ignoreHost = (configuration.scannerType & ScannerType.HostRules) !== ScannerType.HostRules;

        this.ignoreJS = !!configuration.ignoreJS;
        this.ignoreUnsafe = !!configuration.ignoreUnsafe;
    }

    /**
     * Scan advances the RuleScanner to the next rule, which will then be
     * available through the getRule() method.
     *
     * @returns - False when the scan stops, either by reaching the end of the
     * input or an error. If there's a rule available, returns true.
     */
    public scan(): boolean {
        let lineIndex = this.reader.getCurrentPos();
        let line = this.readNextLine();

        while (line !== null) {
            const ruleParts = getRuleParts(line, this.ignoreCosmetic, this.ignoreHost);
            if (ruleParts && !this.isIgnored(ruleParts)) {
                this.currentRule = ruleParts;
                this.currentRuleIndex = lineIndex;
                return true;
            }

            lineIndex = this.reader.getCurrentPos();
            line = this.reader.readLine();
        }

        return false;
    }

    /**
     * Gets the most recent rule generated by a call to scan(), and the
     * index of this rule's text.
     *
     * @returns The most recent rule generated by a call to scan(), and the
     * index of this rule's text.
     */
    public getRule(): IndexedRule | null {
        if (this.currentRule) {
            return new IndexedRule(this.currentRule, this.currentRuleIndex, this.listId);
        }

        return null;
    }

    /**
     * Get filter list id.
     *
     * @returns List id.
     */
    public getListId(): number {
        return this.listId;
    }

    /**
     * Get the length of the data read by the scanner.
     *
     * @returns Data length.
     */
    public getDataLength(): number {
        return this.reader.getDataLength();
    }

    /**
     * Reads the next line and returns it.
     *
     * @returns - Next line string or null.
     */
    private readNextLine(): string | null {
        const line = this.reader.readLine();

        if (line != null) {
            return line.trim();
        }

        return null;
    }

    /**
     * Checks if the rule should be ignored by this scanner.
     *
     * @param rule Rule to check.
     *
     * @returns - True if the rule should be ignored.
     */
    private isIgnored(rule: RuleParts): boolean {
        if (!this.ignoreCosmetic && !this.ignoreJS && !this.ignoreUnsafe) {
            return false;
        }

        if (rule.category === RuleCategory.Network && this.ignoreNetwork) {
            return true;
        }

        if (rule.category === RuleCategory.Host && this.ignoreHost) {
            return true;
        }

        if (rule.category === RuleCategory.Cosmetic) {
            if (this.ignoreCosmetic) {
                return true;
            }

            // Ignore JS type rules.
            // TODO: in the future we may allow CSS rules and Scriptlets (except
            // for "trusted" scriptlets).
            if (
                this.ignoreJS
                && rule.type === CosmeticRuleType.JsInjectionRule
            ) {
                return true;
            }
        }

        // FIXME (David): Handle in AG-43064
        // if (this.ignoreUnsafe) {
        //     if (rule.category === RuleCategory.Network && rule.type === NetworkRuleType.NetworkRule) {
        //         if (
        // eslint-disable-next-line max-len
        //             rule.modifiers?.children?.some((modifier) => NetworkRule.ADVANCED_OPTIONS.has(modifier.name.value))
        //         ) {
        //             return true;
        //         }
        //     }
        // }

        return false;
    }
}
